###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         03/Mar/2020  16:31:25
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\event_groups.c
#    Command line =  
#        C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\event_groups.c
#        "-IC:\Program Files (x86)\IAR Systems\Embedded Workbench 8.1\arm\inc"
#        -I..\..\..\..\..\CMSIS\Include -I..\..\..\..\..\devices -I..\..\..
#        -I..\..\..\..\..\devices\MKW24D5\drivers
#        -I..\..\..\..\..\devices\MKW24D5\utilities
#        -I..\..\..\..\..\devices\MKW24D5 -I..\..\iar -I..\.. -I..\
#        -I..\..\..\..\..\rtos\freertos_9.0.0\Source\portable\IAR\ARM_CM3
#        -I..\..\..\..\..\rtos\freertos_9.0.0\Source\include -DNDEBUG
#        -DCPU_MKW24D512VHA5 -DIAR -DFSL_RTOS_FREE_RTOS -DPRINTF_FLOAT_ENABLE=0
#        -DSCANF_FLOAT_ENABLE=0 -DPRINTF_ADVANCED_ENABLE=0
#        -DSCANF_ADVANCED_ENABLE=0 -DTWR_KW24D512 -DTOWER --diag_suppress
#        Pa082,Pa050,Pe167,Pa182 --endian=little --cpu=Cortex-M4 --fpu=None
#        --no_path_in_file_macros --silent -lC . -e --dlib_config "C:/Program
#        Files (x86)/IAR Systems/Embedded Workbench
#        8.1/arm/inc/c/DLib_Config_Normal.h" -Oh --dependencies=ns
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\event_groups.c.obj.d
#        -o
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\event_groups.c.obj
#    Locale       =  C
#    List file    =  .\event_groups.c.lst
#    Object file  =  
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\event_groups.c.obj
#
###############################################################################

C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\event_groups.c
      1          /*
      2              FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
      3              All rights reserved
      4          
      5              VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              This file is part of the FreeRTOS distribution.
      8          
      9              FreeRTOS is free software; you can redistribute it and/or modify it under
     10              the terms of the GNU General Public License (version 2) as published by the
     11              Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
     12          
     13              ***************************************************************************
     14              >>!   NOTE: The modification to the GPL is included to allow you to     !<<
     15              >>!   distribute a combined work that includes FreeRTOS without being   !<<
     16              >>!   obliged to provide the source code for proprietary components     !<<
     17              >>!   outside of the FreeRTOS kernel.                                   !<<
     18              ***************************************************************************
     19          
     20              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
     21              WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     22              FOR A PARTICULAR PURPOSE.  Full license text is available on the following
     23              link: http://www.freertos.org/a00114.html
     24          
     25              ***************************************************************************
     26               *                                                                       *
     27               *    FreeRTOS provides completely free yet professionally developed,    *
     28               *    robust, strictly quality controlled, supported, and cross          *
     29               *    platform software that is more than just the market leader, it     *
     30               *    is the industry's de facto standard.                               *
     31               *                                                                       *
     32               *    Help yourself get started quickly while simultaneously helping     *
     33               *    to support the FreeRTOS project by purchasing a FreeRTOS           *
     34               *    tutorial book, reference manual, or both:                          *
     35               *    http://www.FreeRTOS.org/Documentation                              *
     36               *                                                                       *
     37              ***************************************************************************
     38          
     39              http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
     40              the FAQ page "My application does not run, what could be wrong?".  Have you
     41              defined configASSERT()?
     42          
     43              http://www.FreeRTOS.org/support - In return for receiving this top quality
     44              embedded software for free we request you assist our global community by
     45              participating in the support forum.
     46          
     47              http://www.FreeRTOS.org/training - Investing in training allows your team to
     48              be as productive as possible as early as possible.  Now you can receive
     49              FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
     50              Ltd, and the world's leading authority on the world's leading RTOS.
     51          
     52              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     53              including FreeRTOS+Trace - an indispensable productivity tool, a DOS
     54              compatible FAT file system, and our tiny thread aware UDP/IP stack.
     55          
     56              http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
     57              Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
     58          
     59              http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
     60              Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
     61              licenses offer ticketed support, indemnification and commercial middleware.
     62          
     63              http://www.SafeRTOS.com - High Integrity Systems also provide a safety
     64              engineered and independently SIL3 certified version for use in safety and
     65              mission critical applications that require provable dependability.
     66          
     67              1 tab == 4 spaces!
     68          */
     69          
     70          /* Standard includes. */
     71          #include <stdlib.h>
     72          
     73          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     74          all the API functions to use the MPU wrappers.  That should only be done when
     75          task.h is included from an application file. */
     76          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     77          
     78          /* FreeRTOS includes. */
     79          #include "FreeRTOS.h"
     80          #include "task.h"
     81          #include "timers.h"
     82          #include "event_groups.h"
     83          
     84          /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
     85          MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
     86          header files above, but not in this file, in order to generate the correct
     87          privileged Vs unprivileged linkage and placement. */
     88          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
     89          
     90          /* The following bit fields convey control information in a task's event list
     91          item value.  It is important they don't clash with the
     92          taskEVENT_LIST_ITEM_VALUE_IN_USE definition. */
     93          #if configUSE_16_BIT_TICKS == 1
     94          	#define eventCLEAR_EVENTS_ON_EXIT_BIT	0x0100U
     95          	#define eventUNBLOCKED_DUE_TO_BIT_SET	0x0200U
     96          	#define eventWAIT_FOR_ALL_BITS			0x0400U
     97          	#define eventEVENT_BITS_CONTROL_BYTES	0xff00U
     98          #else
     99          	#define eventCLEAR_EVENTS_ON_EXIT_BIT	0x01000000UL
    100          	#define eventUNBLOCKED_DUE_TO_BIT_SET	0x02000000UL
    101          	#define eventWAIT_FOR_ALL_BITS			0x04000000UL
    102          	#define eventEVENT_BITS_CONTROL_BYTES	0xff000000UL
    103          #endif
    104          
    105          typedef struct xEventGroupDefinition
    106          {
    107          	EventBits_t uxEventBits;
    108          	List_t xTasksWaitingForBits;		/*< List of tasks waiting for a bit to be set. */
    109          
    110          	#if( configUSE_TRACE_FACILITY == 1 )
    111          		UBaseType_t uxEventGroupNumber;
    112          	#endif
    113          
    114          	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
    115          		uint8_t ucStaticallyAllocated; /*< Set to pdTRUE if the event group is statically allocated to ensure no attempt is made to free the memory. */
    116          	#endif
    117          } EventGroup_t;
    118          
    119          /*-----------------------------------------------------------*/
    120          
    121          /*
    122           * Test the bits set in uxCurrentEventBits to see if the wait condition is met.
    123           * The wait condition is defined by xWaitForAllBits.  If xWaitForAllBits is
    124           * pdTRUE then the wait condition is met if all the bits set in uxBitsToWaitFor
    125           * are also set in uxCurrentEventBits.  If xWaitForAllBits is pdFALSE then the
    126           * wait condition is met if any of the bits set in uxBitsToWait for are also set
    127           * in uxCurrentEventBits.
    128           */
    129          static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits ) PRIVILEGED_FUNCTION;
    130          
    131          /*-----------------------------------------------------------*/
    132          
    133          #if( configSUPPORT_STATIC_ALLOCATION == 1 )
    134          
    135          	EventGroupHandle_t xEventGroupCreateStatic( StaticEventGroup_t *pxEventGroupBuffer )
    136          	{
    137          	EventGroup_t *pxEventBits;
    138          
    139          		/* A StaticEventGroup_t object must be provided. */
    140          		configASSERT( pxEventGroupBuffer );
    141          
    142          		/* The user has provided a statically allocated event group - use it. */
    143          		pxEventBits = ( EventGroup_t * ) pxEventGroupBuffer; /*lint !e740 EventGroup_t and StaticEventGroup_t are guaranteed to have the same size and alignment requirement - checked by configASSERT(). */
    144          
    145          		if( pxEventBits != NULL )
    146          		{
    147          			pxEventBits->uxEventBits = 0;
    148          			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    149          
    150          			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    151          			{
    152          				/* Both static and dynamic allocation can be used, so note that
    153          				this event group was created statically in case the event group
    154          				is later deleted. */
    155          				pxEventBits->ucStaticallyAllocated = pdTRUE;
    156          			}
    157          			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    158          
    159          			traceEVENT_GROUP_CREATE( pxEventBits );
    160          		}
    161          		else
    162          		{
    163          			traceEVENT_GROUP_CREATE_FAILED();
    164          		}
    165          
    166          		return ( EventGroupHandle_t ) pxEventBits;
    167          	}
    168          
    169          #endif /* configSUPPORT_STATIC_ALLOCATION */
    170          /*-----------------------------------------------------------*/
    171          
    172          #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    173          

   \                                 In section .text, align 2, keep-with-next
    174          	EventGroupHandle_t xEventGroupCreate( void )
    175          	{
   \                     xEventGroupCreate: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    176          	EventGroup_t *pxEventBits;
    177          
    178          		/* Allocate the event group. */
    179          		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
   \        0x2   0x201C             MOVS     R0,#+28
   \        0x4   0x.... 0x....      BL       pvPortMalloc
   \        0x8   0x0004             MOVS     R4,R0
    180          
    181          		if( pxEventBits != NULL )
   \        0xA   0xD004             BEQ.N    ??xEventGroupCreate_0
    182          		{
    183          			pxEventBits->uxEventBits = 0;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x6020             STR      R0,[R4, #+0]
    184          			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
   \       0x10   0x1D20             ADDS     R0,R4,#+4
   \       0x12   0x.... 0x....      BL       vListInitialise
    185          
    186          			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
    187          			{
    188          				/* Both static and dynamic allocation can be used, so note this
    189          				event group was allocated statically in case the event group is
    190          				later deleted. */
    191          				pxEventBits->ucStaticallyAllocated = pdFALSE;
    192          			}
    193          			#endif /* configSUPPORT_STATIC_ALLOCATION */
    194          
    195          			traceEVENT_GROUP_CREATE( pxEventBits );
    196          		}
    197          		else
    198          		{
    199          			traceEVENT_GROUP_CREATE_FAILED();
    200          		}
    201          
    202          		return ( EventGroupHandle_t ) pxEventBits;
   \                     ??xEventGroupCreate_0: (+1)
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0xBD10             POP      {R4,PC}          ;; return
    203          	}
    204          
    205          #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    206          /*-----------------------------------------------------------*/
    207          

   \                                 In section .text, align 2, keep-with-next
    208          EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
    209          {
   \                     xEventGroupSync: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4615             MOV      R5,R2
    210          EventBits_t uxOriginalBitValue, uxReturn;
    211          EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    212          BaseType_t xAlreadyYielded;
    213          BaseType_t xTimeoutOccurred = pdFALSE;
    214          
    215          	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
   \        0x6   0xF015 0x4F7F      TST      R5,#0xFF000000
   \        0xA   0x4606             MOV      R6,R0
   \        0xC   0x460F             MOV      R7,R1
   \        0xE   0x461C             MOV      R4,R3
   \       0x10   0xD007             BEQ.N    ??xEventGroupSync_0
   \       0x12   0x2020             MOVS     R0,#+32
   \       0x14   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x18   0xF3BF 0x8F4F      DSB      SY
   \       0x1C   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupSync_1: (+1)
   \       0x20   0xE7FE             B.N      ??xEventGroupSync_1
    216          	configASSERT( uxBitsToWaitFor != 0 );
   \                     ??xEventGroupSync_0: (+1)
   \       0x22   0xB93D             CBNZ.N   R5,??xEventGroupSync_2
   \       0x24   0x2020             MOVS     R0,#+32
   \       0x26   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x2A   0xF3BF 0x8F4F      DSB      SY
   \       0x2E   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupSync_3: (+1)
   \       0x32   0xE7FE             B.N      ??xEventGroupSync_3
    217          	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
    218          	{
    219          		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   \                     ??xEventGroupSync_2: (+1)
   \       0x34   0x.... 0x....      BL       xTaskGetSchedulerState
   \       0x38   0xB900             CBNZ.N   R0,??xEventGroupSync_4
   \       0x3A   0xB994             CBNZ.N   R4,??xEventGroupSync_5
    220          	}
    221          	#endif
    222          
    223          	vTaskSuspendAll();
   \                     ??xEventGroupSync_4: (+1)
   \       0x3C   0x.... 0x....      BL       vTaskSuspendAll
    224          	{
    225          		uxOriginalBitValue = pxEventBits->uxEventBits;
   \       0x40   0xF8D6 0x8000      LDR      R8,[R6, #+0]
    226          
    227          		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
   \       0x44   0x4639             MOV      R1,R7
   \       0x46   0x4630             MOV      R0,R6
   \       0x48   0x.... 0x....      BL       xEventGroupSetBits
    228          
    229          		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
   \       0x4C   0xEA47 0x0708      ORR      R7,R7,R8
   \       0x50   0xEA05 0x0007      AND      R0,R5,R7
   \       0x54   0x42A8             CMP      R0,R5
   \       0x56   0xD10C             BNE.N    ??xEventGroupSync_6
    230          		{
    231          			/* All the rendezvous bits are now set - no need to block. */
    232          			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    233          
    234          			/* Rendezvous always clear the bits.  They will have been cleared
    235          			already unless this is the only task in the rendezvous. */
    236          			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
   \       0x58   0x6830             LDR      R0,[R6, #+0]
   \       0x5A   0x43A8             BICS     R0,R0,R5
   \       0x5C   0x6030             STR      R0,[R6, #+0]
    237          
    238          			xTicksToWait = 0;
   \       0x5E   0x2400             MOVS     R4,#+0
   \       0x60   0xE011             B.N      ??xEventGroupSync_7
    239          		}
   \                     ??xEventGroupSync_5: (+1)
   \       0x62   0x2120             MOVS     R1,#+32
   \       0x64   0xF381 0x8811      MSR      BASEPRI,R1
   \       0x68   0xF3BF 0x8F4F      DSB      SY
   \       0x6C   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupSync_8: (+1)
   \       0x70   0xE7FE             B.N      ??xEventGroupSync_8
    240          		else
    241          		{
    242          			if( xTicksToWait != ( TickType_t ) 0 )
   \                     ??xEventGroupSync_6: (+1)
   \       0x72   0xB13C             CBZ.N    R4,??xEventGroupSync_9
    243          			{
    244          				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );
    245          
    246          				/* Store the bits that the calling task is waiting for in the
    247          				task's event list item so the kernel knows when a match is
    248          				found.  Then enter the blocked state. */
    249          				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
   \       0x74   0x4622             MOV      R2,R4
   \       0x76   0xF045 0x61A0      ORR      R1,R5,#0x5000000
   \       0x7A   0x1D30             ADDS     R0,R6,#+4
   \       0x7C   0x.... 0x....      BL       vTaskPlaceOnUnorderedEventList
    250          
    251          				/* This assignment is obsolete as uxReturn will get set after
    252          				the task unblocks, but some compilers mistakenly generate a
    253          				warning about uxReturn being returned without being set if the
    254          				assignment is omitted. */
    255          				uxReturn = 0;
   \       0x80   0x2700             MOVS     R7,#+0
   \       0x82   0xE000             B.N      ??xEventGroupSync_7
    256          			}
    257          			else
    258          			{
    259          				/* The rendezvous bits were not set, but no block time was
    260          				specified - just return the current event bit value. */
    261          				uxReturn = pxEventBits->uxEventBits;
   \                     ??xEventGroupSync_9: (+1)
   \       0x84   0x6837             LDR      R7,[R6, #+0]
    262          			}
    263          		}
    264          	}
    265          	xAlreadyYielded = xTaskResumeAll();
   \                     ??xEventGroupSync_7: (+1)
   \       0x86   0x.... 0x....      BL       xTaskResumeAll
    266          
    267          	if( xTicksToWait != ( TickType_t ) 0 )
   \       0x8A   0xB1E4             CBZ.N    R4,??xEventGroupSync_10
    268          	{
    269          		if( xAlreadyYielded == pdFALSE )
   \       0x8C   0xB938             CBNZ.N   R0,??xEventGroupSync_11
    270          		{
    271          			portYIELD_WITHIN_API();
   \       0x8E   0x....             LDR.N    R1,??DataTable3  ;; 0xe000ed04
   \       0x90   0xF04F 0x5080      MOV      R0,#+268435456
   \       0x94   0x6008             STR      R0,[R1, #+0]
   \       0x96   0xF3BF 0x8F4F      DSB      SY
   \       0x9A   0xF3BF 0x8F6F      ISB      SY
    272          		}
    273          		else
    274          		{
    275          			mtCOVERAGE_TEST_MARKER();
    276          		}
    277          
    278          		/* The task blocked to wait for its required bits to be set - at this
    279          		point either the required bits were set or the block time expired.  If
    280          		the required bits were set they will have been stored in the task's
    281          		event list item, and they should now be retrieved then cleared. */
    282          		uxReturn = uxTaskResetEventItemValue();
   \                     ??xEventGroupSync_11: (+1)
   \       0x9E   0x.... 0x....      BL       uxTaskResetEventItemValue
   \       0xA2   0x4607             MOV      R7,R0
    283          
    284          		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
   \       0xA4   0x01B8             LSLS     R0,R7,#+6
   \       0xA6   0xD40C             BMI.N    ??xEventGroupSync_12
    285          		{
    286          			/* The task timed out, just return the current event bit value. */
    287          			taskENTER_CRITICAL();
   \       0xA8   0x.... 0x....      BL       vPortEnterCritical
    288          			{
    289          				uxReturn = pxEventBits->uxEventBits;
   \       0xAC   0x6830             LDR      R0,[R6, #+0]
   \       0xAE   0x4607             MOV      R7,R0
    290          
    291          				/* Although the task got here because it timed out before the
    292          				bits it was waiting for were set, it is possible that since it
    293          				unblocked another task has set the bits.  If this is the case
    294          				then it needs to clear the bits before exiting. */
    295          				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
   \       0xB0   0xEA05 0x0107      AND      R1,R5,R7
   \       0xB4   0x42A9             CMP      R1,R5
   \       0xB6   0xBF04             ITT      EQ 
   \       0xB8   0xEA20 0x0505      BICEQ    R5,R0,R5
   \       0xBC   0x6035             STREQ    R5,[R6, #+0]
    296          				{
    297          					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    298          				}
    299          				else
    300          				{
    301          					mtCOVERAGE_TEST_MARKER();
    302          				}
    303          			}
    304          			taskEXIT_CRITICAL();
   \       0xBE   0x.... 0x....      BL       vPortExitCritical
    305          
    306          			xTimeoutOccurred = pdTRUE;
    307          		}
    308          		else
    309          		{
    310          			/* The task unblocked because the bits were set. */
    311          		}
    312          
    313          		/* Control bits might be set as the task had blocked should not be
    314          		returned. */
    315          		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
   \                     ??xEventGroupSync_12: (+1)
   \       0xC2   0xF027 0x477F      BIC      R7,R7,#0xFF000000
    316          	}
    317          
    318          	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );
    319          
    320          	return uxReturn;
   \                     ??xEventGroupSync_10: (+1)
   \       0xC6   0x4638             MOV      R0,R7
   \       0xC8   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    321          }
    322          /*-----------------------------------------------------------*/
    323          

   \                                 In section .text, align 2, keep-with-next
    324          EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
    325          {
   \                     xEventGroupWaitBits: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x4689             MOV      R9,R1
   \        0x8   0x4615             MOV      R5,R2
   \        0xA   0x4698             MOV      R8,R3
    326          EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    327          EventBits_t uxReturn, uxControlBits = 0;
   \        0xC   0xF04F 0x0A00      MOV      R10,#+0
    328          BaseType_t xWaitConditionMet, xAlreadyYielded;
    329          BaseType_t xTimeoutOccurred = pdFALSE;
    330          
    331          	/* Check the user is not attempting to wait on the bits used by the kernel
    332          	itself, and that at least one bit is being requested. */
    333          	configASSERT( xEventGroup );
   \       0x10   0xD107             BNE.N    ??xEventGroupWaitBits_0
   \       0x12   0x2020             MOVS     R0,#+32
   \       0x14   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x18   0xF3BF 0x8F4F      DSB      SY
   \       0x1C   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupWaitBits_1: (+1)
   \       0x20   0xE7FE             B.N      ??xEventGroupWaitBits_1
    334          	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
   \                     ??xEventGroupWaitBits_0: (+1)
   \       0x22   0xF019 0x4F7F      TST      R9,#0xFF000000
   \       0x26   0xD007             BEQ.N    ??xEventGroupWaitBits_2
   \       0x28   0x2020             MOVS     R0,#+32
   \       0x2A   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x2E   0xF3BF 0x8F4F      DSB      SY
   \       0x32   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupWaitBits_3: (+1)
   \       0x36   0xE7FE             B.N      ??xEventGroupWaitBits_3
    335          	configASSERT( uxBitsToWaitFor != 0 );
   \                     ??xEventGroupWaitBits_2: (+1)
   \       0x38   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x3C   0xD107             BNE.N    ??xEventGroupWaitBits_4
   \       0x3E   0x2020             MOVS     R0,#+32
   \       0x40   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x44   0xF3BF 0x8F4F      DSB      SY
   \       0x48   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupWaitBits_5: (+1)
   \       0x4C   0xE7FE             B.N      ??xEventGroupWaitBits_5
   \                     ??xEventGroupWaitBits_4: (+1)
   \       0x4E   0x9C08             LDR      R4,[SP, #+32]
    336          	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
    337          	{
    338          		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   \       0x50   0x.... 0x....      BL       xTaskGetSchedulerState
   \       0x54   0xB900             CBNZ.N   R0,??xEventGroupWaitBits_6
   \       0x56   0xB954             CBNZ.N   R4,??xEventGroupWaitBits_7
    339          	}
    340          	#endif
    341          
    342          	vTaskSuspendAll();
   \                     ??xEventGroupWaitBits_6: (+1)
   \       0x58   0x.... 0x....      BL       vTaskSuspendAll
    343          	{
    344          		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
   \       0x5C   0x6837             LDR      R7,[R6, #+0]
    345          
    346          		/* Check to see if the wait condition is already met or not. */
    347          		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    348          
    349          		if( xWaitConditionMet != pdFALSE )
   \       0x5E   0x4642             MOV      R2,R8
   \       0x60   0x4649             MOV      R1,R9
   \       0x62   0x4638             MOV      R0,R7
   \       0x64   0x.... 0x....      BL       prvTestWaitCondition
   \       0x68   0xB948             CBNZ.N   R0,??xEventGroupWaitBits_8
    350          		{
    351          			/* The wait condition has already been met so there is no need to
    352          			block. */
    353          			uxReturn = uxCurrentEventBits;
    354          			xTicksToWait = ( TickType_t ) 0;
    355          
    356          			/* Clear the wait bits if requested to do so. */
    357          			if( xClearOnExit != pdFALSE )
    358          			{
    359          				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    360          			}
    361          			else
    362          			{
    363          				mtCOVERAGE_TEST_MARKER();
    364          			}
    365          		}
    366          		else if( xTicksToWait == ( TickType_t ) 0 )
   \       0x6A   0xB97C             CBNZ.N   R4,??xEventGroupWaitBits_9
    367          		{
    368          			/* The wait condition has not been met, but no block time was
    369          			specified, so just return the current value. */
    370          			uxReturn = uxCurrentEventBits;
   \       0x6C   0xE01D             B.N      ??xEventGroupWaitBits_10
    371          		}
   \                     ??xEventGroupWaitBits_7: (+1)
   \       0x6E   0x2020             MOVS     R0,#+32
   \       0x70   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x74   0xF3BF 0x8F4F      DSB      SY
   \       0x78   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupWaitBits_11: (+1)
   \       0x7C   0xE7FE             B.N      ??xEventGroupWaitBits_11
   \                     ??xEventGroupWaitBits_8: (+1)
   \       0x7E   0x2400             MOVS     R4,#+0
   \       0x80   0xB19D             CBZ.N    R5,??xEventGroupWaitBits_10
   \       0x82   0x6830             LDR      R0,[R6, #+0]
   \       0x84   0xEA20 0x0009      BIC      R0,R0,R9
   \       0x88   0x6030             STR      R0,[R6, #+0]
   \       0x8A   0xE00E             B.N      ??xEventGroupWaitBits_10
    372          		else
    373          		{
    374          			/* The task is going to block to wait for its required bits to be
    375          			set.  uxControlBits are used to remember the specified behaviour of
    376          			this call to xEventGroupWaitBits() - for use when the event bits
    377          			unblock the task. */
    378          			if( xClearOnExit != pdFALSE )
   \                     ??xEventGroupWaitBits_9: (+1)
   \       0x8C   0xB10D             CBZ.N    R5,??xEventGroupWaitBits_12
    379          			{
    380          				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
   \       0x8E   0xF04F 0x7A80      MOV      R10,#+16777216
    381          			}
    382          			else
    383          			{
    384          				mtCOVERAGE_TEST_MARKER();
    385          			}
    386          
    387          			if( xWaitForAllBits != pdFALSE )
   \                     ??xEventGroupWaitBits_12: (+1)
   \       0x92   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x96   0xBF18             IT       NE 
   \       0x98   0xF04A 0x6A80      ORRNE    R10,R10,#0x4000000
    388          			{
    389          				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    390          			}
    391          			else
    392          			{
    393          				mtCOVERAGE_TEST_MARKER();
    394          			}
    395          
    396          			/* Store the bits that the calling task is waiting for in the
    397          			task's event list item so the kernel knows when a match is
    398          			found.  Then enter the blocked state. */
    399          			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
   \       0x9C   0x4622             MOV      R2,R4
   \       0x9E   0xEA4A 0x0109      ORR      R1,R10,R9
   \       0xA2   0x1D30             ADDS     R0,R6,#+4
   \       0xA4   0x.... 0x....      BL       vTaskPlaceOnUnorderedEventList
    400          
    401          			/* This is obsolete as it will get set after the task unblocks, but
    402          			some compilers mistakenly generate a warning about the variable
    403          			being returned without being set if it is not done. */
    404          			uxReturn = 0;
   \       0xA8   0x2700             MOVS     R7,#+0
    405          
    406          			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
    407          		}
    408          	}
    409          	xAlreadyYielded = xTaskResumeAll();
   \                     ??xEventGroupWaitBits_10: (+1)
   \       0xAA   0x.... 0x....      BL       xTaskResumeAll
    410          
    411          	if( xTicksToWait != ( TickType_t ) 0 )
   \       0xAE   0xB30C             CBZ.N    R4,??xEventGroupWaitBits_13
    412          	{
    413          		if( xAlreadyYielded == pdFALSE )
   \       0xB0   0xB938             CBNZ.N   R0,??xEventGroupWaitBits_14
    414          		{
    415          			portYIELD_WITHIN_API();
   \       0xB2   0x....             LDR.N    R1,??DataTable3  ;; 0xe000ed04
   \       0xB4   0xF04F 0x5080      MOV      R0,#+268435456
   \       0xB8   0x6008             STR      R0,[R1, #+0]
   \       0xBA   0xF3BF 0x8F4F      DSB      SY
   \       0xBE   0xF3BF 0x8F6F      ISB      SY
    416          		}
    417          		else
    418          		{
    419          			mtCOVERAGE_TEST_MARKER();
    420          		}
    421          
    422          		/* The task blocked to wait for its required bits to be set - at this
    423          		point either the required bits were set or the block time expired.  If
    424          		the required bits were set they will have been stored in the task's
    425          		event list item, and they should now be retrieved then cleared. */
    426          		uxReturn = uxTaskResetEventItemValue();
   \                     ??xEventGroupWaitBits_14: (+1)
   \       0xC2   0x.... 0x....      BL       uxTaskResetEventItemValue
   \       0xC6   0x4607             MOV      R7,R0
    427          
    428          		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
   \       0xC8   0x01B8             LSLS     R0,R7,#+6
   \       0xCA   0xD411             BMI.N    ??xEventGroupWaitBits_15
    429          		{
    430          			taskENTER_CRITICAL();
   \       0xCC   0x.... 0x....      BL       vPortEnterCritical
    431          			{
    432          				/* The task timed out, just return the current event bit value. */
    433          				uxReturn = pxEventBits->uxEventBits;
   \       0xD0   0x6837             LDR      R7,[R6, #+0]
    434          
    435          				/* It is possible that the event bits were updated between this
    436          				task leaving the Blocked state and running again. */
    437          				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
   \       0xD2   0x4642             MOV      R2,R8
   \       0xD4   0x4649             MOV      R1,R9
   \       0xD6   0x4638             MOV      R0,R7
   \       0xD8   0x.... 0x....      BL       prvTestWaitCondition
   \       0xDC   0x2800             CMP      R0,#+0
   \       0xDE   0xBF18             IT       NE 
   \       0xE0   0x2D00             CMPNE    R5,#+0
    438          				{
    439          					if( xClearOnExit != pdFALSE )
   \       0xE2   0xD003             BEQ.N    ??xEventGroupWaitBits_16
    440          					{
    441          						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
   \       0xE4   0x6830             LDR      R0,[R6, #+0]
   \       0xE6   0xEA20 0x0009      BIC      R0,R0,R9
   \       0xEA   0x6030             STR      R0,[R6, #+0]
    442          					}
    443          					else
    444          					{
    445          						mtCOVERAGE_TEST_MARKER();
    446          					}
    447          				}
    448          				else
    449          				{
    450          					mtCOVERAGE_TEST_MARKER();
    451          				}
    452          			}
    453          			taskEXIT_CRITICAL();
   \                     ??xEventGroupWaitBits_16: (+1)
   \       0xEC   0x.... 0x....      BL       vPortExitCritical
    454          
    455          			/* Prevent compiler warnings when trace macros are not used. */
    456          			xTimeoutOccurred = pdFALSE;
    457          		}
    458          		else
    459          		{
    460          			/* The task unblocked because the bits were set. */
    461          		}
    462          
    463          		/* The task blocked so control bits may have been set. */
    464          		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
   \                     ??xEventGroupWaitBits_15: (+1)
   \       0xF0   0xF027 0x477F      BIC      R7,R7,#0xFF000000
    465          	}
    466          	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );
    467          
    468          	return uxReturn;
   \                     ??xEventGroupWaitBits_13: (+1)
   \       0xF4   0x4638             MOV      R0,R7
   \       0xF6   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    469          }
    470          /*-----------------------------------------------------------*/
    471          

   \                                 In section .text, align 2, keep-with-next
    472          EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
    473          {
   \                     xEventGroupClearBits: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x460D             MOV      R5,R1
    474          EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    475          EventBits_t uxReturn;
    476          
    477          	/* Check the user is not attempting to clear the bits used by the kernel
    478          	itself. */
    479          	configASSERT( xEventGroup );
   \        0x6   0xD107             BNE.N    ??xEventGroupClearBits_0
   \        0x8   0x2020             MOVS     R0,#+32
   \        0xA   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xE   0xF3BF 0x8F4F      DSB      SY
   \       0x12   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupClearBits_1: (+1)
   \       0x16   0xE7FE             B.N      ??xEventGroupClearBits_1
    480          	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
   \                     ??xEventGroupClearBits_0: (+1)
   \       0x18   0xF015 0x4F7F      TST      R5,#0xFF000000
   \       0x1C   0xD007             BEQ.N    ??xEventGroupClearBits_2
   \       0x1E   0x2020             MOVS     R0,#+32
   \       0x20   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x24   0xF3BF 0x8F4F      DSB      SY
   \       0x28   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupClearBits_3: (+1)
   \       0x2C   0xE7FE             B.N      ??xEventGroupClearBits_3
    481          
    482          	taskENTER_CRITICAL();
   \                     ??xEventGroupClearBits_2: (+1)
   \       0x2E   0x.... 0x....      BL       vPortEnterCritical
    483          	{
    484          		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );
    485          
    486          		/* The value returned is the event group value prior to the bits being
    487          		cleared. */
    488          		uxReturn = pxEventBits->uxEventBits;
   \       0x32   0x6826             LDR      R6,[R4, #+0]
    489          
    490          		/* Clear the bits. */
    491          		pxEventBits->uxEventBits &= ~uxBitsToClear;
   \       0x34   0xEA26 0x0505      BIC      R5,R6,R5
   \       0x38   0x6025             STR      R5,[R4, #+0]
    492          	}
    493          	taskEXIT_CRITICAL();
   \       0x3A   0x.... 0x....      BL       vPortExitCritical
    494          
    495          	return uxReturn;
   \       0x3E   0x4630             MOV      R0,R6
   \       0x40   0xBD70             POP      {R4-R6,PC}       ;; return
    496          }
    497          /*-----------------------------------------------------------*/
    498          
    499          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )
    500          

   \                                 In section .text, align 2, keep-with-next
    501          	BaseType_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
    502          	{
   \                     xEventGroupClearBitsFromISR: (+1)
   \        0x0   0x460A             MOV      R2,R1
    503          		BaseType_t xReturn;
    504          
    505          		traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear );
    506          		xReturn = xTimerPendFunctionCallFromISR( vEventGroupClearBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToClear, NULL );
    507          
    508          		return xReturn;
   \        0x2   0x4601             MOV      R1,R0
   \        0x4   0x2300             MOVS     R3,#+0
   \        0x6   0x.... 0x....      ADR.W    R0,vEventGroupClearBitsCallback
   \        0xA   0x.... 0x....      B.W      xTimerPendFunctionCallFromISR
    509          	}
    510          
    511          #endif
    512          /*-----------------------------------------------------------*/
    513          

   \                                 In section .text, align 2, keep-with-next
    514          EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
    515          {
    516          UBaseType_t uxSavedInterruptStatus;
    517          EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    518          EventBits_t uxReturn;
    519          
    520          	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \                     xEventGroupGetBitsFromISR: (+1)
   \        0x0   0xF3EF 0x8111      MRS      R1,BASEPRI
   \        0x4   0x2220             MOVS     R2,#+32
   \        0x6   0xF382 0x8811      MSR      BASEPRI,R2
   \        0xA   0xF3BF 0x8F4F      DSB      SY
   \        0xE   0xF3BF 0x8F6F      ISB      SY
    521          	{
    522          		uxReturn = pxEventBits->uxEventBits;
   \       0x12   0x6800             LDR      R0,[R0, #+0]
    523          	}
    524          	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \       0x14   0xF381 0x8811      MSR      BASEPRI,R1
    525          
    526          	return uxReturn;
   \       0x18   0x4770             BX       LR               ;; return
    527          }
    528          /*-----------------------------------------------------------*/
    529          

   \                                 In section .text, align 2, keep-with-next
    530          EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
    531          {
   \                     xEventGroupSetBits: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    532          ListItem_t *pxListItem, *pxNext;
    533          ListItem_t const *pxListEnd;
    534          List_t *pxList;
    535          EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
   \        0x6   0x2600             MOVS     R6,#+0
    536          EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    537          BaseType_t xMatchFound = pdFALSE;
    538          
    539          	/* Check the user is not attempting to set the bits used by the kernel
    540          	itself. */
    541          	configASSERT( xEventGroup );
   \        0x8   0xB93C             CBNZ.N   R4,??xEventGroupSetBits_0
   \        0xA   0x2020             MOVS     R0,#+32
   \        0xC   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x10   0xF3BF 0x8F4F      DSB      SY
   \       0x14   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupSetBits_1: (+1)
   \       0x18   0xE7FE             B.N      ??xEventGroupSetBits_1
    542          	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
   \                     ??xEventGroupSetBits_0: (+1)
   \       0x1A   0xF015 0x4F7F      TST      R5,#0xFF000000
   \       0x1E   0xD007             BEQ.N    ??xEventGroupSetBits_2
   \       0x20   0x2020             MOVS     R0,#+32
   \       0x22   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x26   0xF3BF 0x8F4F      DSB      SY
   \       0x2A   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupSetBits_3: (+1)
   \       0x2E   0xE7FE             B.N      ??xEventGroupSetBits_3
    543          
    544          	pxList = &( pxEventBits->xTasksWaitingForBits );
    545          	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    546          	vTaskSuspendAll();
   \                     ??xEventGroupSetBits_2: (+1)
   \       0x30   0x.... 0x....      BL       vTaskSuspendAll
    547          	{
    548          		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );
    549          
    550          		pxListItem = listGET_HEAD_ENTRY( pxList );
    551          
    552          		/* Set the bits. */
    553          		pxEventBits->uxEventBits |= uxBitsToSet;
   \       0x34   0x6820             LDR      R0,[R4, #+0]
   \       0x36   0x6922             LDR      R2,[R4, #+16]
   \       0x38   0x4305             ORRS     R5,R5,R0
   \       0x3A   0x6025             STR      R5,[R4, #+0]
    554          
    555          		/* See if the new bit value should unblock any tasks. */
    556          		while( pxListItem != pxListEnd )
   \                     ??xEventGroupSetBits_4: (+1)
   \       0x3C   0xF104 0x030C      ADD      R3,R4,#+12
   \       0x40   0x6821             LDR      R1,[R4, #+0]
   \       0x42   0x429A             CMP      R2,R3
   \       0x44   0xD017             BEQ.N    ??xEventGroupSetBits_5
    557          		{
    558          			pxNext = listGET_NEXT( pxListItem );
    559          			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    560          			xMatchFound = pdFALSE;
    561          
    562          			/* Split the bits waited for from the control bits. */
    563          			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
   \       0x46   0x6817             LDR      R7,[R2, #+0]
   \       0x48   0x6855             LDR      R5,[R2, #+4]
    564          			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
   \       0x4A   0xF027 0x437F      BIC      R3,R7,#0xFF000000
    565          
    566          			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
   \       0x4E   0xEA5F 0x1C47      LSLS     R12,R7,#+5
   \       0x52   0xEA01 0x0003      AND      R0,R1,R3
   \       0x56   0xD50A             BPL.N    ??xEventGroupSetBits_6
    567          			{
    568          				/* Just looking for single bit being set. */
    569          				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    570          				{
    571          					xMatchFound = pdTRUE;
    572          				}
    573          				else
    574          				{
    575          					mtCOVERAGE_TEST_MARKER();
    576          				}
    577          			}
    578          			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
   \       0x58   0x4298             CMP      R0,R3
   \       0x5A   0xD10A             BNE.N    ??xEventGroupSetBits_7
    579          			{
    580          				/* All bits are set. */
    581          				xMatchFound = pdTRUE;
    582          			}
    583          			else
    584          			{
    585          				/* Need all bits to be set, but not all the bits were set. */
    586          			}
    587          
    588          			if( xMatchFound != pdFALSE )
    589          			{
    590          				/* The bits match.  Should the bits be cleared on exit? */
    591          				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
   \                     ??xEventGroupSetBits_8: (+1)
   \       0x5C   0x01F8             LSLS     R0,R7,#+7
   \       0x5E   0xBF48             IT       MI 
   \       0x60   0x431E             ORRMI    R6,R3,R6
    592          				{
    593          					uxBitsToClear |= uxBitsWaitedFor;
    594          				}
    595          				else
    596          				{
    597          					mtCOVERAGE_TEST_MARKER();
    598          				}
    599          
    600          				/* Store the actual event flag value in the task's event list
    601          				item before removing the task from the event list.  The
    602          				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
    603          				that is was unblocked due to its required bits matching, rather
    604          				than because it timed out. */
    605          				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
   \       0x62   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \       0x66   0x4610             MOV      R0,R2
   \       0x68   0x.... 0x....      BL       xTaskRemoveFromUnorderedEventList
   \       0x6C   0xE001             B.N      ??xEventGroupSetBits_7
    606          			}
   \                     ??xEventGroupSetBits_6: (+1)
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD1F4             BNE.N    ??xEventGroupSetBits_8
    607          
    608          			/* Move onto the next list item.  Note pxListItem->pxNext is not
    609          			used here as the list item may have been removed from the event list
    610          			and inserted into the ready/pending reading list. */
    611          			pxListItem = pxNext;
   \                     ??xEventGroupSetBits_7: (+1)
   \       0x72   0x462A             MOV      R2,R5
   \       0x74   0xE7E2             B.N      ??xEventGroupSetBits_4
    612          		}
    613          
    614          		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
    615          		bit was set in the control word. */
    616          		pxEventBits->uxEventBits &= ~uxBitsToClear;
   \                     ??xEventGroupSetBits_5: (+1)
   \       0x76   0xEA21 0x0606      BIC      R6,R1,R6
   \       0x7A   0x6026             STR      R6,[R4, #+0]
    617          	}
    618          	( void ) xTaskResumeAll();
   \       0x7C   0x.... 0x....      BL       xTaskResumeAll
    619          
    620          	return pxEventBits->uxEventBits;
   \       0x80   0x6820             LDR      R0,[R4, #+0]
   \       0x82   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    621          }
    622          /*-----------------------------------------------------------*/
    623          

   \                                 In section .text, align 2, keep-with-next
    624          void vEventGroupDelete( EventGroupHandle_t xEventGroup )
    625          {
   \                     vEventGroupDelete: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    626          EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    627          const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    628          
    629          	vTaskSuspendAll();
   \        0x4   0x.... 0x....      BL       vTaskSuspendAll
   \        0x8   0xE003             B.N      ??vEventGroupDelete_0
    630          	{
    631          		traceEVENT_GROUP_DELETE( xEventGroup );
    632          
    633          		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    634          		{
    635          			/* Unblock the task, returning 0 as the event list is being deleted
    636          			and	cannot therefore have any bits set. */
    637          			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
    638          			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
   \                     ??vEventGroupDelete_1: (+1)
   \        0xA   0xF04F 0x7100      MOV      R1,#+33554432
   \        0xE   0x.... 0x....      BL       xTaskRemoveFromUnorderedEventList
   \                     ??vEventGroupDelete_0: (+1)
   \       0x12   0x6860             LDR      R0,[R4, #+4]
   \       0x14   0xB160             CBZ.N    R0,??vEventGroupDelete_2
   \       0x16   0x6920             LDR      R0,[R4, #+16]
   \       0x18   0xF104 0x010C      ADD      R1,R4,#+12
   \       0x1C   0x4288             CMP      R0,R1
   \       0x1E   0xD1F4             BNE.N    ??vEventGroupDelete_1
   \       0x20   0x2020             MOVS     R0,#+32
   \       0x22   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x26   0xF3BF 0x8F4F      DSB      SY
   \       0x2A   0xF3BF 0x8F6F      ISB      SY
   \                     ??vEventGroupDelete_3: (+1)
   \       0x2E   0xE7FE             B.N      ??vEventGroupDelete_3
    639          		}
    640          
    641          		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    642          		{
    643          			/* The event group can only have been allocated dynamically - free
    644          			it again. */
    645          			vPortFree( pxEventBits );
   \                     ??vEventGroupDelete_2: (+1)
   \       0x30   0x4620             MOV      R0,R4
   \       0x32   0x.... 0x....      BL       vPortFree
    646          		}
    647          		#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
    648          		{
    649          			/* The event group could have been allocated statically or
    650          			dynamically, so check before attempting to free the memory. */
    651          			if( pxEventBits->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
    652          			{
    653          				vPortFree( pxEventBits );
    654          			}
    655          			else
    656          			{
    657          				mtCOVERAGE_TEST_MARKER();
    658          			}
    659          		}
    660          		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    661          	}
    662          	( void ) xTaskResumeAll();
   \       0x36   0xE8BD 0x4010      POP      {R4,LR}
   \       0x3A   0x.... 0x....      B.W      xTaskResumeAll
    663          }
    664          /*-----------------------------------------------------------*/
    665          
    666          /* For internal use only - execute a 'set bits' command that was pended from
    667          an interrupt. */

   \                                 In section .text, align 2, keep-with-next
    668          void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
    669          {
    670          	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
   \                     vEventGroupSetBitsCallback: (+1)
   \        0x0   0x....             B.N      xEventGroupSetBits
    671          }
    672          /*-----------------------------------------------------------*/
    673          
    674          /* For internal use only - execute a 'clear bits' command that was pended from
    675          an interrupt. */

   \                                 In section .text, align 4, keep-with-next
    676          void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
    677          {
   \                     vEventGroupClearBitsCallback: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x460D             MOV      R5,R1
    678          	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
   \        0x6   0xD107             BNE.N    ??vEventGroupClearBitsCallback_0
   \        0x8   0x2020             MOVS     R0,#+32
   \        0xA   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xE   0xF3BF 0x8F4F      DSB      SY
   \       0x12   0xF3BF 0x8F6F      ISB      SY
   \                     ??vEventGroupClearBitsCallback_1: (+1)
   \       0x16   0xE7FE             B.N      ??vEventGroupClearBitsCallback_1
   \                     ??vEventGroupClearBitsCallback_0: (+1)
   \       0x18   0xF015 0x4F7F      TST      R5,#0xFF000000
   \       0x1C   0xD007             BEQ.N    ??vEventGroupClearBitsCallback_2
   \       0x1E   0x2020             MOVS     R0,#+32
   \       0x20   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x24   0xF3BF 0x8F4F      DSB      SY
   \       0x28   0xF3BF 0x8F6F      ISB      SY
   \                     ??vEventGroupClearBitsCallback_3: (+1)
   \       0x2C   0xE7FE             B.N      ??vEventGroupClearBitsCallback_3
   \                     ??vEventGroupClearBitsCallback_2: (+1)
   \       0x2E   0x.... 0x....      BL       vPortEnterCritical
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0xEA20 0x0505      BIC      R5,R0,R5
   \       0x38   0x6025             STR      R5,[R4, #+0]
   \       0x3A   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \       0x3E   0x.... 0x....      B.W      vPortExitCritical
    679          }
    680          /*-----------------------------------------------------------*/
    681          

   \                                 In section .text, align 2, keep-with-next
    682          static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
    683          {
   \                     prvTestWaitCondition: (+1)
   \        0x0   0x4603             MOV      R3,R0
    684          BaseType_t xWaitConditionMet = pdFALSE;
   \        0x2   0x2000             MOVS     R0,#+0
    685          
    686          	if( xWaitForAllBits == pdFALSE )
   \        0x4   0x400B             ANDS     R3,R1,R3
   \        0x6   0xB90A             CBNZ.N   R2,??prvTestWaitCondition_0
    687          	{
    688          		/* Task only has to wait for one bit within uxBitsToWaitFor to be
    689          		set.  Is one already set? */
    690          		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
   \        0x8   0xB11B             CBZ.N    R3,??prvTestWaitCondition_1
    691          		{
    692          			xWaitConditionMet = pdTRUE;
   \        0xA   0xE001             B.N      ??prvTestWaitCondition_2
    693          		}
    694          		else
    695          		{
    696          			mtCOVERAGE_TEST_MARKER();
    697          		}
    698          	}
    699          	else
    700          	{
    701          		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
    702          		Are they set already? */
    703          		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
   \                     ??prvTestWaitCondition_0: (+1)
   \        0xC   0x428B             CMP      R3,R1
   \        0xE   0xD100             BNE.N    ??prvTestWaitCondition_1
    704          		{
    705          			xWaitConditionMet = pdTRUE;
   \                     ??prvTestWaitCondition_2: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
    706          		}
    707          		else
    708          		{
    709          			mtCOVERAGE_TEST_MARKER();
    710          		}
    711          	}
    712          
    713          	return xWaitConditionMet;
   \                     ??prvTestWaitCondition_1: (+1)
   \       0x12   0x4770             BX       LR               ;; return
    714          }
    715          /*-----------------------------------------------------------*/
    716          
    717          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )
    718          

   \                                 In section .text, align 2, keep-with-next
    719          	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken )
    720          	{
   \                     xEventGroupSetBitsFromISR: (+1)
   \        0x0   0x4613             MOV      R3,R2
    721          	BaseType_t xReturn;
    722          
    723          		traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet );
    724          		xReturn = xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken );
    725          
    726          		return xReturn;
   \        0x2   0x460A             MOV      R2,R1
   \        0x4   0x4601             MOV      R1,R0
   \        0x6   0x....             LDR.N    R0,??DataTable3_1
   \        0x8   0x.... 0x....      B.W      xTimerPendFunctionCallFromISR
    727          	}
    728          
    729          #endif
    730          /*-----------------------------------------------------------*/
    731          
    732          #if (configUSE_TRACE_FACILITY == 1)
    733          

   \                                 In section .text, align 2, keep-with-next
    734          	UBaseType_t uxEventGroupGetNumber( void* xEventGroup )
    735          	{
    736          	UBaseType_t xReturn;
    737          	EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    738          
    739          		if( xEventGroup == NULL )
   \                     uxEventGroupGetNumber: (+1)
   \        0x0   0xB100             CBZ.N    R0,??uxEventGroupGetNumber_0
    740          		{
    741          			xReturn = 0;
    742          		}
    743          		else
    744          		{
    745          			xReturn = pxEventBits->uxEventGroupNumber;
   \        0x2   0x6980             LDR      R0,[R0, #+24]
    746          		}
    747          
    748          		return xReturn;
   \                     ??uxEventGroupGetNumber_0: (+1)
   \        0x4   0x4770             BX       LR               ;; return
    749          	}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0xE000'ED04        DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0x....'....        DC32     vEventGroupSetBitsCallback
    750          
    751          #endif
    752          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   prvTestWaitCondition
       0   uxEventGroupGetNumber
      16   vEventGroupClearBitsCallback
        16   -> vPortEnterCritical
         0   -> vPortExitCritical
       8   vEventGroupDelete
         8   -> vPortFree
         8   -> vTaskSuspendAll
         8   -> xTaskRemoveFromUnorderedEventList
         0   -> xTaskResumeAll
       0   vEventGroupSetBitsCallback
         0   -> xEventGroupSetBits
      16   xEventGroupClearBits
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
       0   xEventGroupClearBitsFromISR
         0   -> xTimerPendFunctionCallFromISR
       8   xEventGroupCreate
         8   -> pvPortMalloc
         8   -> vListInitialise
       0   xEventGroupGetBitsFromISR
      24   xEventGroupSetBits
        24   -> vTaskSuspendAll
        24   -> xTaskRemoveFromUnorderedEventList
        24   -> xTaskResumeAll
       0   xEventGroupSetBitsFromISR
         0   -> xTimerPendFunctionCallFromISR
      24   xEventGroupSync
        24   -> uxTaskResetEventItemValue
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
        24   -> vTaskPlaceOnUnorderedEventList
        24   -> vTaskSuspendAll
        24   -> xEventGroupSetBits
        24   -> xTaskGetSchedulerState
        24   -> xTaskResumeAll
      32   xEventGroupWaitBits
        32   -> prvTestWaitCondition
        32   -> uxTaskResetEventItemValue
        32   -> vPortEnterCritical
        32   -> vPortExitCritical
        32   -> vTaskPlaceOnUnorderedEventList
        32   -> vTaskSuspendAll
        32   -> xTaskGetSchedulerState
        32   -> xTaskResumeAll


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
      20  prvTestWaitCondition
       6  uxEventGroupGetNumber
      66  vEventGroupClearBitsCallback
      62  vEventGroupDelete
       2  vEventGroupSetBitsCallback
      66  xEventGroupClearBits
      14  xEventGroupClearBitsFromISR
      26  xEventGroupCreate
      26  xEventGroupGetBitsFromISR
     132  xEventGroupSetBits
      12  xEventGroupSetBitsFromISR
     204  xEventGroupSync
     250  xEventGroupWaitBits

 
 894 bytes in section .text
 
 894 bytes of CODE memory

Errors: none
Warnings: none
