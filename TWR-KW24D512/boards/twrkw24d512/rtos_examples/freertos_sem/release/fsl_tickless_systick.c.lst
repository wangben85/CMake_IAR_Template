###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         03/Mar/2020  16:31:27
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\portable\IAR\ARM_CM3\fsl_tickless_systick.c
#    Command line =  
#        C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\portable\IAR\ARM_CM3\fsl_tickless_systick.c
#        "-IC:\Program Files (x86)\IAR Systems\Embedded Workbench 8.1\arm\inc"
#        -I..\..\..\..\..\CMSIS\Include -I..\..\..\..\..\devices -I..\..\..
#        -I..\..\..\..\..\devices\MKW24D5\drivers
#        -I..\..\..\..\..\devices\MKW24D5\utilities
#        -I..\..\..\..\..\devices\MKW24D5 -I..\..\iar -I..\.. -I..\
#        -I..\..\..\..\..\rtos\freertos_9.0.0\Source\portable\IAR\ARM_CM3
#        -I..\..\..\..\..\rtos\freertos_9.0.0\Source\include -DNDEBUG
#        -DCPU_MKW24D512VHA5 -DIAR -DFSL_RTOS_FREE_RTOS -DPRINTF_FLOAT_ENABLE=0
#        -DSCANF_FLOAT_ENABLE=0 -DPRINTF_ADVANCED_ENABLE=0
#        -DSCANF_ADVANCED_ENABLE=0 -DTWR_KW24D512 -DTOWER --diag_suppress
#        Pa082,Pa050,Pe167,Pa182 --endian=little --cpu=Cortex-M4 --fpu=None
#        --no_path_in_file_macros --silent -lC . -e --dlib_config "C:/Program
#        Files (x86)/IAR Systems/Embedded Workbench
#        8.1/arm/inc/c/DLib_Config_Normal.h" -Oh --dependencies=ns
#        CMakeFiles\freertos_sem.dir\cd0b8de2f727f3af9b2948347d59898c\rtos\freertos_9.0.0\Source\portable\IAR\ARM_CM3\fsl_tickless_systick.c.obj.d
#        -o
#        CMakeFiles\freertos_sem.dir\cd0b8de2f727f3af9b2948347d59898c\rtos\freertos_9.0.0\Source\portable\IAR\ARM_CM3\fsl_tickless_systick.c.obj
#    Locale       =  C
#    List file    =  .\fsl_tickless_systick.c.lst
#    Object file  =  
#        CMakeFiles\freertos_sem.dir\cd0b8de2f727f3af9b2948347d59898c\rtos\freertos_9.0.0\Source\portable\IAR\ARM_CM3\fsl_tickless_systick.c.obj
#
###############################################################################

C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\portable\IAR\ARM_CM3\fsl_tickless_systick.c
      1          /*
      2              FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
      3              All rights reserved
      4          
      5              VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              This file is part of the FreeRTOS distribution.
      8          
      9              FreeRTOS is free software; you can redistribute it and/or modify it under
     10              the terms of the GNU General Public License (version 2) as published by the
     11              Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
     12          
     13              ***************************************************************************
     14              >>!   NOTE: The modification to the GPL is included to allow you to     !<<
     15              >>!   distribute a combined work that includes FreeRTOS without being   !<<
     16              >>!   obliged to provide the source code for proprietary components     !<<
     17              >>!   outside of the FreeRTOS kernel.                                   !<<
     18              ***************************************************************************
     19          
     20              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
     21              WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     22              FOR A PARTICULAR PURPOSE.  Full license text is available on the following
     23              link: http://www.freertos.org/a00114.html
     24          
     25              ***************************************************************************
     26               *                                                                       *
     27               *    FreeRTOS provides completely free yet professionally developed,    *
     28               *    robust, strictly quality controlled, supported, and cross          *
     29               *    platform software that is more than just the market leader, it     *
     30               *    is the industry's de facto standard.                               *
     31               *                                                                       *
     32               *    Help yourself get started quickly while simultaneously helping     *
     33               *    to support the FreeRTOS project by purchasing a FreeRTOS           *
     34               *    tutorial book, reference manual, or both:                          *
     35               *    http://www.FreeRTOS.org/Documentation                              *
     36               *                                                                       *
     37              ***************************************************************************
     38          
     39              http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
     40              the FAQ page "My application does not run, what could be wrong?".  Have you
     41              defined configASSERT()?
     42          
     43              http://www.FreeRTOS.org/support - In return for receiving this top quality
     44              embedded software for free we request you assist our global community by
     45              participating in the support forum.
     46          
     47              http://www.FreeRTOS.org/training - Investing in training allows your team to
     48              be as productive as possible as early as possible.  Now you can receive
     49              FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
     50              Ltd, and the world's leading authority on the world's leading RTOS.
     51          
     52              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     53              including FreeRTOS+Trace - an indispensable productivity tool, a DOS
     54              compatible FAT file system, and our tiny thread aware UDP/IP stack.
     55          
     56              http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
     57              Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
     58          
     59              http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
     60              Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
     61              licenses offer ticketed support, indemnification and commercial middleware.
     62          
     63              http://www.SafeRTOS.com - High Integrity Systems also provide a safety
     64              engineered and independently SIL3 certified version for use in safety and
     65              mission critical applications that require provable dependability.
     66          
     67              1 tab == 4 spaces!
     68          */
     69          /* Compiler includes. */
     70          #include <intrinsics.h>
     71          
     72          /* Scheduler includes. */
     73          #include "FreeRTOS.h"
     74          #include "task.h"
     75          #include "fsl_tickless_generic.h"
     76          
     77          extern uint32_t SystemCoreClock; /* in Kinetis SDK, this contains the system core clock speed */
     78          
     79          /*
     80           * The number of SysTick increments that make up one tick period.
     81           */
     82          #if configUSE_TICKLESS_IDLE == 1
     83          	static uint32_t ulTimerCountsForOneTick = 0;
     84          #endif /* configUSE_TICKLESS_IDLE */
     85          
     86          /*
     87           * The maximum number of tick periods that can be suppressed is limited by the
     88           * 24 bit resolution of the SysTick timer.
     89           */
     90          #if configUSE_TICKLESS_IDLE == 1
     91          	static uint32_t xMaximumPossibleSuppressedTicks = 0;
     92          #endif /* configUSE_TICKLESS_IDLE */
     93          
     94          /*
     95           * Compensate for the CPU cycles that pass while the SysTick is stopped (low
     96           * power functionality only.
     97           */
     98          #if configUSE_TICKLESS_IDLE == 1
     99          	static uint32_t ulStoppedTimerCompensation = 0;
    100          #endif /* configUSE_TICKLESS_IDLE */
    101          
    102          
    103          /*-----------------------------------------------------------*/
    104          #if configUSE_TICKLESS_IDLE == 1
    105          
    106          	__weak void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
    107          	{
    108          	uint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements, ulSysTickCTRL;
    109          	TickType_t xModifiableIdleTime;
    110          
    111          		/* Make sure the SysTick reload value does not overflow the counter. */
    112          		if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
    113          		{
    114          			xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
    115          		}
    116          		if (xExpectedIdleTime == 0) return;
    117          		/* Stop the SysTick momentarily.  The time the SysTick is stopped for
    118          		is accounted for as best it can be, but using the tickless mode will
    119          		inevitably result in some tiny drift of the time maintained by the
    120          		kernel with respect to calendar time. */
    121          		portNVIC_SYSTICK_CTRL_REG &= ~portNVIC_SYSTICK_ENABLE_BIT;
    122          
    123          		/* Calculate the reload value required to wait xExpectedIdleTime
    124          		tick periods.  -1 is used because this code will execute part way
    125          		through one of the tick periods. */
    126          		ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );
    127          		if( ulReloadValue > ulStoppedTimerCompensation )
    128          		{
    129          			ulReloadValue -= ulStoppedTimerCompensation;
    130          		}
    131          
    132          		/* Enter a critical section but don't use the taskENTER_CRITICAL()
    133          		method as that will mask interrupts that should exit sleep mode. */
    134          		__disable_interrupt();
    135          		__DSB();
    136          		__ISB();
    137          
    138          
    139          		/* If a context switch is pending or a task is waiting for the scheduler
    140          		to be unsuspended then abandon the low power entry. */
    141          		if( eTaskConfirmSleepModeStatus() == eAbortSleep )
    142          		{
    143          			/* Restart from whatever is left in the count register to complete
    144          			this tick period. */
    145          			portNVIC_SYSTICK_LOAD_REG = portNVIC_SYSTICK_CURRENT_VALUE_REG;
    146          
    147          			/* Restart SysTick. */
    148          			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
    149          
    150          			/* Reset the reload register to the value required for normal tick
    151          			periods. */
    152          			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
    153          
    154          			/* Re-enable interrupts - see comments above __disable_interrupt()
    155          			call above. */
    156          			__enable_interrupt();
    157          		}
    158          		else
    159          		{
    160          			/* Set the new reload value. */
    161          			portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
    162          
    163          			/* Clear the SysTick count flag and set the count value back to
    164          			zero. */
    165          			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
    166          
    167          			/* Restart SysTick. */
    168          			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
    169          
    170          			/* Sleep until something happens.  configPRE_SLEEP_PROCESSING() can
    171          			set its parameter to 0 to indicate that its implementation contains
    172          			its own wait for interrupt or wait for event instruction, and so wfi
    173          			should not be executed again.  However, the original expected idle
    174          			time variable must remain unmodified, so a copy is taken. */
    175          			xModifiableIdleTime = xExpectedIdleTime;
    176          			configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
    177          			if( xModifiableIdleTime > 0 )
    178          			{
    179          				__DSB();
    180          				__WFI();
    181          				__ISB();
    182          			}
    183          			configPOST_SLEEP_PROCESSING( xExpectedIdleTime );
    184          
    185          			/* Stop SysTick.  Again, the time the SysTick is stopped for is
    186          			accounted for as best it can be, but using the tickless mode will
    187          			inevitably result in some tiny drift of the time maintained by the
    188          			kernel with respect to calendar time. */
    189          			ulSysTickCTRL = portNVIC_SYSTICK_CTRL_REG;
    190          			portNVIC_SYSTICK_CTRL_REG = ( ulSysTickCTRL & ~portNVIC_SYSTICK_ENABLE_BIT );
    191          
    192          			/* Re-enable interrupts - see comments above __disable_interrupt()
    193          			call above. */
    194          			__enable_interrupt();
    195          
    196          			if( ( ulSysTickCTRL & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
    197          			{
    198          				uint32_t ulCalculatedLoadValue;
    199          
    200          				/* The tick interrupt has already executed, and the SysTick
    201          				count reloaded with ulReloadValue.  Reset the
    202          				portNVIC_SYSTICK_LOAD_REG with whatever remains of this tick
    203          				period. */
    204          				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );
    205          
    206          				/* Don't allow a tiny value, or values that have somehow
    207          				underflowed because the post sleep hook did something
    208          				that took too long. */
    209          				if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimerCountsForOneTick ) )
    210          				{
    211          					ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
    212          				}
    213          
    214          				portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
    215          
    216          				/* The tick interrupt handler will already have pended the tick
    217          				processing in the kernel.  As the pending tick will be
    218          				processed as soon as this function exits, the tick value
    219          				maintained by the tick is stepped forward by one less than the
    220          				time spent waiting. */
    221          				ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
    222          			}
    223          			else
    224          			{
    225          				/* Something other than the tick interrupt ended the sleep.
    226          				Work out how long the sleep lasted rounded to complete tick
    227          				periods (not the ulReload value which accounted for part
    228          				ticks). */
    229          				ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - portNVIC_SYSTICK_CURRENT_VALUE_REG;
    230          
    231          				/* How many complete tick periods passed while the processor
    232          				was waiting? */
    233          				ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
    234          
    235          				/* The reload value is set to whatever fraction of a single tick
    236          				period remains. */
    237          				portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1UL ) * ulTimerCountsForOneTick ) - ulCompletedSysTickDecrements;
    238          			}
    239          
    240          			/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG
    241          			again, then set portNVIC_SYSTICK_LOAD_REG back to its standard
    242          			value.  The critical section is used to ensure the tick interrupt
    243          			can only execute once in the case that the reload register is near
    244          			zero. */
    245          			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
    246          			portENTER_CRITICAL();
    247          			{
    248          				portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
    249          				vTaskStepTick( ulCompleteTickPeriods );
    250          				portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
    251          			}
    252          			portEXIT_CRITICAL();
    253          		}
    254          	}
    255          
    256          #endif /* #if configUSE_TICKLESS_IDLE */
    257          /*-----------------------------------------------------------*/
    258          
    259          /*
    260           * Setup the systick timer to generate the tick interrupts at the required
    261           * frequency.
    262           */

   \                                 In section .text, align 4
    263          __weak void vPortSetupTimerInterrupt( void )
    264          {
    265          	/* Calculate the constants required to configure the tick interrupt. */
    266          	#if( configUSE_TICKLESS_IDLE == 1 )
    267          	{
    268          		ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
    269          		xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
    270          		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
    271          	}
    272          	#endif /* configUSE_TICKLESS_IDLE */
    273          
    274          	/* Configure SysTick to interrupt at the requested rate. */
    275          	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
   \                     vPortSetupTimerInterrupt: (+1)
   \        0x0   0x4907             LDR.N    R1,??vPortSetupTimerInterrupt_0
   \        0x2   0xF8DF 0xC020      LDR.W    R12,??vPortSetupTimerInterrupt_0+0x4  ;; 0x83126e98
   \        0x6   0x680A             LDR      R2,[R1, #+0]
   \        0x8   0x4807             LDR.N    R0,??vPortSetupTimerInterrupt_0+0x8  ;; 0xe000e010
   \        0xA   0xFBA2 0xC30C      UMULL    R12,R3,R2,R12
   \        0xE   0x0A5B             LSRS     R3,R3,#+9
   \       0x10   0x1E5B             SUBS     R3,R3,#+1
   \       0x12   0x6043             STR      R3,[R0, #+4]
    276          	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x6081             STR      R1,[R0, #+8]
    277          	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
   \       0x18   0x2207             MOVS     R2,#+7
   \       0x1A   0x6002             STR      R2,[R0, #+0]
    278          }
   \       0x1C   0x4770             BX       LR               ;; return
   \       0x1E   0xBF00             Nop      
   \                     ??vPortSetupTimerInterrupt_0:
   \       0x20   0x....'....        DC32     SystemCoreClock
   \       0x24   0x8312'6E98        DC32     0x83126e98
   \       0x28   0xE000'E010        DC32     0xe000e010

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   vPortSetupTimerInterrupt


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      44  vPortSetupTimerInterrupt

 
 44 bytes in section .text
 
 0 bytes of CODE memory (+ 44 bytes shared)

Errors: none
Warnings: none
