###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         03/Mar/2020  16:31:27
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\timers.c
#    Command line =  
#        C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\timers.c
#        "-IC:\Program Files (x86)\IAR Systems\Embedded Workbench 8.1\arm\inc"
#        -I..\..\..\..\..\CMSIS\Include -I..\..\..\..\..\devices -I..\..\..
#        -I..\..\..\..\..\devices\MKW24D5\drivers
#        -I..\..\..\..\..\devices\MKW24D5\utilities
#        -I..\..\..\..\..\devices\MKW24D5 -I..\..\iar -I..\.. -I..\
#        -I..\..\..\..\..\rtos\freertos_9.0.0\Source\portable\IAR\ARM_CM3
#        -I..\..\..\..\..\rtos\freertos_9.0.0\Source\include -DNDEBUG
#        -DCPU_MKW24D512VHA5 -DIAR -DFSL_RTOS_FREE_RTOS -DPRINTF_FLOAT_ENABLE=0
#        -DSCANF_FLOAT_ENABLE=0 -DPRINTF_ADVANCED_ENABLE=0
#        -DSCANF_ADVANCED_ENABLE=0 -DTWR_KW24D512 -DTOWER --diag_suppress
#        Pa082,Pa050,Pe167,Pa182 --endian=little --cpu=Cortex-M4 --fpu=None
#        --no_path_in_file_macros --silent -lC . -e --dlib_config "C:/Program
#        Files (x86)/IAR Systems/Embedded Workbench
#        8.1/arm/inc/c/DLib_Config_Normal.h" -Oh --dependencies=ns
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\timers.c.obj.d
#        -o
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\timers.c.obj
#    Locale       =  C
#    List file    =  .\timers.c.lst
#    Object file  =  
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\timers.c.obj
#
###############################################################################

C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\timers.c
      1          /*
      2              FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
      3              All rights reserved
      4          
      5              VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              This file is part of the FreeRTOS distribution.
      8          
      9              FreeRTOS is free software; you can redistribute it and/or modify it under
     10              the terms of the GNU General Public License (version 2) as published by the
     11              Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
     12          
     13              ***************************************************************************
     14              >>!   NOTE: The modification to the GPL is included to allow you to     !<<
     15              >>!   distribute a combined work that includes FreeRTOS without being   !<<
     16              >>!   obliged to provide the source code for proprietary components     !<<
     17              >>!   outside of the FreeRTOS kernel.                                   !<<
     18              ***************************************************************************
     19          
     20              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
     21              WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     22              FOR A PARTICULAR PURPOSE.  Full license text is available on the following
     23              link: http://www.freertos.org/a00114.html
     24          
     25              ***************************************************************************
     26               *                                                                       *
     27               *    FreeRTOS provides completely free yet professionally developed,    *
     28               *    robust, strictly quality controlled, supported, and cross          *
     29               *    platform software that is more than just the market leader, it     *
     30               *    is the industry's de facto standard.                               *
     31               *                                                                       *
     32               *    Help yourself get started quickly while simultaneously helping     *
     33               *    to support the FreeRTOS project by purchasing a FreeRTOS           *
     34               *    tutorial book, reference manual, or both:                          *
     35               *    http://www.FreeRTOS.org/Documentation                              *
     36               *                                                                       *
     37              ***************************************************************************
     38          
     39              http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
     40              the FAQ page "My application does not run, what could be wrong?".  Have you
     41              defined configASSERT()?
     42          
     43              http://www.FreeRTOS.org/support - In return for receiving this top quality
     44              embedded software for free we request you assist our global community by
     45              participating in the support forum.
     46          
     47              http://www.FreeRTOS.org/training - Investing in training allows your team to
     48              be as productive as possible as early as possible.  Now you can receive
     49              FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
     50              Ltd, and the world's leading authority on the world's leading RTOS.
     51          
     52              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     53              including FreeRTOS+Trace - an indispensable productivity tool, a DOS
     54              compatible FAT file system, and our tiny thread aware UDP/IP stack.
     55          
     56              http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
     57              Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
     58          
     59              http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
     60              Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
     61              licenses offer ticketed support, indemnification and commercial middleware.
     62          
     63              http://www.SafeRTOS.com - High Integrity Systems also provide a safety
     64              engineered and independently SIL3 certified version for use in safety and
     65              mission critical applications that require provable dependability.
     66          
     67              1 tab == 4 spaces!
     68          */
     69          
     70          /* Standard includes. */
     71          #include <stdlib.h>
     72          
     73          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     74          all the API functions to use the MPU wrappers.  That should only be done when
     75          task.h is included from an application file. */
     76          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     77          
     78          #include "FreeRTOS.h"
     79          #include "task.h"
     80          #include "queue.h"
     81          #include "timers.h"
     82          
     83          #if ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 0 )
     84          	#error configUSE_TIMERS must be set to 1 to make the xTimerPendFunctionCall() function available.
     85          #endif
     86          
     87          /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
     88          MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
     89          header files above, but not in this file, in order to generate the correct
     90          privileged Vs unprivileged linkage and placement. */
     91          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
     92          
     93          
     94          /* This entire source file will be skipped if the application is not configured
     95          to include software timer functionality.  This #if is closed at the very bottom
     96          of this file.  If you want to include software timer functionality then ensure
     97          configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. */
     98          #if ( configUSE_TIMERS == 1 )
     99          
    100          /* Misc definitions. */
    101          #define tmrNO_DELAY		( TickType_t ) 0U
    102          
    103          /* The definition of the timers themselves. */
    104          typedef struct tmrTimerControl
    105          {
    106          	const char				*pcTimerName;		/*<< Text name.  This is not used by the kernel, it is included simply to make debugging easier. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    107          	ListItem_t				xTimerListItem;		/*<< Standard linked list item as used by all kernel features for event management. */
    108          	TickType_t				xTimerPeriodInTicks;/*<< How quickly and often the timer expires. */
    109          	UBaseType_t				uxAutoReload;		/*<< Set to pdTRUE if the timer should be automatically restarted once expired.  Set to pdFALSE if the timer is, in effect, a one-shot timer. */
    110          	void 					*pvTimerID;			/*<< An ID to identify the timer.  This allows the timer to be identified when the same callback is used for multiple timers. */
    111          	TimerCallbackFunction_t	pxCallbackFunction;	/*<< The function that will be called when the timer expires. */
    112          	#if( configUSE_TRACE_FACILITY == 1 )
    113          		UBaseType_t			uxTimerNumber;		/*<< An ID assigned by trace tools such as FreeRTOS+Trace */
    114          	#endif
    115          
    116          	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
    117          		uint8_t 			ucStaticallyAllocated; /*<< Set to pdTRUE if the timer was created statically so no attempt is made to free the memory again if the timer is later deleted. */
    118          	#endif
    119          } xTIMER;
    120          
    121          /* The old xTIMER name is maintained above then typedefed to the new Timer_t
    122          name below to enable the use of older kernel aware debuggers. */
    123          typedef xTIMER Timer_t;
    124          
    125          /* The definition of messages that can be sent and received on the timer queue.
    126          Two types of message can be queued - messages that manipulate a software timer,
    127          and messages that request the execution of a non-timer related callback.  The
    128          two message types are defined in two separate structures, xTimerParametersType
    129          and xCallbackParametersType respectively. */
    130          typedef struct tmrTimerParameters
    131          {
    132          	TickType_t			xMessageValue;		/*<< An optional value used by a subset of commands, for example, when changing the period of a timer. */
    133          	Timer_t *			pxTimer;			/*<< The timer to which the command will be applied. */
    134          } TimerParameter_t;
    135          
    136          
    137          typedef struct tmrCallbackParameters
    138          {
    139          	PendedFunction_t	pxCallbackFunction;	/* << The callback function to execute. */
    140          	void *pvParameter1;						/* << The value that will be used as the callback functions first parameter. */
    141          	uint32_t ulParameter2;					/* << The value that will be used as the callback functions second parameter. */
    142          } CallbackParameters_t;
    143          
    144          /* The structure that contains the two message types, along with an identifier
    145          that is used to determine which message type is valid. */
    146          typedef struct tmrTimerQueueMessage
    147          {
    148          	BaseType_t			xMessageID;			/*<< The command being sent to the timer service task. */
    149          	union
    150          	{
    151          		TimerParameter_t xTimerParameters;
    152          
    153          		/* Don't include xCallbackParameters if it is not going to be used as
    154          		it makes the structure (and therefore the timer queue) larger. */
    155          		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
    156          			CallbackParameters_t xCallbackParameters;
    157          		#endif /* INCLUDE_xTimerPendFunctionCall */
    158          	} u;
    159          } DaemonTaskMessage_t;
    160          
    161          /*lint -e956 A manual analysis and inspection has been used to determine which
    162          static variables must be declared volatile. */
    163          
    164          /* The list in which active timers are stored.  Timers are referenced in expire
    165          time order, with the nearest expiry time at the front of the list.  Only the
    166          timer service task is allowed to access these lists. */
    167          PRIVILEGED_DATA static List_t xActiveTimerList1;
    168          PRIVILEGED_DATA static List_t xActiveTimerList2;
    169          PRIVILEGED_DATA static List_t *pxCurrentTimerList;
    170          PRIVILEGED_DATA static List_t *pxOverflowTimerList;
    171          
    172          /* A queue that is used to send commands to the timer service task. */
    173          PRIVILEGED_DATA static QueueHandle_t xTimerQueue = NULL;
    174          PRIVILEGED_DATA static TaskHandle_t xTimerTaskHandle = NULL;
    175          
    176          /*lint +e956 */
    177          
    178          /*-----------------------------------------------------------*/
    179          
    180          #if( configSUPPORT_STATIC_ALLOCATION == 1 )
    181          
    182          	/* If static allocation is supported then the application must provide the
    183          	following callback function - which enables the application to optionally
    184          	provide the memory that will be used by the timer task as the task's stack
    185          	and TCB. */
    186          	extern void vApplicationGetTimerTaskMemory( StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize );
    187          
    188          #endif
    189          
    190          /*
    191           * Initialise the infrastructure used by the timer service task if it has not
    192           * been initialised already.
    193           */
    194          static void prvCheckForValidListAndQueue( void ) PRIVILEGED_FUNCTION;
    195          
    196          /*
    197           * The timer service task (daemon).  Timer functionality is controlled by this
    198           * task.  Other tasks communicate with the timer service task using the
    199           * xTimerQueue queue.
    200           */
    201          static void prvTimerTask( void *pvParameters ) PRIVILEGED_FUNCTION;
    202          
    203          /*
    204           * Called by the timer service task to interpret and process a command it
    205           * received on the timer queue.
    206           */
    207          static void prvProcessReceivedCommands( void ) PRIVILEGED_FUNCTION;
    208          
    209          /*
    210           * Insert the timer into either xActiveTimerList1, or xActiveTimerList2,
    211           * depending on if the expire time causes a timer counter overflow.
    212           */
    213          static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime ) PRIVILEGED_FUNCTION;
    214          
    215          /*
    216           * An active timer has reached its expire time.  Reload the timer if it is an
    217           * auto reload timer, then call its callback.
    218           */
    219          static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow ) PRIVILEGED_FUNCTION;
    220          
    221          /*
    222           * The tick count has overflowed.  Switch the timer lists after ensuring the
    223           * current timer list does not still reference some timers.
    224           */
    225          static void prvSwitchTimerLists( void ) PRIVILEGED_FUNCTION;
    226          
    227          /*
    228           * Obtain the current tick count, setting *pxTimerListsWereSwitched to pdTRUE
    229           * if a tick count overflow occurred since prvSampleTimeNow() was last called.
    230           */
    231          static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched ) PRIVILEGED_FUNCTION;
    232          
    233          /*
    234           * If the timer list contains any active timers then return the expire time of
    235           * the timer that will expire first and set *pxListWasEmpty to false.  If the
    236           * timer list does not contain any timers then return 0 and set *pxListWasEmpty
    237           * to pdTRUE.
    238           */
    239          static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty ) PRIVILEGED_FUNCTION;
    240          
    241          /*
    242           * If a timer has expired, process it.  Otherwise, block the timer service task
    243           * until either a timer does expire or a command is received.
    244           */
    245          static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;
    246          
    247          /*
    248           * Called after a Timer_t structure has been allocated either statically or
    249           * dynamically to fill in the structure's members.
    250           */
    251          static void prvInitialiseNewTimer(	const char * const pcTimerName,
    252          									const TickType_t xTimerPeriodInTicks,
    253          									const UBaseType_t uxAutoReload,
    254          									void * const pvTimerID,
    255          									TimerCallbackFunction_t pxCallbackFunction,
    256          									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    257          /*-----------------------------------------------------------*/
    258          

   \                                 In section .text, align 2, keep-with-next
    259          BaseType_t xTimerCreateTimerTask( void )
    260          {
   \                     xTimerCreateTimerTask: (+1)
   \        0x0   0xB5E0             PUSH     {R5-R7,LR}
    261          BaseType_t xReturn = pdFAIL;
    262          
    263          	/* This function is called when the scheduler is started if
    264          	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
    265          	timer service task has been created/initialised.  If timers have already
    266          	been created then the initialisation will already have been performed. */
    267          	prvCheckForValidListAndQueue();
   \        0x2   0x.... 0x....      BL       prvCheckForValidListAndQueue
    268          
    269          	if( xTimerQueue != NULL )
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable12
   \        0xA   0x6888             LDR      R0,[R1, #+8]
   \        0xC   0xB168             CBZ.N    R0,??xTimerCreateTimerTask_0
    270          	{
    271          		#if( configSUPPORT_STATIC_ALLOCATION == 1 )
    272          		{
    273          			StaticTask_t *pxTimerTaskTCBBuffer = NULL;
    274          			StackType_t *pxTimerTaskStackBuffer = NULL;
    275          			uint32_t ulTimerTaskStackSize;
    276          
    277          			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
    278          			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
    279          													"Tmr Svc",
    280          													ulTimerTaskStackSize,
    281          													NULL,
    282          													( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,
    283          													pxTimerTaskStackBuffer,
    284          													pxTimerTaskTCBBuffer );
    285          
    286          			if( xTimerTaskHandle != NULL )
    287          			{
    288          				xReturn = pdPASS;
    289          			}
    290          		}
    291          		#else
    292          		{
    293          			xReturn = xTaskCreate(	prvTimerTask,
    294          									"Tmr Svc",
    295          									configTIMER_TASK_STACK_DEPTH,
    296          									NULL,
    297          									( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,
    298          									&xTimerTaskHandle );
   \        0xE   0x310C             ADDS     R1,R1,#+12
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0x9101             STR      R1,[SP, #+4]
   \       0x14   0x9000             STR      R0,[SP, #+0]
   \       0x16   0x2300             MOVS     R3,#+0
   \       0x18   0xF44F 0x7200      MOV      R2,#+512
   \       0x1C   0x.... 0x....      ADR.W    R1,?_0
   \       0x20   0x.... 0x....      ADR.W    R0,prvTimerTask
   \       0x24   0x.... 0x....      BL       xTaskCreate
    299          		}
    300          		#endif /* configSUPPORT_STATIC_ALLOCATION */
    301          	}
    302          	else
    303          	{
    304          		mtCOVERAGE_TEST_MARKER();
    305          	}
    306          
    307          	configASSERT( xReturn );
   \       0x28   0xB938             CBNZ.N   R0,??xTimerCreateTimerTask_1
   \                     ??xTimerCreateTimerTask_0: (+1)
   \       0x2A   0x2020             MOVS     R0,#+32
   \       0x2C   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x30   0xF3BF 0x8F4F      DSB      SY
   \       0x34   0xF3BF 0x8F6F      ISB      SY
   \                     ??xTimerCreateTimerTask_2: (+1)
   \       0x38   0xE7FE             B.N      ??xTimerCreateTimerTask_2
    308          	return xReturn;
   \                     ??xTimerCreateTimerTask_1: (+1)
   \       0x3A   0xB003             ADD      SP,SP,#+12
   \       0x3C   0xBD00             POP      {PC}             ;; return
    309          }
    310          /*-----------------------------------------------------------*/
    311          
    312          #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    313          

   \                                 In section .text, align 2, keep-with-next
    314          	TimerHandle_t xTimerCreate(	const char * const pcTimerName,
    315          								const TickType_t xTimerPeriodInTicks,
    316          								const UBaseType_t uxAutoReload,
    317          								void * const pvTimerID,
    318          								TimerCallbackFunction_t pxCallbackFunction ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    319          	{
   \                     xTimerCreate: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4691             MOV      R9,R2
   \        0xA   0x4698             MOV      R8,R3
    320          	Timer_t *pxNewTimer;
    321          
    322          		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
   \        0xC   0x202C             MOVS     R0,#+44
   \        0xE   0x.... 0x....      BL       pvPortMalloc
   \       0x12   0x0004             MOVS     R4,R0
    323          
    324          		if( pxNewTimer != NULL )
   \       0x14   0xD015             BEQ.N    ??xTimerCreate_0
    325          		{
    326          			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
   \       0x16   0xB93D             CBNZ.N   R5,??xTimerCreate_1
   \       0x18   0x2020             MOVS     R0,#+32
   \       0x1A   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x1E   0xF3BF 0x8F4F      DSB      SY
   \       0x22   0xF3BF 0x8F6F      ISB      SY
   \                     ??xTimerCreate_2: (+1)
   \       0x26   0xE7FE             B.N      ??xTimerCreate_2
   \                     ??xTimerCreate_1: (+1)
   \       0x28   0x9F08             LDR      R7,[SP, #+32]
   \       0x2A   0x.... 0x....      BL       prvCheckForValidListAndQueue
   \       0x2E   0x6026             STR      R6,[R4, #+0]
   \       0x30   0x61A5             STR      R5,[R4, #+24]
   \       0x32   0xF8C4 0x901C      STR      R9,[R4, #+28]
   \       0x36   0xF8C4 0x8020      STR      R8,[R4, #+32]
   \       0x3A   0x6267             STR      R7,[R4, #+36]
   \       0x3C   0x1D20             ADDS     R0,R4,#+4
   \       0x3E   0x.... 0x....      BL       vListInitialiseItem
    327          
    328          			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
    329          			{
    330          				/* Timers can be created statically or dynamically, so note this
    331          				timer was created dynamically in case the timer is later
    332          				deleted. */
    333          				pxNewTimer->ucStaticallyAllocated = pdFALSE;
    334          			}
    335          			#endif /* configSUPPORT_STATIC_ALLOCATION */
    336          		}
    337          
    338          		return pxNewTimer;
   \                     ??xTimerCreate_0: (+1)
   \       0x42   0x4620             MOV      R0,R4
   \       0x44   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    339          	}
    340          
    341          #endif /* configSUPPORT_STATIC_ALLOCATION */
    342          /*-----------------------------------------------------------*/
    343          
    344          #if( configSUPPORT_STATIC_ALLOCATION == 1 )
    345          
    346          	TimerHandle_t xTimerCreateStatic(	const char * const pcTimerName,
    347          										const TickType_t xTimerPeriodInTicks,
    348          										const UBaseType_t uxAutoReload,
    349          										void * const pvTimerID,
    350          										TimerCallbackFunction_t pxCallbackFunction,
    351          										StaticTimer_t *pxTimerBuffer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    352          	{
    353          	Timer_t *pxNewTimer;
    354          
    355          		#if( configASSERT_DEFINED == 1 )
    356          		{
    357          			/* Sanity check that the size of the structure used to declare a
    358          			variable of type StaticTimer_t equals the size of the real timer
    359          			structures. */
    360          			volatile size_t xSize = sizeof( StaticTimer_t );
    361          			configASSERT( xSize == sizeof( Timer_t ) );
    362          		}
    363          		#endif /* configASSERT_DEFINED */
    364          
    365          		/* A pointer to a StaticTimer_t structure MUST be provided, use it. */
    366          		configASSERT( pxTimerBuffer );
    367          		pxNewTimer = ( Timer_t * ) pxTimerBuffer; /*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
    368          
    369          		if( pxNewTimer != NULL )
    370          		{
    371          			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
    372          
    373          			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    374          			{
    375          				/* Timers can be created statically or dynamically so note this
    376          				timer was created statically in case it is later deleted. */
    377          				pxNewTimer->ucStaticallyAllocated = pdTRUE;
    378          			}
    379          			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    380          		}
    381          
    382          		return pxNewTimer;
    383          	}
    384          
    385          #endif /* configSUPPORT_STATIC_ALLOCATION */
    386          /*-----------------------------------------------------------*/
    387          
    388          static void prvInitialiseNewTimer(	const char * const pcTimerName,
    389          									const TickType_t xTimerPeriodInTicks,
    390          									const UBaseType_t uxAutoReload,
    391          									void * const pvTimerID,
    392          									TimerCallbackFunction_t pxCallbackFunction,
    393          									Timer_t *pxNewTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    394          {
    395          	/* 0 is not a valid value for xTimerPeriodInTicks. */
    396          	configASSERT( ( xTimerPeriodInTicks > 0 ) );
    397          
    398          	if( pxNewTimer != NULL )
    399          	{
    400          		/* Ensure the infrastructure used by the timer service task has been
    401          		created/initialised. */
    402          		prvCheckForValidListAndQueue();
    403          
    404          		/* Initialise the timer structure members using the function
    405          		parameters. */
    406          		pxNewTimer->pcTimerName = pcTimerName;
    407          		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    408          		pxNewTimer->uxAutoReload = uxAutoReload;
    409          		pxNewTimer->pvTimerID = pvTimerID;
    410          		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    411          		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    412          		traceTIMER_CREATE( pxNewTimer );
    413          	}
    414          }
    415          /*-----------------------------------------------------------*/
    416          

   \                                 In section .text, align 2, keep-with-next
    417          BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
    418          {
   \                     xTimerGenericCommand: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x461E             MOV      R6,R3
    419          BaseType_t xReturn = pdFAIL;
   \        0x8   0x2000             MOVS     R0,#+0
    420          DaemonTaskMessage_t xMessage;
    421          
    422          	configASSERT( xTimer );
   \        0xA   0xB93C             CBNZ.N   R4,??xTimerGenericCommand_0
   \        0xC   0x2020             MOVS     R0,#+32
   \        0xE   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x12   0xF3BF 0x8F4F      DSB      SY
   \       0x16   0xF3BF 0x8F6F      ISB      SY
   \                     ??xTimerGenericCommand_1: (+1)
   \       0x1A   0xE7FE             B.N      ??xTimerGenericCommand_1
    423          
    424          	/* Send a message to the timer service task to perform a particular action
    425          	on a particular timer definition. */
    426          	if( xTimerQueue != NULL )
   \                     ??xTimerGenericCommand_0: (+1)
   \       0x1C   0x.... 0x....      LDR.W    R7,??DataTable12
   \       0x20   0x68BD             LDR      R5,[R7, #+8]
   \       0x22   0xB1C5             CBZ.N    R5,??xTimerGenericCommand_2
    427          	{
    428          		/* Send a command to the timer service task to start the xTimer timer. */
    429          		xMessage.xMessageID = xCommandID;
    430          		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    431          		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    432          
    433          		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
   \       0x24   0x2906             CMP      R1,#+6
   \       0x26   0x9100             STR      R1,[SP, #+0]
   \       0x28   0x9201             STR      R2,[SP, #+4]
   \       0x2A   0x9402             STR      R4,[SP, #+8]
   \       0x2C   0xDA0D             BGE.N    ??xTimerGenericCommand_3
    434          		{
    435          			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
   \       0x2E   0x.... 0x....      BL       xTaskGetSchedulerState
   \       0x32   0x2802             CMP      R0,#+2
    436          			{
    437          				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    438          			}
    439          			else
    440          			{
    441          				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
   \       0x34   0x68B8             LDR      R0,[R7, #+8]
   \       0x36   0xBF07             ITTEE    EQ 
   \       0x38   0x9A0A             LDREQ    R2,[SP, #+40]
   \       0x3A   0x2300             MOVEQ    R3,#+0
   \       0x3C   0x2300             MOVNE    R3,#+0
   \       0x3E   0x2200             MOVNE    R2,#+0
   \       0x40   0x4669             MOV      R1,SP
   \       0x42   0x.... 0x....      BL       xQueueGenericSend
    442          			}
    443          		}
    444          		else
    445          		{
    446          			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    447          		}
    448          
    449          		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
    450          	}
    451          	else
    452          	{
    453          		mtCOVERAGE_TEST_MARKER();
    454          	}
    455          
    456          	return xReturn;
   \       0x46   0xB005             ADD      SP,SP,#+20
   \       0x48   0xBDF0             POP      {R4-R7,PC}
   \                     ??xTimerGenericCommand_3: (+1)
   \       0x4A   0x2300             MOVS     R3,#+0
   \       0x4C   0x4632             MOV      R2,R6
   \       0x4E   0x4669             MOV      R1,SP
   \       0x50   0x4628             MOV      R0,R5
   \       0x52   0x.... 0x....      BL       xQueueGenericSendFromISR
   \                     ??xTimerGenericCommand_2: (+1)
   \       0x56   0xB005             ADD      SP,SP,#+20
   \       0x58   0xBDF0             POP      {R4-R7,PC}       ;; return
    457          }
    458          /*-----------------------------------------------------------*/
    459          

   \                                 In section .text, align 2, keep-with-next
    460          TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
    461          {
    462          	/* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
    463          	started, then xTimerTaskHandle will be NULL. */
    464          	configASSERT( ( xTimerTaskHandle != NULL ) );
   \                     xTimerGetTimerDaemonTaskHandle: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable12
   \        0x4   0x68C0             LDR      R0,[R0, #+12]
   \        0x6   0xB938             CBNZ.N   R0,??xTimerGetTimerDaemonTaskHandle_0
   \        0x8   0x2020             MOVS     R0,#+32
   \        0xA   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xE   0xF3BF 0x8F4F      DSB      SY
   \       0x12   0xF3BF 0x8F6F      ISB      SY
   \                     ??xTimerGetTimerDaemonTaskHandle_1: (+1)
   \       0x16   0xE7FE             B.N      ??xTimerGetTimerDaemonTaskHandle_1
    465          	return xTimerTaskHandle;
   \                     ??xTimerGetTimerDaemonTaskHandle_0: (+1)
   \       0x18   0x4770             BX       LR               ;; return
    466          }
    467          /*-----------------------------------------------------------*/
    468          

   \                                 In section .text, align 2, keep-with-next
    469          TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
    470          {
    471          Timer_t *pxTimer = ( Timer_t * ) xTimer;
    472          
    473          	configASSERT( xTimer );
   \                     xTimerGetPeriod: (+1)
   \        0x0   0xB938             CBNZ.N   R0,??xTimerGetPeriod_0
   \        0x2   0x2020             MOVS     R0,#+32
   \        0x4   0xF380 0x8811      MSR      BASEPRI,R0
   \        0x8   0xF3BF 0x8F4F      DSB      SY
   \        0xC   0xF3BF 0x8F6F      ISB      SY
   \                     ??xTimerGetPeriod_1: (+1)
   \       0x10   0xE7FE             B.N      ??xTimerGetPeriod_1
    474          	return pxTimer->xTimerPeriodInTicks;
   \                     ??xTimerGetPeriod_0: (+1)
   \       0x12   0x6980             LDR      R0,[R0, #+24]
   \       0x14   0x4770             BX       LR               ;; return
    475          }
    476          /*-----------------------------------------------------------*/
    477          

   \                                 In section .text, align 2, keep-with-next
    478          TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
    479          {
    480          Timer_t * pxTimer = ( Timer_t * ) xTimer;
    481          TickType_t xReturn;
    482          
    483          	configASSERT( xTimer );
   \                     xTimerGetExpiryTime: (+1)
   \        0x0   0xB938             CBNZ.N   R0,??xTimerGetExpiryTime_0
   \        0x2   0x2020             MOVS     R0,#+32
   \        0x4   0xF380 0x8811      MSR      BASEPRI,R0
   \        0x8   0xF3BF 0x8F4F      DSB      SY
   \        0xC   0xF3BF 0x8F6F      ISB      SY
   \                     ??xTimerGetExpiryTime_1: (+1)
   \       0x10   0xE7FE             B.N      ??xTimerGetExpiryTime_1
    484          	xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
    485          	return xReturn;
   \                     ??xTimerGetExpiryTime_0: (+1)
   \       0x12   0x6840             LDR      R0,[R0, #+4]
   \       0x14   0x4770             BX       LR               ;; return
    486          }
    487          /*-----------------------------------------------------------*/
    488          

   \                                 In section .text, align 2, keep-with-next
    489          const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    490          {
    491          Timer_t *pxTimer = ( Timer_t * ) xTimer;
    492          
    493          	configASSERT( xTimer );
   \                     pcTimerGetName: (+1)
   \        0x0   0xB938             CBNZ.N   R0,??pcTimerGetName_0
   \        0x2   0x2020             MOVS     R0,#+32
   \        0x4   0xF380 0x8811      MSR      BASEPRI,R0
   \        0x8   0xF3BF 0x8F4F      DSB      SY
   \        0xC   0xF3BF 0x8F6F      ISB      SY
   \                     ??pcTimerGetName_1: (+1)
   \       0x10   0xE7FE             B.N      ??pcTimerGetName_1
    494          	return pxTimer->pcTimerName;
   \                     ??pcTimerGetName_0: (+1)
   \       0x12   0x6800             LDR      R0,[R0, #+0]
   \       0x14   0x4770             BX       LR               ;; return
    495          }
    496          /*-----------------------------------------------------------*/
    497          
    498          static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
    499          {
    500          BaseType_t xResult;
    501          Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    502          
    503          	/* Remove the timer from the list of active timers.  A check has already
    504          	been performed to ensure the list is not empty. */
    505          	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    506          	traceTIMER_EXPIRED( pxTimer );
    507          
    508          	/* If the timer is an auto reload timer then calculate the next
    509          	expiry time and re-insert the timer in the list of active timers. */
    510          	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    511          	{
    512          		/* The timer is inserted into a list using a time relative to anything
    513          		other than the current time.  It will therefore be inserted into the
    514          		correct list relative to the time this task thinks it is now. */
    515          		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    516          		{
    517          			/* The timer expired before it was added to the active timer
    518          			list.  Reload it now.  */
    519          			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    520          			configASSERT( xResult );
    521          			( void ) xResult;
    522          		}
    523          		else
    524          		{
    525          			mtCOVERAGE_TEST_MARKER();
    526          		}
    527          	}
    528          	else
    529          	{
    530          		mtCOVERAGE_TEST_MARKER();
    531          	}
    532          
    533          	/* Call the timer callback. */
    534          	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    535          }
    536          /*-----------------------------------------------------------*/
    537          

   \                                 In section .text, align 4, keep-with-next
    538          static void prvTimerTask( void *pvParameters )
    539          {
   \                     prvTimerTask: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    540          TickType_t xNextExpireTime;
    541          BaseType_t xListWasEmpty;
    542          
    543          	/* Just to avoid compiler warnings. */
    544          	( void ) pvParameters;
    545          
    546          	#if( configUSE_DAEMON_TASK_STARTUP_HOOK == 1 )
    547          	{
    548          		extern void vApplicationDaemonTaskStartupHook( void );
    549          
    550          		/* Allow the application writer to execute some code in the context of
    551          		this task at the point the task starts executing.  This is useful if the
    552          		application includes initialisation code that would benefit from
    553          		executing after the scheduler has been started. */
    554          		vApplicationDaemonTaskStartupHook();
    555          	}
    556          	#endif /* configUSE_DAEMON_TASK_STARTUP_HOOK */
    557          
    558          	for( ;; )
    559          	{
    560          		/* Query the timers list to see if it contains any timers, and if so,
    561          		obtain the time at which the next timer will expire. */
    562          		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
   \                     ??prvTimerTask_0: (+1)
   \        0x2   0x.... 0x....      LDR.W    R1,??DataTable12
   \        0x6   0x680A             LDR      R2,[R1, #+0]
   \        0x8   0x6810             LDR      R0,[R2, #+0]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xBF1D             ITTTE    NE 
   \        0xE   0x2100             MOVNE    R1,#+0
   \       0x10   0x68D0             LDRNE    R0,[R2, #+12]
   \       0x12   0x6800             LDRNE    R0,[R0, #+0]
   \       0x14   0x2101             MOVEQ    R1,#+1
    563          
    564          		/* If a timer has expired, process it.  Otherwise, block this task
    565          		until either a timer does expire, or a command is received. */
    566          		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
   \       0x16   0x.... 0x....      BL       prvProcessTimerOrBlockTask
    567          
    568          		/* Empty the command queue. */
    569          		prvProcessReceivedCommands();
   \       0x1A   0x.... 0x....      BL       prvProcessReceivedCommands
   \       0x1E   0xE7F0             B.N      ??prvTimerTask_0
    570          	}
    571          }
    572          /*-----------------------------------------------------------*/
    573          

   \                                 In section .text, align 2, keep-with-next
    574          static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
    575          {
   \                     prvProcessTimerOrBlockTask: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460C             MOV      R4,R1
    576          TickType_t xTimeNow;
    577          BaseType_t xTimerListsWereSwitched;
    578          
    579          	vTaskSuspendAll();
   \        0x6   0x.... 0x....      BL       vTaskSuspendAll
    580          	{
    581          		/* Obtain the time now to make an assessment as to whether the timer
    582          		has expired or not.  If obtaining the time causes the lists to switch
    583          		then don't process this timer as any timers that remained in the list
    584          		when the lists were switched will have been processed within the
    585          		prvSampleTimeNow() function. */
    586          		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
   \        0xA   0xA801             ADD      R0,SP,#+4
   \        0xC   0x.... 0x....      BL       prvSampleTimeNow
   \       0x10   0x4605             MOV      R5,R0
    587          		if( xTimerListsWereSwitched == pdFALSE )
   \       0x12   0x9801             LDR      R0,[SP, #+4]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD144             BNE.N    ??prvProcessTimerOrBlockTask_0
    588          		{
    589          			/* The tick count has not overflowed, has the timer expired? */
    590          			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
   \       0x18   0xBB5C             CBNZ.N   R4,??prvProcessTimerOrBlockTask_1
   \       0x1A   0x42B5             CMP      R5,R6
   \       0x1C   0xD32F             BCC.N    ??prvProcessTimerOrBlockTask_2
    591          			{
    592          				( void ) xTaskResumeAll();
   \       0x1E   0x.... 0x....      BL       xTaskResumeAll
    593          				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0x26   0x6801             LDR      R1,[R0, #+0]
   \       0x28   0x68CA             LDR      R2,[R1, #+12]
   \       0x2A   0x68D4             LDR      R4,[R2, #+12]
   \       0x2C   0x1D20             ADDS     R0,R4,#+4
   \       0x2E   0x.... 0x....      BL       uxListRemove
   \       0x32   0x69E0             LDR      R0,[R4, #+28]
   \       0x34   0x2801             CMP      R0,#+1
   \       0x36   0xD118             BNE.N    ??prvProcessTimerOrBlockTask_3
   \       0x38   0x69A1             LDR      R1,[R4, #+24]
   \       0x3A   0x4633             MOV      R3,R6
   \       0x3C   0x462A             MOV      R2,R5
   \       0x3E   0x1989             ADDS     R1,R1,R6
   \       0x40   0x4620             MOV      R0,R4
   \       0x42   0x.... 0x....      BL       prvInsertTimerInActiveList
   \       0x46   0xB180             CBZ.N    R0,??prvProcessTimerOrBlockTask_3
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0x9000             STR      R0,[SP, #+0]
   \       0x4C   0x2300             MOVS     R3,#+0
   \       0x4E   0x4632             MOV      R2,R6
   \       0x50   0x2100             MOVS     R1,#+0
   \       0x52   0x4620             MOV      R0,R4
   \       0x54   0x.... 0x....      BL       xTimerGenericCommand
   \       0x58   0xB938             CBNZ.N   R0,??prvProcessTimerOrBlockTask_3
   \       0x5A   0x2020             MOVS     R0,#+32
   \       0x5C   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x60   0xF3BF 0x8F4F      DSB      SY
   \       0x64   0xF3BF 0x8F6F      ISB      SY
   \                     ??prvProcessTimerOrBlockTask_4: (+1)
   \       0x68   0xE7FE             B.N      ??prvProcessTimerOrBlockTask_4
   \                     ??prvProcessTimerOrBlockTask_3: (+1)
   \       0x6A   0x6A61             LDR      R1,[R4, #+36]
   \       0x6C   0x4620             MOV      R0,R4
   \       0x6E   0x4788             BLX      R1
    594          			}
   \       0x70   0xBD73             POP      {R0,R1,R4-R6,PC}
    595          			else
    596          			{
    597          				/* The tick count has not overflowed, and the next expire
    598          				time has not been reached yet.  This task should therefore
    599          				block to wait for the next expire time or a command to be
    600          				received - whichever comes first.  The following line cannot
    601          				be reached unless xNextExpireTime > xTimeNow, except in the
    602          				case when the current timer list is empty. */
    603          				if( xListWasEmpty != pdFALSE )
    604          				{
    605          					/* The current timer list is empty - is the overflow list
    606          					also empty? */
    607          					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
   \                     ??prvProcessTimerOrBlockTask_1: (+1)
   \       0x72   0x....             LDR.N    R0,??DataTable12
   \       0x74   0x6841             LDR      R1,[R0, #+4]
   \       0x76   0x680A             LDR      R2,[R1, #+0]
   \       0x78   0x1E54             SUBS     R4,R2,#+1
   \       0x7A   0x41A4             SBCS     R4,R4,R4
   \       0x7C   0x0FE4             LSRS     R4,R4,#+31
    608          				}
    609          
    610          				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
   \                     ??prvProcessTimerOrBlockTask_2: (+1)
   \       0x7E   0x....             LDR.N    R0,??DataTable12
   \       0x80   0x6880             LDR      R0,[R0, #+8]
   \       0x82   0x4622             MOV      R2,R4
   \       0x84   0x1B71             SUBS     R1,R6,R5
   \       0x86   0x.... 0x....      BL       vQueueWaitForMessageRestricted
    611          
    612          				if( xTaskResumeAll() == pdFALSE )
   \       0x8A   0x.... 0x....      BL       xTaskResumeAll
   \       0x8E   0xB950             CBNZ.N   R0,??prvProcessTimerOrBlockTask_5
    613          				{
    614          					/* Yield to wait for either a command to arrive, or the
    615          					block time to expire.  If a command arrived between the
    616          					critical section being exited and this yield then the yield
    617          					will not cause the task to block. */
    618          					portYIELD_WITHIN_API();
   \       0x90   0x....             LDR.N    R1,??DataTable12_1  ;; 0xe000ed04
   \       0x92   0xF04F 0x5080      MOV      R0,#+268435456
   \       0x96   0x6008             STR      R0,[R1, #+0]
   \       0x98   0xF3BF 0x8F4F      DSB      SY
   \       0x9C   0xF3BF 0x8F6F      ISB      SY
   \       0xA0   0xBD73             POP      {R0,R1,R4-R6,PC}
    619          				}
    620          				else
    621          				{
    622          					mtCOVERAGE_TEST_MARKER();
    623          				}
    624          			}
    625          		}
    626          		else
    627          		{
    628          			( void ) xTaskResumeAll();
   \                     ??prvProcessTimerOrBlockTask_0: (+1)
   \       0xA2   0x.... 0x....      BL       xTaskResumeAll
    629          		}
    630          	}
    631          }
   \                     ??prvProcessTimerOrBlockTask_5: (+1)
   \       0xA6   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    632          /*-----------------------------------------------------------*/
    633          
    634          static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
    635          {
    636          TickType_t xNextExpireTime;
    637          
    638          	/* Timers are listed in expiry time order, with the head of the list
    639          	referencing the task that will expire first.  Obtain the time at which
    640          	the timer with the nearest expiry time will expire.  If there are no
    641          	active timers then just set the next expire time to 0.  That will cause
    642          	this task to unblock when the tick count overflows, at which point the
    643          	timer lists will be switched and the next expiry time can be
    644          	re-assessed.  */
    645          	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    646          	if( *pxListWasEmpty == pdFALSE )
    647          	{
    648          		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    649          	}
    650          	else
    651          	{
    652          		/* Ensure the task unblocks when the tick count rolls over. */
    653          		xNextExpireTime = ( TickType_t ) 0U;
    654          	}
    655          
    656          	return xNextExpireTime;
    657          }
    658          /*-----------------------------------------------------------*/
    659          

   \                                 In section .text, align 2, keep-with-next
    660          static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
    661          {
   \                     prvSampleTimeNow: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x4605             MOV      R5,R0
    662          TickType_t xTimeNow;
    663          PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */
    664          
    665          	xTimeNow = xTaskGetTickCount();
   \        0x8   0x.... 0x....      BL       xTaskGetTickCount
    666          
    667          	if( xTimeNow < xLastTime )
   \        0xC   0x....             LDR.N    R7,??DataTable12
   \        0xE   0x4680             MOV      R8,R0
   \       0x10   0x6938             LDR      R0,[R7, #+16]
   \       0x12   0x4580             CMP      R8,R0
   \       0x14   0xD30D             BCC.N    ??prvSampleTimeNow_0
    668          	{
    669          		prvSwitchTimerLists();
    670          		*pxTimerListsWereSwitched = pdTRUE;
    671          	}
    672          	else
    673          	{
    674          		*pxTimerListsWereSwitched = pdFALSE;
   \       0x16   0x2100             MOVS     R1,#+0
   \                     ??prvSampleTimeNow_1: (+1)
   \       0x18   0x6029             STR      R1,[R5, #+0]
    675          	}
    676          
    677          	xLastTime = xTimeNow;
   \       0x1A   0xF8C7 0x8010      STR      R8,[R7, #+16]
    678          
    679          	return xTimeNow;
   \       0x1E   0x4640             MOV      R0,R8
   \       0x20   0xB004             ADD      SP,SP,#+16
   \       0x22   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??prvSampleTimeNow_2: (+1)
   \       0x26   0x6060             STR      R0,[R4, #+4]
   \       0x28   0x6124             STR      R4,[R4, #+16]
   \       0x2A   0x1D21             ADDS     R1,R4,#+4
   \       0x2C   0x6838             LDR      R0,[R7, #+0]
   \       0x2E   0x.... 0x....      BL       vListInsert
   \                     ??prvSampleTimeNow_0: (+1)
   \       0x32   0x6839             LDR      R1,[R7, #+0]
   \       0x34   0x6808             LDR      R0,[R1, #+0]
   \       0x36   0xB380             CBZ.N    R0,??prvSampleTimeNow_3
   \       0x38   0x68C8             LDR      R0,[R1, #+12]
   \       0x3A   0x6806             LDR      R6,[R0, #+0]
   \       0x3C   0x68C4             LDR      R4,[R0, #+12]
   \       0x3E   0x1D20             ADDS     R0,R4,#+4
   \       0x40   0x.... 0x....      BL       uxListRemove
   \       0x44   0x6A61             LDR      R1,[R4, #+36]
   \       0x46   0x4620             MOV      R0,R4
   \       0x48   0x4788             BLX      R1
   \       0x4A   0x69E0             LDR      R0,[R4, #+28]
   \       0x4C   0x2801             CMP      R0,#+1
   \       0x4E   0xD1F0             BNE.N    ??prvSampleTimeNow_0
   \       0x50   0x69A0             LDR      R0,[R4, #+24]
   \       0x52   0x1980             ADDS     R0,R0,R6
   \       0x54   0x4286             CMP      R6,R0
   \       0x56   0xD3E6             BCC.N    ??prvSampleTimeNow_2
   \       0x58   0xB1BC             CBZ.N    R4,??prvSampleTimeNow_4
   \       0x5A   0x68B8             LDR      R0,[R7, #+8]
   \       0x5C   0xB168             CBZ.N    R0,??prvSampleTimeNow_5
   \       0x5E   0x2100             MOVS     R1,#+0
   \       0x60   0x9100             STR      R1,[SP, #+0]
   \       0x62   0x9601             STR      R6,[SP, #+4]
   \       0x64   0x9402             STR      R4,[SP, #+8]
   \       0x66   0x.... 0x....      BL       xTaskGetSchedulerState
   \       0x6A   0x68B8             LDR      R0,[R7, #+8]
   \       0x6C   0x2300             MOVS     R3,#+0
   \       0x6E   0x2200             MOVS     R2,#+0
   \       0x70   0x4669             MOV      R1,SP
   \       0x72   0x.... 0x....      BL       xQueueGenericSend
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD1DB             BNE.N    ??prvSampleTimeNow_0
   \                     ??prvSampleTimeNow_5: (+1)
   \       0x7A   0x2020             MOVS     R0,#+32
   \       0x7C   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x80   0xF3BF 0x8F4F      DSB      SY
   \       0x84   0xF3BF 0x8F6F      ISB      SY
   \                     ??prvSampleTimeNow_6: (+1)
   \       0x88   0xE7FE             B.N      ??prvSampleTimeNow_6
   \                     ??prvSampleTimeNow_4: (+1)
   \       0x8A   0x2020             MOVS     R0,#+32
   \       0x8C   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x90   0xF3BF 0x8F4F      DSB      SY
   \       0x94   0xF3BF 0x8F6F      ISB      SY
   \                     ??prvSampleTimeNow_7: (+1)
   \       0x98   0xE7FE             B.N      ??prvSampleTimeNow_7
   \                     ??prvSampleTimeNow_3: (+1)
   \       0x9A   0x6878             LDR      R0,[R7, #+4]
   \       0x9C   0x6079             STR      R1,[R7, #+4]
   \       0x9E   0x6038             STR      R0,[R7, #+0]
   \       0xA0   0x2101             MOVS     R1,#+1
   \       0xA2   0xE7B9             B.N      ??prvSampleTimeNow_1
    680          }

   \                                 In section .bss, align 4
   \                     pxCurrentTimerList:
   \        0x0                      DS8 4
   \        0x4                      DS8 4
   \        0x8                      DS8 4
   \        0xC                      DS8 4
   \       0x10                      DS8 4
   \       0x14                      DS8 20
   \       0x28                      DS8 20
    681          /*-----------------------------------------------------------*/
    682          

   \                                 In section .text, align 2, keep-with-next
    683          static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
    684          {
   \                     prvInsertTimerInActiveList: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    685          BaseType_t xProcessTimerNow = pdFALSE;
   \        0x2   0x2400             MOVS     R4,#+0
    686          
    687          	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    688          	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    689          
    690          	if( xNextExpiryTime <= xTimeNow )
   \        0x4   0x428A             CMP      R2,R1
   \        0x6   0x6041             STR      R1,[R0, #+4]
   \        0x8   0x6100             STR      R0,[R0, #+16]
   \        0xA   0xD307             BCC.N    ??prvInsertTimerInActiveList_0
    691          	{
    692          		/* Has the expiry time elapsed between the command to start/reset a
    693          		timer was issued, and the time the command was processed? */
    694          		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   \        0xC   0x6981             LDR      R1,[R0, #+24]
   \        0xE   0x1AD2             SUBS     R2,R2,R3
   \       0x10   0x428A             CMP      R2,R1
   \       0x12   0xD207             BCS.N    ??prvInsertTimerInActiveList_1
    695          		{
    696          			/* The time between a command being issued and the command being
    697          			processed actually exceeds the timers period.  */
    698          			xProcessTimerNow = pdTRUE;
    699          		}
    700          		else
    701          		{
    702          			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
   \       0x14   0x....             LDR.N    R2,??DataTable12
   \       0x16   0x1D01             ADDS     R1,R0,#+4
   \       0x18   0x6850             LDR      R0,[R2, #+4]
   \       0x1A   0xE008             B.N      ??prvInsertTimerInActiveList_2
    703          		}
    704          	}
    705          	else
    706          	{
    707          		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
   \                     ??prvInsertTimerInActiveList_0: (+1)
   \       0x1C   0x429A             CMP      R2,R3
   \       0x1E   0xD203             BCS.N    ??prvInsertTimerInActiveList_3
   \       0x20   0x4299             CMP      R1,R3
   \       0x22   0xD301             BCC.N    ??prvInsertTimerInActiveList_3
    708          		{
    709          			/* If, since the command was issued, the tick count has overflowed
    710          			but the expiry time has not, then the timer must have already passed
    711          			its expiry time and should be processed immediately. */
    712          			xProcessTimerNow = pdTRUE;
   \                     ??prvInsertTimerInActiveList_1: (+1)
   \       0x24   0x2401             MOVS     R4,#+1
   \       0x26   0xE004             B.N      ??prvInsertTimerInActiveList_4
    713          		}
    714          		else
    715          		{
    716          			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
   \                     ??prvInsertTimerInActiveList_3: (+1)
   \       0x28   0x1D01             ADDS     R1,R0,#+4
   \       0x2A   0x....             LDR.N    R0,??DataTable12
   \       0x2C   0x6800             LDR      R0,[R0, #+0]
   \                     ??prvInsertTimerInActiveList_2: (+1)
   \       0x2E   0x.... 0x....      BL       vListInsert
    717          		}
    718          	}
    719          
    720          	return xProcessTimerNow;
   \                     ??prvInsertTimerInActiveList_4: (+1)
   \       0x32   0x4620             MOV      R0,R4
   \       0x34   0xBD10             POP      {R4,PC}          ;; return
    721          }
    722          /*-----------------------------------------------------------*/
    723          

   \                                 In section .text, align 4, keep-with-next
    724          static void	prvProcessReceivedCommands( void )
    725          {
   \                     prvProcessReceivedCommands: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0xB089             SUB      SP,SP,#+36
   \        0x4   0x....             LDR.N    R5,??DataTable12
   \        0x6   0xE005             B.N      ??prvProcessReceivedCommands_1
    726          DaemonTaskMessage_t xMessage;
    727          Timer_t *pxTimer;
    728          BaseType_t xTimerListsWereSwitched, xResult;
    729          TickType_t xTimeNow;
    730          
    731          	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    732          	{
    733          		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
    734          		{
    735          			/* Negative commands are pended function calls rather than timer
    736          			commands. */
    737          			if( xMessage.xMessageID < ( BaseType_t ) 0 )
    738          			{
    739          				const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
    740          
    741          				/* The timer uses the xCallbackParameters member to request a
    742          				callback be executed.  Check the callback is not NULL. */
    743          				configASSERT( pxCallback );
    744          
    745          				/* Call the function. */
    746          				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
    747          			}
    748          			else
    749          			{
    750          				mtCOVERAGE_TEST_MARKER();
    751          			}
    752          		}
    753          		#endif /* INCLUDE_xTimerPendFunctionCall */
    754          
    755          		/* Commands that are positive are timer commands rather than pended
    756          		function calls. */
    757          		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    758          		{
    759          			/* The messages uses the xTimerParameters member to work on a
    760          			software timer. */
    761          			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    762          
    763          			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    764          			{
    765          				/* The timer is in a list, remove it. */
    766          				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    767          			}
    768          			else
    769          			{
    770          				mtCOVERAGE_TEST_MARKER();
    771          			}
    772          
    773          			traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.u.xTimerParameters.xMessageValue );
    774          
    775          			/* In this case the xTimerListsWereSwitched parameter is not used, but
    776          			it must be present in the function call.  prvSampleTimeNow() must be
    777          			called after the message is received from xTimerQueue so there is no
    778          			possibility of a higher priority task adding a message to the message
    779          			queue with a time that is ahead of the timer daemon task (because it
    780          			pre-empted the timer daemon task after the xTimeNow value was set). */
    781          			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    782          
    783          			switch( xMessage.xMessageID )
    784          			{
    785          				case tmrCOMMAND_START :
    786          			    case tmrCOMMAND_START_FROM_ISR :
    787          			    case tmrCOMMAND_RESET :
    788          			    case tmrCOMMAND_RESET_FROM_ISR :
    789          				case tmrCOMMAND_START_DONT_TRACE :
    790          					/* Start or restart a timer. */
    791          					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    792          					{
    793          						/* The timer expired before it was added to the active
    794          						timer list.  Process it now. */
    795          						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    796          						traceTIMER_EXPIRED( pxTimer );
    797          
    798          						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    799          						{
    800          							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    801          							configASSERT( xResult );
    802          							( void ) xResult;
    803          						}
    804          						else
    805          						{
    806          							mtCOVERAGE_TEST_MARKER();
    807          						}
    808          					}
    809          					else
    810          					{
    811          						mtCOVERAGE_TEST_MARKER();
    812          					}
    813          					break;
    814          
    815          				case tmrCOMMAND_STOP :
    816          				case tmrCOMMAND_STOP_FROM_ISR :
    817          					/* The timer has already been removed from the active list.
    818          					There is nothing to do here. */
    819          					break;
    820          
    821          				case tmrCOMMAND_CHANGE_PERIOD :
    822          				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
    823          					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    824          					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
    825          
    826          					/* The new period does not really have a reference, and can
    827          					be longer or shorter than the old one.  The command time is
    828          					therefore set to the current time, and as the period cannot
    829          					be zero the next expiry time can only be in the future,
    830          					meaning (unlike for the xTimerStart() case above) there is
    831          					no fail case that needs to be handled here. */
    832          					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
   \                     ??prvProcessReceivedCommands_2: (+1)
   \        0x8   0x460B             MOV      R3,R1
   \        0xA   0x460A             MOV      R2,R1
   \        0xC   0x1841             ADDS     R1,R0,R1
   \        0xE   0x4620             MOV      R0,R4
   \       0x10   0x.... 0x....      BL       prvInsertTimerInActiveList
    833          					break;
   \                     ??prvProcessReceivedCommands_1: (+1)
   \       0x14   0x68A8             LDR      R0,[R5, #+8]
   \       0x16   0x2300             MOVS     R3,#+0
   \       0x18   0x2200             MOVS     R2,#+0
   \       0x1A   0xA901             ADD      R1,SP,#+4
   \       0x1C   0x.... 0x....      BL       xQueueGenericReceive
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD062             BEQ.N    ??prvProcessReceivedCommands_3
   \       0x24   0x9801             LDR      R0,[SP, #+4]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD503             BPL.N    ??prvProcessReceivedCommands_4
   \       0x2A   0x9904             LDR      R1,[SP, #+16]
   \       0x2C   0x9803             LDR      R0,[SP, #+12]
   \       0x2E   0x9A02             LDR      R2,[SP, #+8]
   \       0x30   0x4790             BLX      R2
   \                     ??prvProcessReceivedCommands_4: (+1)
   \       0x32   0x9801             LDR      R0,[SP, #+4]
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD4ED             BMI.N    ??prvProcessReceivedCommands_1
   \       0x38   0x9C03             LDR      R4,[SP, #+12]
   \       0x3A   0x6960             LDR      R0,[R4, #+20]
   \       0x3C   0xB110             CBZ.N    R0,??prvProcessReceivedCommands_5
   \       0x3E   0x1D20             ADDS     R0,R4,#+4
   \       0x40   0x.... 0x....      BL       uxListRemove
   \                     ??prvProcessReceivedCommands_5: (+1)
   \       0x44   0x4668             MOV      R0,SP
   \       0x46   0x.... 0x....      BL       prvSampleTimeNow
   \       0x4A   0x4601             MOV      R1,R0
   \       0x4C   0x9801             LDR      R0,[SP, #+4]
   \       0x4E   0x2809             CMP      R0,#+9
   \       0x50   0xD8E0             BHI.N    ??prvProcessReceivedCommands_1
   \       0x52   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??prvProcessReceivedCommands_0:
   \       0x56   0x06 0x06          DC8      0x6,0x6,0x6,0x5
   \              0x06 0x05    
   \       0x5A   0x3A 0x46          DC8      0x3A,0x46,0x6,0x6
   \              0x06 0x06    
   \       0x5E   0x05 0x3A          DC8      0x5,0x3A
   \                     ??prvProcessReceivedCommands_6: (+1)
   \       0x60   0xE7D8             B.N      ??prvProcessReceivedCommands_1
   \                     ??prvProcessReceivedCommands_7: (+1)
   \       0x62   0x460A             MOV      R2,R1
   \       0x64   0x9802             LDR      R0,[SP, #+8]
   \       0x66   0x69A1             LDR      R1,[R4, #+24]
   \       0x68   0x4603             MOV      R3,R0
   \       0x6A   0x1809             ADDS     R1,R1,R0
   \       0x6C   0x4620             MOV      R0,R4
   \       0x6E   0x.... 0x....      BL       prvInsertTimerInActiveList
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD0CE             BEQ.N    ??prvProcessReceivedCommands_1
   \       0x76   0x6A61             LDR      R1,[R4, #+36]
   \       0x78   0x4620             MOV      R0,R4
   \       0x7A   0x4788             BLX      R1
   \       0x7C   0x69E0             LDR      R0,[R4, #+28]
   \       0x7E   0x2801             CMP      R0,#+1
   \       0x80   0xD1C8             BNE.N    ??prvProcessReceivedCommands_1
   \       0x82   0x9902             LDR      R1,[SP, #+8]
   \       0x84   0x69A0             LDR      R0,[R4, #+24]
   \       0x86   0x1841             ADDS     R1,R0,R1
   \       0x88   0xB93C             CBNZ.N   R4,??prvProcessReceivedCommands_8
   \       0x8A   0x2120             MOVS     R1,#+32
   \       0x8C   0xF381 0x8811      MSR      BASEPRI,R1
   \       0x90   0xF3BF 0x8F4F      DSB      SY
   \       0x94   0xF3BF 0x8F6F      ISB      SY
   \                     ??prvProcessReceivedCommands_9: (+1)
   \       0x98   0xE7FE             B.N      ??prvProcessReceivedCommands_9
   \                     ??prvProcessReceivedCommands_8: (+1)
   \       0x9A   0x68A8             LDR      R0,[R5, #+8]
   \       0x9C   0xB168             CBZ.N    R0,??prvProcessReceivedCommands_10
   \       0x9E   0x2200             MOVS     R2,#+0
   \       0xA0   0x9205             STR      R2,[SP, #+20]
   \       0xA2   0x9106             STR      R1,[SP, #+24]
   \       0xA4   0x9407             STR      R4,[SP, #+28]
   \       0xA6   0x.... 0x....      BL       xTaskGetSchedulerState
   \       0xAA   0x68A8             LDR      R0,[R5, #+8]
   \       0xAC   0x2300             MOVS     R3,#+0
   \       0xAE   0x2200             MOVS     R2,#+0
   \       0xB0   0xA905             ADD      R1,SP,#+20
   \       0xB2   0x.... 0x....      BL       xQueueGenericSend
   \       0xB6   0x2800             CMP      R0,#+0
   \       0xB8   0xD1AC             BNE.N    ??prvProcessReceivedCommands_1
   \                     ??prvProcessReceivedCommands_10: (+1)
   \       0xBA   0x2020             MOVS     R0,#+32
   \       0xBC   0xF380 0x8811      MSR      BASEPRI,R0
   \       0xC0   0xF3BF 0x8F4F      DSB      SY
   \       0xC4   0xF3BF 0x8F6F      ISB      SY
   \                     ??prvProcessReceivedCommands_11: (+1)
   \       0xC8   0xE7FE             B.N      ??prvProcessReceivedCommands_11
   \                     ??prvProcessReceivedCommands_12: (+1)
   \       0xCA   0x9802             LDR      R0,[SP, #+8]
   \       0xCC   0x61A0             STR      R0,[R4, #+24]
   \       0xCE   0x2800             CMP      R0,#+0
   \       0xD0   0xD19A             BNE.N    ??prvProcessReceivedCommands_2
   \       0xD2   0x2020             MOVS     R0,#+32
   \       0xD4   0xF380 0x8811      MSR      BASEPRI,R0
   \       0xD8   0xF3BF 0x8F4F      DSB      SY
   \       0xDC   0xF3BF 0x8F6F      ISB      SY
   \                     ??prvProcessReceivedCommands_13: (+1)
   \       0xE0   0xE7FE             B.N      ??prvProcessReceivedCommands_13
    834          
    835          				case tmrCOMMAND_DELETE :
    836          					/* The timer has already been removed from the active list,
    837          					just free up the memory if the memory was dynamically
    838          					allocated. */
    839          					#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    840          					{
    841          						/* The timer can only have been allocated dynamically -
    842          						free it again. */
    843          						vPortFree( pxTimer );
   \                     ??prvProcessReceivedCommands_14: (+1)
   \       0xE2   0x4620             MOV      R0,R4
   \       0xE4   0x.... 0x....      BL       vPortFree
    844          					}
    845          					#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
    846          					{
    847          						/* The timer could have been allocated statically or
    848          						dynamically, so check before attempting to free the
    849          						memory. */
    850          						if( pxTimer->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
    851          						{
    852          							vPortFree( pxTimer );
    853          						}
    854          						else
    855          						{
    856          							mtCOVERAGE_TEST_MARKER();
    857          						}
    858          					}
    859          					#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    860          					break;
   \       0xE8   0xE794             B.N      ??prvProcessReceivedCommands_1
    861          
    862          				default	:
    863          					/* Don't expect to get here. */
    864          					break;
    865          			}
    866          		}
    867          	}
    868          }
   \                     ??prvProcessReceivedCommands_3: (+1)
   \       0xEA   0xB009             ADD      SP,SP,#+36
   \       0xEC   0xBD30             POP      {R4,R5,PC}       ;; return
    869          /*-----------------------------------------------------------*/
    870          
    871          static void prvSwitchTimerLists( void )
    872          {
    873          TickType_t xNextExpireTime, xReloadTime;
    874          List_t *pxTemp;
    875          Timer_t *pxTimer;
    876          BaseType_t xResult;
    877          
    878          	/* The tick count has overflowed.  The timer lists must be switched.
    879          	If there are any timers still referenced from the current timer list
    880          	then they must have expired and should be processed before the lists
    881          	are switched. */
    882          	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    883          	{
    884          		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    885          
    886          		/* Remove the timer from the list. */
    887          		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    888          		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    889          		traceTIMER_EXPIRED( pxTimer );
    890          
    891          		/* Execute its callback, then send a command to restart the timer if
    892          		it is an auto-reload timer.  It cannot be restarted here as the lists
    893          		have not yet been switched. */
    894          		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    895          
    896          		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    897          		{
    898          			/* Calculate the reload value, and if the reload value results in
    899          			the timer going into the same timer list then it has already expired
    900          			and the timer should be re-inserted into the current list so it is
    901          			processed again within this loop.  Otherwise a command should be sent
    902          			to restart the timer to ensure it is only inserted into a list after
    903          			the lists have been swapped. */
    904          			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    905          			if( xReloadTime > xNextExpireTime )
    906          			{
    907          				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    908          				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    909          				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    910          			}
    911          			else
    912          			{
    913          				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    914          				configASSERT( xResult );
    915          				( void ) xResult;
    916          			}
    917          		}
    918          		else
    919          		{
    920          			mtCOVERAGE_TEST_MARKER();
    921          		}
    922          	}
    923          
    924          	pxTemp = pxCurrentTimerList;
    925          	pxCurrentTimerList = pxOverflowTimerList;
    926          	pxOverflowTimerList = pxTemp;
    927          }
    928          /*-----------------------------------------------------------*/
    929          

   \                                 In section .text, align 4, keep-with-next
    930          static void prvCheckForValidListAndQueue( void )
    931          {
   \                     prvCheckForValidListAndQueue: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    932          	/* Check that the list from which active timers are referenced, and the
    933          	queue used to communicate with the timer service, have been
    934          	initialised. */
    935          	taskENTER_CRITICAL();
   \        0x2   0x.... 0x....      BL       vPortEnterCritical
    936          	{
    937          		if( xTimerQueue == NULL )
   \        0x6   0x....             LDR.N    R4,??DataTable12
   \        0x8   0x68A0             LDR      R0,[R4, #+8]
   \        0xA   0xB9C0             CBNZ.N   R0,??prvCheckForValidListAndQueue_0
    938          		{
    939          			vListInitialise( &xActiveTimerList1 );
   \        0xC   0xF104 0x0014      ADD      R0,R4,#+20
   \       0x10   0x.... 0x....      BL       vListInitialise
    940          			vListInitialise( &xActiveTimerList2 );
   \       0x14   0xF104 0x0028      ADD      R0,R4,#+40
   \       0x18   0x.... 0x....      BL       vListInitialise
    941          			pxCurrentTimerList = &xActiveTimerList1;
   \       0x1C   0xF104 0x0014      ADD      R0,R4,#+20
    942          			pxOverflowTimerList = &xActiveTimerList2;
   \       0x20   0xF104 0x0128      ADD      R1,R4,#+40
   \       0x24   0x6020             STR      R0,[R4, #+0]
   \       0x26   0x6061             STR      R1,[R4, #+4]
    943          
    944          			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
    945          			{
    946          				/* The timer queue is allocated statically in case
    947          				configSUPPORT_DYNAMIC_ALLOCATION is 0. */
    948          				static StaticQueue_t xStaticTimerQueue;
    949          				static uint8_t ucStaticTimerQueueStorage[ configTIMER_QUEUE_LENGTH * sizeof( DaemonTaskMessage_t ) ];
    950          
    951          				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
    952          			}
    953          			#else
    954          			{
    955          				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
   \       0x28   0x2200             MOVS     R2,#+0
   \       0x2A   0x2110             MOVS     R1,#+16
   \       0x2C   0x200A             MOVS     R0,#+10
   \       0x2E   0x.... 0x....      BL       xQueueGenericCreate
   \       0x32   0x60A0             STR      R0,[R4, #+8]
    956          			}
    957          			#endif
    958          
    959          			#if ( configQUEUE_REGISTRY_SIZE > 0 )
    960          			{
    961          				if( xTimerQueue != NULL )
   \       0x34   0xB118             CBZ.N    R0,??prvCheckForValidListAndQueue_0
    962          				{
    963          					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
   \       0x36   0xBF00             Nop      
   \       0x38   0x....             ADR.N    R1,?_1
   \       0x3A   0x.... 0x....      BL       vQueueAddToRegistry
    964          				}
    965          				else
    966          				{
    967          					mtCOVERAGE_TEST_MARKER();
    968          				}
    969          			}
    970          			#endif /* configQUEUE_REGISTRY_SIZE */
    971          		}
    972          		else
    973          		{
    974          			mtCOVERAGE_TEST_MARKER();
    975          		}
    976          	}
    977          	taskEXIT_CRITICAL();
   \                     ??prvCheckForValidListAndQueue_0: (+1)
   \       0x3E   0xE8BD 0x4010      POP      {R4,LR}
   \       0x42   0x.... 0x....      B.W      vPortExitCritical
    978          }
    979          /*-----------------------------------------------------------*/
    980          

   \                                 In section .text, align 2, keep-with-next
    981          BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
    982          {
   \                     xTimerIsTimerActive: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    983          BaseType_t xTimerIsInActiveList;
    984          Timer_t *pxTimer = ( Timer_t * ) xTimer;
    985          
    986          	configASSERT( xTimer );
   \        0x4   0xD107             BNE.N    ??xTimerIsTimerActive_0
   \        0x6   0x2020             MOVS     R0,#+32
   \        0x8   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xC   0xF3BF 0x8F4F      DSB      SY
   \       0x10   0xF3BF 0x8F6F      ISB      SY
   \                     ??xTimerIsTimerActive_1: (+1)
   \       0x14   0xE7FE             B.N      ??xTimerIsTimerActive_1
    987          
    988          	/* Is the timer in the list of active timers? */
    989          	taskENTER_CRITICAL();
   \                     ??xTimerIsTimerActive_0: (+1)
   \       0x16   0x.... 0x....      BL       vPortEnterCritical
    990          	{
    991          		/* Checking to see if it is in the NULL list in effect checks to see if
    992          		it is referenced from either the current or the overflow timer lists in
    993          		one go, but the logic has to be reversed, hence the '!'. */
    994          		xTimerIsInActiveList = ( BaseType_t ) !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) );
   \       0x1A   0x6960             LDR      R0,[R4, #+20]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xBF14             ITE      NE 
   \       0x20   0x2401             MOVNE    R4,#+1
   \       0x22   0x2400             MOVEQ    R4,#+0
    995          	}
    996          	taskEXIT_CRITICAL();
   \       0x24   0x....             B.N      ?Subroutine0
    997          
    998          	return xTimerIsInActiveList;
    999          } /*lint !e818 Can't be pointer to const due to the typedef. */

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x.... 0x....      BL       vPortExitCritical
   \        0x4   0x4620             MOV      R0,R4
   \        0x6   0xBD10             POP      {R4,PC}          ;; return
   1000          /*-----------------------------------------------------------*/
   1001          

   \                                 In section .text, align 2, keep-with-next
   1002          void *pvTimerGetTimerID( const TimerHandle_t xTimer )
   1003          {
   \                     pvTimerGetTimerID: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1004          Timer_t * const pxTimer = ( Timer_t * ) xTimer;
   1005          void *pvReturn;
   1006          
   1007          	configASSERT( xTimer );
   \        0x4   0xD107             BNE.N    ??pvTimerGetTimerID_0
   \        0x6   0x2020             MOVS     R0,#+32
   \        0x8   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xC   0xF3BF 0x8F4F      DSB      SY
   \       0x10   0xF3BF 0x8F6F      ISB      SY
   \                     ??pvTimerGetTimerID_1: (+1)
   \       0x14   0xE7FE             B.N      ??pvTimerGetTimerID_1
   1008          
   1009          	taskENTER_CRITICAL();
   \                     ??pvTimerGetTimerID_0: (+1)
   \       0x16   0x.... 0x....      BL       vPortEnterCritical
   1010          	{
   1011          		pvReturn = pxTimer->pvTimerID;
   \       0x1A   0x6A24             LDR      R4,[R4, #+32]
   1012          	}
   1013          	taskEXIT_CRITICAL();
   \       0x1C                      REQUIRE ?Subroutine0
   \       0x1C                      ;; // Fall through to label ?Subroutine0
   1014          
   1015          	return pvReturn;
   1016          }
   1017          /*-----------------------------------------------------------*/
   1018          

   \                                 In section .text, align 2, keep-with-next
   1019          void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID )
   1020          {
   \                     vTimerSetTimerID: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x460D             MOV      R5,R1
   1021          Timer_t * const pxTimer = ( Timer_t * ) xTimer;
   1022          
   1023          	configASSERT( xTimer );
   \        0x6   0xD107             BNE.N    ??vTimerSetTimerID_0
   \        0x8   0x2020             MOVS     R0,#+32
   \        0xA   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xE   0xF3BF 0x8F4F      DSB      SY
   \       0x12   0xF3BF 0x8F6F      ISB      SY
   \                     ??vTimerSetTimerID_1: (+1)
   \       0x16   0xE7FE             B.N      ??vTimerSetTimerID_1
   1024          
   1025          	taskENTER_CRITICAL();
   \                     ??vTimerSetTimerID_0: (+1)
   \       0x18   0x.... 0x....      BL       vPortEnterCritical
   1026          	{
   1027          		pxTimer->pvTimerID = pvNewID;
   \       0x1C   0x6225             STR      R5,[R4, #+32]
   1028          	}
   1029          	taskEXIT_CRITICAL();
   \       0x1E   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \       0x22   0x.... 0x....      B.W      vPortExitCritical
   1030          }
   1031          /*-----------------------------------------------------------*/
   1032          
   1033          #if( INCLUDE_xTimerPendFunctionCall == 1 )
   1034          

   \                                 In section .text, align 2, keep-with-next
   1035          	BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken )
   1036          	{
   \                     xTimerPendFunctionCallFromISR: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x461C             MOV      R4,R3
   1037          	DaemonTaskMessage_t xMessage;
   1038          	BaseType_t xReturn;
   1039          
   1040          		/* Complete the message with the function parameters and post it to the
   1041          		daemon task. */
   1042          		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
   1043          		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
   1044          		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
   1045          		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
   \        0x6   0x9203             STR      R2,[SP, #+12]
   \        0x8   0x9001             STR      R0,[SP, #+4]
   1046          
   1047          		xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
   1048          
   1049          		tracePEND_FUNC_CALL_FROM_ISR( xFunctionToPend, pvParameter1, ulParameter2, xReturn );
   1050          
   1051          		return xReturn;
   \        0xA   0x4622             MOV      R2,R4
   \        0xC   0x....             LDR.N    R4,??DataTable12
   \        0xE   0x68A0             LDR      R0,[R4, #+8]
   \       0x10   0x9102             STR      R1,[SP, #+8]
   \       0x12   0xF06F 0x0501      MVN      R5,#+1
   \       0x16   0x9500             STR      R5,[SP, #+0]
   \       0x18   0x2300             MOVS     R3,#+0
   \       0x1A   0x4669             MOV      R1,SP
   \       0x1C   0x.... 0x....      BL       xQueueGenericSendFromISR
   \       0x20   0xB005             ADD      SP,SP,#+20
   \       0x22   0xBD30             POP      {R4,R5,PC}       ;; return
   1052          	}
   1053          
   1054          #endif /* INCLUDE_xTimerPendFunctionCall */
   1055          /*-----------------------------------------------------------*/
   1056          
   1057          #if( INCLUDE_xTimerPendFunctionCall == 1 )
   1058          

   \                                 In section .text, align 2, keep-with-next
   1059          	BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait )
   1060          	{
   \                     xTimerPendFunctionCall: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x461D             MOV      R5,R3
   1061          	DaemonTaskMessage_t xMessage;
   1062          	BaseType_t xReturn;
   1063          
   1064          		/* This function can only be called after a timer has been created or
   1065          		after the scheduler has been started because, until then, the timer
   1066          		queue does not exist. */
   1067          		configASSERT( xTimerQueue );
   \        0x4   0x....             LDR.N    R3,??DataTable12
   \        0x6   0x689C             LDR      R4,[R3, #+8]
   \        0x8   0xB084             SUB      SP,SP,#+16
   \        0xA   0xB93C             CBNZ.N   R4,??xTimerPendFunctionCall_0
   \        0xC   0x2020             MOVS     R0,#+32
   \        0xE   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x12   0xF3BF 0x8F4F      DSB      SY
   \       0x16   0xF3BF 0x8F6F      ISB      SY
   \                     ??xTimerPendFunctionCall_1: (+1)
   \       0x1A   0xE7FE             B.N      ??xTimerPendFunctionCall_1
   1068          
   1069          		/* Complete the message with the function parameters and post it to the
   1070          		daemon task. */
   1071          		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK;
   1072          		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
   \                     ??xTimerPendFunctionCall_0: (+1)
   \       0x1C   0x9001             STR      R0,[SP, #+4]
   1073          		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
   \       0x1E   0x9102             STR      R1,[SP, #+8]
   1074          		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
   \       0x20   0x9203             STR      R2,[SP, #+12]
   \       0x22   0xF04F 0x36FF      MOV      R6,#-1
   \       0x26   0x9600             STR      R6,[SP, #+0]
   1075          
   1076          		xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
   1077          
   1078          		tracePEND_FUNC_CALL( xFunctionToPend, pvParameter1, ulParameter2, xReturn );
   1079          
   1080          		return xReturn;
   \       0x28   0x2300             MOVS     R3,#+0
   \       0x2A   0x462A             MOV      R2,R5
   \       0x2C   0x4669             MOV      R1,SP
   \       0x2E   0x4620             MOV      R0,R4
   \       0x30   0x.... 0x....      BL       xQueueGenericSend
   \       0x34   0xB004             ADD      SP,SP,#+16
   \       0x36   0xBD70             POP      {R4-R6,PC}       ;; return
   1081          	}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0x....'....        DC32     pxCurrentTimerList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \        0x0   0xE000'ED04        DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \        0x0   0x54 0x6D          DC8 "Tmr Svc"
   \              0x72 0x20    
   \              0x53 0x76    
   \              0x63 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \        0x0   0x54 0x6D          DC8 "TmrQ"
   \              0x72 0x51    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   1082          
   1083          #endif /* INCLUDE_xTimerPendFunctionCall */
   1084          /*-----------------------------------------------------------*/
   1085          
   1086          /* This entire source file will be skipped if the application is not configured
   1087          to include software timer functionality.  If you want to include software timer
   1088          functionality then ensure configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. */
   1089          #endif /* configUSE_TIMERS == 1 */
   1090          
   1091          
   1092          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   pcTimerGetName
       8   prvCheckForValidListAndQueue
         8   -> vListInitialise
         8   -> vPortEnterCritical
         0   -> vPortExitCritical
         8   -> vQueueAddToRegistry
         8   -> xQueueGenericCreate
       8   prvInsertTimerInActiveList
         8   -> vListInsert
      48   prvProcessReceivedCommands
        48   -- Indirect call
        48   -> prvInsertTimerInActiveList
        48   -> prvSampleTimeNow
        48   -> uxListRemove
        48   -> vPortFree
        48   -> xQueueGenericReceive
        48   -> xQueueGenericSend
        48   -> xTaskGetSchedulerState
      24   prvProcessTimerOrBlockTask
        24   -- Indirect call
        24   -> prvInsertTimerInActiveList
        24   -> prvSampleTimeNow
        24   -> uxListRemove
        24   -> vQueueWaitForMessageRestricted
        24   -> vTaskSuspendAll
        24   -> xTaskResumeAll
        24   -> xTimerGenericCommand
      40   prvSampleTimeNow
        40   -- Indirect call
        40   -> uxListRemove
        40   -> vListInsert
        40   -> xQueueGenericSend
        40   -> xTaskGetSchedulerState
        40   -> xTaskGetTickCount
       8   prvTimerTask
         8   -> prvProcessReceivedCommands
         8   -> prvProcessTimerOrBlockTask
       8   pvTimerGetTimerID
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
      16   vTimerSetTimerID
        16   -> vPortEnterCritical
         0   -> vPortExitCritical
      32   xTimerCreate
        32   -> prvCheckForValidListAndQueue
        32   -> pvPortMalloc
        32   -> vListInitialiseItem
      16   xTimerCreateTimerTask
        16   -> prvCheckForValidListAndQueue
        16   -> xTaskCreate
      40   xTimerGenericCommand
        40   -> xQueueGenericSend
        40   -> xQueueGenericSendFromISR
        40   -> xTaskGetSchedulerState
       0   xTimerGetExpiryTime
       0   xTimerGetPeriod
       0   xTimerGetTimerDaemonTaskHandle
       8   xTimerIsTimerActive
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
      32   xTimerPendFunctionCall
        32   -> xQueueGenericSend
      32   xTimerPendFunctionCallFromISR
        32   -> xQueueGenericSendFromISR


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       8  ?Subroutine0
       8  ?_0
       8  ?_1
      22  pcTimerGetName
      70  prvCheckForValidListAndQueue
      54  prvInsertTimerInActiveList
     238  prvProcessReceivedCommands
     168  prvProcessTimerOrBlockTask
     164  prvSampleTimeNow
      32  prvTimerTask
      28  pvTimerGetTimerID
      60  pxCurrentTimerList
          pxOverflowTimerList
          xTimerQueue
          xTimerTaskHandle
          xLastTime
          xActiveTimerList1
          xActiveTimerList2
      38  vTimerSetTimerID
      72  xTimerCreate
      62  xTimerCreateTimerTask
      90  xTimerGenericCommand
      22  xTimerGetExpiryTime
      22  xTimerGetPeriod
      26  xTimerGetTimerDaemonTaskHandle
      38  xTimerIsTimerActive
      56  xTimerPendFunctionCall
      36  xTimerPendFunctionCallFromISR

 
    60 bytes in section .bss
 1 270 bytes in section .text
 
 1 270 bytes of CODE memory
    60 bytes of DATA memory

Errors: none
Warnings: none
