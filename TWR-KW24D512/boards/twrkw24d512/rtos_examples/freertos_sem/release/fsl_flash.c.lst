###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         03/Mar/2020  16:31:25
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_flash.c
#    Command line =  
#        C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_flash.c
#        "-IC:\Program Files (x86)\IAR Systems\Embedded Workbench 8.1\arm\inc"
#        -I..\..\..\..\..\CMSIS\Include -I..\..\..\..\..\devices -I..\..\..
#        -I..\..\..\..\..\devices\MKW24D5\drivers
#        -I..\..\..\..\..\devices\MKW24D5\utilities
#        -I..\..\..\..\..\devices\MKW24D5 -I..\..\iar -I..\.. -I..\
#        -I..\..\..\..\..\rtos\freertos_9.0.0\Source\portable\IAR\ARM_CM3
#        -I..\..\..\..\..\rtos\freertos_9.0.0\Source\include -DNDEBUG
#        -DCPU_MKW24D512VHA5 -DIAR -DFSL_RTOS_FREE_RTOS -DPRINTF_FLOAT_ENABLE=0
#        -DSCANF_FLOAT_ENABLE=0 -DPRINTF_ADVANCED_ENABLE=0
#        -DSCANF_ADVANCED_ENABLE=0 -DTWR_KW24D512 -DTOWER --diag_suppress
#        Pa082,Pa050,Pe167,Pa182 --endian=little --cpu=Cortex-M4 --fpu=None
#        --no_path_in_file_macros --silent -lC . -e --dlib_config "C:/Program
#        Files (x86)/IAR Systems/Embedded Workbench
#        8.1/arm/inc/c/DLib_Config_Normal.h" -Oh --dependencies=ns
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_flash.c.obj.d
#        -o
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_flash.c.obj
#    Locale       =  C
#    List file    =  .\fsl_flash.c.lst
#    Object file  =  
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_flash.c.obj
#
###############################################################################

C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_flash.c
      1          /*
      2           * Copyright (c) 2015-2016, Freescale Semiconductor, Inc.
      3           * Copyright 2016-2017 NXP
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of the copyright holder nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "fsl_flash.h"
     32          
     33          /*******************************************************************************
     34           * Definitions
     35           ******************************************************************************/
     36          
     37          /*!
     38           * @name Misc utility defines
     39           * @{
     40           */
     41          /*! @brief Alignment utility. */
     42          #ifndef ALIGN_DOWN
     43          #define ALIGN_DOWN(x, a) ((x) & (uint32_t)(-((int32_t)(a))))
     44          #endif
     45          #ifndef ALIGN_UP
     46          #define ALIGN_UP(x, a) (-((int32_t)((uint32_t)(-((int32_t)(x))) & (uint32_t)(-((int32_t)(a))))))
     47          #endif
     48          
     49          /*! @brief Join bytes to word utility. */
     50          #define B1P4(b) (((uint32_t)(b)&0xFFU) << 24)
     51          #define B1P3(b) (((uint32_t)(b)&0xFFU) << 16)
     52          #define B1P2(b) (((uint32_t)(b)&0xFFU) << 8)
     53          #define B1P1(b) ((uint32_t)(b)&0xFFU)
     54          #define B2P3(b) (((uint32_t)(b)&0xFFFFU) << 16)
     55          #define B2P2(b) (((uint32_t)(b)&0xFFFFU) << 8)
     56          #define B2P1(b) ((uint32_t)(b)&0xFFFFU)
     57          #define B3P2(b) (((uint32_t)(b)&0xFFFFFFU) << 8)
     58          #define B3P1(b) ((uint32_t)(b)&0xFFFFFFU)
     59          #define BYTES_JOIN_TO_WORD_1_3(x, y) (B1P4(x) | B3P1(y))
     60          #define BYTES_JOIN_TO_WORD_2_2(x, y) (B2P3(x) | B2P1(y))
     61          #define BYTES_JOIN_TO_WORD_3_1(x, y) (B3P2(x) | B1P1(y))
     62          #define BYTES_JOIN_TO_WORD_1_1_2(x, y, z) (B1P4(x) | B1P3(y) | B2P1(z))
     63          #define BYTES_JOIN_TO_WORD_1_2_1(x, y, z) (B1P4(x) | B2P2(y) | B1P1(z))
     64          #define BYTES_JOIN_TO_WORD_2_1_1(x, y, z) (B2P3(x) | B1P2(y) | B1P1(z))
     65          #define BYTES_JOIN_TO_WORD_1_1_1_1(x, y, z, w) (B1P4(x) | B1P3(y) | B1P2(z) | B1P1(w))
     66          /*@}*/
     67          
     68          /*!
     69           * @name Secondary flash configuration
     70           * @{
     71           */
     72          /*! @brief Indicates whether the secondary flash has its own protection register in flash module. */
     73          #if defined(FSL_FEATURE_FLASH_HAS_MULTIPLE_FLASH) && defined(FTFE_FPROTS_PROTS_MASK)
     74          #define FLASH_SSD_SECONDARY_FLASH_HAS_ITS_OWN_PROTECTION_REGISTER (1)
     75          #else
     76          #define FLASH_SSD_SECONDARY_FLASH_HAS_ITS_OWN_PROTECTION_REGISTER (0)
     77          #endif
     78          
     79          /*! @brief Indicates whether the secondary flash has its own Execute-Only access register in flash module. */
     80          #if defined(FSL_FEATURE_FLASH_HAS_MULTIPLE_FLASH) && defined(FTFE_FACSSS_SGSIZE_S_MASK)
     81          #define FLASH_SSD_SECONDARY_FLASH_HAS_ITS_OWN_ACCESS_REGISTER (1)
     82          #else
     83          #define FLASH_SSD_SECONDARY_FLASH_HAS_ITS_OWN_ACCESS_REGISTER (0)
     84          #endif
     85          /*@}*/
     86          
     87          /*!
     88           * @name Flash cache ands speculation control defines
     89           * @{
     90           */
     91          #if defined(MCM_PLACR_CFCC_MASK) || defined(MCM_CPCR2_CCBC_MASK)
     92          #define FLASH_CACHE_IS_CONTROLLED_BY_MCM (1)
     93          #else
     94          #define FLASH_CACHE_IS_CONTROLLED_BY_MCM (0)
     95          #endif
     96          #if defined(FMC_PFB0CR_CINV_WAY_MASK) || defined(FMC_PFB01CR_CINV_WAY_MASK)
     97          #define FLASH_CACHE_IS_CONTROLLED_BY_FMC (1)
     98          #else
     99          #define FLASH_CACHE_IS_CONTROLLED_BY_FMC (0)
    100          #endif
    101          #if defined(MCM_PLACR_DFCS_MASK)
    102          #define FLASH_PREFETCH_SPECULATION_IS_CONTROLLED_BY_MCM (1)
    103          #else
    104          #define FLASH_PREFETCH_SPECULATION_IS_CONTROLLED_BY_MCM (0)
    105          #endif
    106          #if defined(MSCM_OCMDR_OCM1_MASK) || defined(MSCM_OCMDR_OCMC1_MASK)
    107          #define FLASH_PREFETCH_SPECULATION_IS_CONTROLLED_BY_MSCM (1)
    108          #else
    109          #define FLASH_PREFETCH_SPECULATION_IS_CONTROLLED_BY_MSCM (0)
    110          #endif
    111          #if defined(FMC_PFB0CR_S_INV_MASK) || defined(FMC_PFB0CR_S_B_INV_MASK) || defined(FMC_PFB01CR_S_INV_MASK) || \
    112              defined(FMC_PFB01CR_S_B_INV_MASK)
    113          #define FLASH_PREFETCH_SPECULATION_IS_CONTROLLED_BY_FMC (1)
    114          #else
    115          #define FLASH_PREFETCH_SPECULATION_IS_CONTROLLED_BY_FMC (0)
    116          #endif
    117          /*@}*/
    118          
    119          /*! @brief Data flash IFR map Field*/
    120          #if defined(FSL_FEATURE_FLASH_IS_FTFE) && FSL_FEATURE_FLASH_IS_FTFE
    121          #define DFLASH_IFR_READRESOURCE_START_ADDRESS 0x8003F8U
    122          #else /* FSL_FEATURE_FLASH_IS_FTFL == 1 or FSL_FEATURE_FLASH_IS_FTFA = =1 */
    123          #define DFLASH_IFR_READRESOURCE_START_ADDRESS 0x8000F8U
    124          #endif
    125          
    126          /*!
    127           * @name Reserved FlexNVM size (For a variety of purposes) defines
    128           * @{
    129           */
    130          #define FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED 0xFFFFFFFFU
    131          #define FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_RESERVED 0xFFFFU
    132          /*@}*/
    133          
    134          /*!
    135           * @name Flash Program Once Field defines
    136           * @{
    137           */
    138          #if defined(FSL_FEATURE_FLASH_IS_FTFA) && FSL_FEATURE_FLASH_IS_FTFA
    139          /* FTFA parts(eg. K80, KL80, L5K) support both 4-bytes and 8-bytes unit size */
    140          #define FLASH_PROGRAM_ONCE_MIN_ID_8BYTES \
    141              0x10U /* Minimum Index indcating one of Progam Once Fields which is accessed in 8-byte records */
    142          #define FLASH_PROGRAM_ONCE_MAX_ID_8BYTES \
    143              0x13U /* Maximum Index indcating one of Progam Once Fields which is accessed in 8-byte records */
    144          #define FLASH_PROGRAM_ONCE_IS_4BYTES_UNIT_SUPPORT 1
    145          #define FLASH_PROGRAM_ONCE_IS_8BYTES_UNIT_SUPPORT 1
    146          #elif defined(FSL_FEATURE_FLASH_IS_FTFE) && FSL_FEATURE_FLASH_IS_FTFE
    147          /* FTFE parts(eg. K65, KE18) only support 8-bytes unit size */
    148          #define FLASH_PROGRAM_ONCE_IS_4BYTES_UNIT_SUPPORT 0
    149          #define FLASH_PROGRAM_ONCE_IS_8BYTES_UNIT_SUPPORT 1
    150          #elif defined(FSL_FEATURE_FLASH_IS_FTFL) && FSL_FEATURE_FLASH_IS_FTFL
    151          /* FTFL parts(eg. K20) only support 4-bytes unit size */
    152          #define FLASH_PROGRAM_ONCE_IS_4BYTES_UNIT_SUPPORT 1
    153          #define FLASH_PROGRAM_ONCE_IS_8BYTES_UNIT_SUPPORT 0
    154          #endif
    155          /*@}*/
    156          
    157          /*!
    158           * @name Flash security status defines
    159           * @{
    160           */
    161          #define FLASH_SECURITY_STATE_KEYEN 0x80U
    162          #define FLASH_SECURITY_STATE_UNSECURED 0x02U
    163          #define FLASH_NOT_SECURE 0x01U
    164          #define FLASH_SECURE_BACKDOOR_ENABLED 0x02U
    165          #define FLASH_SECURE_BACKDOOR_DISABLED 0x04U
    166          /*@}*/
    167          
    168          /*!
    169           * @name Flash controller command numbers
    170           * @{
    171           */
    172          #define FTFx_VERIFY_BLOCK 0x00U                    /*!< RD1BLK*/
    173          #define FTFx_VERIFY_SECTION 0x01U                  /*!< RD1SEC*/
    174          #define FTFx_PROGRAM_CHECK 0x02U                   /*!< PGMCHK*/
    175          #define FTFx_READ_RESOURCE 0x03U                   /*!< RDRSRC*/
    176          #define FTFx_PROGRAM_LONGWORD 0x06U                /*!< PGM4*/
    177          #define FTFx_PROGRAM_PHRASE 0x07U                  /*!< PGM8*/
    178          #define FTFx_ERASE_BLOCK 0x08U                     /*!< ERSBLK*/
    179          #define FTFx_ERASE_SECTOR 0x09U                    /*!< ERSSCR*/
    180          #define FTFx_PROGRAM_SECTION 0x0BU                 /*!< PGMSEC*/
    181          #define FTFx_GENERATE_CRC 0x0CU                    /*!< CRCGEN*/
    182          #define FTFx_VERIFY_ALL_BLOCK 0x40U                /*!< RD1ALL*/
    183          #define FTFx_READ_ONCE 0x41U                       /*!< RDONCE or RDINDEX*/
    184          #define FTFx_PROGRAM_ONCE 0x43U                    /*!< PGMONCE or PGMINDEX*/
    185          #define FTFx_ERASE_ALL_BLOCK 0x44U                 /*!< ERSALL*/
    186          #define FTFx_SECURITY_BY_PASS 0x45U                /*!< VFYKEY*/
    187          #define FTFx_SWAP_CONTROL 0x46U                    /*!< SWAP*/
    188          #define FTFx_ERASE_ALL_BLOCK_UNSECURE 0x49U        /*!< ERSALLU*/
    189          #define FTFx_VERIFY_ALL_EXECUTE_ONLY_SEGMENT 0x4AU /*!< RD1XA*/
    190          #define FTFx_ERASE_ALL_EXECUTE_ONLY_SEGMENT 0x4BU  /*!< ERSXA*/
    191          #define FTFx_PROGRAM_PARTITION 0x80U               /*!< PGMPART)*/
    192          #define FTFx_SET_FLEXRAM_FUNCTION 0x81U            /*!< SETRAM*/
    193                                                             /*@}*/
    194          
    195          /*!
    196           * @name Common flash register info defines
    197           * @{
    198           */
    199          #if defined(FTFA)
    200          #define FTFx FTFA
    201          #define FTFx_BASE FTFA_BASE
    202          #define FTFx_FSTAT_CCIF_MASK FTFA_FSTAT_CCIF_MASK
    203          #define FTFx_FSTAT_RDCOLERR_MASK FTFA_FSTAT_RDCOLERR_MASK
    204          #define FTFx_FSTAT_ACCERR_MASK FTFA_FSTAT_ACCERR_MASK
    205          #define FTFx_FSTAT_FPVIOL_MASK FTFA_FSTAT_FPVIOL_MASK
    206          #define FTFx_FSTAT_MGSTAT0_MASK FTFA_FSTAT_MGSTAT0_MASK
    207          #define FTFx_FSEC_SEC_MASK FTFA_FSEC_SEC_MASK
    208          #define FTFx_FSEC_KEYEN_MASK FTFA_FSEC_KEYEN_MASK
    209          #if defined(FSL_FEATURE_FLASH_HAS_FLEX_RAM) && FSL_FEATURE_FLASH_HAS_FLEX_RAM
    210          #define FTFx_FCNFG_RAMRDY_MASK FTFA_FCNFG_RAMRDY_MASK
    211          #endif /* FSL_FEATURE_FLASH_HAS_FLEX_RAM */
    212          #if defined(FSL_FEATURE_FLASH_HAS_FLEX_NVM) && FSL_FEATURE_FLASH_HAS_FLEX_NVM
    213          #define FTFx_FCNFG_EEERDY_MASK FTFA_FCNFG_EEERDY_MASK
    214          #endif /* FSL_FEATURE_FLASH_HAS_FLEX_NVM */
    215          #elif defined(FTFE)
    216          #define FTFx FTFE
    217          #define FTFx_BASE FTFE_BASE
    218          #define FTFx_FSTAT_CCIF_MASK FTFE_FSTAT_CCIF_MASK
    219          #define FTFx_FSTAT_RDCOLERR_MASK FTFE_FSTAT_RDCOLERR_MASK
    220          #define FTFx_FSTAT_ACCERR_MASK FTFE_FSTAT_ACCERR_MASK
    221          #define FTFx_FSTAT_FPVIOL_MASK FTFE_FSTAT_FPVIOL_MASK
    222          #define FTFx_FSTAT_MGSTAT0_MASK FTFE_FSTAT_MGSTAT0_MASK
    223          #define FTFx_FSEC_SEC_MASK FTFE_FSEC_SEC_MASK
    224          #define FTFx_FSEC_KEYEN_MASK FTFE_FSEC_KEYEN_MASK
    225          #if defined(FSL_FEATURE_FLASH_HAS_FLEX_RAM) && FSL_FEATURE_FLASH_HAS_FLEX_RAM
    226          #define FTFx_FCNFG_RAMRDY_MASK FTFE_FCNFG_RAMRDY_MASK
    227          #endif /* FSL_FEATURE_FLASH_HAS_FLEX_RAM */
    228          #if defined(FSL_FEATURE_FLASH_HAS_FLEX_NVM) && FSL_FEATURE_FLASH_HAS_FLEX_NVM
    229          #define FTFx_FCNFG_EEERDY_MASK FTFE_FCNFG_EEERDY_MASK
    230          #endif /* FSL_FEATURE_FLASH_HAS_FLEX_NVM */
    231          #elif defined(FTFL)
    232          #define FTFx FTFL
    233          #define FTFx_BASE FTFL_BASE
    234          #define FTFx_FSTAT_CCIF_MASK FTFL_FSTAT_CCIF_MASK
    235          #define FTFx_FSTAT_RDCOLERR_MASK FTFL_FSTAT_RDCOLERR_MASK
    236          #define FTFx_FSTAT_ACCERR_MASK FTFL_FSTAT_ACCERR_MASK
    237          #define FTFx_FSTAT_FPVIOL_MASK FTFL_FSTAT_FPVIOL_MASK
    238          #define FTFx_FSTAT_MGSTAT0_MASK FTFL_FSTAT_MGSTAT0_MASK
    239          #define FTFx_FSEC_SEC_MASK FTFL_FSEC_SEC_MASK
    240          #define FTFx_FSEC_KEYEN_MASK FTFL_FSEC_KEYEN_MASK
    241          #if defined(FSL_FEATURE_FLASH_HAS_FLEX_RAM) && FSL_FEATURE_FLASH_HAS_FLEX_RAM
    242          #define FTFx_FCNFG_RAMRDY_MASK FTFL_FCNFG_RAMRDY_MASK
    243          #endif /* FSL_FEATURE_FLASH_HAS_FLEX_RAM */
    244          #if defined(FSL_FEATURE_FLASH_HAS_FLEX_NVM) && FSL_FEATURE_FLASH_HAS_FLEX_NVM
    245          #define FTFx_FCNFG_EEERDY_MASK FTFL_FCNFG_EEERDY_MASK
    246          #endif /* FSL_FEATURE_FLASH_HAS_FLEX_NVM */
    247          #else
    248          #error "Unknown flash controller"
    249          #endif
    250          /*@}*/
    251          
    252          /*!
    253           * @name Common flash register access info defines
    254           * @{
    255           */
    256          #define FTFx_FCCOB3_REG (FTFx->FCCOB3)
    257          #define FTFx_FCCOB5_REG (FTFx->FCCOB5)
    258          #define FTFx_FCCOB6_REG (FTFx->FCCOB6)
    259          #define FTFx_FCCOB7_REG (FTFx->FCCOB7)
    260          
    261          #if defined(FTFA_FPROTH0_PROT_MASK) || defined(FTFE_FPROTH0_PROT_MASK) || defined(FTFL_FPROTH0_PROT_MASK)
    262          #define FTFx_FPROT_HIGH_REG (FTFx->FPROTH3)
    263          #define FTFx_FPROTH3_REG (FTFx->FPROTH3)
    264          #define FTFx_FPROTH2_REG (FTFx->FPROTH2)
    265          #define FTFx_FPROTH1_REG (FTFx->FPROTH1)
    266          #define FTFx_FPROTH0_REG (FTFx->FPROTH0)
    267          #endif
    268          
    269          #if defined(FTFA_FPROTL0_PROT_MASK) || defined(FTFE_FPROTL0_PROT_MASK) || defined(FTFL_FPROTL0_PROT_MASK)
    270          #define FTFx_FPROT_LOW_REG (FTFx->FPROTL3)
    271          #define FTFx_FPROTL3_REG (FTFx->FPROTL3)
    272          #define FTFx_FPROTL2_REG (FTFx->FPROTL2)
    273          #define FTFx_FPROTL1_REG (FTFx->FPROTL1)
    274          #define FTFx_FPROTL0_REG (FTFx->FPROTL0)
    275          #elif defined(FTFA_FPROT0_PROT_MASK) || defined(FTFE_FPROT0_PROT_MASK) || defined(FTFL_FPROT0_PROT_MASK)
    276          #define FTFx_FPROT_LOW_REG (FTFx->FPROT3)
    277          #define FTFx_FPROTL3_REG (FTFx->FPROT3)
    278          #define FTFx_FPROTL2_REG (FTFx->FPROT2)
    279          #define FTFx_FPROTL1_REG (FTFx->FPROT1)
    280          #define FTFx_FPROTL0_REG (FTFx->FPROT0)
    281          #endif
    282          
    283          #if FLASH_SSD_IS_SECONDARY_FLASH_ENABLED && FLASH_SSD_SECONDARY_FLASH_HAS_ITS_OWN_PROTECTION_REGISTER
    284          #define FTFx_FPROTSH_REG (FTFx->FPROTSH)
    285          #define FTFx_FPROTSL_REG (FTFx->FPROTSL)
    286          #endif
    287          
    288          #define FTFx_XACCH3_REG (FTFx->XACCH3)
    289          #define FTFx_XACCL3_REG (FTFx->XACCL3)
    290          
    291          #if FLASH_SSD_IS_SECONDARY_FLASH_ENABLED && FLASH_SSD_SECONDARY_FLASH_HAS_ITS_OWN_ACCESS_REGISTER
    292          #define FTFx_XACCSH_REG (FTFx->XACCSH)
    293          #define FTFx_XACCSL_REG (FTFx->XACCSL)
    294          #endif
    295          /*@}*/
    296          
    297          /*!
    298           * @brief Enumeration for access segment property.
    299           */
    300          enum _flash_access_segment_property
    301          {
    302              kFLASH_AccessSegmentBase = 256UL,
    303          };
    304          
    305          /*!
    306           * @brief Enumeration for flash config area.
    307           */
    308          enum _flash_config_area_range
    309          {
    310              kFLASH_ConfigAreaStart = 0x400U,
    311              kFLASH_ConfigAreaEnd = 0x40FU
    312          };
    313          
    314          /*!
    315           * @name Flash register access type defines
    316           * @{
    317           */
    318          #define FTFx_REG8_ACCESS_TYPE volatile uint8_t *
    319          #define FTFx_REG32_ACCESS_TYPE volatile uint32_t *
    320          /*@}*/
    321          
    322          /*!
    323           * @brief MCM cache register access info defines.
    324           */
    325          #if defined(MCM_PLACR_CFCC_MASK)
    326          #define MCM_CACHE_CLEAR_MASK MCM_PLACR_CFCC_MASK
    327          #define MCM_CACHE_CLEAR_SHIFT MCM_PLACR_CFCC_SHIFT
    328          #if defined(MCM)
    329          #define MCM0_CACHE_REG MCM->PLACR
    330          #elif defined(MCM0)
    331          #define MCM0_CACHE_REG MCM0->PLACR
    332          #endif
    333          #if defined(MCM1)
    334          #define MCM1_CACHE_REG MCM1->PLACR
    335          #endif
    336          #elif defined(MCM_CPCR2_CCBC_MASK)
    337          #define MCM_CACHE_CLEAR_MASK MCM_CPCR2_CCBC_MASK
    338          #define MCM_CACHE_CLEAR_SHIFT MCM_CPCR2_CCBC_SHIFT
    339          #if defined(MCM)
    340          #define MCM0_CACHE_REG MCM->CPCR2
    341          #elif defined(MCM0)
    342          #define MCM0_CACHE_REG MCM0->CPCR2
    343          #endif
    344          #if defined(MCM1)
    345          #define MCM1_CACHE_REG MCM1->CPCR2
    346          #endif
    347          #endif
    348          
    349          /*!
    350           * @brief MSCM cache register access info defines.
    351           */
    352          #if defined(MSCM_OCMDR_OCM1_MASK)
    353          #define MSCM_SPECULATION_DISABLE_MASK MSCM_OCMDR_OCM1_MASK
    354          #define MSCM_SPECULATION_DISABLE_SHIFT MSCM_OCMDR_OCM1_SHIFT
    355          #define MSCM_SPECULATION_DISABLE(x) MSCM_OCMDR_OCM1(x)
    356          #elif defined(MSCM_OCMDR_OCMC1_MASK)
    357          #define MSCM_SPECULATION_DISABLE_MASK MSCM_OCMDR_OCMC1_MASK
    358          #define MSCM_SPECULATION_DISABLE_SHIFT MSCM_OCMDR_OCMC1_SHIFT
    359          #define MSCM_SPECULATION_DISABLE(x) MSCM_OCMDR_OCMC1(x)
    360          #endif
    361          
    362          /*!
    363           * @brief MSCM prefetch speculation defines.
    364           */
    365          #define MSCM_OCMDR_OCMC1_DFDS_MASK (0x10U)
    366          #define MSCM_OCMDR_OCMC1_DFCS_MASK (0x20U)
    367          
    368          #define MSCM_OCMDR_OCMC1_DFDS_SHIFT (4U)
    369          #define MSCM_OCMDR_OCMC1_DFCS_SHIFT (5U)
    370          
    371          /*!
    372           * @brief Flash size encoding rule.
    373           */
    374          #define FLASH_MEMORY_SIZE_ENCODING_RULE_K1_2 (0x00U)
    375          #define FLASH_MEMORY_SIZE_ENCODING_RULE_K3 (0x01U)
    376          
    377          #if defined(K32W042S1M2_M0P_SERIES) || defined(K32W042S1M2_M4_SERIES)
    378          #define FLASH_MEMORY_SIZE_ENCODING_RULE (FLASH_MEMORY_SIZE_ENCODING_RULE_K3)
    379          #else
    380          #define FLASH_MEMORY_SIZE_ENCODING_RULE (FLASH_MEMORY_SIZE_ENCODING_RULE_K1_2)
    381          #endif
    382          
    383          /*******************************************************************************
    384           * Prototypes
    385           ******************************************************************************/
    386          
    387          #if FLASH_DRIVER_IS_FLASH_RESIDENT
    388          /*! @brief Copy flash_run_command() to RAM*/
    389          static void copy_flash_run_command(uint32_t *flashRunCommand);
    390          /*! @brief Copy flash_cache_clear_command() to RAM*/
    391          static void copy_flash_common_bit_operation(uint32_t *flashCommonBitOperation);
    392          /*! @brief Check whether flash execute-in-ram functions are ready*/
    393          static status_t flash_check_execute_in_ram_function_info(flash_config_t *config);
    394          #endif /* FLASH_DRIVER_IS_FLASH_RESIDENT */
    395          
    396          /*! @brief Internal function Flash command sequence. Called by driver APIs only*/
    397          static status_t flash_command_sequence(flash_config_t *config);
    398          
    399          /*! @brief Perform the cache clear to the flash*/
    400          void flash_cache_clear(flash_config_t *config);
    401          
    402          /*! @brief Process the cache to the flash*/
    403          static void flash_cache_clear_process(flash_config_t *config, flash_cache_clear_process_t process);
    404          
    405          /*! @brief Validates the range and alignment of the given address range.*/
    406          static status_t flash_check_range(flash_config_t *config,
    407                                            uint32_t startAddress,
    408                                            uint32_t lengthInBytes,
    409                                            uint32_t alignmentBaseline);
    410          /*! @brief Gets the right address, sector and block size of current flash type which is indicated by address.*/
    411          static status_t flash_get_matched_operation_info(flash_config_t *config,
    412                                                           uint32_t address,
    413                                                           flash_operation_config_t *info);
    414          /*! @brief Validates the given user key for flash erase APIs.*/
    415          static status_t flash_check_user_key(uint32_t key);
    416          
    417          #if FLASH_SSD_IS_FLEXNVM_ENABLED
    418          /*! @brief Updates FlexNVM memory partition status according to data flash 0 IFR.*/
    419          static status_t flash_update_flexnvm_memory_partition_status(flash_config_t *config);
    420          #endif /* FLASH_SSD_IS_FLEXNVM_ENABLED */
    421          
    422          #if defined(FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD) && FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD
    423          /*! @brief Validates the range of the given resource address.*/
    424          static status_t flash_check_resource_range(uint32_t start,
    425                                                     uint32_t lengthInBytes,
    426                                                     uint32_t alignmentBaseline,
    427                                                     flash_read_resource_option_t option);
    428          #endif /* FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD */
    429          
    430          #if defined(FSL_FEATURE_FLASH_HAS_SWAP_CONTROL_CMD) && FSL_FEATURE_FLASH_HAS_SWAP_CONTROL_CMD
    431          /*! @brief Validates the gived swap control option.*/
    432          static status_t flash_check_swap_control_option(flash_swap_control_option_t option);
    433          #endif /* FSL_FEATURE_FLASH_HAS_SWAP_CONTROL_CMD */
    434          
    435          #if defined(FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP) && FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP
    436          /*! @brief Validates the gived address to see if it is equal to swap indicator address in pflash swap IFR.*/
    437          static status_t flash_validate_swap_indicator_address(flash_config_t *config, uint32_t address);
    438          #endif /* FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP */
    439          
    440          #if defined(FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD) && FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD
    441          /*! @brief Validates the gived flexram function option.*/
    442          static inline status_t flasn_check_flexram_function_option_range(flash_flexram_function_option_t option);
    443          #endif /* FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD */
    444          
    445          /*! @brief Gets the flash protection information (region size, region count).*/
    446          static status_t flash_get_protection_info(flash_config_t *config, flash_protection_config_t *info);
    447          
    448          #if defined(FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL) && FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    449          /*! @brief Gets the flash Execute-Only access information (Segment size, Segment count).*/
    450          static status_t flash_get_access_info(flash_config_t *config, flash_access_config_t *info);
    451          #endif /* FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL */
    452          
    453          #if FLASH_CACHE_IS_CONTROLLED_BY_MCM
    454          /*! @brief Performs the cache clear to the flash by MCM.*/
    455          void mcm_flash_cache_clear(flash_config_t *config);
    456          #endif /* FLASH_CACHE_IS_CONTROLLED_BY_MCM */
    457          
    458          #if FLASH_CACHE_IS_CONTROLLED_BY_FMC
    459          /*! @brief Performs the cache clear to the flash by FMC.*/
    460          void fmc_flash_cache_clear(void);
    461          #endif /* FLASH_CACHE_IS_CONTROLLED_BY_FMC */
    462          
    463          #if FLASH_PREFETCH_SPECULATION_IS_CONTROLLED_BY_MSCM
    464          /*! @brief Sets the prefetch speculation buffer to the flash by MSCM.*/
    465          void mscm_flash_prefetch_speculation_enable(bool enable);
    466          #endif /* FLASH_PREFETCH_SPECULATION_IS_CONTROLLED_BY_MSCM */
    467          
    468          #if FLASH_PREFETCH_SPECULATION_IS_CONTROLLED_BY_FMC
    469          /*! @brief Performs the prefetch speculation buffer clear to the flash by FMC.*/
    470          void fmc_flash_prefetch_speculation_clear(void);
    471          #endif /* FLASH_PREFETCH_SPECULATION_IS_CONTROLLED_BY_FMC */
    472          
    473          /*******************************************************************************
    474           * Variables
    475           ******************************************************************************/
    476          
    477          /*! @brief Access to FTFx->FCCOB */

   \                                 In section .rodata, align 4, keep-with-next
    478          volatile uint32_t *const kFCCOBx = (volatile uint32_t *)&FTFx_FCCOB3_REG;
   \                     kFCCOBx:
   \        0x0   0x4002'0004        DC32 40020004H
    479          /*! @brief Access to FTFx->FPROT */

   \                                 In section .rodata, align 4, keep-with-next
    480          volatile uint32_t *const kFPROTL = (volatile uint32_t *)&FTFx_FPROT_LOW_REG;
   \                     kFPROTL:
   \        0x0   0x4002'0010        DC32 40020010H
    481          #if defined(FTFx_FPROT_HIGH_REG)
    482          volatile uint32_t *const kFPROTH = (volatile uint32_t *)&FTFx_FPROT_HIGH_REG;
    483          #endif
    484          
    485          #if FLASH_SSD_IS_SECONDARY_FLASH_ENABLED && FLASH_SSD_SECONDARY_FLASH_HAS_ITS_OWN_PROTECTION_REGISTER
    486          volatile uint8_t *const kFPROTSL = (volatile uint8_t *)&FTFx_FPROTSL_REG;
    487          volatile uint8_t *const kFPROTSH = (volatile uint8_t *)&FTFx_FPROTSH_REG;
    488          #endif
    489          
    490          #if FLASH_DRIVER_IS_FLASH_RESIDENT
    491          /*! @brief A function pointer used to point to relocated flash_run_command() */

   \                                 In section .bss, align 4
    492          static void (*callFlashRunCommand)(FTFx_REG8_ACCESS_TYPE ftfx_fstat);
   \                     callFlashRunCommand:
   \        0x0                      DS8 4
   \        0x4                      DS8 4
    493          /*! @brief A function pointer used to point to relocated flash_common_bit_operation() */
    494          static void (*callFlashCommonBitOperation)(FTFx_REG32_ACCESS_TYPE base,
    495                                                     uint32_t bitMask,
    496                                                     uint32_t bitShift,
    497                                                     uint32_t bitValue);
    498          
    499          /*!
    500           * @brief Position independent code of flash_run_command()
    501           *
    502           * Note1: The prototype of C function is shown as below:
    503           * @code
    504           *   void flash_run_command(FTFx_REG8_ACCESS_TYPE ftfx_fstat)
    505           *   {
    506           *       // clear CCIF bit
    507           *       *ftfx_fstat = FTFx_FSTAT_CCIF_MASK;
    508           *
    509           *       // Check CCIF bit of the flash status register, wait till it is set.
    510           *       // IP team indicates that this loop will always complete.
    511           *       while (!((*ftfx_fstat) & FTFx_FSTAT_CCIF_MASK))
    512           *       {
    513           *       }
    514           *   }
    515           * @endcode
    516           * Note2: The binary code is generated by IAR 7.70.1
    517           */

   \                                 In section .text, align 4, keep-with-next
    518          const static uint16_t s_flashRunCommandFunctionCode[] = {
   \                     s_flashRunCommandFunctionCode:
   \        0x0   0x2180 0x7001      DC16 8576, 28673, 30722, 16906, 53500, 18288
   \               0x7802 0x420
   \              A 0xD0FC 0x47
   \              70           
    519              0x2180, /* MOVS  R1, #128 ; 0x80 */
    520              0x7001, /* STRB  R1, [R0] */
    521              /* @4: */
    522              0x7802, /* LDRB  R2, [R0] */
    523              0x420a, /* TST   R2, R1 */
    524              0xd0fc, /* BEQ.N @4 */
    525              0x4770  /* BX    LR */
    526          };
    527          
    528          /*!
    529           * @brief Position independent code of flash_common_bit_operation()
    530           *
    531           * Note1: The prototype of C function is shown as below:
    532           * @code
    533           *   void flash_common_bit_operation(FTFx_REG32_ACCESS_TYPE base, uint32_t bitMask, uint32_t bitShift, uint32_t
    534           * bitValue)
    535           *   {
    536           *       if (bitMask)
    537           *       {
    538           *           uint32_t value = (((uint32_t)(((uint32_t)(bitValue)) << bitShift)) & bitMask);
    539           *           *base = (*base & (~bitMask)) | value;
    540           *       }
    541           *
    542           *       __ISB();
    543           *       __DSB();
    544           *   }
    545           * @endcode
    546           * Note2: The binary code is generated by IAR 7.70.1
    547           */

   \                                 In section .text, align 4, keep-with-next
    548          const static uint16_t s_flashCommonBitOperationFunctionCode[] = {
   \                     s_flashCommonBitOperationFunctionCode:
   \        0x0   0xB510 0x2900      DC16 46352, 10496, 53253, 26628, 17292, 16531, 16409, 17185, 24577
   \               0xD005 0x680
   \              4 0x438C 0x40
   \              93 0x4019 0x4
   \              321 0x6001   
   \       0x12   0xF3BF 0x8F6F      DC16 62399, 36719, 62399, 36687, 48400
   \               0xF3BF 0x8F4
   \              F 0xBD10     
    549              0xb510, /* PUSH  {R4, LR} */
    550              0x2900, /* CMP   R1, #0 */
    551              0xd005, /* BEQ.N @12 */
    552              0x6804, /* LDR   R4, [R0] */
    553              0x438c, /* BICS  R4, R4, R1 */
    554              0x4093, /* LSLS  R3, R3, R2 */
    555              0x4019, /* ANDS  R1, R1, R3 */
    556              0x4321, /* ORRS  R1, R1, R4 */
    557              0x6001, /* STR   R1, [R0] */
    558              /*  @12: */
    559              0xf3bf, 0x8f6f, /* ISB */
    560              0xf3bf, 0x8f4f, /* DSB */
    561              0xbd10          /* POP   {R4, PC} */
    562          };
    563          #endif /* FLASH_DRIVER_IS_FLASH_RESIDENT */
    564          
    565          #if (FLASH_DRIVER_IS_FLASH_RESIDENT && !FLASH_DRIVER_IS_EXPORTED)
    566          /*! @brief A static buffer used to hold flash_run_command() */

   \                                 In section .bss, align 4
    567          static uint32_t s_flashRunCommand[kFLASH_ExecuteInRamFunctionMaxSizeInWords];
    568          /*! @brief A static buffer used to hold flash_common_bit_operation() */
    569          static uint32_t s_flashCommonBitOperation[kFLASH_ExecuteInRamFunctionMaxSizeInWords];
    570          /*! @brief Flash execute-in-ram function information */
    571          static flash_execute_in_ram_function_config_t s_flashExecuteInRamFunctionInfo;
   \                     s_flashExecuteInRamFunctionInfo:
   \        0x0                      DS8 12
   \        0xC                      DS8 64
   \       0x4C                      DS8 64
    572          #endif
    573          
    574          /*!
    575           * @brief Table of pflash sizes.
    576           *
    577           *  The index into this table is the value of the SIM_FCFG1.PFSIZE bitfield.
    578           *
    579           *  The values in this table have been right shifted 10 bits so that they will all fit within
    580           *  an 16-bit integer. To get the actual flash density, you must left shift the looked up value
    581           *  by 10 bits.
    582           *
    583           *  Elements of this table have a value of 0 in cases where the PFSIZE bitfield value is
    584           *  reserved.
    585           *
    586           *  Code to use the table:
    587           *  @code
    588           *      uint8_t pfsize = (SIM->FCFG1 & SIM_FCFG1_PFSIZE_MASK) >> SIM_FCFG1_PFSIZE_SHIFT;
    589           *      flashDensity = ((uint32_t)kPFlashDensities[pfsize]) << 10;
    590           *  @endcode
    591           */
    592          #if (FLASH_MEMORY_SIZE_ENCODING_RULE == FLASH_MEMORY_SIZE_ENCODING_RULE_K1_2)

   \                                 In section .text, align 4, keep-with-next
    593          const uint16_t kPFlashDensities[] = {
   \                     kPFlashDensities:
   \        0x0   0x0008 0x0010      DC16 8, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024
   \               0x0018 0x002
   \              0 0x0030 0x00
   \              40 0x0060 0x0
   \              080 0x00C0 0x
   \              0100 0x0180 0
   \              x0200 0x0300 
   \              0x0400       
   \       0x1C   0x0600             DC16 1536
   \       0x1E   0x00 0x00          DC8 0, 0
    594              8,    /* 0x0 - 8192, 8KB */
    595              16,   /* 0x1 - 16384, 16KB */
    596              24,   /* 0x2 - 24576, 24KB */
    597              32,   /* 0x3 - 32768, 32KB */
    598              48,   /* 0x4 - 49152, 48KB */
    599              64,   /* 0x5 - 65536, 64KB */
    600              96,   /* 0x6 - 98304, 96KB */
    601              128,  /* 0x7 - 131072, 128KB */
    602              192,  /* 0x8 - 196608, 192KB */
    603              256,  /* 0x9 - 262144, 256KB */
    604              384,  /* 0xa - 393216, 384KB */
    605              512,  /* 0xb - 524288, 512KB */
    606              768,  /* 0xc - 786432, 768KB */
    607              1024, /* 0xd - 1048576, 1MB */
    608              1536, /* 0xe - 1572864, 1.5MB */
    609              /* 2048,  0xf - 2097152, 2MB */
    610          };
    611          #elif(FLASH_MEMORY_SIZE_ENCODING_RULE == FLASH_MEMORY_SIZE_ENCODING_RULE_K3)
    612          const uint16_t kPFlashDensities[] = {
    613              0,    /* 0x0 - undefined */
    614              0,    /* 0x1 - undefined */
    615              0,    /* 0x2 - undefined */
    616              0,    /* 0x3 - undefined */
    617              0,    /* 0x4 - undefined */
    618              0,    /* 0x5 - undefined */
    619              0,    /* 0x6 - undefined */
    620              0,    /* 0x7 - undefined */
    621              0,    /* 0x8 - undefined */
    622              0,    /* 0x9 - undefined */
    623              256,  /* 0xa - 262144, 256KB */
    624              0,    /* 0xb - undefined */
    625              1024, /* 0xc - 1048576, 1MB */
    626              0,    /* 0xd - undefined */
    627              0,    /* 0xe - undefined */
    628              0,    /* 0xf - undefined */
    629          };
    630          #endif
    631          
    632          /*******************************************************************************
    633           * Code
    634           ******************************************************************************/
    635          

   \                                 In section .text, align 2, keep-with-next
    636          status_t FLASH_Init(flash_config_t *config)
    637          {
   \                     FLASH_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    638              if (config == NULL)
   \        0x4   0xD101             BNE.N    ??FLASH_Init_0
    639              {
    640                  return kStatus_FLASH_InvalidArgument;
   \        0x6   0x2004             MOVS     R0,#+4
   \        0x8   0xBD10             POP      {R4,PC}
    641              }
    642          
    643          #if FLASH_SSD_IS_SECONDARY_FLASH_ENABLED
    644              if (config->FlashMemoryIndex == (uint8_t)kFLASH_MemoryIndexSecondaryFlash)
    645              {
    646          /* calculate the flash density from SIM_FCFG1.PFSIZE */
    647          #if defined(SIM_FCFG1_CORE1_PFSIZE_MASK)
    648                  uint32_t flashDensity;
    649                  uint8_t pfsize = (SIM->FCFG1 & SIM_FCFG1_CORE1_PFSIZE_MASK) >> SIM_FCFG1_CORE1_PFSIZE_SHIFT;
    650                  if (pfsize == 0xf)
    651                  {
    652                      flashDensity = FSL_FEATURE_FLASH_PFLASH_1_BLOCK_COUNT * FSL_FEATURE_FLASH_PFLASH_1_BLOCK_SIZE;
    653                  }
    654                  else
    655                  {
    656                      flashDensity = ((uint32_t)kPFlashDensities[pfsize]) << 10;
    657                  }
    658                  config->PFlashTotalSize = flashDensity;
    659          #else
    660                  /* Unused code to solve MISRA-C issue*/
    661                  config->PFlashBlockBase = kPFlashDensities[0];
    662                  config->PFlashTotalSize = FSL_FEATURE_FLASH_PFLASH_1_BLOCK_COUNT * FSL_FEATURE_FLASH_PFLASH_1_BLOCK_SIZE;
    663          #endif
    664                  config->PFlashBlockBase = FSL_FEATURE_FLASH_PFLASH_1_START_ADDRESS;
    665                  config->PFlashBlockCount = FSL_FEATURE_FLASH_PFLASH_1_BLOCK_COUNT;
    666                  config->PFlashSectorSize = FSL_FEATURE_FLASH_PFLASH_1_BLOCK_SECTOR_SIZE;
    667              }
    668              else
    669          #endif /* FLASH_SSD_IS_SECONDARY_FLASH_ENABLED */
    670              {
    671                  uint32_t flashDensity;
    672          
    673          /* calculate the flash density from SIM_FCFG1.PFSIZE */
    674          #if defined(SIM_FCFG1_CORE0_PFSIZE_MASK)
    675                  uint8_t pfsize = (SIM->FCFG1 & SIM_FCFG1_CORE0_PFSIZE_MASK) >> SIM_FCFG1_CORE0_PFSIZE_SHIFT;
    676          #elif defined(SIM_FCFG1_PFSIZE_MASK)
    677                  uint8_t pfsize = (SIM->FCFG1 & SIM_FCFG1_PFSIZE_MASK) >> SIM_FCFG1_PFSIZE_SHIFT;
   \                     ??FLASH_Init_0: (+1)
   \        0xA   0x.... 0x....      LDR.W    R0,??DataTable31  ;; 0x4004804c
   \        0xE   0x6800             LDR      R0,[R0, #+0]
   \       0x10   0x0E00             LSRS     R0,R0,#+24
   \       0x12   0xF000 0x000F      AND      R0,R0,#0xF
    678          #else
    679          #error "Unknown flash size"
    680          #endif
    681                  /* PFSIZE=0xf means that on customer parts the IFR was not correctly programmed.
    682                   * We just use the pre-defined flash size in feature file here to support pre-production parts */
    683                  if (pfsize == 0xf)
   \       0x16   0x280F             CMP      R0,#+15
   \       0x18   0xBF0F             ITEEE    EQ 
   \       0x1A   0xF44F 0x2000      MOVEQ    R0,#+524288
   \       0x1E   0x.... 0x....      ADRNE.W  R1,kPFlashDensities
   \       0x22   0xF831 0x0010      LDRHNE   R0,[R1, R0, LSL #+1]
   \       0x26   0x0280             LSLNE    R0,R0,#+10
    684                  {
    685                      flashDensity = FSL_FEATURE_FLASH_PFLASH_BLOCK_COUNT * FSL_FEATURE_FLASH_PFLASH_BLOCK_SIZE;
    686                  }
    687                  else
    688                  {
    689                      flashDensity = ((uint32_t)kPFlashDensities[pfsize]) << 10;
    690                  }
    691          
    692                  /* fill out a few of the structure members */
    693                  config->PFlashBlockBase = FSL_FEATURE_FLASH_PFLASH_START_ADDRESS;
   \       0x28   0x2100             MOVS     R1,#+0
   \       0x2A   0x6021             STR      R1,[R4, #+0]
    694                  config->PFlashTotalSize = flashDensity;
   \       0x2C   0x6060             STR      R0,[R4, #+4]
    695                  config->PFlashBlockCount = FSL_FEATURE_FLASH_PFLASH_BLOCK_COUNT;
    696                  config->PFlashSectorSize = FSL_FEATURE_FLASH_PFLASH_BLOCK_SECTOR_SIZE;
   \       0x2E   0xF44F 0x6100      MOV      R1,#+2048
   \       0x32   0x2002             MOVS     R0,#+2
   \       0x34   0x7220             STRB     R0,[R4, #+8]
   \       0x36   0x60E1             STR      R1,[R4, #+12]
    697              }
    698          
    699              {
    700          #if defined(FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL) && FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
    701          #if FLASH_SSD_IS_SECONDARY_FLASH_ENABLED && FLASH_SSD_SECONDARY_FLASH_HAS_ITS_OWN_ACCESS_REGISTER
    702                  if (config->FlashMemoryIndex == (uint8_t)kFLASH_MemoryIndexSecondaryFlash)
    703                  {
    704                      config->PFlashAccessSegmentSize = kFLASH_AccessSegmentBase << FTFx->FACSSS;
    705                      config->PFlashAccessSegmentCount = FTFx->FACSNS;
    706                  }
    707                  else
    708          #endif
    709                  {
    710                      config->PFlashAccessSegmentSize = kFLASH_AccessSegmentBase << FTFx->FACSS;
    711                      config->PFlashAccessSegmentCount = FTFx->FACSN;
    712                  }
    713          #else
    714                  config->PFlashAccessSegmentSize = 0;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0x6160             STR      R0,[R4, #+20]
    715                  config->PFlashAccessSegmentCount = 0;
    716          #endif /* FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL */
    717              }
    718          
    719              config->PFlashCallback = NULL;
   \       0x3C   0x6120             STR      R0,[R4, #+16]
   \       0x3E   0x2100             MOVS     R1,#+0
    720          
    721          /* copy required flash commands to RAM */
    722          #if (FLASH_DRIVER_IS_FLASH_RESIDENT && !FLASH_DRIVER_IS_EXPORTED)
    723              if (kStatus_FLASH_Success != flash_check_execute_in_ram_function_info(config))
   \       0x40   0x69E0             LDR      R0,[R4, #+28]
   \       0x42   0x61A1             STR      R1,[R4, #+24]
   \       0x44   0xB110             CBZ.N    R0,??FLASH_Init_1
   \       0x46   0x6800             LDR      R0,[R0, #+0]
   \       0x48   0x2802             CMP      R0,#+2
   \       0x4A   0xD00C             BEQ.N    ??FLASH_Init_2
    724              {
    725                  s_flashExecuteInRamFunctionInfo.activeFunctionCount = 0;
   \                     ??FLASH_Init_1: (+1)
   \       0x4C   0x.... 0x....      LDR.W    R0,??DataTable31_1
    726                  s_flashExecuteInRamFunctionInfo.flashRunCommand = s_flashRunCommand;
   \       0x50   0xF100 0x020C      ADD      R2,R0,#+12
    727                  s_flashExecuteInRamFunctionInfo.flashCommonBitOperation = s_flashCommonBitOperation;
   \       0x54   0xF100 0x034C      ADD      R3,R0,#+76
   \       0x58   0x6001             STR      R1,[R0, #+0]
   \       0x5A   0x6042             STR      R2,[R0, #+4]
   \       0x5C   0x6083             STR      R3,[R0, #+8]
    728                  config->flashExecuteInRamFunctionInfo = &s_flashExecuteInRamFunctionInfo.activeFunctionCount;
   \       0x5E   0x61E0             STR      R0,[R4, #+28]
    729                  FLASH_PrepareExecuteInRamFunctions(config);
   \       0x60   0x4620             MOV      R0,R4
   \       0x62   0x.... 0x....      BL       FLASH_PrepareExecuteInRamFunctions
    730              }
    731          #endif
    732          
    733              config->FlexRAMBlockBase = FSL_FEATURE_FLASH_FLEX_RAM_START_ADDRESS;
   \                     ??FLASH_Init_2: (+1)
   \       0x66   0xF04F 0x50A0      MOV      R0,#+335544320
   \       0x6A   0x6220             STR      R0,[R4, #+32]
    734              config->FlexRAMTotalSize = FSL_FEATURE_FLASH_FLEX_RAM_SIZE;
   \       0x6C   0xF44F 0x5180      MOV      R1,#+4096
   \       0x70   0x6261             STR      R1,[R4, #+36]
    735          
    736          #if FLASH_SSD_IS_FLEXNVM_ENABLED
    737              {
    738                  status_t returnCode;
    739                  config->DFlashBlockBase = FSL_FEATURE_FLASH_FLEX_NVM_START_ADDRESS;
    740                  returnCode = flash_update_flexnvm_memory_partition_status(config);
    741                  if (returnCode != kStatus_FLASH_Success)
    742                  {
    743                      return returnCode;
    744                  }
    745              }
    746          #endif
    747          
    748              return kStatus_FLASH_Success;
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0xBD10             POP      {R4,PC}          ;; return
    749          }
    750          

   \                                 In section .text, align 2, keep-with-next
    751          status_t FLASH_SetCallback(flash_config_t *config, flash_callback_t callback)
    752          {
    753              if (config == NULL)
   \                     FLASH_SetCallback: (+1)
   \        0x0   0xB908             CBNZ.N   R0,??FLASH_SetCallback_0
    754              {
    755                  return kStatus_FLASH_InvalidArgument;
   \        0x2   0x2004             MOVS     R0,#+4
   \        0x4   0x4770             BX       LR
    756              }
    757          
    758              config->PFlashCallback = callback;
   \                     ??FLASH_SetCallback_0: (+1)
   \        0x6   0x6101             STR      R1,[R0, #+16]
    759          
    760              return kStatus_FLASH_Success;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x4770             BX       LR               ;; return
    761          }
    762          
    763          #if FLASH_DRIVER_IS_FLASH_RESIDENT

   \                                 In section .text, align 2, keep-with-next
    764          status_t FLASH_PrepareExecuteInRamFunctions(flash_config_t *config)
    765          {
   \                     FLASH_PrepareExecuteInRamFunctions: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    766              flash_execute_in_ram_function_config_t *flashExecuteInRamFunctionInfo;
    767          
    768              if (config == NULL)
   \        0x2   0xB908             CBNZ.N   R0,??FLASH_PrepareExecuteInRamFunctions_0
    769              {
    770                  return kStatus_FLASH_InvalidArgument;
   \        0x4   0x2004             MOVS     R0,#+4
   \        0x6   0xBD70             POP      {R4-R6,PC}
    771              }
    772          
    773              flashExecuteInRamFunctionInfo = (flash_execute_in_ram_function_config_t *)config->flashExecuteInRamFunctionInfo;
   \                     ??FLASH_PrepareExecuteInRamFunctions_0: (+1)
   \        0x8   0x69C4             LDR      R4,[R0, #+28]
    774          
    775              copy_flash_run_command(flashExecuteInRamFunctionInfo->flashRunCommand);
   \        0xA   0x.... 0x....      ADR.W    R1,s_flashRunCommandFunctionCode
   \        0xE   0x6865             LDR      R5,[R4, #+4]
   \       0x10   0x220C             MOVS     R2,#+12
   \       0x12   0x4628             MOV      R0,R5
   \       0x14   0x.... 0x....      BL       __aeabi_memcpy
   \       0x18   0x.... 0x....      LDR.W    R6,??DataTable31_2
    776              copy_flash_common_bit_operation(flashExecuteInRamFunctionInfo->flashCommonBitOperation);
   \       0x1C   0x.... 0x....      ADR.W    R1,s_flashCommonBitOperationFunctionCode
   \       0x20   0x1C6D             ADDS     R5,R5,#+1
   \       0x22   0x6035             STR      R5,[R6, #+0]
   \       0x24   0x221C             MOVS     R2,#+28
   \       0x26   0x68A5             LDR      R5,[R4, #+8]
   \       0x28   0x4628             MOV      R0,R5
   \       0x2A   0x.... 0x....      BL       __aeabi_memcpy
   \       0x2E   0x1C6D             ADDS     R5,R5,#+1
   \       0x30   0x6075             STR      R5,[R6, #+4]
   \       0x32   0x2300             MOVS     R3,#+0
   \       0x34   0x2200             MOVS     R2,#+0
   \       0x36   0x2100             MOVS     R1,#+0
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0x47A8             BLX      R5
    777              flashExecuteInRamFunctionInfo->activeFunctionCount = kFLASH_ExecuteInRamFunctionTotalNum;
   \       0x3C   0x2002             MOVS     R0,#+2
   \       0x3E   0x6020             STR      R0,[R4, #+0]
    778          
    779              return kStatus_FLASH_Success;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xBD70             POP      {R4-R6,PC}       ;; return
    780          }
    781          #endif /* FLASH_DRIVER_IS_FLASH_RESIDENT */
    782          

   \                                 In section .text, align 2, keep-with-next
    783          status_t FLASH_EraseAll(flash_config_t *config, uint32_t key)
    784          {
   \                     FLASH_EraseAll: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    785              status_t returnCode;
    786          
    787              if (config == NULL)
   \        0x4   0xD101             BNE.N    ??FLASH_EraseAll_0
    788              {
    789                  return kStatus_FLASH_InvalidArgument;
   \        0x6   0x2004             MOVS     R0,#+4
   \        0x8   0xBD32             POP      {R1,R4,R5,PC}
    790              }
    791          
    792              /* preparing passing parameter to erase all flash blocks */
    793              kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_ERASE_ALL_BLOCK, 0xFFFFFFU);
   \                     ??FLASH_EraseAll_0: (+1)
   \        0xA   0x.... 0x....      LDR.W    R2,??DataTable31_3  ;; 0x40020004
    794          
    795              /* Validate the user key */
    796              returnCode = flash_check_user_key(key);
   \        0xE   0x.... 0x....      LDR.W    R3,??DataTable31_4  ;; 0x6b65666b
   \       0x12   0xF06F 0x403B      MVN      R0,#-1157627904
   \       0x16   0x4299             CMP      R1,R3
   \       0x18   0x6010             STR      R0,[R2, #+0]
   \       0x1A   0xD001             BEQ.N    ??FLASH_EraseAll_1
    797              if (returnCode)
    798              {
    799                  return returnCode;
   \       0x1C   0x206B             MOVS     R0,#+107
   \       0x1E   0xBD32             POP      {R1,R4,R5,PC}
    800              }
    801          
    802              flash_cache_clear_process(config, kFLASH_CacheClearProcessPre);
   \                     ??FLASH_EraseAll_1: (+1)
   \       0x20   0x....             B.N      ?Subroutine0
    803          
    804              /* calling flash command sequence function to execute the command */
    805              returnCode = flash_command_sequence(config);
    806          
    807              flash_cache_clear(config);
    808          
    809          #if FLASH_SSD_IS_FLEXNVM_ENABLED
    810              /* Data flash IFR will be erased by erase all command, so we need to
    811               *  update FlexNVM memory partition status synchronously */
    812              if (returnCode == kStatus_FLASH_Success)
    813              {
    814                  returnCode = flash_update_flexnvm_memory_partition_status(config);
    815              }
    816          #endif
    817          
    818              return returnCode;
    819          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \                     ??Subroutine0_0: (+1)
   \        0x2   0x4620             MOV      R0,R4
   \        0x4   0x.... 0x....      BL       flash_cache_clear_process
   \        0x8   0x4620             MOV      R0,R4
   \        0xA   0x.... 0x....      BL       flash_command_sequence
   \        0xE   0x4605             MOV      R5,R0
   \       0x10   0x2101             MOVS     R1,#+1
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0x.... 0x....      BL       flash_cache_clear_process
   \       0x18   0x4628             MOV      R0,R5
   \       0x1A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    820          

   \                                 In section .text, align 2, keep-with-next
    821          status_t FLASH_Erase(flash_config_t *config, uint32_t start, uint32_t lengthInBytes, uint32_t key)
    822          {
   \                     FLASH_Erase: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0xB088             SUB      SP,SP,#+32
   \        0x6   0x4617             MOV      R7,R2
   \        0x8   0x4681             MOV      R9,R0
   \        0xA   0x460C             MOV      R4,R1
   \        0xC   0x461D             MOV      R5,R3
    823              uint32_t sectorSize;
    824              flash_operation_config_t flashOperationInfo;
    825              uint32_t endAddress;      /* storing end address */
    826              uint32_t numberOfSectors; /* number of sectors calculated by endAddress */
    827              status_t returnCode;
    828          
    829              flash_get_matched_operation_info(config, start, &flashOperationInfo);
   \        0xE   0x466A             MOV      R2,SP
   \       0x10   0x.... 0x....      BL       flash_get_matched_operation_info
    830          
    831              /* Check the supplied address range. */
    832              returnCode = flash_check_range(config, start, lengthInBytes, flashOperationInfo.sectorCmdAddressAligment);
   \       0x14   0x9B04             LDR      R3,[SP, #+16]
   \       0x16   0x463A             MOV      R2,R7
   \       0x18   0x4621             MOV      R1,R4
   \       0x1A   0x4648             MOV      R0,R9
   \       0x1C   0x.... 0x....      BL       flash_check_range
   \       0x20   0x0004             MOVS     R4,R0
    833              if (returnCode)
   \       0x22   0xD12F             BNE.N    ??FLASH_Erase_0
    834              {
    835                  return returnCode;
    836              }
    837          
    838              /* Validate the user key */
    839              returnCode = flash_check_user_key(key);
   \       0x24   0x.... 0x....      LDR.W    R0,??DataTable31_4  ;; 0x6b65666b
   \       0x28   0x4285             CMP      R5,R0
   \       0x2A   0xBF18             IT       NE 
   \       0x2C   0x246B             MOVNE    R4,#+107
    840              if (returnCode)
    841              {
    842                  return returnCode;
   \       0x2E   0xD129             BNE.N    ??FLASH_Erase_0
    843              }
    844          
    845              start = flashOperationInfo.convertedAddress;
   \       0x30   0xF8DD 0x8000      LDR      R8,[SP, #+0]
    846              sectorSize = flashOperationInfo.activeSectorSize;
   \       0x34   0x9D01             LDR      R5,[SP, #+4]
    847          
    848              /* calculating Flash end address */
    849              endAddress = start + lengthInBytes - 1;
   \       0x36   0x4447             ADD      R7,R7,R8
   \       0x38   0x1E7F             SUBS     R7,R7,#+1
    850          
    851              /* re-calculate the endAddress and align it to the start of the next sector
    852               * which will be used in the comparison below */
    853              if (endAddress % sectorSize)
   \       0x3A   0xFBB7 0xF1F5      UDIV     R1,R7,R5
   \       0x3E   0xFB05 0x7011      MLS      R0,R5,R1,R7
   \       0x42   0xB110             CBZ.N    R0,??FLASH_Erase_1
    854              {
    855                  numberOfSectors = endAddress / sectorSize + 1;
    856                  endAddress = numberOfSectors * sectorSize - 1;
   \       0x44   0x1C4F             ADDS     R7,R1,#+1
   \       0x46   0x436F             MULS     R7,R7,R5
   \       0x48   0x1E7F             SUBS     R7,R7,#+1
    857              }
    858          
    859              flash_cache_clear_process(config, kFLASH_CacheClearProcessPre);
   \                     ??FLASH_Erase_1: (+1)
   \       0x4A   0x2100             MOVS     R1,#+0
   \       0x4C   0x4648             MOV      R0,R9
   \       0x4E   0x.... 0x....      BL       flash_cache_clear_process
   \       0x52   0x.... 0x....      LDR.W    R6,??DataTable31_3  ;; 0x40020004
    860          
    861              /* the start address will increment to the next sector address
    862               * until it reaches the endAdddress */
    863              while (start <= endAddress)
   \                     ??FLASH_Erase_2: (+1)
   \       0x56   0x4547             CMP      R7,R8
   \       0x58   0xD310             BCC.N    ??FLASH_Erase_3
    864              {
    865                  /* preparing passing parameter to erase a flash block */
    866                  kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_ERASE_SECTOR, start);
   \       0x5A   0xF028 0x407F      BIC      R0,R8,#0xFF000000
   \       0x5E   0xF040 0x6010      ORR      R0,R0,#0x9000000
   \       0x62   0x6030             STR      R0,[R6, #+0]
    867          
    868                  /* calling flash command sequence function to execute the command */
    869                  returnCode = flash_command_sequence(config);
   \       0x64   0x4648             MOV      R0,R9
   \       0x66   0x.... 0x....      BL       flash_command_sequence
   \       0x6A   0x4604             MOV      R4,R0
    870          
    871                  /* calling flash callback function if it is available */
    872                  if (config->PFlashCallback)
   \       0x6C   0xF8D9 0x0010      LDR      R0,[R9, #+16]
   \       0x70   0xB100             CBZ.N    R0,??FLASH_Erase_4
    873                  {
    874                      config->PFlashCallback();
   \       0x72   0x4780             BLX      R0
    875                  }
    876          
    877                  /* checking the success of command execution */
    878                  if (kStatus_FLASH_Success != returnCode)
   \                     ??FLASH_Erase_4: (+1)
   \       0x74   0x2C00             CMP      R4,#+0
   \       0x76   0xBF08             IT       EQ 
   \       0x78   0x44A8             ADDEQ    R8,R5,R8
    879                  {
    880                      break;
    881                  }
    882                  else
    883                  {
    884                      /* Increment to the next sector */
    885                      start += sectorSize;
   \       0x7A   0xD0EC             BEQ.N    ??FLASH_Erase_2
   \                     ??FLASH_Erase_3: (+1)
   \       0x7C   0x4648             MOV      R0,R9
    886                  }
    887              }
    888          
    889              flash_cache_clear(config);
   \       0x7E   0x2101             MOVS     R1,#+1
   \       0x80   0x.... 0x....      BL       flash_cache_clear_process
    890          
    891              return (returnCode);
   \                     ??FLASH_Erase_0: (+1)
   \       0x84   0x4620             MOV      R0,R4
   \       0x86                      REQUIRE ?Subroutine1
   \       0x86                      ;; // Fall through to label ?Subroutine1
    892          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0xB009             ADD      SP,SP,#+36
   \        0x2   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    893          
    894          #if defined(FSL_FEATURE_FLASH_HAS_ERASE_ALL_BLOCKS_UNSECURE_CMD) && FSL_FEATURE_FLASH_HAS_ERASE_ALL_BLOCKS_UNSECURE_CMD
    895          status_t FLASH_EraseAllUnsecure(flash_config_t *config, uint32_t key)
    896          {
    897              status_t returnCode;
    898          
    899              if (config == NULL)
    900              {
    901                  return kStatus_FLASH_InvalidArgument;
    902              }
    903          
    904              /* Prepare passing parameter to erase all flash blocks (unsecure). */
    905              kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_ERASE_ALL_BLOCK_UNSECURE, 0xFFFFFFU);
    906          
    907              /* Validate the user key */
    908              returnCode = flash_check_user_key(key);
    909              if (returnCode)
    910              {
    911                  return returnCode;
    912              }
    913          
    914              flash_cache_clear_process(config, kFLASH_CacheClearProcessPre);
    915          
    916              /* calling flash command sequence function to execute the command */
    917              returnCode = flash_command_sequence(config);
    918          
    919              flash_cache_clear(config);
    920          
    921          #if FLASH_SSD_IS_FLEXNVM_ENABLED
    922              /* Data flash IFR will be erased by erase all unsecure command, so we need to
    923               *  update FlexNVM memory partition status synchronously */
    924              if (returnCode == kStatus_FLASH_Success)
    925              {
    926                  returnCode = flash_update_flexnvm_memory_partition_status(config);
    927              }
    928          #endif
    929          
    930              return returnCode;
    931          }
    932          #endif /* FSL_FEATURE_FLASH_HAS_ERASE_ALL_BLOCKS_UNSECURE_CMD */
    933          

   \                                 In section .text, align 2, keep-with-next
    934          status_t FLASH_EraseAllExecuteOnlySegments(flash_config_t *config, uint32_t key)
    935          {
   \                     FLASH_EraseAllExecuteOnlySegments: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    936              status_t returnCode;
    937          
    938              if (config == NULL)
   \        0x4   0xD101             BNE.N    ??FLASH_EraseAllExecuteOnlySegments_0
    939              {
    940                  return kStatus_FLASH_InvalidArgument;
   \        0x6   0x2004             MOVS     R0,#+4
   \        0x8   0xBD32             POP      {R1,R4,R5,PC}
    941              }
    942          
    943              /* preparing passing parameter to erase all execute-only segments
    944               * 1st element for the FCCOB register */
    945              kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_ERASE_ALL_EXECUTE_ONLY_SEGMENT, 0xFFFFFFU);
   \                     ??FLASH_EraseAllExecuteOnlySegments_0: (+1)
   \        0xA   0x.... 0x....      LDR.W    R2,??DataTable31_3  ;; 0x40020004
    946          
    947              /* Validate the user key */
    948              returnCode = flash_check_user_key(key);
   \        0xE   0x.... 0x....      LDR.W    R3,??DataTable31_4  ;; 0x6b65666b
   \       0x12   0xF06F 0x4034      MVN      R0,#-1275068416
   \       0x16   0x4299             CMP      R1,R3
   \       0x18   0x6010             STR      R0,[R2, #+0]
   \       0x1A   0xD001             BEQ.N    ??FLASH_EraseAllExecuteOnlySegments_1
    949              if (returnCode)
    950              {
    951                  return returnCode;
   \       0x1C   0x206B             MOVS     R0,#+107
   \       0x1E   0xBD32             POP      {R1,R4,R5,PC}
    952              }
    953          
    954              flash_cache_clear_process(config, kFLASH_CacheClearProcessPre);
   \                     ??FLASH_EraseAllExecuteOnlySegments_1: (+1)
   \       0x20                      REQUIRE ?Subroutine0
   \       0x20                      ;; // Fall through to label ?Subroutine0
    955          
    956              /* calling flash command sequence function to execute the command */
    957              returnCode = flash_command_sequence(config);
    958          
    959              flash_cache_clear(config);
    960          
    961              return returnCode;
    962          }
    963          

   \                                 In section .text, align 2, keep-with-next
    964          status_t FLASH_Program(flash_config_t *config, uint32_t start, uint32_t *src, uint32_t lengthInBytes)
    965          {
   \                     FLASH_Program: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x0014             MOVS     R4,R2
   \        0x8   0xB088             SUB      SP,SP,#+32
   \        0xA   0x460D             MOV      R5,R1
    966              status_t returnCode;
    967              flash_operation_config_t flashOperationInfo;
    968          
    969              if (src == NULL)
   \        0xC   0xBF08             IT       EQ 
   \        0xE   0x2004             MOVEQ    R0,#+4
    970              {
    971                  return kStatus_FLASH_InvalidArgument;
   \       0x10   0xD03D             BEQ.N    ??FLASH_Program_0
   \       0x12   0x469A             MOV      R10,R3
    972              }
    973          
    974              flash_get_matched_operation_info(config, start, &flashOperationInfo);
   \       0x14   0x466A             MOV      R2,SP
   \       0x16   0x.... 0x....      BL       flash_get_matched_operation_info
    975          
    976              /* Check the supplied address range. */
    977              returnCode = flash_check_range(config, start, lengthInBytes, flashOperationInfo.blockWriteUnitSize);
   \       0x1A   0x9B03             LDR      R3,[SP, #+12]
   \       0x1C   0x4652             MOV      R2,R10
   \       0x1E   0x4629             MOV      R1,R5
   \       0x20   0x4630             MOV      R0,R6
   \       0x22   0x.... 0x....      BL       flash_check_range
   \       0x26   0x0005             MOVS     R5,R0
    978              if (returnCode)
   \       0x28   0xD131             BNE.N    ??FLASH_Program_0
    979              {
    980                  return returnCode;
    981              }
    982          
    983              start = flashOperationInfo.convertedAddress;
   \       0x2A   0xF8DD 0x8000      LDR      R8,[SP, #+0]
    984          
    985              flash_cache_clear_process(config, kFLASH_CacheClearProcessPre);
   \       0x2E   0x2100             MOVS     R1,#+0
   \       0x30   0x4630             MOV      R0,R6
   \       0x32   0x.... 0x....      BL       flash_cache_clear_process
   \       0x36   0x46A1             MOV      R9,R4
   \       0x38   0x.... 0x....      LDR.W    R7,??DataTable31_3  ;; 0x40020004
   \       0x3C   0x4654             MOV      R4,R10
   \       0x3E   0xE014             B.N      ??FLASH_Program_1
    986          
    987              while (lengthInBytes > 0)
    988              {
    989                  /* preparing passing parameter to program the flash block */
    990                  kFCCOBx[1] = *src++;
    991                  if (4 == flashOperationInfo.blockWriteUnitSize)
    992                  {
    993                      kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_PROGRAM_LONGWORD, start);
    994                  }
    995                  else if (8 == flashOperationInfo.blockWriteUnitSize)
   \                     ??FLASH_Program_2: (+1)
   \       0x40   0x2808             CMP      R0,#+8
   \       0x42   0xD107             BNE.N    ??FLASH_Program_3
    996                  {
    997                      kFCCOBx[2] = *src++;
   \       0x44   0xF859 0x0B04      LDR      R0,[R9], #+4
   \       0x48   0x60B8             STR      R0,[R7, #+8]
    998                      kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_PROGRAM_PHRASE, start);
   \       0x4A   0xF028 0x417F      BIC      R1,R8,#0xFF000000
   \       0x4E   0xF041 0x61E0      ORR      R1,R1,#0x7000000
   \       0x52   0x6039             STR      R1,[R7, #+0]
    999                  }
   1000                  else
   1001                  {
   1002                  }
   1003          
   1004                  /* calling flash command sequence function to execute the command */
   1005                  returnCode = flash_command_sequence(config);
   \                     ??FLASH_Program_3: (+1)
   \       0x54   0x4630             MOV      R0,R6
   \       0x56   0x.... 0x....      BL       flash_command_sequence
   \       0x5A   0x4605             MOV      R5,R0
   1006          
   1007                  /* calling flash callback function if it is available */
   1008                  if (config->PFlashCallback)
   \       0x5C   0x6930             LDR      R0,[R6, #+16]
   \       0x5E   0xB100             CBZ.N    R0,??FLASH_Program_4
   1009                  {
   1010                      config->PFlashCallback();
   \       0x60   0x4780             BLX      R0
   1011                  }
   1012          
   1013                  /* checking for the success of command execution */
   1014                  if (kStatus_FLASH_Success != returnCode)
   \                     ??FLASH_Program_4: (+1)
   \       0x62   0xB97D             CBNZ.N   R5,??FLASH_Program_5
   1015                  {
   1016                      break;
   1017                  }
   1018                  else
   1019                  {
   1020                      /* update start address for next iteration */
   1021                      start += flashOperationInfo.blockWriteUnitSize;
   \       0x64   0x9803             LDR      R0,[SP, #+12]
   \       0x66   0x4480             ADD      R8,R0,R8
   1022          
   1023                      /* update lengthInBytes for next iteration */
   1024                      lengthInBytes -= flashOperationInfo.blockWriteUnitSize;
   \       0x68   0x1A24             SUBS     R4,R4,R0
   1025                  }
   \                     ??FLASH_Program_1: (+1)
   \       0x6A   0xB15C             CBZ.N    R4,??FLASH_Program_5
   \       0x6C   0xF859 0x0B04      LDR      R0,[R9], #+4
   \       0x70   0x6078             STR      R0,[R7, #+4]
   \       0x72   0x9803             LDR      R0,[SP, #+12]
   \       0x74   0x2804             CMP      R0,#+4
   \       0x76   0xD1E3             BNE.N    ??FLASH_Program_2
   \       0x78   0xF028 0x407F      BIC      R0,R8,#0xFF000000
   \       0x7C   0xF040 0x60C0      ORR      R0,R0,#0x6000000
   \       0x80   0x6038             STR      R0,[R7, #+0]
   \       0x82   0xE7E7             B.N      ??FLASH_Program_3
   1026              }
   \                     ??FLASH_Program_5: (+1)
   \       0x84   0x4630             MOV      R0,R6
   1027          
   1028              flash_cache_clear(config);
   \       0x86   0x2101             MOVS     R1,#+1
   \       0x88   0x.... 0x....      BL       flash_cache_clear_process
   1029          
   1030              return (returnCode);
   \       0x8C   0x4628             MOV      R0,R5
   \                     ??FLASH_Program_0: (+1)
   \       0x8E   0xB008             ADD      SP,SP,#+32
   \       0x90   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1031          }
   1032          

   \                                 In section .text, align 2, keep-with-next
   1033          status_t FLASH_ProgramOnce(flash_config_t *config, uint32_t index, uint32_t *src, uint32_t lengthInBytes)
   1034          {
   \                     FLASH_ProgramOnce: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1035              status_t returnCode;
   1036          
   1037              if ((config == NULL) || (src == NULL))
   \        0x4   0xBF18             IT       NE 
   \        0x6   0x2A00             CMPNE    R2,#+0
   \        0x8   0xD101             BNE.N    ??FLASH_ProgramOnce_0
   1038              {
   1039                  return kStatus_FLASH_InvalidArgument;
   \        0xA   0x2004             MOVS     R0,#+4
   \        0xC   0xBD32             POP      {R1,R4,R5,PC}
   1040              }
   1041          
   1042              /* pass paramters to FTFx */
   1043              kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_1_2(FTFx_PROGRAM_ONCE, index, 0xFFFFU);
   \                     ??FLASH_ProgramOnce_0: (+1)
   \        0xE   0x0409             LSLS     R1,R1,#+16
   \       0x10   0x.... 0x....      LDR.W    R3,??DataTable31_3  ;; 0x40020004
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable31_5  ;; 0x4300ffff
   \       0x18   0xF401 0x017F      AND      R1,R1,#0xFF0000
   \       0x1C   0x4301             ORRS     R1,R0,R1
   \       0x1E   0x6019             STR      R1,[R3, #+0]
   1044          
   1045              kFCCOBx[1] = *src;
   1046          
   1047          /* Note: Have to seperate the first index from the rest if it equals 0
   1048           * to avoid a pointless comparison of unsigned int to 0 compiler warning */
   1049          #if FLASH_PROGRAM_ONCE_IS_8BYTES_UNIT_SUPPORT
   1050          #if FLASH_PROGRAM_ONCE_IS_4BYTES_UNIT_SUPPORT
   1051              if (((index == FLASH_PROGRAM_ONCE_MIN_ID_8BYTES) ||
   1052                   /* Range check */
   1053                   ((index >= FLASH_PROGRAM_ONCE_MIN_ID_8BYTES + 1) && (index <= FLASH_PROGRAM_ONCE_MAX_ID_8BYTES))) &&
   1054                  (lengthInBytes == 8))
   1055          #endif /* FLASH_PROGRAM_ONCE_IS_4BYTES_UNIT_SUPPORT */
   1056              {
   1057                  kFCCOBx[2] = *(src + 1);
   1058              }
   1059          #endif /* FLASH_PROGRAM_ONCE_IS_8BYTES_UNIT_SUPPORT */
   1060          
   1061              flash_cache_clear_process(config, kFLASH_CacheClearProcessPre);
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0x6812             LDR      R2,[R2, #+0]
   \       0x24   0x605A             STR      R2,[R3, #+4]
   \       0x26   0x....             B.N      ??Subroutine0_0
   1062          
   1063              /* calling flash command sequence function to execute the command */
   1064              returnCode = flash_command_sequence(config);
   1065          
   1066              flash_cache_clear(config);
   1067          
   1068              return returnCode;
   1069          }
   1070          
   1071          #if defined(FSL_FEATURE_FLASH_HAS_PROGRAM_SECTION_CMD) && FSL_FEATURE_FLASH_HAS_PROGRAM_SECTION_CMD

   \                                 In section .text, align 2, keep-with-next
   1072          status_t FLASH_ProgramSection(flash_config_t *config, uint32_t start, uint32_t *src, uint32_t lengthInBytes)
   1073          {
   \                     FLASH_ProgramSection: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0xEA5F 0x0A02      MOVS     R10,R2
   \        0xA   0xB08A             SUB      SP,SP,#+40
   \        0xC   0x460E             MOV      R6,R1
   1074              status_t returnCode;
   1075              uint32_t sectorSize;
   1076              flash_operation_config_t flashOperationInfo;
   1077          #if defined(FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD) && FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD
   1078              bool needSwitchFlexRamMode = false;
   1079          #endif /* FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD */
   1080          
   1081              if (src == NULL)
   \        0xE   0xBF08             IT       EQ 
   \       0x10   0x2004             MOVEQ    R0,#+4
   1082              {
   1083                  return kStatus_FLASH_InvalidArgument;
   \       0x12   0xF000 0x8083      BEQ.W    ??FLASH_ProgramSection_0
   \       0x16   0x461D             MOV      R5,R3
   1084              }
   1085          
   1086              flash_get_matched_operation_info(config, start, &flashOperationInfo);
   \       0x18   0xAA02             ADD      R2,SP,#+8
   \       0x1A   0x.... 0x....      BL       flash_get_matched_operation_info
   1087          
   1088              /* Check the supplied address range. */
   1089              returnCode = flash_check_range(config, start, lengthInBytes, flashOperationInfo.sectionCmdAddressAligment);
   \       0x1E   0x9B07             LDR      R3,[SP, #+28]
   \       0x20   0x462A             MOV      R2,R5
   \       0x22   0x4631             MOV      R1,R6
   \       0x24   0x4640             MOV      R0,R8
   \       0x26   0x.... 0x....      BL       flash_check_range
   \       0x2A   0x0007             MOVS     R7,R0
   1090              if (returnCode)
   \       0x2C   0xD176             BNE.N    ??FLASH_ProgramSection_0
   1091              {
   1092                  return returnCode;
   1093              }
   1094          
   1095              start = flashOperationInfo.convertedAddress;
   \       0x2E   0x9C02             LDR      R4,[SP, #+8]
   1096              sectorSize = flashOperationInfo.activeSectorSize;
   \       0x30   0x9E03             LDR      R6,[SP, #+12]
   1097          
   1098          #if defined(FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD) && FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD
   1099              /* Switch function of FlexRAM if needed */
   1100              if (!(FTFx->FCNFG & FTFx_FCNFG_RAMRDY_MASK))
   1101              {
   1102                  needSwitchFlexRamMode = true;
   1103          
   1104                  returnCode = FLASH_SetFlexramFunction(config, kFLASH_FlexramFunctionOptionAvailableAsRam);
   1105                  if (returnCode != kStatus_FLASH_Success)
   1106                  {
   1107                      return kStatus_FLASH_SetFlexramAsRamError;
   1108                  }
   1109              }
   1110          #endif /* FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD */
   1111          
   1112              flash_cache_clear_process(config, kFLASH_CacheClearProcessPre);
   \       0x32   0x2100             MOVS     R1,#+0
   \       0x34   0x4640             MOV      R0,R8
   \       0x36   0x.... 0x....      BL       flash_cache_clear_process
   \       0x3A   0x4271             RSBS     R1,R6,#+0
   \       0x3C   0x46D1             MOV      R9,R10
   \       0x3E   0x9100             STR      R1,[SP, #+0]
   \       0x40   0x46AA             MOV      R10,R5
   \       0x42   0x9601             STR      R6,[SP, #+4]
   \       0x44   0xE00F             B.N      ??FLASH_ProgramSection_1
   1113          
   1114              while (lengthInBytes > 0)
   1115              {
   1116                  /* Make sure the write operation doesn't span two sectors */
   1117                  uint32_t endAddressOfCurrentSector = ALIGN_UP(start, sectorSize);
   1118                  uint32_t lengthTobeProgrammedOfCurrentSector;
   1119                  uint32_t currentOffset = 0;
   1120          
   1121                  if (endAddressOfCurrentSector == start)
   1122                  {
   1123                      endAddressOfCurrentSector += sectorSize;
   1124                  }
   1125          
   1126                  if (lengthInBytes + start > endAddressOfCurrentSector)
   1127                  {
   1128                      lengthTobeProgrammedOfCurrentSector = endAddressOfCurrentSector - start;
   1129                  }
   1130                  else
   1131                  {
   1132                      lengthTobeProgrammedOfCurrentSector = lengthInBytes;
   1133                  }
   1134          
   1135                  /* Program Current Sector */
   1136                  while (lengthTobeProgrammedOfCurrentSector > 0)
   1137                  {
   1138                      /* Make sure the program size doesn't exceeds Acceleration RAM size */
   1139                      uint32_t programSizeOfCurrentPass;
   1140                      uint32_t numberOfPhases;
   1141          
   1142                      if (lengthTobeProgrammedOfCurrentSector > kFLASH_AccelerationRamSize)
   1143                      {
   1144                          programSizeOfCurrentPass = kFLASH_AccelerationRamSize;
   1145                      }
   1146                      else
   1147                      {
   1148                          programSizeOfCurrentPass = lengthTobeProgrammedOfCurrentSector;
   1149                      }
   1150          
   1151                      /* Copy data to FlexRAM */
   1152                      memcpy((void *)FSL_FEATURE_FLASH_FLEX_RAM_START_ADDRESS, src + currentOffset / 4, programSizeOfCurrentPass);
   1153                      /* Set start address of the data to be programmed */
   1154                      kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_PROGRAM_SECTION, start + currentOffset);
   1155                      /* Set program size in terms of FEATURE_FLASH_SECTION_CMD_ADDRESS_ALIGMENT */
   1156                      numberOfPhases = programSizeOfCurrentPass / flashOperationInfo.sectionCmdAddressAligment;
   1157          
   1158                      kFCCOBx[1] = BYTES_JOIN_TO_WORD_2_2(numberOfPhases, 0xFFFFU);
   1159          
   1160                      /* Peform command sequence */
   1161                      returnCode = flash_command_sequence(config);
   1162          
   1163                      /* calling flash callback function if it is available */
   1164                      if (config->PFlashCallback)
   \                     ??FLASH_ProgramSection_2: (+1)
   \       0x46   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \       0x4A   0xB100             CBZ.N    R0,??FLASH_ProgramSection_3
   1165                      {
   1166                          config->PFlashCallback();
   \       0x4C   0x4780             BLX      R0
   1167                      }
   1168          
   1169                      if (returnCode != kStatus_FLASH_Success)
   \                     ??FLASH_ProgramSection_3: (+1)
   \       0x4E   0x2F00             CMP      R7,#+0
   \       0x50   0xD15F             BNE.N    ??FLASH_ProgramSection_4
   1170                      {
   1171                          flash_cache_clear(config);
   1172                          return returnCode;
   1173                      }
   1174          
   1175                      lengthTobeProgrammedOfCurrentSector -= programSizeOfCurrentPass;
   \       0x52   0xEBA6 0x060B      SUB      R6,R6,R11
   1176                      currentOffset += programSizeOfCurrentPass;
   \       0x56   0x445D             ADD      R5,R11,R5
   \                     ??FLASH_ProgramSection_5: (+1)
   \       0x58   0xB9C6             CBNZ.N   R6,??FLASH_ProgramSection_6
   1177                  }
   1178          
   1179                  src += currentOffset / 4;
   \       0x5A   0x08A8             LSRS     R0,R5,#+2
   \       0x5C   0xEB09 0x0980      ADD      R9,R9,R0, LSL #+2
   1180                  start += currentOffset;
   \       0x60   0x192C             ADDS     R4,R5,R4
   1181                  lengthInBytes -= currentOffset;
   \       0x62   0xEBAA 0x0A05      SUB      R10,R10,R5
   \                     ??FLASH_ProgramSection_1: (+1)
   \       0x66   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x6A   0xD052             BEQ.N    ??FLASH_ProgramSection_4
   \       0x6C   0x9800             LDR      R0,[SP, #+0]
   \       0x6E   0x4266             RSBS     R6,R4,#+0
   \       0x70   0x4006             ANDS     R6,R0,R6
   \       0x72   0x4276             RSBS     R6,R6,#+0
   \       0x74   0x2500             MOVS     R5,#+0
   \       0x76   0x42A6             CMP      R6,R4
   \       0x78   0xBF04             ITT      EQ 
   \       0x7A   0x9801             LDREQ    R0,[SP, #+4]
   \       0x7C   0x1986             ADDEQ    R6,R0,R6
   \       0x7E   0xEB04 0x000A      ADD      R0,R4,R10
   \       0x82   0x4286             CMP      R6,R0
   \       0x84   0xBF38             IT       CC 
   \       0x86   0x1B36             SUBCC    R6,R6,R4
   \       0x88   0xD3E6             BCC.N    ??FLASH_ProgramSection_5
   \       0x8A   0x4656             MOV      R6,R10
   \                     ??FLASH_ProgramSection_6: (+1)
   \       0x8C   0xF5B6 0x6F80      CMP      R6,#+1024
   \       0x90   0xBF8C             ITE      HI 
   \       0x92   0xF44F 0x6B80      MOVHI    R11,#+1024
   \       0x96   0x46B3             MOVLS    R11,R6
   \       0x98   0x08A8             LSRS     R0,R5,#+2
   \       0x9A   0xEB09 0x0180      ADD      R1,R9,R0, LSL #+2
   \       0x9E   0x465A             MOV      R2,R11
   \       0xA0   0xF04F 0x50A0      MOV      R0,#+335544320
   \       0xA4   0x.... 0x....      BL       __aeabi_memcpy
   \       0xA8   0x1928             ADDS     R0,R5,R4
   \       0xAA   0xF020 0x407F      BIC      R0,R0,#0xFF000000
   \       0xAE   0x.... 0x....      LDR.W    R1,??DataTable31_6  ;; 0x40020000
   \       0xB2   0x.... 0x....      LDR.W    R2,??DataTable31_6  ;; 0x40020000
   \       0xB6   0xF040 0x6030      ORR      R0,R0,#0xB000000
   \       0xBA   0x6048             STR      R0,[R1, #+4]
   \       0xBC   0xF64F 0x71FF      MOVW     R1,#+65535
   \       0xC0   0x9807             LDR      R0,[SP, #+28]
   \       0xC2   0xFBBB 0xF0F0      UDIV     R0,R11,R0
   \       0xC6   0xEA41 0x4100      ORR      R1,R1,R0, LSL #+16
   \       0xCA   0x6091             STR      R1,[R2, #+8]
   \       0xCC   0x2070             MOVS     R0,#+112
   \       0xCE   0xF1B8 0x0F00      CMP      R8,#+0
   \       0xD2   0x7010             STRB     R0,[R2, #+0]
   \       0xD4   0xBF08             IT       EQ 
   \       0xD6   0x2704             MOVEQ    R7,#+4
   \       0xD8   0xD0B5             BEQ.N    ??FLASH_ProgramSection_2
   \       0xDA   0xF8D8 0x001C      LDR      R0,[R8, #+28]
   \       0xDE   0xB178             CBZ.N    R0,??FLASH_ProgramSection_7
   \       0xE0   0x6800             LDR      R0,[R0, #+0]
   \       0xE2   0x2802             CMP      R0,#+2
   \       0xE4   0xD10C             BNE.N    ??FLASH_ProgramSection_7
   \       0xE6   0x.... 0x....      LDR.W    R1,??DataTable31_2
   \       0xEA   0x4617             MOV      R7,R2
   \       0xEC   0x680A             LDR      R2,[R1, #+0]
   \       0xEE   0x4638             MOV      R0,R7
   \       0xF0   0x4790             BLX      R2
   \       0xF2   0x7838             LDRB     R0,[R7, #+0]
   \       0xF4   0x0681             LSLS     R1,R0,#+26
   \       0xF6   0xD405             BMI.N    ??FLASH_ProgramSection_8
   \       0xF8   0x06C2             LSLS     R2,R0,#+27
   \       0xFA   0xD505             BPL.N    ??FLASH_ProgramSection_9
   \       0xFC   0x2768             MOVS     R7,#+104
   \       0xFE   0xE7A2             B.N      ??FLASH_ProgramSection_2
   \                     ??FLASH_ProgramSection_7: (+1)
   \      0x100   0x276D             MOVS     R7,#+109
   \      0x102   0xE7A0             B.N      ??FLASH_ProgramSection_2
   \                     ??FLASH_ProgramSection_8: (+1)
   \      0x104   0x2767             MOVS     R7,#+103
   \      0x106   0xE79E             B.N      ??FLASH_ProgramSection_2
   \                     ??FLASH_ProgramSection_9: (+1)
   \      0x108   0x07C0             LSLS     R0,R0,#+31
   \      0x10A   0xBF4C             ITE      MI 
   \      0x10C   0x2769             MOVMI    R7,#+105
   \      0x10E   0x2700             MOVPL    R7,#+0
   \      0x110   0xE799             B.N      ??FLASH_ProgramSection_2
   1182              }
   \                     ??FLASH_ProgramSection_4: (+1)
   \      0x112   0x4640             MOV      R0,R8
   1183          
   1184              flash_cache_clear(config);
   \      0x114   0x2101             MOVS     R1,#+1
   \      0x116   0x.... 0x....      BL       flash_cache_clear_process
   1185          
   1186          #if defined(FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD) && FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD
   1187              /* Restore function of FlexRAM if needed. */
   1188              if (needSwitchFlexRamMode)
   1189              {
   1190                  returnCode = FLASH_SetFlexramFunction(config, kFLASH_FlexramFunctionOptionAvailableForEeprom);
   1191                  if (returnCode != kStatus_FLASH_Success)
   1192                  {
   1193                      return kStatus_FLASH_RecoverFlexramAsEepromError;
   1194                  }
   1195              }
   1196          #endif /* FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD */
   1197          
   1198              return returnCode;
   \      0x11A   0x4638             MOV      R0,R7
   \                     ??FLASH_ProgramSection_0: (+1)
   \      0x11C   0xB00B             ADD      SP,SP,#+44
   \      0x11E   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1199          }
   1200          #endif /* FSL_FEATURE_FLASH_HAS_PROGRAM_SECTION_CMD */
   1201          
   1202          #if FLASH_SSD_IS_FLEXNVM_ENABLED
   1203          status_t FLASH_EepromWrite(flash_config_t *config, uint32_t start, uint8_t *src, uint32_t lengthInBytes)
   1204          {
   1205              status_t returnCode;
   1206              bool needSwitchFlexRamMode = false;
   1207          
   1208              if (config == NULL)
   1209              {
   1210                  return kStatus_FLASH_InvalidArgument;
   1211              }
   1212          
   1213              /* Validates the range of the given address */
   1214              if ((start < config->FlexRAMBlockBase) ||
   1215                  ((start + lengthInBytes) > (config->FlexRAMBlockBase + config->EEpromTotalSize)))
   1216              {
   1217                  return kStatus_FLASH_AddressError;
   1218              }
   1219          
   1220              returnCode = kStatus_FLASH_Success;
   1221          
   1222              /* Switch function of FlexRAM if needed */
   1223              if (!(FTFx->FCNFG & FTFx_FCNFG_EEERDY_MASK))
   1224              {
   1225                  needSwitchFlexRamMode = true;
   1226          
   1227                  returnCode = FLASH_SetFlexramFunction(config, kFLASH_FlexramFunctionOptionAvailableForEeprom);
   1228                  if (returnCode != kStatus_FLASH_Success)
   1229                  {
   1230                      return kStatus_FLASH_SetFlexramAsEepromError;
   1231                  }
   1232              }
   1233          
   1234              /* Write data to FlexRAM when it is used as EEPROM emulator */
   1235              while (lengthInBytes > 0)
   1236              {
   1237                  if ((!(start & 0x3U)) && (lengthInBytes >= 4))
   1238                  {
   1239                      *(uint32_t *)start = *(uint32_t *)src;
   1240                      start += 4;
   1241                      src += 4;
   1242                      lengthInBytes -= 4;
   1243                  }
   1244                  else if ((!(start & 0x1U)) && (lengthInBytes >= 2))
   1245                  {
   1246                      *(uint16_t *)start = *(uint16_t *)src;
   1247                      start += 2;
   1248                      src += 2;
   1249                      lengthInBytes -= 2;
   1250                  }
   1251                  else
   1252                  {
   1253                      *(uint8_t *)start = *src;
   1254                      start += 1;
   1255                      src += 1;
   1256                      lengthInBytes -= 1;
   1257                  }
   1258                  /* Wait till EEERDY bit is set */
   1259                  while (!(FTFx->FCNFG & FTFx_FCNFG_EEERDY_MASK))
   1260                  {
   1261                  }
   1262          
   1263                  /* Check for protection violation error */
   1264                  if (FTFx->FSTAT & FTFx_FSTAT_FPVIOL_MASK)
   1265                  {
   1266                      return kStatus_FLASH_ProtectionViolation;
   1267                  }
   1268              }
   1269          
   1270              /* Switch function of FlexRAM if needed */
   1271              if (needSwitchFlexRamMode)
   1272              {
   1273                  returnCode = FLASH_SetFlexramFunction(config, kFLASH_FlexramFunctionOptionAvailableAsRam);
   1274                  if (returnCode != kStatus_FLASH_Success)
   1275                  {
   1276                      return kStatus_FLASH_RecoverFlexramAsRamError;
   1277                  }
   1278              }
   1279          
   1280              return returnCode;
   1281          }
   1282          #endif /* FLASH_SSD_IS_FLEXNVM_ENABLED */
   1283          
   1284          #if defined(FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD) && FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD

   \                                 In section .text, align 2, keep-with-next
   1285          status_t FLASH_ReadResource(
   1286              flash_config_t *config, uint32_t start, uint32_t *dst, uint32_t lengthInBytes, flash_read_resource_option_t option)
   1287          {
   \                     FLASH_ReadResource: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0xEA5F 0x0900      MOVS     R9,R0
   1288              status_t returnCode;
   1289              flash_operation_config_t flashOperationInfo;
   1290          
   1291              if ((config == NULL) || (dst == NULL))
   \        0x8   0xBF14             ITE      NE 
   \        0xA   0xEA5F 0x0802      MOVSNE   R8,R2
   \        0xE   0x2004             MOVEQ    R0,#+4
   \       0x10   0xB088             SUB      SP,SP,#+32
   \       0x12   0x460E             MOV      R6,R1
   \       0x14   0x461C             MOV      R4,R3
   1292              {
   1293                  return kStatus_FLASH_InvalidArgument;
   \       0x16   0xD02C             BEQ.N    ??FLASH_ReadResource_0
   1294              }
   1295          
   1296              flash_get_matched_operation_info(config, start, &flashOperationInfo);
   \       0x18   0x466A             MOV      R2,SP
   \       0x1A   0x.... 0x....      BL       flash_get_matched_operation_info
   1297          
   1298              /* Check the supplied address range. */
   1299              returnCode =
   1300                  flash_check_resource_range(start, lengthInBytes, flashOperationInfo.resourceCmdAddressAligment, option);
   \       0x1E   0x9806             LDR      R0,[SP, #+24]
   \       0x20   0x1E40             SUBS     R0,R0,#+1
   \       0x22   0x4206             TST      R6,R0
   \       0x24   0xBF08             IT       EQ 
   \       0x26   0x4204             TSTEQ    R4,R0
   \       0x28   0xD122             BNE.N    ??FLASH_ReadResource_1
   \       0x2A   0x9D10             LDR      R5,[SP, #+64]
   \       0x2C   0x19A1             ADDS     R1,R4,R6
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x1E49             SUBS     R1,R1,#+1
   \       0x32   0x2D01             CMP      R5,#+1
   \       0x34   0xD105             BNE.N    ??FLASH_ReadResource_2
   \       0x36   0x2E00             CMP      R6,#+0
   \       0x38   0xBF04             ITT      EQ 
   \       0x3A   0x1E61             SUBEQ    R1,R4,#+1
   \       0x3C   0x2907             CMPEQ    R1,#+7
   \       0x3E   0xD112             BNE.N    ??FLASH_ReadResource_3
   \       0x40   0xE012             B.N      ??FLASH_ReadResource_4
   \                     ??FLASH_ReadResource_2: (+1)
   \       0x42   0xB985             CBNZ.N   R5,??FLASH_ReadResource_3
   \       0x44   0xF5B1 0x7F80      CMP      R1,#+256
   \       0x48   0xD30E             BCC.N    ??FLASH_ReadResource_4
   \       0x4A   0xF5B6 0x3F00      CMP      R6,#+131072
   \       0x4E   0xD303             BCC.N    ??FLASH_ReadResource_5
   \       0x50   0x.... 0x....      LDR.W    R2,??DataTable31_7  ;; 0x20100
   \       0x54   0x4291             CMP      R1,R2
   \       0x56   0xD307             BCC.N    ??FLASH_ReadResource_4
   \                     ??FLASH_ReadResource_5: (+1)
   \       0x58   0xF5B6 0x0F00      CMP      R6,#+8388608
   \       0x5C   0xD303             BCC.N    ??FLASH_ReadResource_3
   \       0x5E   0x.... 0x....      LDR.W    R2,??DataTable31_8  ;; 0x800400
   \       0x62   0x4291             CMP      R1,R2
   \       0x64   0xD300             BCC.N    ??FLASH_ReadResource_4
   \                     ??FLASH_ReadResource_3: (+1)
   \       0x66   0x2004             MOVS     R0,#+4
   1301              if (returnCode != kStatus_FLASH_Success)
   \                     ??FLASH_ReadResource_4: (+1)
   \       0x68   0xB918             CBNZ.N   R0,??FLASH_ReadResource_0
   \       0x6A   0x.... 0x....      LDR.W    R7,??DataTable31_3  ;; 0x40020004
   \       0x6E   0xE018             B.N      ??FLASH_ReadResource_6
   \                     ??FLASH_ReadResource_1: (+1)
   \       0x70   0x2065             MOVS     R0,#+101
   1302              {
   1303                  return returnCode;
   1304              }
   1305          
   1306              while (lengthInBytes > 0)
   1307              {
   1308                  /* preparing passing parameter */
   1309                  kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_READ_RESOURCE, start);
   1310                  if (flashOperationInfo.resourceCmdAddressAligment == 4)
   1311                  {
   1312                      kFCCOBx[2] = BYTES_JOIN_TO_WORD_1_3(option, 0xFFFFFFU);
   1313                  }
   1314                  else if (flashOperationInfo.resourceCmdAddressAligment == 8)
   1315                  {
   1316                      kFCCOBx[1] = BYTES_JOIN_TO_WORD_1_3(option, 0xFFFFFFU);
   1317                  }
   1318                  else
   1319                  {
   1320                  }
   1321          
   1322                  /* calling flash command sequence function to execute the command */
   1323                  returnCode = flash_command_sequence(config);
   1324          
   1325                  if (kStatus_FLASH_Success != returnCode)
   1326                  {
   1327                      break;
   1328                  }
   1329          
   1330                  /* fetch data */
   1331                  *dst++ = kFCCOBx[1];
   1332                  if (flashOperationInfo.resourceCmdAddressAligment == 8)
   1333                  {
   1334                      *dst++ = kFCCOBx[2];
   1335                  }
   1336                  /* update start address for next iteration */
   1337                  start += flashOperationInfo.resourceCmdAddressAligment;
   1338                  /* update lengthInBytes for next iteration */
   1339                  lengthInBytes -= flashOperationInfo.resourceCmdAddressAligment;
   1340              }
   1341          
   1342              return (returnCode);
   \                     ??FLASH_ReadResource_0: (+1)
   \       0x72   0x....             B.N      ?Subroutine1
   \                     ??FLASH_ReadResource_7: (+1)
   \       0x74   0x2808             CMP      R0,#+8
   \       0x76   0xD103             BNE.N    ??FLASH_ReadResource_8
   \       0x78   0x0628             LSLS     R0,R5,#+24
   \       0x7A   0xF060 0x407F      ORN      R0,R0,#-16777216
   \       0x7E   0x6078             STR      R0,[R7, #+4]
   \                     ??FLASH_ReadResource_8: (+1)
   \       0x80   0x4648             MOV      R0,R9
   \       0x82   0x.... 0x....      BL       flash_command_sequence
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xD1F3             BNE.N    ??FLASH_ReadResource_0
   \       0x8A   0x6879             LDR      R1,[R7, #+4]
   \       0x8C   0xF848 0x1B04      STR      R1,[R8], #+4
   \       0x90   0x9A06             LDR      R2,[SP, #+24]
   \       0x92   0x2A08             CMP      R2,#+8
   \       0x94   0xBF04             ITT      EQ 
   \       0x96   0x68B9             LDREQ    R1,[R7, #+8]
   \       0x98   0xF848 0x1B04      STREQ    R1,[R8], #+4
   \       0x9C   0x9906             LDR      R1,[SP, #+24]
   \       0x9E   0x198E             ADDS     R6,R1,R6
   \       0xA0   0x1A64             SUBS     R4,R4,R1
   \                     ??FLASH_ReadResource_6: (+1)
   \       0xA2   0x2C00             CMP      R4,#+0
   \       0xA4   0xD0E5             BEQ.N    ??FLASH_ReadResource_0
   \       0xA6   0xF026 0x407F      BIC      R0,R6,#0xFF000000
   \       0xAA   0xF040 0x7040      ORR      R0,R0,#0x3000000
   \       0xAE   0x6038             STR      R0,[R7, #+0]
   \       0xB0   0x9806             LDR      R0,[SP, #+24]
   \       0xB2   0x2804             CMP      R0,#+4
   \       0xB4   0xD1DE             BNE.N    ??FLASH_ReadResource_7
   \       0xB6   0x0628             LSLS     R0,R5,#+24
   \       0xB8   0xF060 0x407F      ORN      R0,R0,#-16777216
   \       0xBC   0x60B8             STR      R0,[R7, #+8]
   \       0xBE   0xE7DF             B.N      ??FLASH_ReadResource_8
   1343          }
   1344          #endif /* FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD */
   1345          

   \                                 In section .text, align 2, keep-with-next
   1346          status_t FLASH_ReadOnce(flash_config_t *config, uint32_t index, uint32_t *dst, uint32_t lengthInBytes)
   1347          {
   \                     FLASH_ReadOnce: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4614             MOV      R4,R2
   1348              status_t returnCode;
   1349          
   1350              if ((config == NULL) || (dst == NULL))
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xBF18             IT       NE 
   \        0x8   0x2C00             CMPNE    R4,#+0
   \        0xA   0xD101             BNE.N    ??FLASH_ReadOnce_0
   1351              {
   1352                  return kStatus_FLASH_InvalidArgument;
   \        0xC   0x2004             MOVS     R0,#+4
   \        0xE   0xBD32             POP      {R1,R4,R5,PC}
   1353              }
   1354          
   1355              /* pass paramters to FTFx */
   1356              kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_1_2(FTFx_READ_ONCE, index, 0xFFFFU);
   \                     ??FLASH_ReadOnce_0: (+1)
   \       0x10   0x0409             LSLS     R1,R1,#+16
   \       0x12   0x.... 0x....      LDR.W    R5,??DataTable31_3  ;; 0x40020004
   \       0x16   0x.... 0x....      LDR.W    R2,??DataTable31_9  ;; 0x4100ffff
   \       0x1A   0xF401 0x017F      AND      R1,R1,#0xFF0000
   \       0x1E   0x4311             ORRS     R1,R2,R1
   \       0x20   0x6029             STR      R1,[R5, #+0]
   1357          
   1358              /* calling flash command sequence function to execute the command */
   1359              returnCode = flash_command_sequence(config);
   \       0x22   0x.... 0x....      BL       flash_command_sequence
   1360          
   1361              if (kStatus_FLASH_Success == returnCode)
   \       0x26   0xB908             CBNZ.N   R0,??FLASH_ReadOnce_1
   1362              {
   1363                  *dst = kFCCOBx[1];
   \       0x28   0x6869             LDR      R1,[R5, #+4]
   \       0x2A   0x6021             STR      R1,[R4, #+0]
   1364          /* Note: Have to seperate the first index from the rest if it equals 0
   1365           *       to avoid a pointless comparison of unsigned int to 0 compiler warning */
   1366          #if FLASH_PROGRAM_ONCE_IS_8BYTES_UNIT_SUPPORT
   1367          #if FLASH_PROGRAM_ONCE_IS_4BYTES_UNIT_SUPPORT
   1368                  if (((index == FLASH_PROGRAM_ONCE_MIN_ID_8BYTES) ||
   1369                       /* Range check */
   1370                       ((index >= FLASH_PROGRAM_ONCE_MIN_ID_8BYTES + 1) && (index <= FLASH_PROGRAM_ONCE_MAX_ID_8BYTES))) &&
   1371                      (lengthInBytes == 8))
   1372          #endif /* FLASH_PROGRAM_ONCE_IS_4BYTES_UNIT_SUPPORT */
   1373                  {
   1374                      *(dst + 1) = kFCCOBx[2];
   1375                  }
   1376          #endif /* FLASH_PROGRAM_ONCE_IS_8BYTES_UNIT_SUPPORT */
   1377              }
   1378          
   1379              return returnCode;
   \                     ??FLASH_ReadOnce_1: (+1)
   \       0x2C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1380          }
   1381          

   \                                 In section .text, align 2, keep-with-next
   1382          status_t FLASH_GetSecurityState(flash_config_t *config, flash_security_state_t *state)
   1383          {
   1384              /* store data read from flash register */
   1385              uint8_t registerValue;
   1386          
   1387              if ((config == NULL) || (state == NULL))
   \                     FLASH_GetSecurityState: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xBF18             IT       NE 
   \        0x4   0x2900             CMPNE    R1,#+0
   \        0x6   0xD101             BNE.N    ??FLASH_GetSecurityState_0
   1388              {
   1389                  return kStatus_FLASH_InvalidArgument;
   \        0x8   0x2004             MOVS     R0,#+4
   \        0xA   0x4770             BX       LR
   1390              }
   1391          
   1392              /* Get flash security register value */
   1393              registerValue = FTFx->FSEC;
   \                     ??FLASH_GetSecurityState_0: (+1)
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable31_10  ;; 0x40020002
   \       0x10   0x7800             LDRB     R0,[R0, #+0]
   1394          
   1395              /* check the status of the flash security bits in the security register */
   1396              if (FLASH_SECURITY_STATE_UNSECURED == (registerValue & FTFx_FSEC_SEC_MASK))
   \       0x12   0xF000 0x0203      AND      R2,R0,#0x3
   \       0x16   0x2A02             CMP      R2,#+2
   \       0x18   0xBF08             IT       EQ 
   \       0x1A   0x2000             MOVEQ    R0,#+0
   1397              {
   1398                  /* Flash in unsecured state */
   1399                  *state = kFLASH_SecurityStateNotSecure;
   \       0x1C   0xD005             BEQ.N    ??FLASH_GetSecurityState_1
   1400              }
   1401              else
   1402              {
   1403                  /* Flash in secured state
   1404                   * check for backdoor key security enable bit */
   1405                  if (FLASH_SECURITY_STATE_KEYEN == (registerValue & FTFx_FSEC_KEYEN_MASK))
   \       0x1E   0xF000 0x00C0      AND      R0,R0,#0xC0
   \       0x22   0x2880             CMP      R0,#+128
   \       0x24   0xBF0C             ITE      EQ 
   \       0x26   0x2001             MOVEQ    R0,#+1
   \       0x28   0x2002             MOVNE    R0,#+2
   1406                  {
   1407                      /* Backdoor key security enabled */
   1408                      *state = kFLASH_SecurityStateBackdoorEnabled;
   1409                  }
   1410                  else
   1411                  {
   1412                      /* Backdoor key security disabled */
   1413                      *state = kFLASH_SecurityStateBackdoorDisabled;
   \                     ??FLASH_GetSecurityState_1: (+1)
   \       0x2A   0x7008             STRB     R0,[R1, #+0]
   1414                  }
   1415              }
   1416          
   1417              return (kStatus_FLASH_Success);
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x4770             BX       LR               ;; return
   1418          }
   1419          

   \                                 In section .text, align 2, keep-with-next
   1420          status_t FLASH_SecurityBypass(flash_config_t *config, const uint8_t *backdoorKey)
   1421          {
   \                     FLASH_SecurityBypass: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   1422              uint8_t registerValue; /* registerValue */
   1423              status_t returnCode;   /* return code variable */
   1424          
   1425              if ((config == NULL) || (backdoorKey == NULL))
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xBF18             IT       NE 
   \        0x6   0x2900             CMPNE    R1,#+0
   \        0x8   0xD101             BNE.N    ??FLASH_SecurityBypass_0
   1426              {
   1427                  return kStatus_FLASH_InvalidArgument;
   \        0xA   0x2004             MOVS     R0,#+4
   \        0xC   0xBD32             POP      {R1,R4,R5,PC}
   1428              }
   1429          
   1430              /* set the default return code as kStatus_Success */
   1431              returnCode = kStatus_FLASH_Success;
   1432          
   1433              /* Get flash security register value */
   1434              registerValue = FTFx->FSEC;
   \                     ??FLASH_SecurityBypass_0: (+1)
   \        0xE   0x.... 0x....      LDR.W    R3,??DataTable31_10  ;; 0x40020002
   \       0x12   0x781C             LDRB     R4,[R3, #+0]
   \       0x14   0x2200             MOVS     R2,#+0
   1435          
   1436              /* Check to see if flash is in secure state (any state other than 0x2)
   1437               * If not, then skip this since flash is not secure */
   1438              if (0x02 != (registerValue & 0x03))
   \       0x16   0xF004 0x0403      AND      R4,R4,#0x3
   \       0x1A   0x2C02             CMP      R4,#+2
   \       0x1C   0xD01E             BEQ.N    ??FLASH_SecurityBypass_1
   1439              {
   1440                  /* preparing passing parameter to erase a flash block */
   1441                  kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_SECURITY_BY_PASS, 0xFFFFFFU);
   \       0x1E   0xF06F 0x423A      MVN      R2,#-1174405120
   \       0x22   0xF8C3 0x2002      STR      R2,[R3, #+2]
   1442                  kFCCOBx[1] = BYTES_JOIN_TO_WORD_1_1_1_1(backdoorKey[0], backdoorKey[1], backdoorKey[2], backdoorKey[3]);
   \       0x26   0x784D             LDRB     R5,[R1, #+1]
   \       0x28   0x780C             LDRB     R4,[R1, #+0]
   \       0x2A   0x78CA             LDRB     R2,[R1, #+3]
   \       0x2C   0x042D             LSLS     R5,R5,#+16
   \       0x2E   0xEA45 0x6504      ORR      R5,R5,R4, LSL #+24
   \       0x32   0x788C             LDRB     R4,[R1, #+2]
   \       0x34   0xEA45 0x2504      ORR      R5,R5,R4, LSL #+8
   \       0x38   0x4315             ORRS     R5,R2,R5
   \       0x3A   0xF8C3 0x5006      STR      R5,[R3, #+6]
   1443                  kFCCOBx[2] = BYTES_JOIN_TO_WORD_1_1_1_1(backdoorKey[4], backdoorKey[5], backdoorKey[6], backdoorKey[7]);
   \       0x3E   0x794A             LDRB     R2,[R1, #+5]
   \       0x40   0x790C             LDRB     R4,[R1, #+4]
   \       0x42   0x0412             LSLS     R2,R2,#+16
   \       0x44   0xEA42 0x6204      ORR      R2,R2,R4, LSL #+24
   \       0x48   0x798C             LDRB     R4,[R1, #+6]
   \       0x4A   0x79C9             LDRB     R1,[R1, #+7]
   \       0x4C   0xEA42 0x2204      ORR      R2,R2,R4, LSL #+8
   \       0x50   0x430A             ORRS     R2,R1,R2
   \       0x52   0xF8C3 0x200A      STR      R2,[R3, #+10]
   1444          
   1445                  /* calling flash command sequence function to execute the command */
   1446                  returnCode = flash_command_sequence(config);
   \       0x56   0x.... 0x....      BL       flash_command_sequence
   \       0x5A   0x4602             MOV      R2,R0
   1447              }
   1448          
   1449              return (returnCode);
   \                     ??FLASH_SecurityBypass_1: (+1)
   \       0x5C   0x4610             MOV      R0,R2
   \       0x5E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1450          }
   1451          

   \                                 In section .text, align 2, keep-with-next
   1452          status_t FLASH_VerifyEraseAll(flash_config_t *config, flash_margin_value_t margin)
   1453          {
   1454              if (config == NULL)
   \                     FLASH_VerifyEraseAll: (+1)
   \        0x0   0xB908             CBNZ.N   R0,??FLASH_VerifyEraseAll_0
   1455              {
   1456                  return kStatus_FLASH_InvalidArgument;
   \        0x2   0x2004             MOVS     R0,#+4
   \        0x4   0x4770             BX       LR
   1457              }
   1458          
   1459              /* preparing passing parameter to verify all block command */
   1460              kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_1_2(FTFx_VERIFY_ALL_BLOCK, margin, 0xFFFFU);
   \                     ??FLASH_VerifyEraseAll_0: (+1)
   \        0x6   0x.... 0x....      LDR.W    R2,??DataTable31_11  ;; 0x4000ffff
   \        0xA   0x....             B.N      ?Subroutine4
   1461          
   1462              /* calling flash command sequence function to execute the command */
   1463              return flash_command_sequence(config);
   1464          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0xEA42 0x4201      ORR      R2,R2,R1, LSL #+16
   \        0x4   0x.... 0x....      LDR.W    R1,??DataTable31_3  ;; 0x40020004
   \        0x8   0x600A             STR      R2,[R1, #+0]
   \        0xA   0x....             B.N      flash_command_sequence
   1465          

   \                                 In section .text, align 2, keep-with-next
   1466          status_t FLASH_VerifyErase(flash_config_t *config, uint32_t start, uint32_t lengthInBytes, flash_margin_value_t margin)
   1467          {
   \                     FLASH_VerifyErase: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB088             SUB      SP,SP,#+32
   \        0x6   0x4690             MOV      R8,R2
   \        0x8   0x4681             MOV      R9,R0
   \        0xA   0x460C             MOV      R4,R1
   \        0xC   0x461D             MOV      R5,R3
   1468              /* Check arguments. */
   1469              uint32_t blockSize;
   1470              flash_operation_config_t flashOperationInfo;
   1471              uint32_t nextBlockStartAddress;
   1472              uint32_t remainingBytes;
   1473              status_t returnCode;
   1474          
   1475              flash_get_matched_operation_info(config, start, &flashOperationInfo);
   \        0xE   0x466A             MOV      R2,SP
   \       0x10   0x.... 0x....      BL       flash_get_matched_operation_info
   1476          
   1477              returnCode = flash_check_range(config, start, lengthInBytes, flashOperationInfo.sectionCmdAddressAligment);
   \       0x14   0x9B05             LDR      R3,[SP, #+20]
   \       0x16   0x4642             MOV      R2,R8
   \       0x18   0x4621             MOV      R1,R4
   \       0x1A   0x4648             MOV      R0,R9
   \       0x1C   0x.... 0x....      BL       flash_check_range
   1478              if (returnCode)
   \       0x20   0xBB90             CBNZ.N   R0,??FLASH_VerifyErase_0
   1479              {
   1480                  return returnCode;
   1481              }
   1482          
   1483              flash_get_matched_operation_info(config, start, &flashOperationInfo);
   \       0x22   0x466A             MOV      R2,SP
   \       0x24   0x4621             MOV      R1,R4
   \       0x26   0x4648             MOV      R0,R9
   \       0x28   0x.... 0x....      BL       flash_get_matched_operation_info
   1484              start = flashOperationInfo.convertedAddress;
   \       0x2C   0x9F00             LDR      R7,[SP, #+0]
   1485              blockSize = flashOperationInfo.activeBlockSize;
   \       0x2E   0x9C02             LDR      R4,[SP, #+8]
   1486          
   1487              nextBlockStartAddress = ALIGN_UP(start, blockSize);
   \       0x30   0x427E             RSBS     R6,R7,#+0
   \       0x32   0x4260             RSBS     R0,R4,#+0
   \       0x34   0x4006             ANDS     R6,R0,R6
   \       0x36   0x4276             RSBS     R6,R6,#+0
   1488              if (nextBlockStartAddress == start)
   \       0x38   0x42BE             CMP      R6,R7
   1489              {
   1490                  nextBlockStartAddress += blockSize;
   1491              }
   1492          
   1493              remainingBytes = lengthInBytes;
   \       0x3A   0xEA4F 0x2B05      LSL      R11,R5,#+8
   \       0x3E   0xBF08             IT       EQ 
   \       0x40   0x19A6             ADDEQ    R6,R4,R6
   \       0x42   0x.... 0x....      LDR.W    R5,??DataTable31_3  ;; 0x40020004
   \       0x46   0xE003             B.N      ??FLASH_VerifyErase_1
   1494          
   1495              while (remainingBytes)
   1496              {
   1497                  uint32_t numberOfPhrases;
   1498                  uint32_t verifyLength = nextBlockStartAddress - start;
   1499                  if (verifyLength > remainingBytes)
   1500                  {
   1501                      verifyLength = remainingBytes;
   1502                  }
   1503          
   1504                  numberOfPhrases = verifyLength / flashOperationInfo.sectionCmdAddressAligment;
   1505          
   1506                  /* Fill in verify section command parameters. */
   1507                  kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_VERIFY_SECTION, start);
   1508                  kFCCOBx[1] = BYTES_JOIN_TO_WORD_2_1_1(numberOfPhrases, margin, 0xFFU);
   1509          
   1510                  /* calling flash command sequence function to execute the command */
   1511                  returnCode = flash_command_sequence(config);
   1512                  if (returnCode)
   1513                  {
   1514                      return returnCode;
   1515                  }
   1516          
   1517                  remainingBytes -= verifyLength;
   \                     ??FLASH_VerifyErase_2: (+1)
   \       0x48   0xEBA8 0x080A      SUB      R8,R8,R10
   1518                  start += verifyLength;
   \       0x4C   0x4457             ADD      R7,R10,R7
   1519                  nextBlockStartAddress += blockSize;
   \       0x4E   0x19A6             ADDS     R6,R4,R6
   \                     ??FLASH_VerifyErase_1: (+1)
   \       0x50   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x54   0xD017             BEQ.N    ??FLASH_VerifyErase_3
   \       0x56   0x1BF0             SUBS     R0,R6,R7
   \       0x58   0x46C2             MOV      R10,R8
   \       0x5A   0x4580             CMP      R8,R0
   \       0x5C   0xBF88             IT       HI 
   \       0x5E   0x4682             MOVHI    R10,R0
   \       0x60   0x9805             LDR      R0,[SP, #+20]
   \       0x62   0xFBBA 0xF0F0      UDIV     R0,R10,R0
   \       0x66   0xF027 0x417F      BIC      R1,R7,#0xFF000000
   \       0x6A   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \       0x6E   0xEA4B 0x4200      ORR      R2,R11,R0, LSL #+16
   \       0x72   0x6029             STR      R1,[R5, #+0]
   \       0x74   0xF042 0x02FF      ORR      R2,R2,#0xFF
   \       0x78   0x606A             STR      R2,[R5, #+4]
   \       0x7A   0x4648             MOV      R0,R9
   \       0x7C   0x.... 0x....      BL       flash_command_sequence
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD0E1             BEQ.N    ??FLASH_VerifyErase_2
   \       0x84   0x....             B.N      ?Subroutine2
   1520              }
   1521          
   1522              return kStatus_FLASH_Success;
   \                     ??FLASH_VerifyErase_3: (+1)
   \       0x86   0x2000             MOVS     R0,#+0
   \                     ??FLASH_VerifyErase_0: (+1)
   \       0x88                      REQUIRE ?Subroutine2
   \       0x88                      ;; // Fall through to label ?Subroutine2
   1523          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0xB009             ADD      SP,SP,#+36
   \        0x2   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1524          

   \                                 In section .text, align 2, keep-with-next
   1525          status_t FLASH_VerifyProgram(flash_config_t *config,
   1526                                       uint32_t start,
   1527                                       uint32_t lengthInBytes,
   1528                                       const uint32_t *expectedData,
   1529                                       flash_margin_value_t margin,
   1530                                       uint32_t *failedAddress,
   1531                                       uint32_t *failedData)
   1532          {
   \                     FLASH_VerifyProgram: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x001F             MOVS     R7,R3
   \        0x8   0xB088             SUB      SP,SP,#+32
   \        0xA   0x460E             MOV      R6,R1
   1533              status_t returnCode;
   1534              flash_operation_config_t flashOperationInfo;
   1535          
   1536              if (expectedData == NULL)
   \        0xC   0xBF08             IT       EQ 
   \        0xE   0x2004             MOVEQ    R0,#+4
   1537              {
   1538                  return kStatus_FLASH_InvalidArgument;
   \       0x10   0xD02F             BEQ.N    ??FLASH_VerifyProgram_0
   \       0x12   0x4614             MOV      R4,R2
   1539              }
   1540          
   1541              flash_get_matched_operation_info(config, start, &flashOperationInfo);
   \       0x14   0x466A             MOV      R2,SP
   \       0x16   0x.... 0x....      BL       flash_get_matched_operation_info
   1542          
   1543              returnCode = flash_check_range(config, start, lengthInBytes, flashOperationInfo.checkCmdAddressAligment);
   \       0x1A   0x9B07             LDR      R3,[SP, #+28]
   \       0x1C   0x4622             MOV      R2,R4
   \       0x1E   0x4631             MOV      R1,R6
   \       0x20   0x4648             MOV      R0,R9
   \       0x22   0x.... 0x....      BL       flash_check_range
   1544              if (returnCode)
   \       0x26   0xBB20             CBNZ.N   R0,??FLASH_VerifyProgram_0
   \       0x28   0x9910             LDR      R1,[SP, #+64]
   1545              {
   1546                  return returnCode;
   1547              }
   1548          
   1549              start = flashOperationInfo.convertedAddress;
   \       0x2A   0x9E00             LDR      R6,[SP, #+0]
   \       0x2C   0x.... 0x....      LDR.W    R5,??DataTable31_3  ;; 0x40020004
   \       0x30   0x0609             LSLS     R1,R1,#+24
   \       0x32   0xF061 0x417F      ORN      R1,R1,#-16777216
   \       0x36   0x4688             MOV      R8,R1
   \       0x38   0xE005             B.N      ??FLASH_VerifyProgram_1
   1550          
   1551              while (lengthInBytes)
   1552              {
   1553                  /* preparing passing parameter to program check the flash block */
   1554                  kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_PROGRAM_CHECK, start);
   1555                  kFCCOBx[1] = BYTES_JOIN_TO_WORD_1_3(margin, 0xFFFFFFU);
   1556                  kFCCOBx[2] = *expectedData;
   1557          
   1558                  /* calling flash command sequence function to execute the command */
   1559                  returnCode = flash_command_sequence(config);
   1560          
   1561                  /* checking for the success of command execution */
   1562                  if (kStatus_FLASH_Success != returnCode)
   1563                  {
   1564                      if (failedAddress)
   1565                      {
   1566                          *failedAddress = start;
   1567                      }
   1568                      if (failedData)
   1569                      {
   1570                          *failedData = 0;
   1571                      }
   1572                      break;
   1573                  }
   1574          
   1575                  lengthInBytes -= flashOperationInfo.checkCmdAddressAligment;
   \                     ??FLASH_VerifyProgram_2: (+1)
   \       0x3A   0x9907             LDR      R1,[SP, #+28]
   1576                  expectedData += flashOperationInfo.checkCmdAddressAligment / sizeof(*expectedData);
   \       0x3C   0x088A             LSRS     R2,R1,#+2
   \       0x3E   0x1A64             SUBS     R4,R4,R1
   \       0x40   0xEB07 0x0782      ADD      R7,R7,R2, LSL #+2
   1577                  start += flashOperationInfo.checkCmdAddressAligment;
   \       0x44   0x198E             ADDS     R6,R1,R6
   \                     ??FLASH_VerifyProgram_1: (+1)
   \       0x46   0xB1A4             CBZ.N    R4,??FLASH_VerifyProgram_0
   \       0x48   0xF026 0x407F      BIC      R0,R6,#0xFF000000
   \       0x4C   0xF040 0x7000      ORR      R0,R0,#0x2000000
   \       0x50   0x6028             STR      R0,[R5, #+0]
   \       0x52   0xF8C5 0x8004      STR      R8,[R5, #+4]
   \       0x56   0x4648             MOV      R0,R9
   \       0x58   0x6839             LDR      R1,[R7, #+0]
   \       0x5A   0x60A9             STR      R1,[R5, #+8]
   \       0x5C   0x.... 0x....      BL       flash_command_sequence
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD0EA             BEQ.N    ??FLASH_VerifyProgram_2
   \       0x64   0x9911             LDR      R1,[SP, #+68]
   \       0x66   0xB101             CBZ.N    R1,??FLASH_VerifyProgram_3
   \       0x68   0x600E             STR      R6,[R1, #+0]
   \                     ??FLASH_VerifyProgram_3: (+1)
   \       0x6A   0x9912             LDR      R1,[SP, #+72]
   \       0x6C   0xB109             CBZ.N    R1,??FLASH_VerifyProgram_0
   \       0x6E   0x2200             MOVS     R2,#+0
   \       0x70   0x600A             STR      R2,[R1, #+0]
   1578              }
   1579          
   1580              return (returnCode);
   \                     ??FLASH_VerifyProgram_0: (+1)
   \       0x72   0x....             B.N      ?Subroutine1
   1581          }
   1582          

   \                                 In section .text, align 2, keep-with-next
   1583          status_t FLASH_VerifyEraseAllExecuteOnlySegments(flash_config_t *config, flash_margin_value_t margin)
   1584          {
   1585              if (config == NULL)
   \                     FLASH_VerifyEraseAllExecuteOnlySegments: (+1)
   \        0x0   0xB908             CBNZ.N   R0,??FLASH_VerifyEraseAllExecuteOnlySegments_0
   1586              {
   1587                  return kStatus_FLASH_InvalidArgument;
   \        0x2   0x2004             MOVS     R0,#+4
   \        0x4   0x4770             BX       LR
   1588              }
   1589          
   1590              /* preparing passing parameter to verify erase all execute-only segments command */
   1591              kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_1_2(FTFx_VERIFY_ALL_EXECUTE_ONLY_SEGMENT, margin, 0xFFFFU);
   \                     ??FLASH_VerifyEraseAllExecuteOnlySegments_0: (+1)
   \        0x6   0x.... 0x....      LDR.W    R2,??DataTable31_12  ;; 0x4a00ffff
   \        0xA                      REQUIRE ?Subroutine4
   \        0xA                      ;; // Fall through to label ?Subroutine4
   1592          
   1593              /* calling flash command sequence function to execute the command */
   1594              return flash_command_sequence(config);
   1595          }
   1596          

   \                                 In section .text, align 2, keep-with-next
   1597          status_t FLASH_IsProtected(flash_config_t *config,
   1598                                     uint32_t start,
   1599                                     uint32_t lengthInBytes,
   1600                                     flash_protection_state_t *protection_state)
   1601          {
   \                     FLASH_IsProtected: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x001D             MOVS     R5,R3
   \        0x6   0xB0AC             SUB      SP,SP,#+176
   \        0x8   0x4606             MOV      R6,R0
   \        0xA   0x4617             MOV      R7,R2
   1602              uint32_t endAddress;           /* end address for protection check */
   1603              uint32_t regionCheckedCounter; /* increments each time the flash address was checked for
   1604                                              * protection status */
   1605              uint32_t regionCounter;        /* incrementing variable used to increment through the flash
   1606                                              * protection regions */
   1607              uint32_t protectStatusCounter; /* increments each time a flash region was detected as protected */
   1608          
   1609              uint8_t flashRegionProtectStatus[FSL_FEATURE_FLASH_PFLASH_PROTECTION_REGION_COUNT]; /* array of the protection
   1610                                                                                * status for each
   1611                                                                                * protection region */
   1612              uint32_t flashRegionAddress[FSL_FEATURE_FLASH_PFLASH_PROTECTION_REGION_COUNT +
   1613                                          1];                /* array of the start addresses for each flash
   1614                                           * protection region. Note this is REGION_COUNT+1
   1615                                           * due to requiring the next start address after
   1616                                           * the end of flash for loop-check purposes below */
   1617              flash_protection_config_t flashProtectionInfo; /* flash protection information */
   1618              status_t returnCode;
   1619          
   1620              if (protection_state == NULL)
   \        0xC   0xD006             BEQ.N    ??FLASH_IsProtected_0
   \        0xE   0x460C             MOV      R4,R1
   1621              {
   1622                  return kStatus_FLASH_InvalidArgument;
   1623              }
   1624          
   1625              /* Check the supplied address range. */
   1626              returnCode = flash_check_range(config, start, lengthInBytes, FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE);
   \       0x10   0x2304             MOVS     R3,#+4
   \       0x12   0x.... 0x....      BL       flash_check_range
   1627              if (returnCode)
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD170             BNE.N    ??FLASH_IsProtected_1
   1628              {
   1629                  return returnCode;
   1630              }
   1631          
   1632              /* Get necessary flash protection information. */
   1633              returnCode = flash_get_protection_info(config, &flashProtectionInfo);
   \       0x1A   0xB90E             CBNZ.N   R6,??FLASH_IsProtected_2
   \                     ??FLASH_IsProtected_0: (+1)
   \       0x1C   0x2004             MOVS     R0,#+4
   1634              if (returnCode)
   1635              {
   1636                  return returnCode;
   1637              }
   1638          
   1639              /* calculating Flash end address */
   1640              endAddress = start + lengthInBytes;
   1641          
   1642              /* populate the flashRegionAddress array with the start address of each flash region */
   1643              regionCounter = 0; /* make sure regionCounter is initialized to 0 first */
   1644          
   1645              /* populate up to 33rd element of array, this is the next address after end of flash array */
   1646              while (regionCounter <= flashProtectionInfo.regionCount)
   1647              {
   1648                  flashRegionAddress[regionCounter] =
   1649                      flashProtectionInfo.regionBase + flashProtectionInfo.regionSize * regionCounter;
   1650                  regionCounter++;
   1651              }
   1652          
   1653              /* populate flashRegionProtectStatus array with status information
   1654               * Protection status for each region is stored in the FPROT[3:0] registers
   1655               * Each bit represents one region of flash
   1656               * 4 registers * 8-bits-per-register = 32-bits (32-regions)
   1657               * The convention is:
   1658               * FPROT3[bit 0] is the first protection region (start of flash memory)
   1659               * FPROT0[bit 7] is the last protection region (end of flash memory)
   1660               * regionCounter is used to determine which FPROT[3:0] register to check for protection status
   1661               * Note: FPROT=1 means NOT protected, FPROT=0 means protected */
   1662              regionCounter = 0; /* make sure regionCounter is initialized to 0 first */
   1663              while (regionCounter < flashProtectionInfo.regionCount)
   1664              {
   1665          #if FLASH_SSD_IS_SECONDARY_FLASH_ENABLED && FLASH_SSD_SECONDARY_FLASH_HAS_ITS_OWN_PROTECTION_REGISTER
   1666                  if (config->FlashMemoryIndex == (uint8_t)kFLASH_MemoryIndexSecondaryFlash)
   1667                  {
   1668                      if (regionCounter < 8)
   1669                      {
   1670                          flashRegionProtectStatus[regionCounter] = (FTFx_FPROTSL_REG >> regionCounter) & (0x01u);
   1671                      }
   1672                      else if ((regionCounter >= 8) && (regionCounter < 16))
   1673                      {
   1674                          flashRegionProtectStatus[regionCounter] = (FTFx_FPROTSH_REG >> (regionCounter - 8)) & (0x01u);
   1675                      }
   1676                      else
   1677                      {
   1678                          break;
   1679                      }
   1680                  }
   1681                  else
   1682          #endif
   1683                  {
   1684                      /* Note: So far protection region count may be 16/20/24/32/64 */
   1685                      if (regionCounter < 8)
   1686                      {
   1687                          flashRegionProtectStatus[regionCounter] = (FTFx_FPROTL3_REG >> regionCounter) & (0x01u);
   1688                      }
   1689                      else if ((regionCounter >= 8) && (regionCounter < 16))
   1690                      {
   1691                          flashRegionProtectStatus[regionCounter] = (FTFx_FPROTL2_REG >> (regionCounter - 8)) & (0x01u);
   1692                      }
   1693          #if defined(FSL_FEATURE_FLASH_PFLASH_PROTECTION_REGION_COUNT) && (FSL_FEATURE_FLASH_PFLASH_PROTECTION_REGION_COUNT > 16)
   1694          #if (FSL_FEATURE_FLASH_PFLASH_PROTECTION_REGION_COUNT == 20)
   1695                      else if ((regionCounter >= 16) && (regionCounter < 20))
   1696                      {
   1697                          flashRegionProtectStatus[regionCounter] = (FTFx_FPROTL1_REG >> (regionCounter - 16)) & (0x01u);
   1698                      }
   1699          #else
   1700                      else if ((regionCounter >= 16) && (regionCounter < 24))
   1701                      {
   1702                          flashRegionProtectStatus[regionCounter] = (FTFx_FPROTL1_REG >> (regionCounter - 16)) & (0x01u);
   1703                      }
   1704          #endif /* (FSL_FEATURE_FLASH_PFLASH_PROTECTION_REGION_COUNT == 20) */
   1705          #endif
   1706          #if defined(FSL_FEATURE_FLASH_PFLASH_PROTECTION_REGION_COUNT) && (FSL_FEATURE_FLASH_PFLASH_PROTECTION_REGION_COUNT > 24)
   1707                      else if ((regionCounter >= 24) && (regionCounter < 32))
   1708                      {
   1709                          flashRegionProtectStatus[regionCounter] = (FTFx_FPROTL0_REG >> (regionCounter - 24)) & (0x01u);
   1710                      }
   1711          #endif
   1712          #if defined(FSL_FEATURE_FLASH_PFLASH_PROTECTION_REGION_COUNT) && \
   1713              (FSL_FEATURE_FLASH_PFLASH_PROTECTION_REGION_COUNT == 64)
   1714                      else if (regionCounter < 40)
   1715                      {
   1716                          flashRegionProtectStatus[regionCounter] = (FTFx_FPROTH3_REG >> (regionCounter - 32)) & (0x01u);
   1717                      }
   1718                      else if (regionCounter < 48)
   1719                      {
   1720                          flashRegionProtectStatus[regionCounter] = (FTFx_FPROTH2_REG >> (regionCounter - 40)) & (0x01u);
   1721                      }
   1722                      else if (regionCounter < 56)
   1723                      {
   1724                          flashRegionProtectStatus[regionCounter] = (FTFx_FPROTH1_REG >> (regionCounter - 48)) & (0x01u);
   1725                      }
   1726                      else if (regionCounter < 64)
   1727                      {
   1728                          flashRegionProtectStatus[regionCounter] = (FTFx_FPROTH0_REG >> (regionCounter - 56)) & (0x01u);
   1729                      }
   1730          #endif
   1731                      else
   1732                      {
   1733                          break;
   1734                      }
   1735                  }
   1736          
   1737                  regionCounter++;
   1738              }
   1739          
   1740              /* loop through the flash regions and check
   1741               * desired flash address range for protection status
   1742               * loop stops when it is detected that start has exceeded the endAddress */
   1743              regionCounter = 0; /* make sure regionCounter is initialized to 0 first */
   1744              regionCheckedCounter = 0;
   1745              protectStatusCounter = 0; /* make sure protectStatusCounter is initialized to 0 first */
   1746              while (start < endAddress)
   1747              {
   1748                  /* check to see if the address falls within this protection region
   1749                   * Note that if the entire flash is to be checked, the last protection
   1750                   * region checked would consist of the last protection start address and
   1751                   * the start address following the end of flash */
   1752                  if ((start >= flashRegionAddress[regionCounter]) && (start < flashRegionAddress[regionCounter + 1]))
   1753                  {
   1754                      /* increment regionCheckedCounter to indicate this region was checked */
   1755                      regionCheckedCounter++;
   1756          
   1757                      /* check the protection status of this region
   1758                       * Note: FPROT=1 means NOT protected, FPROT=0 means protected */
   1759                      if (!flashRegionProtectStatus[regionCounter])
   1760                      {
   1761                          /* increment protectStatusCounter to indicate this region is protected */
   1762                          protectStatusCounter++;
   1763                      }
   1764                      start += flashProtectionInfo.regionSize; /* increment to an address within the next region */
   1765                  }
   1766                  regionCounter++; /* increment regionCounter to check for the next flash protection region */
   1767              }
   1768          
   1769              /* if protectStatusCounter == 0, then no region of the desired flash region is protected */
   1770              if (protectStatusCounter == 0)
   1771              {
   1772                  *protection_state = kFLASH_ProtectionStateUnprotected;
   1773              }
   1774              /* if protectStatusCounter == regionCheckedCounter, then each region checked was protected */
   1775              else if (protectStatusCounter == regionCheckedCounter)
   1776              {
   1777                  *protection_state = kFLASH_ProtectionStateProtected;
   1778              }
   1779              /* if protectStatusCounter != regionCheckedCounter, then protection status is mixed
   1780               * In other words, some regions are protected while others are unprotected */
   1781              else
   1782              {
   1783                  *protection_state = kFLASH_ProtectionStateMixed;
   1784              }
   1785          
   1786              return (returnCode);
   \       0x1E   0x....             B.N      ?Subroutine5
   \                     ??FLASH_IsProtected_2: (+1)
   \       0x20   0x4669             MOV      R1,SP
   \       0x22   0x2200             MOVS     R2,#+0
   \       0x24   0x2300             MOVS     R3,#+0
   \       0x26   0x4694             MOV      R12,R2
   \       0x28   0xE881 0x100C      STM      R1,{R2,R3,R12}
   \       0x2C   0x6872             LDR      R2,[R6, #+4]
   \       0x2E   0x6833             LDR      R3,[R6, #+0]
   \       0x30   0x9300             STR      R3,[SP, #+0]
   \       0x32   0xF248 0x0101      MOVW     R1,#+32769
   \       0x36   0x2620             MOVS     R6,#+32
   \       0x38   0x428A             CMP      R2,R1
   \       0x3A   0xBF34             ITE      CC 
   \       0x3C   0xF44F 0x6280      MOVCC    R2,#+1024
   \       0x40   0x0952             LSRCS    R2,R2,#+5
   \       0x42   0x9201             STR      R2,[SP, #+4]
   \       0x44   0x9602             STR      R6,[SP, #+8]
   \       0x46   0x193F             ADDS     R7,R7,R4
   \       0x48   0x9B01             LDR      R3,[SP, #+4]
   \       0x4A   0x2100             MOVS     R1,#+0
   \       0x4C   0xAA0B             ADD      R2,SP,#+44
   \                     ??FLASH_IsProtected_3: (+1)
   \       0x4E   0x9E00             LDR      R6,[SP, #+0]
   \       0x50   0xFB01 0x6603      MLA      R6,R1,R3,R6
   \       0x54   0x1C49             ADDS     R1,R1,#+1
   \       0x56   0x2920             CMP      R1,#+32
   \       0x58   0xF842 0x6B04      STR      R6,[R2], #+4
   \       0x5C   0xD9F7             BLS.N    ??FLASH_IsProtected_3
   \       0x5E   0x2100             MOVS     R1,#+0
   \       0x60   0xAA03             ADD      R2,SP,#+12
   \       0x62   0x.... 0x....      LDR.W    R6,??DataTable31_13  ;; 0x40020010
   \                     ??FLASH_IsProtected_4: (+1)
   \       0x66   0xF896 0xC000      LDRB     R12,[R6, #+0]
   \       0x6A   0xFA2C 0xFC01      LSR      R12,R12,R1
   \       0x6E   0xE014             B.N      ??FLASH_IsProtected_5
   \                     ??FLASH_IsProtected_6: (+1)
   \       0x70   0xF1A1 0x0E10      SUB      LR,R1,#+16
   \       0x74   0xF1BE 0x0F08      CMP      LR,#+8
   \       0x78   0xD204             BCS.N    ??FLASH_IsProtected_7
   \       0x7A   0xF896 0xC002      LDRB     R12,[R6, #+2]
   \       0x7E   0xF1A1 0x0810      SUB      R8,R1,#+16
   \       0x82   0xE008             B.N      ??FLASH_IsProtected_8
   \                     ??FLASH_IsProtected_7: (+1)
   \       0x84   0xF1A1 0x0C18      SUB      R12,R1,#+24
   \       0x88   0xF1BC 0x0F08      CMP      R12,#+8
   \       0x8C   0xD237             BCS.N    ??FLASH_IsProtected_9
   \       0x8E   0xF896 0xC003      LDRB     R12,[R6, #+3]
   \       0x92   0xF1A1 0x0818      SUB      R8,R1,#+24
   \                     ??FLASH_IsProtected_8: (+1)
   \       0x96   0xFA2C 0xFC08      LSR      R12,R12,R8
   \                     ??FLASH_IsProtected_5: (+1)
   \       0x9A   0x1C49             ADDS     R1,R1,#+1
   \       0x9C   0xF00C 0x0C01      AND      R12,R12,#0x1
   \       0xA0   0x2920             CMP      R1,#+32
   \       0xA2   0xF802 0xCB01      STRB     R12,[R2], #+1
   \       0xA6   0xD22A             BCS.N    ??FLASH_IsProtected_9
   \       0xA8   0x2908             CMP      R1,#+8
   \       0xAA   0xD3DC             BCC.N    ??FLASH_IsProtected_4
   \       0xAC   0xF1A1 0x0C08      SUB      R12,R1,#+8
   \       0xB0   0xF1BC 0x0F08      CMP      R12,#+8
   \       0xB4   0xD2DC             BCS.N    ??FLASH_IsProtected_6
   \       0xB6   0xF896 0xC001      LDRB     R12,[R6, #+1]
   \       0xBA   0xF1A1 0x0808      SUB      R8,R1,#+8
   \       0xBE   0xE7EA             B.N      ??FLASH_IsProtected_8
   \                     ??FLASH_IsProtected_10: (+1)
   \       0xC0   0xF8DE 0x1000      LDR      R1,[LR, #+0]
   \       0xC4   0x428C             CMP      R4,R1
   \       0xC6   0xD309             BCC.N    ??FLASH_IsProtected_11
   \       0xC8   0xF8DE 0x1004      LDR      R1,[LR, #+4]
   \       0xCC   0x428C             CMP      R4,R1
   \       0xCE   0xD205             BCS.N    ??FLASH_IsProtected_11
   \       0xD0   0xF89C 0x1000      LDRB     R1,[R12, #+0]
   \       0xD4   0x1C76             ADDS     R6,R6,#+1
   \       0xD6   0xB901             CBNZ.N   R1,??FLASH_IsProtected_12
   \       0xD8   0x1C52             ADDS     R2,R2,#+1
   \                     ??FLASH_IsProtected_12: (+1)
   \       0xDA   0x191C             ADDS     R4,R3,R4
   \                     ??FLASH_IsProtected_11: (+1)
   \       0xDC   0xF10E 0x0E04      ADD      LR,LR,#+4
   \       0xE0   0xF10C 0x0C01      ADD      R12,R12,#+1
   \                     ??FLASH_IsProtected_13: (+1)
   \       0xE4   0x42BC             CMP      R4,R7
   \       0xE6   0xD3EB             BCC.N    ??FLASH_IsProtected_10
   \       0xE8   0xB90A             CBNZ.N   R2,??FLASH_IsProtected_14
   \       0xEA   0x2100             MOVS     R1,#+0
   \       0xEC   0xE005             B.N      ??FLASH_IsProtected_15
   \                     ??FLASH_IsProtected_14: (+1)
   \       0xEE   0x42B2             CMP      R2,R6
   \       0xF0   0xD102             BNE.N    ??FLASH_IsProtected_16
   \       0xF2   0x2201             MOVS     R2,#+1
   \       0xF4   0x702A             STRB     R2,[R5, #+0]
   \       0xF6   0x....             B.N      ?Subroutine5
   \                     ??FLASH_IsProtected_16: (+1)
   \       0xF8   0x2102             MOVS     R1,#+2
   \                     ??FLASH_IsProtected_15: (+1)
   \       0xFA   0x7029             STRB     R1,[R5, #+0]
   \                     ??FLASH_IsProtected_1: (+1)
   \       0xFC   0x....             B.N      ?Subroutine5
   \                     ??FLASH_IsProtected_9: (+1)
   \       0xFE   0x2600             MOVS     R6,#+0
   \      0x100   0x2200             MOVS     R2,#+0
   \      0x102   0xF10D 0x0C0C      ADD      R12,SP,#+12
   \      0x106   0xF10D 0x0E2C      ADD      LR,SP,#+44
   \      0x10A   0xE7EB             B.N      ??FLASH_IsProtected_13
   1787          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0xB02C             ADD      SP,SP,#+176
   \        0x2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1788          

   \                                 In section .text, align 2, keep-with-next
   1789          status_t FLASH_IsExecuteOnly(flash_config_t *config,
   1790                                       uint32_t start,
   1791                                       uint32_t lengthInBytes,
   1792                                       flash_execute_only_access_state_t *access_state)
   1793          {
   1794          #if defined(FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL) && FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
   1795              flash_access_config_t flashAccessInfo; /* flash Execute-Only information */
   1796          #endif                                     /* FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL */
   1797              status_t returnCode;
   1798          
   1799              if (access_state == NULL)
   \                     FLASH_IsExecuteOnly: (+1)
   \        0x0   0x2B00             CMP      R3,#+0
   \        0x2   0xBF18             IT       NE 
   \        0x4   0x2800             CMPNE    R0,#+0
   1800              {
   1801                  return kStatus_FLASH_InvalidArgument;
   1802              }
   1803          
   1804              /* Check the supplied address range. */
   1805              returnCode = flash_check_range(config, start, lengthInBytes, FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE);
   \        0x6   0xD101             BNE.N    ??FLASH_IsExecuteOnly_0
   \        0x8   0x2004             MOVS     R0,#+4
   \        0xA   0x4770             BX       LR
   \                     ??FLASH_IsExecuteOnly_0: (+1)
   \        0xC   0xF011 0x0F03      TST      R1,#0x3
   \       0x10   0xBF08             IT       EQ 
   \       0x12   0xF012 0x0F03      TSTEQ    R2,#0x3
   \       0x16   0xD10E             BNE.N    ??FLASH_IsExecuteOnly_1
   \       0x18   0xF8D0 0xC000      LDR      R12,[R0, #+0]
   \       0x1C   0x4561             CMP      R1,R12
   \       0x1E   0xBF21             ITTTT    CS 
   \       0x20   0x6840             LDRCS    R0,[R0, #+4]
   \       0x22   0x4484             ADDCS    R12,R0,R12
   \       0x24   0x1851             ADDCS    R1,R2,R1
   \       0x26   0x458C             CMPCS    R12,R1
   \       0x28   0xD303             BCC.N    ??FLASH_IsExecuteOnly_2
   1806              if (returnCode)
   1807              {
   1808                  return returnCode;
   1809              }
   1810          
   1811          #if defined(FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL) && FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
   1812              /* Get necessary flash Execute-Only information. */
   1813              returnCode = flash_get_access_info(config, &flashAccessInfo);
   1814              if (returnCode)
   1815              {
   1816                  return returnCode;
   1817              }
   1818          
   1819              {
   1820                  uint32_t executeOnlySegmentCounter = 0;
   1821          
   1822                  /* calculating end address */
   1823                  uint32_t endAddress = start + lengthInBytes;
   1824          
   1825                  /* Aligning start address and end address */
   1826                  uint32_t alignedStartAddress = ALIGN_DOWN(start, flashAccessInfo.SegmentSize);
   1827                  uint32_t alignedEndAddress = ALIGN_UP(endAddress, flashAccessInfo.SegmentSize);
   1828          
   1829                  uint32_t segmentIndex = 0;
   1830                  uint32_t maxSupportedExecuteOnlySegmentCount =
   1831                      (alignedEndAddress - alignedStartAddress) / flashAccessInfo.SegmentSize;
   1832          
   1833                  while (start < endAddress)
   1834                  {
   1835                      uint32_t xacc;
   1836          
   1837                      segmentIndex = (start - flashAccessInfo.SegmentBase) / flashAccessInfo.SegmentSize;
   1838          
   1839          #if FLASH_SSD_IS_SECONDARY_FLASH_ENABLED && FLASH_SSD_SECONDARY_FLASH_HAS_ITS_OWN_ACCESS_REGISTER
   1840                      if (config->FlashMemoryIndex == (uint8_t)kFLASH_MemoryIndexSecondaryFlash)
   1841                      {
   1842                          /* For secondary flash, The two XACCS registers allow up to 16 restricted segments of equal memory size.
   1843                           */
   1844                          if (segmentIndex < 8)
   1845                          {
   1846                              xacc = *(const volatile uint8_t *)&FTFx_XACCSL_REG;
   1847                          }
   1848                          else if (segmentIndex < flashAccessInfo.SegmentCount)
   1849                          {
   1850                              xacc = *(const volatile uint8_t *)&FTFx_XACCSH_REG;
   1851                              segmentIndex -= 8;
   1852                          }
   1853                          else
   1854                          {
   1855                              break;
   1856                          }
   1857                      }
   1858                      else
   1859          #endif
   1860                      {
   1861                          /* For primary flash, The eight XACC registers allow up to 64 restricted segments of equal memory size.
   1862                           */
   1863                          if (segmentIndex < 32)
   1864                          {
   1865                              xacc = *(const volatile uint32_t *)&FTFx_XACCL3_REG;
   1866                          }
   1867                          else if (segmentIndex < flashAccessInfo.SegmentCount)
   1868                          {
   1869                              xacc = *(const volatile uint32_t *)&FTFx_XACCH3_REG;
   1870                              segmentIndex -= 32;
   1871                          }
   1872                          else
   1873                          {
   1874                              break;
   1875                          }
   1876                      }
   1877          
   1878                      /* Determine if this address range is in a execute-only protection flash segment. */
   1879                      if ((~xacc) & (1u << segmentIndex))
   1880                      {
   1881                          executeOnlySegmentCounter++;
   1882                      }
   1883          
   1884                      start += flashAccessInfo.SegmentSize;
   1885                  }
   1886          
   1887                  if (executeOnlySegmentCounter < 1u)
   1888                  {
   1889                      *access_state = kFLASH_AccessStateUnLimited;
   1890                  }
   1891                  else if (executeOnlySegmentCounter < maxSupportedExecuteOnlySegmentCount)
   1892                  {
   1893                      *access_state = kFLASH_AccessStateMixed;
   1894                  }
   1895                  else
   1896                  {
   1897                      *access_state = kFLASH_AccessStateExecuteOnly;
   1898                  }
   1899              }
   1900          #else
   1901              *access_state = kFLASH_AccessStateUnLimited;
   \       0x2A   0x2100             MOVS     R1,#+0
   \       0x2C   0x7019             STRB     R1,[R3, #+0]
   1902          #endif /* FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL */
   1903          
   1904              return (returnCode);
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x4770             BX       LR
   \                     ??FLASH_IsExecuteOnly_2: (+1)
   \       0x32   0x2066             MOVS     R0,#+102
   \       0x34   0x4770             BX       LR
   \                     ??FLASH_IsExecuteOnly_1: (+1)
   \       0x36   0x2065             MOVS     R0,#+101
   \       0x38   0x4770             BX       LR               ;; return
   1905          }
   1906          

   \                                 In section .text, align 4, keep-with-next
   1907          status_t FLASH_GetProperty(flash_config_t *config, flash_property_tag_t whichProperty, uint32_t *value)
   1908          {
   1909              if ((config == NULL) || (value == NULL))
   \                     FLASH_GetProperty: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xBF18             IT       NE 
   \        0x4   0x2A00             CMPNE    R2,#+0
   \        0x6   0xD101             BNE.N    ??FLASH_GetProperty_1
   1910              {
   1911                  return kStatus_FLASH_InvalidArgument;
   \        0x8   0x2004             MOVS     R0,#+4
   \        0xA   0x4770             BX       LR
   1912              }
   1913          
   1914              switch (whichProperty)
   \                     ??FLASH_GetProperty_1: (+1)
   \        0xC   0x2909             CMP      R1,#+9
   \        0xE   0xD81E             BHI.N    ??FLASH_GetProperty_2
   \       0x10   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??FLASH_GetProperty_0:
   \       0x14   0x05 0x09          DC8      0x5,0x9,0xB,0xF
   \              0x0B 0x0F    
   \       0x18   0x11 0x13          DC8      0x11,0x13,0x15,0x17
   \              0x15 0x17    
   \       0x1C   0x19 0x1B          DC8      0x19,0x1B
   1915              {
   1916                  case kFLASH_PropertyPflashSectorSize:
   1917                      *value = config->PFlashSectorSize;
   \                     ??FLASH_GetProperty_3: (+1)
   \       0x1E   0x68C0             LDR      R0,[R0, #+12]
   \                     ??FLASH_GetProperty_4: (+1)
   \       0x20   0x6010             STR      R0,[R2, #+0]
   1918                      break;
   1919          
   1920                  case kFLASH_PropertyPflashTotalSize:
   1921                      *value = config->PFlashTotalSize;
   1922                      break;
   1923          
   1924                  case kFLASH_PropertyPflashBlockSize:
   1925                      *value = config->PFlashTotalSize / FSL_FEATURE_FLASH_PFLASH_BLOCK_COUNT;
   1926                      break;
   1927          
   1928                  case kFLASH_PropertyPflashBlockCount:
   1929                      *value = (uint32_t)config->PFlashBlockCount;
   1930                      break;
   1931          
   1932                  case kFLASH_PropertyPflashBlockBaseAddr:
   1933                      *value = config->PFlashBlockBase;
   1934                      break;
   1935          
   1936                  case kFLASH_PropertyPflashFacSupport:
   1937          #if defined(FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL)
   1938                      *value = FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL;
   1939          #else
   1940                      *value = 0;
   1941          #endif /* FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL */
   1942                      break;
   1943          
   1944                  case kFLASH_PropertyPflashAccessSegmentSize:
   1945                      *value = config->PFlashAccessSegmentSize;
   1946                      break;
   1947          
   1948                  case kFLASH_PropertyPflashAccessSegmentCount:
   1949                      *value = config->PFlashAccessSegmentCount;
   1950                      break;
   1951          
   1952                  case kFLASH_PropertyFlexRamBlockBaseAddr:
   1953                      *value = config->FlexRAMBlockBase;
   1954                      break;
   1955          
   1956                  case kFLASH_PropertyFlexRamTotalSize:
   1957                      *value = config->FlexRAMTotalSize;
   1958                      break;
   1959          
   1960          #if FLASH_SSD_IS_FLEXNVM_ENABLED
   1961                  case kFLASH_PropertyDflashSectorSize:
   1962                      *value = FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_SECTOR_SIZE;
   1963                      break;
   1964                  case kFLASH_PropertyDflashTotalSize:
   1965                      *value = config->DFlashTotalSize;
   1966                      break;
   1967                  case kFLASH_PropertyDflashBlockSize:
   1968                      *value = FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_SIZE;
   1969                      break;
   1970                  case kFLASH_PropertyDflashBlockCount:
   1971                      *value = FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_COUNT;
   1972                      break;
   1973                  case kFLASH_PropertyDflashBlockBaseAddr:
   1974                      *value = config->DFlashBlockBase;
   1975                      break;
   1976                  case kFLASH_PropertyEepromTotalSize:
   1977                      *value = config->EEpromTotalSize;
   1978                      break;
   1979          #endif /* FLASH_SSD_IS_FLEXNVM_ENABLED */
   1980          
   1981                  default: /* catch inputs that are not recognized */
   1982                      return kStatus_FLASH_UnknownProperty;
   1983              }
   1984          
   1985              return kStatus_FLASH_Success;
   \                     ??FLASH_GetProperty_5: (+1)
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x4770             BX       LR               ;; return
   \                     ??FLASH_GetProperty_6: (+1)
   \       0x26   0x6840             LDR      R0,[R0, #+4]
   \       0x28   0xE7FA             B.N      ??FLASH_GetProperty_4
   \                     ??FLASH_GetProperty_7: (+1)
   \       0x2A   0x6841             LDR      R1,[R0, #+4]
   \       0x2C   0x0849             LSRS     R1,R1,#+1
   \                     ??FLASH_GetProperty_8: (+1)
   \       0x2E   0x6011             STR      R1,[R2, #+0]
   \       0x30   0xE7F7             B.N      ??FLASH_GetProperty_5
   \                     ??FLASH_GetProperty_9: (+1)
   \       0x32   0x7A00             LDRB     R0,[R0, #+8]
   \       0x34   0xE7F4             B.N      ??FLASH_GetProperty_4
   \                     ??FLASH_GetProperty_10: (+1)
   \       0x36   0x6801             LDR      R1,[R0, #+0]
   \       0x38   0xE7F9             B.N      ??FLASH_GetProperty_8
   \                     ??FLASH_GetProperty_11: (+1)
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0xE7F0             B.N      ??FLASH_GetProperty_4
   \                     ??FLASH_GetProperty_12: (+1)
   \       0x3E   0x6941             LDR      R1,[R0, #+20]
   \       0x40   0xE7F5             B.N      ??FLASH_GetProperty_8
   \                     ??FLASH_GetProperty_13: (+1)
   \       0x42   0x6980             LDR      R0,[R0, #+24]
   \       0x44   0xE7EC             B.N      ??FLASH_GetProperty_4
   \                     ??FLASH_GetProperty_14: (+1)
   \       0x46   0x6A01             LDR      R1,[R0, #+32]
   \       0x48   0xE7F1             B.N      ??FLASH_GetProperty_8
   \                     ??FLASH_GetProperty_15: (+1)
   \       0x4A   0x6A40             LDR      R0,[R0, #+36]
   \       0x4C   0xE7E8             B.N      ??FLASH_GetProperty_4
   \                     ??FLASH_GetProperty_2: (+1)
   \       0x4E   0x206A             MOVS     R0,#+106
   \       0x50   0x4770             BX       LR
   1986          }
   1987          

   \                                 In section .text, align 2, keep-with-next
   1988          status_t FLASH_SetProperty(flash_config_t *config, flash_property_tag_t whichProperty, uint32_t value)
   1989          {
   \                     FLASH_SetProperty: (+1)
   \        0x0   0x4603             MOV      R3,R0
   1990              status_t status = kStatus_FLASH_Success;
   \        0x2   0x2000             MOVS     R0,#+0
   1991          
   1992              if (config == NULL)
   \        0x4   0xB90B             CBNZ.N   R3,??FLASH_SetProperty_0
   1993              {
   1994                  return kStatus_FLASH_InvalidArgument;
   \        0x6   0x2004             MOVS     R0,#+4
   \        0x8   0x4770             BX       LR
   1995              }
   1996          
   1997              switch (whichProperty)
   \                     ??FLASH_SetProperty_0: (+1)
   \        0xA   0x2909             CMP      R1,#+9
   \        0xC   0xD909             BLS.N    ??FLASH_SetProperty_1
   \        0xE   0x3921             SUBS     R1,R1,#+33
   \       0x10   0xD109             BNE.N    ??FLASH_SetProperty_2
   1998              {
   1999          #if FLASH_SSD_IS_SECONDARY_FLASH_ENABLED
   2000                  case kFLASH_PropertyFlashMemoryIndex:
   2001                      if ((value != (uint32_t)kFLASH_MemoryIndexPrimaryFlash) &&
   2002                          (value != (uint32_t)kFLASH_MemoryIndexSecondaryFlash))
   2003                      {
   2004                          return kStatus_FLASH_InvalidPropertyValue;
   2005                      }
   2006                      config->FlashMemoryIndex = (uint8_t)value;
   2007                      break;
   2008          #endif /* FLASH_SSD_IS_SECONDARY_FLASH_ENABLED */
   2009          
   2010                  case kFLASH_PropertyFlashCacheControllerIndex:
   2011                      if ((value != (uint32_t)kFLASH_CacheControllerIndexForCore0) &&
   2012                          (value != (uint32_t)kFLASH_CacheControllerIndexForCore1))
   \       0x12   0x2A00             CMP      R2,#+0
   \       0x14   0xBF18             IT       NE 
   \       0x16   0x2A01             CMPNE    R2,#+1
   \       0x18   0xD001             BEQ.N    ??FLASH_SetProperty_3
   2013                      {
   2014                          return kStatus_FLASH_InvalidPropertyValue;
   \       0x1A   0x2077             MOVS     R0,#+119
   \       0x1C   0x4770             BX       LR
   2015                      }
   2016                      config->FlashCacheControllerIndex = (uint8_t)value;
   \                     ??FLASH_SetProperty_3: (+1)
   \       0x1E   0x729A             STRB     R2,[R3, #+10]
   2017                      break;
   \       0x20   0x4770             BX       LR
   2018          
   2019                  case kFLASH_PropertyPflashSectorSize:
   2020                  case kFLASH_PropertyPflashTotalSize:
   2021                  case kFLASH_PropertyPflashBlockSize:
   2022                  case kFLASH_PropertyPflashBlockCount:
   2023                  case kFLASH_PropertyPflashBlockBaseAddr:
   2024                  case kFLASH_PropertyPflashFacSupport:
   2025                  case kFLASH_PropertyPflashAccessSegmentSize:
   2026                  case kFLASH_PropertyPflashAccessSegmentCount:
   2027                  case kFLASH_PropertyFlexRamBlockBaseAddr:
   2028                  case kFLASH_PropertyFlexRamTotalSize:
   2029          #if FLASH_SSD_IS_FLEXNVM_ENABLED
   2030                  case kFLASH_PropertyDflashSectorSize:
   2031                  case kFLASH_PropertyDflashTotalSize:
   2032                  case kFLASH_PropertyDflashBlockSize:
   2033                  case kFLASH_PropertyDflashBlockCount:
   2034                  case kFLASH_PropertyDflashBlockBaseAddr:
   2035                  case kFLASH_PropertyEepromTotalSize:
   2036          #endif /* FLASH_SSD_IS_FLEXNVM_ENABLED */
   2037                      status = kStatus_FLASH_ReadOnlyProperty;
   \                     ??FLASH_SetProperty_1: (+1)
   \       0x22   0x2076             MOVS     R0,#+118
   2038                      break;
   \       0x24   0x4770             BX       LR
   2039                  default: /* catch inputs that are not recognized */
   2040                      status = kStatus_FLASH_UnknownProperty;
   \                     ??FLASH_SetProperty_2: (+1)
   \       0x26   0x206A             MOVS     R0,#+106
   2041                      break;
   2042              }
   2043          
   2044              return status;
   \       0x28   0x4770             BX       LR               ;; return
   2045          }
   2046          
   2047          #if defined(FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD) && FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD
   2048          status_t FLASH_SetFlexramFunction(flash_config_t *config, flash_flexram_function_option_t option)
   2049          {
   2050              status_t status;
   2051          
   2052              if (config == NULL)
   2053              {
   2054                  return kStatus_FLASH_InvalidArgument;
   2055              }
   2056          
   2057              status = flasn_check_flexram_function_option_range(option);
   2058              if (status != kStatus_FLASH_Success)
   2059              {
   2060                  return status;
   2061              }
   2062          
   2063              /* preparing passing parameter to verify all block command */
   2064              kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_1_2(FTFx_SET_FLEXRAM_FUNCTION, option, 0xFFFFU);
   2065          
   2066              /* calling flash command sequence function to execute the command */
   2067              return flash_command_sequence(config);
   2068          }
   2069          #endif /* FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD */
   2070          
   2071          #if defined(FSL_FEATURE_FLASH_HAS_SWAP_CONTROL_CMD) && FSL_FEATURE_FLASH_HAS_SWAP_CONTROL_CMD

   \                                 In section .text, align 2, keep-with-next
   2072          status_t FLASH_SwapControl(flash_config_t *config,
   2073                                     uint32_t address,
   2074                                     flash_swap_control_option_t option,
   2075                                     flash_swap_state_config_t *returnInfo)
   2076          {
   \                     FLASH_SwapControl: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x461C             MOV      R4,R3
   2077              status_t returnCode;
   2078          
   2079              if ((config == NULL) || (returnInfo == NULL))
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xBF18             IT       NE 
   \        0x8   0x2C00             CMPNE    R4,#+0
   \        0xA   0xD017             BEQ.N    ??FLASH_SwapControl_0
   2080              {
   2081                  return kStatus_FLASH_InvalidArgument;
   2082              }
   2083          
   2084              if (address & (FSL_FEATURE_FLASH_PFLASH_SWAP_CONTROL_CMD_ADDRESS_ALIGMENT - 1))
   \        0xC   0xF011 0x0F07      TST      R1,#0x7
   \       0x10   0xD001             BEQ.N    ??FLASH_SwapControl_1
   2085              {
   2086                  return kStatus_FLASH_AlignmentError;
   \       0x12   0x2065             MOVS     R0,#+101
   \       0x14   0xBD32             POP      {R1,R4,R5,PC}
   2087              }
   2088          
   2089              /* Make sure address provided is in the lower half of Program flash but not in the Flash Configuration Field */
   2090              if ((address >= (config->PFlashTotalSize / 2)) ||
   2091                  ((address >= kFLASH_ConfigAreaStart) && (address <= kFLASH_ConfigAreaEnd)))
   \                     ??FLASH_SwapControl_1: (+1)
   \       0x16   0x6843             LDR      R3,[R0, #+4]
   \       0x18   0xEBB1 0x0F53      CMP      R1,R3, LSR #+1
   \       0x1C   0xD203             BCS.N    ??FLASH_SwapControl_2
   \       0x1E   0xF5A1 0x6580      SUB      R5,R1,#+1024
   \       0x22   0x2D10             CMP      R5,#+16
   \       0x24   0xD201             BCS.N    ??FLASH_SwapControl_3
   2092              {
   2093                  return kStatus_FLASH_SwapIndicatorAddressError;
   \                     ??FLASH_SwapControl_2: (+1)
   \       0x26   0x2075             MOVS     R0,#+117
   \       0x28   0xBD32             POP      {R1,R4,R5,PC}
   2094              }
   2095          
   2096              /* Check the option. */
   2097              returnCode = flash_check_swap_control_option(option);
   \                     ??FLASH_SwapControl_3: (+1)
   \       0x2A   0x2A01             CMP      R2,#+1
   \       0x2C   0xBF18             IT       NE 
   \       0x2E   0x2A02             CMPNE    R2,#+2
   \       0x30   0xD006             BEQ.N    ??FLASH_SwapControl_4
   \       0x32   0x2A04             CMP      R2,#+4
   \       0x34   0xBF1C             ITT      NE 
   \       0x36   0x2A08             CMPNE    R2,#+8
   \       0x38   0x2A10             CMPNE    R2,#+16
   \       0x3A   0xD001             BEQ.N    ??FLASH_SwapControl_4
   2098              if (returnCode)
   2099              {
   2100                  return returnCode;
   \                     ??FLASH_SwapControl_0: (+1)
   \       0x3C   0x2004             MOVS     R0,#+4
   \       0x3E   0xBD32             POP      {R1,R4,R5,PC}
   2101              }
   2102          
   2103              kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_3(FTFx_SWAP_CONTROL, address);
   \                     ??FLASH_SwapControl_4: (+1)
   \       0x40   0x....             LDR.N    R5,??DataTable31_3  ;; 0x40020004
   \       0x42   0xF021 0x417F      BIC      R1,R1,#0xFF000000
   \       0x46   0xF041 0x418C      ORR      R1,R1,#0x46000000
   2104              kFCCOBx[1] = BYTES_JOIN_TO_WORD_1_3(option, 0xFFFFFFU);
   \       0x4A   0x0612             LSLS     R2,R2,#+24
   \       0x4C   0x6029             STR      R1,[R5, #+0]
   \       0x4E   0xF062 0x427F      ORN      R2,R2,#-16777216
   \       0x52   0x606A             STR      R2,[R5, #+4]
   2105          
   2106              returnCode = flash_command_sequence(config);
   \       0x54   0x.... 0x....      BL       flash_command_sequence
   2107          
   2108              returnInfo->flashSwapState = (flash_swap_state_t)FTFx_FCCOB5_REG;
   \       0x58   0x79A9             LDRB     R1,[R5, #+6]
   \       0x5A   0x7021             STRB     R1,[R4, #+0]
   2109              returnInfo->currentSwapBlockStatus = (flash_swap_block_status_t)FTFx_FCCOB6_REG;
   \       0x5C   0x796A             LDRB     R2,[R5, #+5]
   \       0x5E   0x7062             STRB     R2,[R4, #+1]
   2110              returnInfo->nextSwapBlockStatus = (flash_swap_block_status_t)FTFx_FCCOB7_REG;
   \       0x60   0x7929             LDRB     R1,[R5, #+4]
   \       0x62   0x70A1             STRB     R1,[R4, #+2]
   2111          
   2112              return returnCode;
   \       0x64   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2113          }
   2114          #endif /* FSL_FEATURE_FLASH_HAS_SWAP_CONTROL_CMD */
   2115          
   2116          #if defined(FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP) && FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP

   \                                 In section .text, align 4, keep-with-next
   2117          status_t FLASH_Swap(flash_config_t *config, uint32_t address, flash_swap_function_option_t option)
   2118          {
   \                     FLASH_Swap: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x4607             MOV      R7,R0
   \        0x8   0x468A             MOV      R10,R1
   \        0xA   0x4616             MOV      R6,R2
   2119              flash_swap_state_config_t returnInfo;
   2120              status_t returnCode;
   2121          
   2122              memset(&returnInfo, 0xFFU, sizeof(returnInfo));
   \        0xC   0x22FF             MOVS     R2,#+255
   \        0xE   0x2103             MOVS     R1,#+3
   \       0x10   0xA801             ADD      R0,SP,#+4
   \       0x12   0x.... 0x....      BL       __aeabi_memset4
   \       0x16   0xF02A 0x457F      BIC      R5,R10,#0xFF000000
   2123          
   2124              do
   2125              {
   2126                  returnCode = FLASH_SwapControl(config, address, kFLASH_SwapControlOptionReportStatus, &returnInfo);
   \       0x1A   0x2F00             CMP      R7,#+0
   \       0x1C   0xF045 0x458C      ORR      R5,R5,#0x46000000
   \       0x20   0xF06F 0x4B7B      MVN      R11,#-83886080
   \       0x24   0xF06F 0x496F      MVN      R9,#-285212672
   \       0x28   0xF06F 0x4877      MVN      R8,#-150994944
   \       0x2C   0x....             LDR.N    R4,??DataTable31_3  ;; 0x40020004
   \       0x2E   0xF000 0x8089      BEQ.W    ??FLASH_Swap_1
   \       0x32   0xF01A 0x0F07      TST      R10,#0x7
   \       0x36   0xF000 0x807C      BEQ.W    ??FLASH_Swap_2
   \       0x3A   0x2065             MOVS     R0,#+101
   2127                  if (returnCode != kStatus_FLASH_Success)
   2128                  {
   2129                      return returnCode;
   2130                  }
   2131          
   2132                  if (kFLASH_SwapFunctionOptionDisable == option)
   2133                  {
   2134                      if (returnInfo.flashSwapState == kFLASH_SwapStateDisabled)
   2135                      {
   2136                          return kStatus_FLASH_Success;
   2137                      }
   2138                      else if (returnInfo.flashSwapState == kFLASH_SwapStateUninitialized)
   2139                      {
   2140                          /* The swap system changed to the DISABLED state with Program flash block 0
   2141                           * located at relative flash address 0x0_0000 */
   2142                          returnCode = FLASH_SwapControl(config, address, kFLASH_SwapControlOptionDisableSystem, &returnInfo);
   2143                      }
   2144                      else
   2145                      {
   2146                          /* Swap disable should be requested only when swap system is in the uninitialized state */
   2147                          return kStatus_FLASH_SwapSystemNotInUninitialized;
   2148                      }
   2149                  }
   2150                  else
   2151                  {
   2152                      /* When first swap: the initial swap state is Uninitialized, flash swap inidicator address is unset,
   2153                       *    the swap procedure should be Uninitialized -> Update-Erased -> Complete.
   2154                       * After the first swap has been completed, the flash swap inidicator address cannot be modified
   2155                       *    unless EraseAllBlocks command is issued, the swap procedure is changed to Update -> Update-Erased ->
   2156                       *    Complete. */
   2157                      switch (returnInfo.flashSwapState)
   2158                      {
   2159                          case kFLASH_SwapStateUninitialized:
   2160                              /* If current swap mode is Uninitialized, Initialize Swap to Initialized/READY state. */
   2161                              returnCode =
   2162                                  FLASH_SwapControl(config, address, kFLASH_SwapControlOptionIntializeSystem, &returnInfo);
   2163                              break;
   2164                          case kFLASH_SwapStateReady:
   2165                              /* Validate whether the address provided to the swap system is matched to
   2166                               * swap indicator address in the IFR */
   2167                              returnCode = flash_validate_swap_indicator_address(config, address);
   2168                              if (returnCode == kStatus_FLASH_Success)
   2169                              {
   2170                                  /* If current swap mode is Initialized/Ready, Initialize Swap to UPDATE state. */
   2171                                  returnCode =
   2172                                      FLASH_SwapControl(config, address, kFLASH_SwapControlOptionSetInUpdateState, &returnInfo);
   2173                              }
   2174                              break;
   2175                          case kFLASH_SwapStateUpdate:
   2176                              /* If current swap mode is Update, Erase indicator sector in non active block
   2177                               * to proceed swap system to update-erased state */
   2178                              returnCode = FLASH_Erase(config, address + (config->PFlashTotalSize >> 1),
   2179                                                       FSL_FEATURE_FLASH_PFLASH_SECTOR_CMD_ADDRESS_ALIGMENT, kFLASH_ApiEraseKey);
   2180                              break;
   2181                          case kFLASH_SwapStateUpdateErased:
   2182                              /* If current swap mode is Update or Update-Erased, progress Swap to COMPLETE State */
   2183                              returnCode =
   2184                                  FLASH_SwapControl(config, address, kFLASH_SwapControlOptionSetInCompleteState, &returnInfo);
   2185                              break;
   2186                          case kFLASH_SwapStateComplete:
   2187                              break;
   2188                          case kFLASH_SwapStateDisabled:
   2189                              /* When swap system is in disabled state, We need to clear swap system back to uninitialized
   2190                               * by issuing EraseAllBlocks command */
   2191                              returnCode = kStatus_FLASH_SwapSystemNotInUninitialized;
   2192                              break;
   2193                          default:
   2194                              returnCode = kStatus_FLASH_InvalidArgument;
   2195                              break;
   2196                      }
   2197                  }
   2198                  if (returnCode != kStatus_FLASH_Success)
   2199                  {
   2200                      break;
   2201                  }
   2202              } while (!((kFLASH_SwapStateComplete == returnInfo.flashSwapState) && (kFLASH_SwapFunctionOptionEnable == option)));
   2203          
   2204              return returnCode;
   \                     ??FLASH_Swap_3: (+1)
   \       0x3C   0x....             B.N      ?Subroutine3
   \                     ??FLASH_Swap_4: (+1)
   \       0x3E   0xF5AA 0x6080      SUB      R0,R10,#+1024
   \       0x42   0x2810             CMP      R0,#+16
   \       0x44   0xF0C0 0x807A      BCC.W    ??FLASH_Swap_5
   \       0x48   0x6025             STR      R5,[R4, #+0]
   \       0x4A   0xF8C4 0x8004      STR      R8,[R4, #+4]
   \       0x4E   0x4638             MOV      R0,R7
   \       0x50   0x.... 0x....      BL       flash_command_sequence
   \       0x54   0x79A1             LDRB     R1,[R4, #+6]
   \       0x56   0xF88D 0x1004      STRB     R1,[SP, #+4]
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0x7962             LDRB     R2,[R4, #+5]
   \       0x5E   0xF88D 0x2005      STRB     R2,[SP, #+5]
   \       0x62   0x7921             LDRB     R1,[R4, #+4]
   \       0x64   0xF88D 0x1006      STRB     R1,[SP, #+6]
   \       0x68   0xD1E8             BNE.N    ??FLASH_Swap_3
   \       0x6A   0x2E01             CMP      R6,#+1
   \       0x6C   0xD123             BNE.N    ??FLASH_Swap_6
   \       0x6E   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \       0x72   0x2805             CMP      R0,#+5
   \       0x74   0xD101             BNE.N    ??FLASH_Swap_7
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0x....             B.N      ?Subroutine3
   \                     ??FLASH_Swap_7: (+1)
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD160             BNE.N    ??FLASH_Swap_8
   \       0x7E   0x6878             LDR      R0,[R7, #+4]
   \       0x80   0xEBBA 0x0F50      CMP      R10,R0, LSR #+1
   \       0x84   0xD25A             BCS.N    ??FLASH_Swap_5
   \       0x86   0x6025             STR      R5,[R4, #+0]
   \       0x88   0xF8C4 0x9004      STR      R9,[R4, #+4]
   \                     ??FLASH_Swap_9: (+1)
   \       0x8C   0x4638             MOV      R0,R7
   \       0x8E   0x.... 0x....      BL       flash_command_sequence
   \       0x92   0x79A1             LDRB     R1,[R4, #+6]
   \       0x94   0xF88D 0x1004      STRB     R1,[SP, #+4]
   \       0x98   0x7962             LDRB     R2,[R4, #+5]
   \       0x9A   0xF88D 0x2005      STRB     R2,[SP, #+5]
   \       0x9E   0x7921             LDRB     R1,[R4, #+4]
   \       0xA0   0xF88D 0x1006      STRB     R1,[SP, #+6]
   \                     ??FLASH_Swap_10: (+1)
   \       0xA4   0x2800             CMP      R0,#+0
   \       0xA6   0xD1C9             BNE.N    ??FLASH_Swap_3
   \       0xA8   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \       0xAC   0x2904             CMP      R1,#+4
   \       0xAE   0xBF08             IT       EQ 
   \       0xB0   0x2E00             CMPEQ    R6,#+0
   \       0xB2   0xD13E             BNE.N    ??FLASH_Swap_2
   \       0xB4   0x....             B.N      ?Subroutine3
   \                     ??FLASH_Swap_6: (+1)
   \       0xB6   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \       0xBA   0x2905             CMP      R1,#+5
   \       0xBC   0xD842             BHI.N    ??FLASH_Swap_1
   \       0xBE   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??FLASH_Swap_0:
   \       0xC2   0x04 0x0E          DC8      0x4,0xE,0x27,0x30
   \              0x27 0x30    
   \       0xC6   0x03 0x3F          DC8      0x3,0x3F
   \                     ??FLASH_Swap_11: (+1)
   \       0xC8   0xE7EC             B.N      ??FLASH_Swap_10
   \                     ??FLASH_Swap_12: (+1)
   \       0xCA   0x6878             LDR      R0,[R7, #+4]
   \       0xCC   0xEBBA 0x0F50      CMP      R10,R0, LSR #+1
   \       0xD0   0xBF3E             ITTT     CC 
   \       0xD2   0x6025             STRCC    R5,[R4, #+0]
   \       0xD4   0xF06F 0x417E      MVNCC    R1,#-33554432
   \       0xD8   0x6061             STRCC    R1,[R4, #+4]
   \       0xDA   0xD3D7             BCC.N    ??FLASH_Swap_9
   \       0xDC   0xE02E             B.N      ??FLASH_Swap_5
   \                     ??FLASH_Swap_13: (+1)
   \       0xDE   0x9000             STR      R0,[SP, #+0]
   \       0xE0   0x2308             MOVS     R3,#+8
   \       0xE2   0xAA02             ADD      R2,SP,#+8
   \       0xE4   0xF44F 0x3100      MOV      R1,#+131072
   \       0xE8   0x4638             MOV      R0,R7
   \       0xEA   0x.... 0x....      BL       FLASH_ReadResource
   \       0xEE   0x2800             CMP      R0,#+0
   \       0xF0   0xD1A4             BNE.N    ??FLASH_Swap_3
   \       0xF2   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \       0xF6   0xEBBA 0x0FC0      CMP      R10,R0, LSL #+3
   \       0xFA   0xD11F             BNE.N    ??FLASH_Swap_5
   \       0xFC   0x6878             LDR      R0,[R7, #+4]
   \       0xFE   0xEBBA 0x0F50      CMP      R10,R0, LSR #+1
   \      0x102   0xBF3E             ITTT     CC 
   \      0x104   0x6025             STRCC    R5,[R4, #+0]
   \      0x106   0xF06F 0x417D      MVNCC    R1,#-50331648
   \      0x10A   0x6061             STRCC    R1,[R4, #+4]
   \      0x10C   0xD3BE             BCC.N    ??FLASH_Swap_9
   \      0x10E   0xE015             B.N      ??FLASH_Swap_5
   \                     ??FLASH_Swap_14: (+1)
   \      0x110   0x6878             LDR      R0,[R7, #+4]
   \      0x112   0x....             LDR.N    R3,??DataTable31_4  ;; 0x6b65666b
   \      0x114   0xEB0A 0x0150      ADD      R1,R10,R0, LSR #+1
   \      0x118   0x2208             MOVS     R2,#+8
   \      0x11A   0x4638             MOV      R0,R7
   \      0x11C   0x.... 0x....      BL       FLASH_Erase
   \      0x120   0xE7C0             B.N      ??FLASH_Swap_10
   \                     ??FLASH_Swap_15: (+1)
   \      0x122   0x6878             LDR      R0,[R7, #+4]
   \      0x124   0xEBBA 0x0F50      CMP      R10,R0, LSR #+1
   \      0x128   0xD208             BCS.N    ??FLASH_Swap_5
   \      0x12A   0x6025             STR      R5,[R4, #+0]
   \      0x12C   0xF8C4 0xB004      STR      R11,[R4, #+4]
   \      0x130   0xE7AC             B.N      ??FLASH_Swap_9
   \                     ??FLASH_Swap_2: (+1)
   \      0x132   0x6878             LDR      R0,[R7, #+4]
   \      0x134   0xEBBA 0x0F50      CMP      R10,R0, LSR #+1
   \      0x138   0xF4FF 0xAF81      BCC.W    ??FLASH_Swap_4
   \                     ??FLASH_Swap_5: (+1)
   \      0x13C   0x2075             MOVS     R0,#+117
   \      0x13E   0x....             B.N      ?Subroutine3
   \                     ??FLASH_Swap_8: (+1)
   \      0x140   0x2074             MOVS     R0,#+116
   \      0x142   0x....             B.N      ?Subroutine3
   \                     ??FLASH_Swap_1: (+1)
   \      0x144   0x2004             MOVS     R0,#+4
   \      0x146                      REQUIRE ?Subroutine3
   \      0x146                      ;; // Fall through to label ?Subroutine3
   2205          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0xB005             ADD      SP,SP,#+20
   \        0x2   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2206          #endif /* FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP */
   2207          
   2208          #if defined(FSL_FEATURE_FLASH_HAS_PROGRAM_PARTITION_CMD) && FSL_FEATURE_FLASH_HAS_PROGRAM_PARTITION_CMD
   2209          status_t FLASH_ProgramPartition(flash_config_t *config,
   2210                                          flash_partition_flexram_load_option_t option,
   2211                                          uint32_t eepromDataSizeCode,
   2212                                          uint32_t flexnvmPartitionCode)
   2213          {
   2214              status_t returnCode;
   2215          
   2216              if (config == NULL)
   2217              {
   2218                  return kStatus_FLASH_InvalidArgument;
   2219              }
   2220          
   2221              /* eepromDataSizeCode[7:6], flexnvmPartitionCode[7:4] should be all 1'b0
   2222               *  or it will cause access error. */
   2223              /* eepromDataSizeCode &= 0x3FU;  */
   2224              /* flexnvmPartitionCode &= 0x0FU; */
   2225          
   2226              /* preparing passing parameter to program the flash block */
   2227              kFCCOBx[0] = BYTES_JOIN_TO_WORD_1_2_1(FTFx_PROGRAM_PARTITION, 0xFFFFU, option);
   2228              kFCCOBx[1] = BYTES_JOIN_TO_WORD_1_1_2(eepromDataSizeCode, flexnvmPartitionCode, 0xFFFFU);
   2229          
   2230              flash_cache_clear_process(config, kFLASH_CacheClearProcessPre);
   2231          
   2232              /* calling flash command sequence function to execute the command */
   2233              returnCode = flash_command_sequence(config);
   2234          
   2235              flash_cache_clear(config);
   2236          
   2237          #if FLASH_SSD_IS_FLEXNVM_ENABLED
   2238              /* Data flash IFR will be updated by program partition command during reset sequence,
   2239               * so we just set reserved values for partitioned FlexNVM size here */
   2240              config->EEpromTotalSize = FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_RESERVED;
   2241              config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   2242          #endif
   2243          
   2244              return (returnCode);
   2245          }
   2246          #endif /* FSL_FEATURE_FLASH_HAS_PROGRAM_PARTITION_CMD */
   2247          

   \                                 In section .text, align 2, keep-with-next
   2248          status_t FLASH_PflashSetProtection(flash_config_t *config, pflash_protection_status_t *protectStatus)
   2249          {
   2250              if (config == NULL)
   \                     FLASH_PflashSetProtection: (+1)
   \        0x0   0xB908             CBNZ.N   R0,??FLASH_PflashSetProtection_0
   2251              {
   2252                  return kStatus_FLASH_InvalidArgument;
   \        0x2   0x2004             MOVS     R0,#+4
   \        0x4   0x4770             BX       LR
   2253              }
   2254          
   2255          #if FLASH_SSD_IS_SECONDARY_FLASH_ENABLED && FLASH_SSD_SECONDARY_FLASH_HAS_ITS_OWN_PROTECTION_REGISTER
   2256              if (config->FlashMemoryIndex == (uint8_t)kFLASH_MemoryIndexSecondaryFlash)
   2257              {
   2258                  *kFPROTSL = protectStatus->valueLow32b.prots16b.protsl;
   2259                  if (protectStatus->valueLow32b.prots16b.protsl != *kFPROTSL)
   2260                  {
   2261                      return kStatus_FLASH_CommandFailure;
   2262                  }
   2263          
   2264                  *kFPROTSH = protectStatus->valueLow32b.prots16b.protsh;
   2265                  if (protectStatus->valueLow32b.prots16b.protsh != *kFPROTSH)
   2266                  {
   2267                      return kStatus_FLASH_CommandFailure;
   2268                  }
   2269              }
   2270              else
   2271          #endif
   2272              {
   2273                  *kFPROTL = protectStatus->valueLow32b.protl32b;
   \                     ??FLASH_PflashSetProtection_0: (+1)
   \        0x6   0x....             LDR.N    R0,??DataTable31_13  ;; 0x40020010
   \        0x8   0x680A             LDR      R2,[R1, #+0]
   \        0xA   0x6002             STR      R2,[R0, #+0]
   2274                  if (protectStatus->valueLow32b.protl32b != *kFPROTL)
   \        0xC   0x6809             LDR      R1,[R1, #+0]
   \        0xE   0x6800             LDR      R0,[R0, #+0]
   \       0x10   0x4281             CMP      R1,R0
   \       0x12   0xD001             BEQ.N    ??FLASH_PflashSetProtection_1
   2275                  {
   2276                      return kStatus_FLASH_CommandFailure;
   \       0x14   0x2069             MOVS     R0,#+105
   \       0x16   0x4770             BX       LR
   2277                  }
   2278          
   2279          #if defined(FTFx_FPROT_HIGH_REG)
   2280                  *kFPROTH = protectStatus->valueHigh32b.proth32b;
   2281                  if (protectStatus->valueHigh32b.proth32b != *kFPROTH)
   2282                  {
   2283                      return kStatus_FLASH_CommandFailure;
   2284                  }
   2285          #endif
   2286              }
   2287          
   2288              return kStatus_FLASH_Success;
   \                     ??FLASH_PflashSetProtection_1: (+1)
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x4770             BX       LR               ;; return
   2289          }
   2290          

   \                                 In section .text, align 2, keep-with-next
   2291          status_t FLASH_PflashGetProtection(flash_config_t *config, pflash_protection_status_t *protectStatus)
   2292          {
   2293              if ((config == NULL) || (protectStatus == NULL))
   \                     FLASH_PflashGetProtection: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xBF18             IT       NE 
   \        0x4   0x2900             CMPNE    R1,#+0
   \        0x6   0xD101             BNE.N    ??FLASH_PflashGetProtection_0
   2294              {
   2295                  return kStatus_FLASH_InvalidArgument;
   \        0x8   0x2004             MOVS     R0,#+4
   \        0xA   0x4770             BX       LR
   2296              }
   2297          
   2298          #if FLASH_SSD_IS_SECONDARY_FLASH_ENABLED && FLASH_SSD_SECONDARY_FLASH_HAS_ITS_OWN_PROTECTION_REGISTER
   2299              if (config->FlashMemoryIndex == (uint8_t)kFLASH_MemoryIndexSecondaryFlash)
   2300              {
   2301                  protectStatus->valueLow32b.prots16b.protsl = *kFPROTSL;
   2302                  protectStatus->valueLow32b.prots16b.protsh = *kFPROTSH;
   2303              }
   2304              else
   2305          #endif
   2306              {
   2307                  protectStatus->valueLow32b.protl32b = *kFPROTL;
   \                     ??FLASH_PflashGetProtection_0: (+1)
   \        0xC   0x....             LDR.N    R0,??DataTable31_13  ;; 0x40020010
   \        0xE   0x6802             LDR      R2,[R0, #+0]
   \       0x10   0x600A             STR      R2,[R1, #+0]
   2308          #if defined(FTFx_FPROT_HIGH_REG)
   2309                  protectStatus->valueHigh32b.proth32b = *kFPROTH;
   2310          #endif
   2311              }
   2312          
   2313              return kStatus_FLASH_Success;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x4770             BX       LR               ;; return
   2314          }
   2315          
   2316          #if FLASH_SSD_IS_FLEXNVM_ENABLED
   2317          status_t FLASH_DflashSetProtection(flash_config_t *config, uint8_t protectStatus)
   2318          {
   2319              if (config == NULL)
   2320              {
   2321                  return kStatus_FLASH_InvalidArgument;
   2322              }
   2323          
   2324              if ((config->DFlashTotalSize == 0) || (config->DFlashTotalSize == FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED))
   2325              {
   2326                  return kStatus_FLASH_CommandNotSupported;
   2327              }
   2328          
   2329              FTFx->FDPROT = protectStatus;
   2330          
   2331              if (FTFx->FDPROT != protectStatus)
   2332              {
   2333                  return kStatus_FLASH_CommandFailure;
   2334              }
   2335          
   2336              return kStatus_FLASH_Success;
   2337          }
   2338          #endif /* FLASH_SSD_IS_FLEXNVM_ENABLED */
   2339          
   2340          #if FLASH_SSD_IS_FLEXNVM_ENABLED
   2341          status_t FLASH_DflashGetProtection(flash_config_t *config, uint8_t *protectStatus)
   2342          {
   2343              if ((config == NULL) || (protectStatus == NULL))
   2344              {
   2345                  return kStatus_FLASH_InvalidArgument;
   2346              }
   2347          
   2348              if ((config->DFlashTotalSize == 0) || (config->DFlashTotalSize == FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED))
   2349              {
   2350                  return kStatus_FLASH_CommandNotSupported;
   2351              }
   2352          
   2353              *protectStatus = FTFx->FDPROT;
   2354          
   2355              return kStatus_FLASH_Success;
   2356          }
   2357          #endif /* FLASH_SSD_IS_FLEXNVM_ENABLED */
   2358          
   2359          #if FLASH_SSD_IS_FLEXNVM_ENABLED
   2360          status_t FLASH_EepromSetProtection(flash_config_t *config, uint8_t protectStatus)
   2361          {
   2362              if (config == NULL)
   2363              {
   2364                  return kStatus_FLASH_InvalidArgument;
   2365              }
   2366          
   2367              if ((config->EEpromTotalSize == 0) || (config->EEpromTotalSize == FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_RESERVED))
   2368              {
   2369                  return kStatus_FLASH_CommandNotSupported;
   2370              }
   2371          
   2372              FTFx->FEPROT = protectStatus;
   2373          
   2374              if (FTFx->FEPROT != protectStatus)
   2375              {
   2376                  return kStatus_FLASH_CommandFailure;
   2377              }
   2378          
   2379              return kStatus_FLASH_Success;
   2380          }
   2381          #endif /* FLASH_SSD_IS_FLEXNVM_ENABLED */
   2382          
   2383          #if FLASH_SSD_IS_FLEXNVM_ENABLED
   2384          status_t FLASH_EepromGetProtection(flash_config_t *config, uint8_t *protectStatus)
   2385          {
   2386              if ((config == NULL) || (protectStatus == NULL))
   2387              {
   2388                  return kStatus_FLASH_InvalidArgument;
   2389              }
   2390          
   2391              if ((config->EEpromTotalSize == 0) || (config->EEpromTotalSize == FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_RESERVED))
   2392              {
   2393                  return kStatus_FLASH_CommandNotSupported;
   2394              }
   2395          
   2396              *protectStatus = FTFx->FEPROT;
   2397          
   2398              return kStatus_FLASH_Success;
   2399          }
   2400          #endif /* FLASH_SSD_IS_FLEXNVM_ENABLED */
   2401          

   \                                 In section .text, align 2, keep-with-next
   2402          status_t FLASH_PflashSetPrefetchSpeculation(flash_prefetch_speculation_status_t *speculationStatus)
   2403          {
   2404          #if FLASH_PREFETCH_SPECULATION_IS_CONTROLLED_BY_MCM
   2405              {
   2406                  FTFx_REG32_ACCESS_TYPE regBase;
   2407          #if defined(MCM)
   2408                  regBase = (FTFx_REG32_ACCESS_TYPE)&MCM->PLACR;
   2409          #elif defined(MCM0)
   2410                  regBase = (FTFx_REG32_ACCESS_TYPE)&MCM0->PLACR;
   2411          #endif
   2412                  if (speculationStatus->instructionOption == kFLASH_prefetchSpeculationOptionDisable)
   2413                  {
   2414                      if (speculationStatus->dataOption == kFLASH_prefetchSpeculationOptionEnable)
   2415                      {
   2416                          return kStatus_FLASH_InvalidSpeculationOption;
   2417                      }
   2418                      else
   2419                      {
   2420                          *regBase |= MCM_PLACR_DFCS_MASK;
   2421                      }
   2422                  }
   2423                  else
   2424                  {
   2425                      *regBase &= ~MCM_PLACR_DFCS_MASK;
   2426                      if (speculationStatus->dataOption == kFLASH_prefetchSpeculationOptionEnable)
   2427                      {
   2428                          *regBase |= MCM_PLACR_EFDS_MASK;
   2429                      }
   2430                      else
   2431                      {
   2432                          *regBase &= ~MCM_PLACR_EFDS_MASK;
   2433                      }
   2434                  }
   2435              }
   2436          #elif FLASH_PREFETCH_SPECULATION_IS_CONTROLLED_BY_FMC
   2437              {
   2438                  FTFx_REG32_ACCESS_TYPE regBase;
   2439                  uint32_t b0dpeMask, b0ipeMask;
   2440          #if defined(FMC_PFB01CR_B0DPE_MASK)
   2441                  regBase = (FTFx_REG32_ACCESS_TYPE)&FMC->PFB01CR;
   2442                  b0dpeMask = FMC_PFB01CR_B0DPE_MASK;
   2443                  b0ipeMask = FMC_PFB01CR_B0IPE_MASK;
   2444          #elif defined(FMC_PFB0CR_B0DPE_MASK)
   2445                  regBase = (FTFx_REG32_ACCESS_TYPE)&FMC->PFB0CR;
   2446                  b0dpeMask = FMC_PFB0CR_B0DPE_MASK;
   2447                  b0ipeMask = FMC_PFB0CR_B0IPE_MASK;
   2448          #endif
   2449                  if (speculationStatus->instructionOption == kFLASH_prefetchSpeculationOptionEnable)
   \                     FLASH_PflashSetPrefetchSpeculation: (+1)
   \        0x0   0x7801             LDRB     R1,[R0, #+0]
   \        0x2   0x....             LDR.N    R2,??DataTable31_14  ;; 0x4001f004
   \        0x4   0xB921             CBNZ.N   R1,??FLASH_PflashSetPrefetchSpeculation_0
   2450                  {
   2451                      *regBase |= b0ipeMask;
   \        0x6   0x6813             LDR      R3,[R2, #+0]
   \        0x8   0xF043 0x0302      ORR      R3,R3,#0x2
   \        0xC   0x6013             STR      R3,[R2, #+0]
   \        0xE   0xE003             B.N      ??FLASH_PflashSetPrefetchSpeculation_1
   2452                  }
   2453                  else
   2454                  {
   2455                      *regBase &= ~b0ipeMask;
   \                     ??FLASH_PflashSetPrefetchSpeculation_0: (+1)
   \       0x10   0x6811             LDR      R1,[R2, #+0]
   \       0x12   0xF021 0x0102      BIC      R1,R1,#0x2
   \       0x16   0x6011             STR      R1,[R2, #+0]
   2456                  }
   2457                  if (speculationStatus->dataOption == kFLASH_prefetchSpeculationOptionEnable)
   \                     ??FLASH_PflashSetPrefetchSpeculation_1: (+1)
   \       0x18   0x7840             LDRB     R0,[R0, #+1]
   \       0x1A   0xB920             CBNZ.N   R0,??FLASH_PflashSetPrefetchSpeculation_2
   2458                  {
   2459                      *regBase |= b0dpeMask;
   \       0x1C   0x6811             LDR      R1,[R2, #+0]
   \       0x1E   0xF041 0x0104      ORR      R1,R1,#0x4
   \       0x22   0x6011             STR      R1,[R2, #+0]
   \       0x24   0xE003             B.N      ??FLASH_PflashSetPrefetchSpeculation_3
   2460                  }
   2461                  else
   2462                  {
   2463                      *regBase &= ~b0dpeMask;
   \                     ??FLASH_PflashSetPrefetchSpeculation_2: (+1)
   \       0x26   0x6810             LDR      R0,[R2, #+0]
   \       0x28   0xF020 0x0004      BIC      R0,R0,#0x4
   \       0x2C   0x6010             STR      R0,[R2, #+0]
   2464                  }
   2465          
   2466          /* Invalidate Prefetch Speculation Buffer */
   2467          #if defined(FMC_PFB01CR_S_INV_MASK)
   2468                  FMC->PFB01CR |= FMC_PFB01CR_S_INV_MASK;
   2469          #elif defined(FMC_PFB01CR_S_B_INV_MASK)
   2470                  FMC->PFB01CR |= FMC_PFB01CR_S_B_INV_MASK;
   2471          #elif defined(FMC_PFB0CR_S_INV_MASK)
   2472                  FMC->PFB0CR |= FMC_PFB0CR_S_INV_MASK;
   2473          #elif defined(FMC_PFB0CR_S_B_INV_MASK)
   2474                  FMC->PFB0CR |= FMC_PFB0CR_S_B_INV_MASK;
   2475          #endif
   2476              }
   2477          #elif FLASH_PREFETCH_SPECULATION_IS_CONTROLLED_BY_MSCM
   2478              {
   2479                  FTFx_REG32_ACCESS_TYPE regBase;
   2480                  uint32_t flashSpeculationMask, dataPrefetchMask;
   2481                  regBase = (FTFx_REG32_ACCESS_TYPE)&MSCM->OCMDR[0];
   2482                  flashSpeculationMask = MSCM_OCMDR_OCMC1_DFCS_MASK;
   2483                  dataPrefetchMask = MSCM_OCMDR_OCMC1_DFDS_MASK;
   2484          
   2485                  if (speculationStatus->instructionOption == kFLASH_prefetchSpeculationOptionDisable)
   2486                  {
   2487                      if (speculationStatus->dataOption == kFLASH_prefetchSpeculationOptionEnable)
   2488                      {
   2489                          return kStatus_FLASH_InvalidSpeculationOption;
   2490                      }
   2491                      else
   2492                      {
   2493                          *regBase |= flashSpeculationMask;
   2494                      }
   2495                  }
   2496                  else
   2497                  {
   2498                      *regBase &= ~flashSpeculationMask;
   2499                      if (speculationStatus->dataOption == kFLASH_prefetchSpeculationOptionEnable)
   2500                      {
   2501                          *regBase &= ~dataPrefetchMask;
   2502                      }
   2503                      else
   2504                      {
   2505                          *regBase |= dataPrefetchMask;
   2506                      }
   2507                  }
   2508              }
   2509          #endif /* FSL_FEATURE_FTFx_MCM_FLASH_CACHE_CONTROLS */
   2510          
   2511              return kStatus_FLASH_Success;
   \                     ??FLASH_PflashSetPrefetchSpeculation_3: (+1)
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x6811             LDR      R1,[R2, #+0]
   \       0x32   0xF441 0x2100      ORR      R1,R1,#0x80000
   \       0x36   0x6011             STR      R1,[R2, #+0]
   \       0x38   0x4770             BX       LR               ;; return
   2512          }
   2513          

   \                                 In section .text, align 2, keep-with-next
   2514          status_t FLASH_PflashGetPrefetchSpeculation(flash_prefetch_speculation_status_t *speculationStatus)
   2515          {
   2516              memset(speculationStatus, 0, sizeof(flash_prefetch_speculation_status_t));
   \                     FLASH_PflashGetPrefetchSpeculation: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x7001             STRB     R1,[R0, #+0]
   \        0x4   0x7041             STRB     R1,[R0, #+1]
   2517          
   2518              /* Assuming that all speculation options are enabled. */
   2519              speculationStatus->instructionOption = kFLASH_prefetchSpeculationOptionEnable;
   \        0x6   0x7001             STRB     R1,[R0, #+0]
   2520              speculationStatus->dataOption = kFLASH_prefetchSpeculationOptionEnable;
   \        0x8   0x7041             STRB     R1,[R0, #+1]
   2521          
   2522          #if FLASH_PREFETCH_SPECULATION_IS_CONTROLLED_BY_MCM
   2523              {
   2524                  uint32_t value;
   2525          #if defined(MCM)
   2526                  value = MCM->PLACR;
   2527          #elif defined(MCM0)
   2528                  value = MCM0->PLACR;
   2529          #endif
   2530                  if (value & MCM_PLACR_DFCS_MASK)
   2531                  {
   2532                      /* Speculation buffer is off. */
   2533                      speculationStatus->instructionOption = kFLASH_prefetchSpeculationOptionDisable;
   2534                      speculationStatus->dataOption = kFLASH_prefetchSpeculationOptionDisable;
   2535                  }
   2536                  else
   2537                  {
   2538                      /* Speculation buffer is on for instruction. */
   2539                      if (!(value & MCM_PLACR_EFDS_MASK))
   2540                      {
   2541                          /* Speculation buffer is off for data. */
   2542                          speculationStatus->dataOption = kFLASH_prefetchSpeculationOptionDisable;
   2543                      }
   2544                  }
   2545              }
   2546          #elif FLASH_PREFETCH_SPECULATION_IS_CONTROLLED_BY_FMC
   2547              {
   2548                  uint32_t value;
   2549                  uint32_t b0dpeMask, b0ipeMask;
   2550          #if defined(FMC_PFB01CR_B0DPE_MASK)
   2551                  value = FMC->PFB01CR;
   2552                  b0dpeMask = FMC_PFB01CR_B0DPE_MASK;
   2553                  b0ipeMask = FMC_PFB01CR_B0IPE_MASK;
   2554          #elif defined(FMC_PFB0CR_B0DPE_MASK)
   2555                  value = FMC->PFB0CR;
   \        0xA   0x....             LDR.N    R3,??DataTable31_14  ;; 0x4001f004
   \        0xC   0x6819             LDR      R1,[R3, #+0]
   2556                  b0dpeMask = FMC_PFB0CR_B0DPE_MASK;
   2557                  b0ipeMask = FMC_PFB0CR_B0IPE_MASK;
   2558          #endif
   2559                  if (!(value & b0dpeMask))
   \        0xE   0x074A             LSLS     R2,R1,#+29
   \       0x10   0xBF5C             ITT      PL 
   \       0x12   0x2301             MOVPL    R3,#+1
   \       0x14   0x7043             STRBPL   R3,[R0, #+1]
   2560                  {
   2561                      /* Do not prefetch in response to data references. */
   2562                      speculationStatus->dataOption = kFLASH_prefetchSpeculationOptionDisable;
   2563                  }
   2564                  if (!(value & b0ipeMask))
   \       0x16   0x0789             LSLS     R1,R1,#+30
   \       0x18   0xBF5C             ITT      PL 
   \       0x1A   0x2201             MOVPL    R2,#+1
   \       0x1C   0x7002             STRBPL   R2,[R0, #+0]
   2565                  {
   2566                      /* Do not prefetch in response to instruction fetches. */
   2567                      speculationStatus->instructionOption = kFLASH_prefetchSpeculationOptionDisable;
   2568                  }
   2569              }
   2570          #elif FLASH_PREFETCH_SPECULATION_IS_CONTROLLED_BY_MSCM
   2571              {
   2572                  uint32_t value;
   2573                  uint32_t flashSpeculationMask, dataPrefetchMask;
   2574                  value = MSCM->OCMDR[0];
   2575                  flashSpeculationMask = MSCM_OCMDR_OCMC1_DFCS_MASK;
   2576                  dataPrefetchMask = MSCM_OCMDR_OCMC1_DFDS_MASK;
   2577          
   2578                  if (value & flashSpeculationMask)
   2579                  {
   2580                      /* Speculation buffer is off. */
   2581                      speculationStatus->instructionOption = kFLASH_prefetchSpeculationOptionDisable;
   2582                      speculationStatus->dataOption = kFLASH_prefetchSpeculationOptionDisable;
   2583                  }
   2584                  else
   2585                  {
   2586                      /* Speculation buffer is on for instruction. */
   2587                      if (value & dataPrefetchMask)
   2588                      {
   2589                          /* Speculation buffer is off for data. */
   2590                          speculationStatus->dataOption = kFLASH_prefetchSpeculationOptionDisable;
   2591                      }
   2592                  }
   2593              }
   2594          #endif
   2595          
   2596              return kStatus_FLASH_Success;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x4770             BX       LR               ;; return
   2597          }
   2598          
   2599          #if FLASH_DRIVER_IS_FLASH_RESIDENT
   2600          /*!
   2601           * @brief Copy PIC of flash_run_command() to RAM
   2602           */
   2603          static void copy_flash_run_command(uint32_t *flashRunCommand)
   2604          {
   2605              assert(sizeof(s_flashRunCommandFunctionCode) <= (kFLASH_ExecuteInRamFunctionMaxSizeInWords * 4));
   2606          
   2607              /* Since the value of ARM function pointer is always odd, but the real start address
   2608               * of function memory should be even, that's why +1 operation exist. */
   2609              memcpy((void *)flashRunCommand, (void *)s_flashRunCommandFunctionCode, sizeof(s_flashRunCommandFunctionCode));
   2610              callFlashRunCommand = (void (*)(FTFx_REG8_ACCESS_TYPE ftfx_fstat))((uint32_t)flashRunCommand + 1);
   2611          }
   2612          #endif /* FLASH_DRIVER_IS_FLASH_RESIDENT */
   2613          
   2614          /*!
   2615           * @brief Flash Command Sequence
   2616           *
   2617           * This function is used to perform the command write sequence to the flash.
   2618           *
   2619           * @param driver Pointer to storage for the driver runtime state.
   2620           * @return An error code or kStatus_FLASH_Success
   2621           */

   \                                 In section .text, align 2, keep-with-next
   2622          static status_t flash_command_sequence(flash_config_t *config)
   2623          {
   \                     flash_command_sequence: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   2624              uint8_t registerValue;
   2625          
   2626          #if FLASH_DRIVER_IS_FLASH_RESIDENT
   2627              /* clear RDCOLERR & ACCERR & FPVIOL flag in flash status register */
   2628              FTFx->FSTAT = FTFx_FSTAT_RDCOLERR_MASK | FTFx_FSTAT_ACCERR_MASK | FTFx_FSTAT_FPVIOL_MASK;
   \        0x2   0x....             LDR.N    R4,??DataTable31_6  ;; 0x40020000
   \        0x4   0x2170             MOVS     R1,#+112
   \        0x6   0x7021             STRB     R1,[R4, #+0]
   2629          
   2630              status_t returnCode = flash_check_execute_in_ram_function_info(config);
   \        0x8   0xB908             CBNZ.N   R0,??flash_command_sequence_0
   \        0xA   0x2004             MOVS     R0,#+4
   \        0xC   0xBD10             POP      {R4,PC}
   \                     ??flash_command_sequence_0: (+1)
   \        0xE   0x69C0             LDR      R0,[R0, #+28]
   \       0x10   0xB168             CBZ.N    R0,??flash_command_sequence_1
   \       0x12   0x6800             LDR      R0,[R0, #+0]
   \       0x14   0x2802             CMP      R0,#+2
   \       0x16   0xD10A             BNE.N    ??flash_command_sequence_1
   2631              if (kStatus_FLASH_Success != returnCode)
   2632              {
   2633                  return returnCode;
   2634              }
   2635          
   2636              /* We pass the ftfx_fstat address as a parameter to flash_run_comamnd() instead of using
   2637               * pre-processed MICRO sentences or operating global variable in flash_run_comamnd()
   2638               * to make sure that flash_run_command() will be compiled into position-independent code (PIC). */
   2639              callFlashRunCommand((FTFx_REG8_ACCESS_TYPE)(&FTFx->FSTAT));
   \       0x18   0x....             LDR.N    R1,??DataTable31_2
   \       0x1A   0x680A             LDR      R2,[R1, #+0]
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x4790             BLX      R2
   2640          #else
   2641              /* clear RDCOLERR & ACCERR & FPVIOL flag in flash status register */
   2642              FTFx->FSTAT = FTFx_FSTAT_RDCOLERR_MASK | FTFx_FSTAT_ACCERR_MASK | FTFx_FSTAT_FPVIOL_MASK;
   2643          
   2644              /* clear CCIF bit */
   2645              FTFx->FSTAT = FTFx_FSTAT_CCIF_MASK;
   2646          
   2647              /* Check CCIF bit of the flash status register, wait till it is set.
   2648               * IP team indicates that this loop will always complete. */
   2649              while (!(FTFx->FSTAT & FTFx_FSTAT_CCIF_MASK))
   2650              {
   2651              }
   2652          #endif /* FLASH_DRIVER_IS_FLASH_RESIDENT */
   2653          
   2654              /* Check error bits */
   2655              /* Get flash status register value */
   2656              registerValue = FTFx->FSTAT;
   \       0x20   0x7820             LDRB     R0,[R4, #+0]
   2657          
   2658              /* checking access error */
   2659              if (registerValue & FTFx_FSTAT_ACCERR_MASK)
   \       0x22   0x0681             LSLS     R1,R0,#+26
   \       0x24   0xD405             BMI.N    ??flash_command_sequence_2
   2660              {
   2661                  return kStatus_FLASH_AccessError;
   2662              }
   2663              /* checking protection error */
   2664              else if (registerValue & FTFx_FSTAT_FPVIOL_MASK)
   \       0x26   0x06C2             LSLS     R2,R0,#+27
   \       0x28   0xD505             BPL.N    ??flash_command_sequence_3
   2665              {
   2666                  return kStatus_FLASH_ProtectionViolation;
   \       0x2A   0x2068             MOVS     R0,#+104
   \       0x2C   0xBD10             POP      {R4,PC}
   2667              }
   \                     ??flash_command_sequence_1: (+1)
   \       0x2E   0x206D             MOVS     R0,#+109
   \       0x30   0xBD10             POP      {R4,PC}
   \                     ??flash_command_sequence_2: (+1)
   \       0x32   0x2067             MOVS     R0,#+103
   \       0x34   0xBD10             POP      {R4,PC}
   2668              /* checking MGSTAT0 non-correctable error */
   2669              else if (registerValue & FTFx_FSTAT_MGSTAT0_MASK)
   \                     ??flash_command_sequence_3: (+1)
   \       0x36   0x07C0             LSLS     R0,R0,#+31
   \       0x38   0xD501             BPL.N    ??flash_command_sequence_4
   2670              {
   2671                  return kStatus_FLASH_CommandFailure;
   \       0x3A   0x2069             MOVS     R0,#+105
   \       0x3C   0xBD10             POP      {R4,PC}
   2672              }
   2673              else
   2674              {
   2675                  return kStatus_FLASH_Success;
   \                     ??flash_command_sequence_4: (+1)
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0xBD10             POP      {R4,PC}          ;; return
   2676              }
   2677          }
   2678          
   2679          #if FLASH_DRIVER_IS_FLASH_RESIDENT
   2680          /*!
   2681           * @brief Copy PIC of flash_common_bit_operation() to RAM
   2682           *
   2683           */
   2684          static void copy_flash_common_bit_operation(uint32_t *flashCommonBitOperation)
   2685          {
   2686              assert(sizeof(s_flashCommonBitOperationFunctionCode) <= (kFLASH_ExecuteInRamFunctionMaxSizeInWords * 4));
   2687          
   2688              /* Since the value of ARM function pointer is always odd, but the real start address
   2689               * of function memory should be even, that's why +1 operation exist. */
   2690              memcpy((void *)flashCommonBitOperation, (void *)s_flashCommonBitOperationFunctionCode,
   2691                     sizeof(s_flashCommonBitOperationFunctionCode));
   2692              callFlashCommonBitOperation = (void (*)(FTFx_REG32_ACCESS_TYPE base, uint32_t bitMask, uint32_t bitShift,
   2693                                                      uint32_t bitValue))((uint32_t)flashCommonBitOperation + 1);
   2694              /* Workround for some devices which doesn't need this function */
   2695              callFlashCommonBitOperation((FTFx_REG32_ACCESS_TYPE)0, 0, 0, 0);
   2696          }
   2697          #endif /* FLASH_DRIVER_IS_FLASH_RESIDENT */
   2698          
   2699          #if FLASH_CACHE_IS_CONTROLLED_BY_MCM
   2700          /*! @brief Performs the cache clear to the flash by MCM.*/
   2701          void mcm_flash_cache_clear(flash_config_t *config)
   2702          {
   2703              FTFx_REG32_ACCESS_TYPE regBase = (FTFx_REG32_ACCESS_TYPE)&MCM0_CACHE_REG;
   2704          
   2705          #if defined(MCM0) && defined(MCM1)
   2706              if (config->FlashCacheControllerIndex == (uint8_t)kFLASH_CacheControllerIndexForCore1)
   2707              {
   2708                  regBase = (FTFx_REG32_ACCESS_TYPE)&MCM1_CACHE_REG;
   2709              }
   2710          #endif
   2711          
   2712          #if FLASH_DRIVER_IS_FLASH_RESIDENT
   2713              callFlashCommonBitOperation(regBase, MCM_CACHE_CLEAR_MASK, MCM_CACHE_CLEAR_SHIFT, 1U);
   2714          #else  /* !FLASH_DRIVER_IS_FLASH_RESIDENT */
   2715              *regBase |= MCM_CACHE_CLEAR_MASK;
   2716          
   2717              /* Memory barriers for good measure.
   2718               * All Cache, Branch predictor and TLB maintenance operations before this instruction complete */
   2719              __ISB();
   2720              __DSB();
   2721          #endif /* FLASH_DRIVER_IS_FLASH_RESIDENT */
   2722          }
   2723          #endif /* FLASH_CACHE_IS_CONTROLLED_BY_MCM */
   2724          
   2725          #if FLASH_CACHE_IS_CONTROLLED_BY_FMC
   2726          /*! @brief Performs the cache clear to the flash by FMC.*/

   \                                 In section .text, align 2, keep-with-next
   2727          void fmc_flash_cache_clear(void)
   2728          {
   \                     fmc_flash_cache_clear: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   2729          #if FLASH_DRIVER_IS_FLASH_RESIDENT
   2730              FTFx_REG32_ACCESS_TYPE regBase = (FTFx_REG32_ACCESS_TYPE)0;
   2731          #if defined(FMC_PFB01CR_CINV_WAY_MASK)
   2732              regBase = (FTFx_REG32_ACCESS_TYPE)&FMC->PFB01CR;
   2733              callFlashCommonBitOperation(regBase, FMC_PFB01CR_CINV_WAY_MASK, FMC_PFB01CR_CINV_WAY_SHIFT, 0xFU);
   2734          #else
   2735              regBase = (FTFx_REG32_ACCESS_TYPE)&FMC->PFB0CR;
   2736              callFlashCommonBitOperation(regBase, FMC_PFB0CR_CINV_WAY_MASK, FMC_PFB0CR_CINV_WAY_SHIFT, 0xFU);
   \        0x2   0x....             LDR.N    R4,??DataTable31_2
   \        0x4   0x....             LDR.N    R0,??DataTable31_14  ;; 0x4001f004
   \        0x6   0x6865             LDR      R5,[R4, #+4]
   \        0x8   0x230F             MOVS     R3,#+15
   \        0xA   0x2214             MOVS     R2,#+20
   \        0xC   0xF44F 0x0170      MOV      R1,#+15728640
   \       0x10   0x47A8             BLX      R5
   2737          #endif
   2738          #else /* !FLASH_DRIVER_IS_FLASH_RESIDENT */
   2739          #if defined(FMC_PFB01CR_CINV_WAY_MASK)
   2740              FMC->PFB01CR = (FMC->PFB01CR & ~FMC_PFB01CR_CINV_WAY_MASK) | FMC_PFB01CR_CINV_WAY(~0);
   2741          #else
   2742              FMC->PFB0CR = (FMC->PFB0CR & ~FMC_PFB0CR_CINV_WAY_MASK) | FMC_PFB0CR_CINV_WAY(~0);
   2743          #endif
   2744              /* Memory barriers for good measure.
   2745               * All Cache, Branch predictor and TLB maintenance operations before this instruction complete */
   2746              __ISB();
   2747              __DSB();
   2748          #endif /* FLASH_DRIVER_IS_FLASH_RESIDENT */
   2749          }
   \       0x12   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2750          #endif /* FLASH_CACHE_IS_CONTROLLED_BY_FMC */
   2751          
   2752          #if FLASH_PREFETCH_SPECULATION_IS_CONTROLLED_BY_MSCM
   2753          /*! @brief Performs the prefetch speculation buffer clear to the flash by MSCM.*/
   2754          void mscm_flash_prefetch_speculation_enable(bool enable)
   2755          {
   2756              uint8_t setValue;
   2757              if (enable)
   2758              {
   2759                  setValue = 0x0U;
   2760              }
   2761              else
   2762              {
   2763                  setValue = 0x3U;
   2764              }
   2765          
   2766          /* The OCMDR[0] is always used to prefetch main Pflash*/
   2767          /* For device with FlexNVM support, the OCMDR[1] is used to prefetch Dflash.
   2768           * For device with secondary flash support, the OCMDR[1] is used to prefetch secondary Pflash. */
   2769          #if FLASH_DRIVER_IS_FLASH_RESIDENT
   2770              callFlashCommonBitOperation((FTFx_REG32_ACCESS_TYPE)&MSCM->OCMDR[0], MSCM_SPECULATION_DISABLE_MASK,
   2771                                          MSCM_SPECULATION_DISABLE_SHIFT, setValue);
   2772          #if FLASH_SSD_IS_FLEXNVM_ENABLED || BL_HAS_SECONDARY_INTERNAL_FLASH
   2773              callFlashCommonBitOperation((FTFx_REG32_ACCESS_TYPE)&MSCM->OCMDR[1], MSCM_SPECULATION_DISABLE_MASK,
   2774                                          MSCM_SPECULATION_DISABLE_SHIFT, setValue);
   2775          #endif
   2776          #else /* !FLASH_DRIVER_IS_FLASH_RESIDENT */
   2777              MSCM->OCMDR[0] |= MSCM_SPECULATION_DISABLE(setValue);
   2778          
   2779              /* Memory barriers for good measure.
   2780               * All Cache, Branch predictor and TLB maintenance operations before this instruction complete */
   2781              __ISB();
   2782              __DSB();
   2783          #if FLASH_SSD_IS_FLEXNVM_ENABLED || BL_HAS_SECONDARY_INTERNAL_FLASH
   2784              MSCM->OCMDR[1] |= MSCM_SPECULATION_DISABLE(setValue);
   2785          
   2786              /* Each cahce clear instaruction should be followed by below code*/
   2787              __ISB();
   2788              __DSB();
   2789          #endif
   2790          
   2791          #endif /* FLASH_DRIVER_IS_FLASH_RESIDENT */
   2792          }
   2793          #endif /* FLASH_PREFETCH_SPECULATION_IS_CONTROLLED_BY_MSCM */
   2794          
   2795          #if FLASH_PREFETCH_SPECULATION_IS_CONTROLLED_BY_FMC
   2796          /*! @brief Performs the prefetch speculation buffer clear to the flash by FMC.*/

   \                                 In section .text, align 2, keep-with-next
   2797          void fmc_flash_prefetch_speculation_clear(void)
   2798          {
   \                     fmc_flash_prefetch_speculation_clear: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   2799          #if FLASH_DRIVER_IS_FLASH_RESIDENT
   2800              FTFx_REG32_ACCESS_TYPE regBase = (FTFx_REG32_ACCESS_TYPE)0;
   2801          #if defined(FMC_PFB01CR_S_INV_MASK)
   2802              regBase = (FTFx_REG32_ACCESS_TYPE)&FMC->PFB01CR;
   2803              callFlashCommonBitOperation(regBase, FMC_PFB01CR_S_INV_MASK, FMC_PFB01CR_S_INV_SHIFT, 1U);
   2804          #elif defined(FMC_PFB01CR_S_B_INV_MASK)
   2805              regBase = (FTFx_REG32_ACCESS_TYPE)&FMC->PFB01CR;
   2806              callFlashCommonBitOperation(regBase, FMC_PFB01CR_S_B_INV_MASK, FMC_PFB01CR_S_B_INV_SHIFT, 1U);
   2807          #elif defined(FMC_PFB0CR_S_INV_MASK)
   2808              regBase = (FTFx_REG32_ACCESS_TYPE)&FMC->PFB0CR;
   2809              callFlashCommonBitOperation(regBase, FMC_PFB0CR_S_INV_MASK, FMC_PFB0CR_S_INV_SHIFT, 1U);
   2810          #elif defined(FMC_PFB0CR_S_B_INV_MASK)
   2811              regBase = (FTFx_REG32_ACCESS_TYPE)&FMC->PFB0CR;
   2812              callFlashCommonBitOperation(regBase, FMC_PFB0CR_S_B_INV_MASK, FMC_PFB0CR_S_B_INV_SHIFT, 1U);
   \        0x2   0x....             LDR.N    R4,??DataTable31_2
   \        0x4   0x....             LDR.N    R0,??DataTable31_14  ;; 0x4001f004
   \        0x6   0x6865             LDR      R5,[R4, #+4]
   \        0x8   0x2301             MOVS     R3,#+1
   \        0xA   0x2213             MOVS     R2,#+19
   \        0xC   0xF44F 0x2100      MOV      R1,#+524288
   \       0x10   0x47A8             BLX      R5
   2813          #endif
   2814          #else /* !FLASH_DRIVER_IS_FLASH_RESIDENT */
   2815          #if defined(FMC_PFB01CR_S_INV_MASK)
   2816              FMC->PFB01CR |= FMC_PFB01CR_S_INV_MASK;
   2817          #elif defined(FMC_PFB01CR_S_B_INV_MASK)
   2818              FMC->PFB01CR |= FMC_PFB01CR_S_B_INV_MASK;
   2819          #elif defined(FMC_PFB0CR_S_INV_MASK)
   2820              FMC->PFB0CR |= FMC_PFB0CR_S_INV_MASK;
   2821          #elif defined(FMC_PFB0CR_S_B_INV_MASK)
   2822              FMC->PFB0CR |= FMC_PFB0CR_S_B_INV_MASK;
   2823          #endif
   2824              /* Memory barriers for good measure.
   2825               * All Cache, Branch predictor and TLB maintenance operations before this instruction complete */
   2826              __ISB();
   2827              __DSB();
   2828          #endif /* FLASH_DRIVER_IS_FLASH_RESIDENT */
   2829          }
   \       0x12   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2830          #endif /* FLASH_PREFETCH_SPECULATION_IS_CONTROLLED_BY_FMC */
   2831          
   2832          /*!
   2833           * @brief Flash Cache Clear
   2834           *
   2835           * This function is used to perform the cache and prefetch speculation clear to the flash.
   2836           */

   \                                 In section .text, align 2, keep-with-next
   2837          void flash_cache_clear(flash_config_t *config)
   2838          {
   2839              flash_cache_clear_process(config, kFLASH_CacheClearProcessPost);
   \                     flash_cache_clear: (+1)
   \        0x0   0x2101             MOVS     R1,#+1
   \        0x2                      REQUIRE flash_cache_clear_process
   \        0x2                      ;; // Fall through to label flash_cache_clear_process
   2840          }
   2841          
   2842          /*!
   2843           * @brief Flash Cache Clear Process
   2844           *
   2845           * This function is used to perform the cache and prefetch speculation clear process to the flash.
   2846           */

   \                                 In section .text, align 2, keep-with-next
   2847          static void flash_cache_clear_process(flash_config_t *config, flash_cache_clear_process_t process)
   2848          {
   \                     flash_cache_clear_process: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD100             BNE.N    ??flash_cache_clear_process_0
   \        0x4   0x4770             BX       LR
   \                     ??flash_cache_clear_process_0: (+1)
   \        0x6   0xB570             PUSH     {R4-R6,LR}
   2849          #if FLASH_DRIVER_IS_FLASH_RESIDENT
   2850              status_t returnCode = flash_check_execute_in_ram_function_info(config);
   \        0x8   0x69C0             LDR      R0,[R0, #+28]
   \        0xA   0xB1A0             CBZ.N    R0,??flash_cache_clear_process_1
   \        0xC   0x6800             LDR      R0,[R0, #+0]
   \        0xE   0x2802             CMP      R0,#+2
   \       0x10   0xBF08             IT       EQ 
   \       0x12   0x2901             CMPEQ    R1,#+1
   2851              if (kStatus_FLASH_Success != returnCode)
   2852              {
   2853                  return;
   2854              }
   2855          #endif /* FLASH_DRIVER_IS_FLASH_RESIDENT */
   2856          
   2857              /* We pass the ftfx register address as a parameter to flash_common_bit_operation() instead of using
   2858               * pre-processed MACROs or a global variable in flash_common_bit_operation()
   2859               * to make sure that flash_common_bit_operation() will be compiled into position-independent code (PIC). */
   2860              if (process == kFLASH_CacheClearProcessPost)
   \       0x14   0xD10F             BNE.N    ??flash_cache_clear_process_1
   2861              {
   2862          #if FLASH_CACHE_IS_CONTROLLED_BY_MCM
   2863                  mcm_flash_cache_clear(config);
   2864          #endif
   2865          #if FLASH_CACHE_IS_CONTROLLED_BY_FMC
   2866                  fmc_flash_cache_clear();
   \       0x16   0x....             LDR.N    R4,??DataTable31_2
   \       0x18   0x....             LDR.N    R5,??DataTable31_14  ;; 0x4001f004
   \       0x1A   0x6866             LDR      R6,[R4, #+4]
   \       0x1C   0x230F             MOVS     R3,#+15
   \       0x1E   0x2214             MOVS     R2,#+20
   \       0x20   0xF44F 0x0170      MOV      R1,#+15728640
   \       0x24   0x4628             MOV      R0,R5
   \       0x26   0x47B0             BLX      R6
   2867          #endif
   2868          #if FLASH_PREFETCH_SPECULATION_IS_CONTROLLED_BY_MSCM
   2869                  mscm_flash_prefetch_speculation_enable(true);
   2870          #endif
   2871          #if FLASH_PREFETCH_SPECULATION_IS_CONTROLLED_BY_FMC
   2872                  fmc_flash_prefetch_speculation_clear();
   \       0x28   0x6864             LDR      R4,[R4, #+4]
   \       0x2A   0x2301             MOVS     R3,#+1
   \       0x2C   0x2213             MOVS     R2,#+19
   \       0x2E   0xF44F 0x2100      MOV      R1,#+524288
   \       0x32   0x4628             MOV      R0,R5
   \       0x34   0x47A0             BLX      R4
   2873          #endif
   2874              }
   2875              if (process == kFLASH_CacheClearProcessPre)
   2876              {
   2877          #if FLASH_PREFETCH_SPECULATION_IS_CONTROLLED_BY_MSCM
   2878                  mscm_flash_prefetch_speculation_enable(false);
   2879          #endif
   2880              }
   2881          }
   \                     ??flash_cache_clear_process_1: (+1)
   \       0x36   0xBD70             POP      {R4-R6,PC}       ;; return
   2882          
   2883          #if FLASH_DRIVER_IS_FLASH_RESIDENT
   2884          /*! @brief Check whether flash execute-in-ram functions are ready  */
   2885          static status_t flash_check_execute_in_ram_function_info(flash_config_t *config)
   2886          {
   2887              flash_execute_in_ram_function_config_t *flashExecuteInRamFunctionInfo;
   2888          
   2889              if (config == NULL)
   2890              {
   2891                  return kStatus_FLASH_InvalidArgument;
   2892              }
   2893          
   2894              flashExecuteInRamFunctionInfo = (flash_execute_in_ram_function_config_t *)config->flashExecuteInRamFunctionInfo;
   2895          
   2896              if ((config->flashExecuteInRamFunctionInfo) &&
   2897                  (kFLASH_ExecuteInRamFunctionTotalNum == flashExecuteInRamFunctionInfo->activeFunctionCount))
   2898              {
   2899                  return kStatus_FLASH_Success;
   2900              }
   2901          
   2902              return kStatus_FLASH_ExecuteInRamFunctionNotReady;
   2903          }
   2904          #endif /* FLASH_DRIVER_IS_FLASH_RESIDENT */
   2905          
   2906          /*! @brief Validates the range and alignment of the given address range.*/

   \                                 In section .text, align 2, keep-with-next
   2907          static status_t flash_check_range(flash_config_t *config,
   2908                                            uint32_t startAddress,
   2909                                            uint32_t lengthInBytes,
   2910                                            uint32_t alignmentBaseline)
   2911          {
   2912              if (config == NULL)
   \                     flash_check_range: (+1)
   \        0x0   0xB908             CBNZ.N   R0,??flash_check_range_0
   2913              {
   2914                  return kStatus_FLASH_InvalidArgument;
   \        0x2   0x2004             MOVS     R0,#+4
   \        0x4   0x4770             BX       LR
   2915              }
   2916          
   2917              /* Verify the start and length are alignmentBaseline aligned. */
   2918              if ((startAddress & (alignmentBaseline - 1)) || (lengthInBytes & (alignmentBaseline - 1)))
   \                     ??flash_check_range_0: (+1)
   \        0x6   0x1E5B             SUBS     R3,R3,#+1
   \        0x8   0x4219             TST      R1,R3
   \        0xA   0xBF08             IT       EQ 
   \        0xC   0x421A             TSTEQ    R2,R3
   \        0xE   0xD001             BEQ.N    ??flash_check_range_1
   2919              {
   2920                  return kStatus_FLASH_AlignmentError;
   \       0x10   0x2065             MOVS     R0,#+101
   \       0x12   0x4770             BX       LR
   2921              }
   2922          
   2923              /* check for valid range of the target addresses */
   2924              if (
   2925          #if FLASH_SSD_IS_FLEXNVM_ENABLED
   2926                  ((startAddress >= config->DFlashBlockBase) &&
   2927                   ((startAddress + lengthInBytes) <= (config->DFlashBlockBase + config->DFlashTotalSize))) ||
   2928          #endif
   2929                  ((startAddress >= config->PFlashBlockBase) &&
   2930                   ((startAddress + lengthInBytes) <= (config->PFlashBlockBase + config->PFlashTotalSize))))
   \                     ??flash_check_range_1: (+1)
   \       0x14   0x6803             LDR      R3,[R0, #+0]
   \       0x16   0x4299             CMP      R1,R3
   \       0x18   0xBF21             ITTTT    CS 
   \       0x1A   0x6840             LDRCS    R0,[R0, #+4]
   \       0x1C   0x18C3             ADDCS    R3,R0,R3
   \       0x1E   0x1851             ADDCS    R1,R2,R1
   \       0x20   0x428B             CMPCS    R3,R1
   \       0x22   0xD301             BCC.N    ??flash_check_range_2
   2931              {
   2932                  return kStatus_FLASH_Success;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x4770             BX       LR
   2933              }
   2934          
   2935              return kStatus_FLASH_AddressError;
   \                     ??flash_check_range_2: (+1)
   \       0x28   0x2066             MOVS     R0,#+102
   \       0x2A   0x4770             BX       LR               ;; return
   2936          }
   2937          
   2938          /*! @brief Gets the right address, sector and block size of current flash type which is indicated by address.*/

   \                                 In section .text, align 2, keep-with-next
   2939          static status_t flash_get_matched_operation_info(flash_config_t *config,
   2940                                                           uint32_t address,
   2941                                                           flash_operation_config_t *info)
   2942          {
   \                     flash_get_matched_operation_info: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x460E             MOV      R6,R1
   \        0x6   0x4615             MOV      R5,R2
   2943              if (config == NULL)
   \        0x8   0xD101             BNE.N    ??flash_get_matched_operation_info_0
   2944              {
   2945                  return kStatus_FLASH_InvalidArgument;
   \        0xA   0x2004             MOVS     R0,#+4
   \        0xC   0xBD70             POP      {R4-R6,PC}
   2946              }
   2947          
   2948              /* Clean up info Structure*/
   2949              memset(info, 0, sizeof(flash_operation_config_t));
   \                     ??flash_get_matched_operation_info_0: (+1)
   \        0xE   0x2120             MOVS     R1,#+32
   \       0x10   0x4628             MOV      R0,R5
   \       0x12   0x.... 0x....      BL       __aeabi_memclr4
   2950          
   2951          #if FLASH_SSD_IS_FLEXNVM_ENABLED
   2952              if ((address >= config->DFlashBlockBase) && (address <= (config->DFlashBlockBase + config->DFlashTotalSize)))
   2953              {
   2954                  /* When required by the command, address bit 23 selects between program flash memory
   2955                   * (=0) and data flash memory (=1).*/
   2956                  info->convertedAddress = address - config->DFlashBlockBase + 0x800000U;
   2957                  info->activeSectorSize = FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_SECTOR_SIZE;
   2958                  info->activeBlockSize = config->DFlashTotalSize / FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_COUNT;
   2959          
   2960                  info->blockWriteUnitSize = FSL_FEATURE_FLASH_FLEX_NVM_BLOCK_WRITE_UNIT_SIZE;
   2961                  info->sectorCmdAddressAligment = FSL_FEATURE_FLASH_FLEX_NVM_SECTOR_CMD_ADDRESS_ALIGMENT;
   2962                  info->sectionCmdAddressAligment = FSL_FEATURE_FLASH_FLEX_NVM_SECTION_CMD_ADDRESS_ALIGMENT;
   2963                  info->resourceCmdAddressAligment = FSL_FEATURE_FLASH_FLEX_NVM_RESOURCE_CMD_ADDRESS_ALIGMENT;
   2964                  info->checkCmdAddressAligment = FSL_FEATURE_FLASH_FLEX_NVM_CHECK_CMD_ADDRESS_ALIGMENT;
   2965              }
   2966              else
   2967          #endif /* FLASH_SSD_IS_FLEXNVM_ENABLED */
   2968              {
   2969                  info->convertedAddress = address - config->PFlashBlockBase;
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x1A36             SUBS     R6,R6,R0
   \       0x1A   0x602E             STR      R6,[R5, #+0]
   2970                  info->activeSectorSize = config->PFlashSectorSize;
   \       0x1C   0x68E1             LDR      R1,[R4, #+12]
   \       0x1E   0x6069             STR      R1,[R5, #+4]
   2971                  info->activeBlockSize = config->PFlashTotalSize / config->PFlashBlockCount;
   \       0x20   0x6860             LDR      R0,[R4, #+4]
   \       0x22   0x7A21             LDRB     R1,[R4, #+8]
   \       0x24   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \       0x28   0x60A9             STR      R1,[R5, #+8]
   2972          #if FLASH_SSD_IS_SECONDARY_FLASH_ENABLED
   2973                  if (config->FlashMemoryIndex == (uint8_t)kFLASH_MemoryIndexSecondaryFlash)
   2974                  {
   2975          #if FLASH_SSD_SECONDARY_FLASH_HAS_ITS_OWN_PROTECTION_REGISTER || FLASH_SSD_SECONDARY_FLASH_HAS_ITS_OWN_ACCESS_REGISTER
   2976                      /* When required by the command, address bit 23 selects between main flash memory
   2977                       * (=0) and secondary flash memory (=1).*/
   2978                      info->convertedAddress += 0x800000U;
   2979          #endif
   2980                      info->blockWriteUnitSize = FSL_FEATURE_FLASH_PFLASH_1_BLOCK_WRITE_UNIT_SIZE;
   2981                  }
   2982                  else
   2983          #endif /* FLASH_SSD_IS_SECONDARY_FLASH_ENABLED */
   2984                  {
   2985                      info->blockWriteUnitSize = FSL_FEATURE_FLASH_PFLASH_BLOCK_WRITE_UNIT_SIZE;
   \       0x2A   0x2004             MOVS     R0,#+4
   2986                  }
   2987          
   2988                  info->sectorCmdAddressAligment = FSL_FEATURE_FLASH_PFLASH_SECTOR_CMD_ADDRESS_ALIGMENT;
   \       0x2C   0x2108             MOVS     R1,#+8
   \       0x2E   0x6129             STR      R1,[R5, #+16]
   2989                  info->sectionCmdAddressAligment = FSL_FEATURE_FLASH_PFLASH_SECTION_CMD_ADDRESS_ALIGMENT;
   \       0x30   0x6169             STR      R1,[R5, #+20]
   \       0x32   0x60E8             STR      R0,[R5, #+12]
   2990                  info->resourceCmdAddressAligment = FSL_FEATURE_FLASH_PFLASH_RESOURCE_CMD_ADDRESS_ALIGMENT;
   \       0x34   0x2104             MOVS     R1,#+4
   \       0x36   0x61A9             STR      R1,[R5, #+24]
   2991                  info->checkCmdAddressAligment = FSL_FEATURE_FLASH_PFLASH_CHECK_CMD_ADDRESS_ALIGMENT;
   \       0x38   0x61E9             STR      R1,[R5, #+28]
   2992              }
   2993          
   2994              return kStatus_FLASH_Success;
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0xBD70             POP      {R4-R6,PC}       ;; return
   2995          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \        0x0   0x4004'804C        DC32     0x4004804c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_1:
   \        0x0   0x....'....        DC32     s_flashExecuteInRamFunctionInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_2:
   \        0x0   0x....'....        DC32     callFlashRunCommand

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_3:
   \        0x0   0x4002'0004        DC32     0x40020004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_4:
   \        0x0   0x6B65'666B        DC32     0x6b65666b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_5:
   \        0x0   0x4300'FFFF        DC32     0x4300ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_6:
   \        0x0   0x4002'0000        DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_7:
   \        0x0   0x0002'0100        DC32     0x20100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_8:
   \        0x0   0x0080'0400        DC32     0x800400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_9:
   \        0x0   0x4100'FFFF        DC32     0x4100ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_10:
   \        0x0   0x4002'0002        DC32     0x40020002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_11:
   \        0x0   0x4000'FFFF        DC32     0x4000ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_12:
   \        0x0   0x4A00'FFFF        DC32     0x4a00ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_13:
   \        0x0   0x4002'0010        DC32     0x40020010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_14:
   \        0x0   0x4001'F004        DC32     0x4001f004
   2996          
   2997          /*! @brief Validates the given user key for flash erase APIs.*/
   2998          static status_t flash_check_user_key(uint32_t key)
   2999          {
   3000              /* Validate the user key */
   3001              if (key != kFLASH_ApiEraseKey)
   3002              {
   3003                  return kStatus_FLASH_EraseKeyError;
   3004              }
   3005          
   3006              return kStatus_FLASH_Success;
   3007          }
   3008          
   3009          #if FLASH_SSD_IS_FLEXNVM_ENABLED
   3010          /*! @brief Updates FlexNVM memory partition status according to data flash 0 IFR.*/
   3011          static status_t flash_update_flexnvm_memory_partition_status(flash_config_t *config)
   3012          {
   3013              struct
   3014              {
   3015                  uint32_t reserved0;
   3016                  uint8_t FlexNVMPartitionCode;
   3017                  uint8_t EEPROMDataSetSize;
   3018                  uint16_t reserved1;
   3019              } dataIFRReadOut;
   3020              status_t returnCode;
   3021          
   3022              if (config == NULL)
   3023              {
   3024                  return kStatus_FLASH_InvalidArgument;
   3025              }
   3026          
   3027          #if defined(FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD) && FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD
   3028              /* Get FlexNVM memory partition info from data flash IFR */
   3029              returnCode = FLASH_ReadResource(config, DFLASH_IFR_READRESOURCE_START_ADDRESS, (uint32_t *)&dataIFRReadOut,
   3030                                              sizeof(dataIFRReadOut), kFLASH_ResourceOptionFlashIfr);
   3031              if (returnCode != kStatus_FLASH_Success)
   3032              {
   3033                  return kStatus_FLASH_PartitionStatusUpdateFailure;
   3034              }
   3035          #else
   3036          #error "Cannot get FlexNVM memory partition info"
   3037          #endif
   3038          
   3039              /* Fill out partitioned EEPROM size */
   3040              dataIFRReadOut.EEPROMDataSetSize &= 0x0FU;
   3041              switch (dataIFRReadOut.EEPROMDataSetSize)
   3042              {
   3043                  case 0x00U:
   3044                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0000;
   3045                      break;
   3046                  case 0x01U:
   3047                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0001;
   3048                      break;
   3049                  case 0x02U:
   3050                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0010;
   3051                      break;
   3052                  case 0x03U:
   3053                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0011;
   3054                      break;
   3055                  case 0x04U:
   3056                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0100;
   3057                      break;
   3058                  case 0x05U:
   3059                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0101;
   3060                      break;
   3061                  case 0x06U:
   3062                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0110;
   3063                      break;
   3064                  case 0x07U:
   3065                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_0111;
   3066                      break;
   3067                  case 0x08U:
   3068                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1000;
   3069                      break;
   3070                  case 0x09U:
   3071                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1001;
   3072                      break;
   3073                  case 0x0AU:
   3074                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1010;
   3075                      break;
   3076                  case 0x0BU:
   3077                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1011;
   3078                      break;
   3079                  case 0x0CU:
   3080                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1100;
   3081                      break;
   3082                  case 0x0DU:
   3083                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1101;
   3084                      break;
   3085                  case 0x0EU:
   3086                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1110;
   3087                      break;
   3088                  case 0x0FU:
   3089                      config->EEpromTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_1111;
   3090                      break;
   3091                  default:
   3092                      config->EEpromTotalSize = FLEX_NVM_EEPROM_SIZE_FOR_EEESIZE_RESERVED;
   3093                      break;
   3094              }
   3095          
   3096              /* Fill out partitioned DFlash size */
   3097              dataIFRReadOut.FlexNVMPartitionCode &= 0x0FU;
   3098              switch (dataIFRReadOut.FlexNVMPartitionCode)
   3099              {
   3100                  case 0x00U:
   3101          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0000 != 0xFFFFFFFF)
   3102                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0000;
   3103          #else
   3104                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   3105          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0000 */
   3106                      break;
   3107                  case 0x01U:
   3108          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0001 != 0xFFFFFFFF)
   3109                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0001;
   3110          #else
   3111                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   3112          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0001 */
   3113                      break;
   3114                  case 0x02U:
   3115          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0010 != 0xFFFFFFFF)
   3116                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0010;
   3117          #else
   3118                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   3119          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0010 */
   3120                      break;
   3121                  case 0x03U:
   3122          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0011 != 0xFFFFFFFF)
   3123                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0011;
   3124          #else
   3125                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   3126          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0011 */
   3127                      break;
   3128                  case 0x04U:
   3129          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0100 != 0xFFFFFFFF)
   3130                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0100;
   3131          #else
   3132                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   3133          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0100 */
   3134                      break;
   3135                  case 0x05U:
   3136          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0101 != 0xFFFFFFFF)
   3137                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0101;
   3138          #else
   3139                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   3140          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0101 */
   3141                      break;
   3142                  case 0x06U:
   3143          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0110 != 0xFFFFFFFF)
   3144                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0110;
   3145          #else
   3146                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   3147          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0110 */
   3148                      break;
   3149                  case 0x07U:
   3150          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0111 != 0xFFFFFFFF)
   3151                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0111;
   3152          #else
   3153                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   3154          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_0111 */
   3155                      break;
   3156                  case 0x08U:
   3157          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1000 != 0xFFFFFFFF)
   3158                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1000;
   3159          #else
   3160                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   3161          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1000 */
   3162                      break;
   3163                  case 0x09U:
   3164          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1001 != 0xFFFFFFFF)
   3165                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1001;
   3166          #else
   3167                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   3168          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1001 */
   3169                      break;
   3170                  case 0x0AU:
   3171          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1010 != 0xFFFFFFFF)
   3172                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1010;
   3173          #else
   3174                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   3175          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1010 */
   3176                      break;
   3177                  case 0x0BU:
   3178          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1011 != 0xFFFFFFFF)
   3179                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1011;
   3180          #else
   3181                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   3182          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1011 */
   3183                      break;
   3184                  case 0x0CU:
   3185          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1100 != 0xFFFFFFFF)
   3186                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1100;
   3187          #else
   3188                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   3189          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1100 */
   3190                      break;
   3191                  case 0x0DU:
   3192          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1101 != 0xFFFFFFFF)
   3193                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1101;
   3194          #else
   3195                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   3196          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1101 */
   3197                      break;
   3198                  case 0x0EU:
   3199          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1110 != 0xFFFFFFFF)
   3200                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1110;
   3201          #else
   3202                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   3203          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1110 */
   3204                      break;
   3205                  case 0x0FU:
   3206          #if (FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1111 != 0xFFFFFFFF)
   3207                      config->DFlashTotalSize = FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1111;
   3208          #else
   3209                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   3210          #endif /* FSL_FEATURE_FLASH_FLEX_NVM_DFLASH_SIZE_FOR_DEPART_1111 */
   3211                      break;
   3212                  default:
   3213                      config->DFlashTotalSize = FLEX_NVM_DFLASH_SIZE_FOR_DEPART_RESERVED;
   3214                      break;
   3215              }
   3216          
   3217              return kStatus_FLASH_Success;
   3218          }
   3219          #endif /* FLASH_SSD_IS_FLEXNVM_ENABLED */
   3220          
   3221          #if defined(FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD) && FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD
   3222          /*! @brief Validates the range of the given resource address.*/
   3223          static status_t flash_check_resource_range(uint32_t start,
   3224                                                     uint32_t lengthInBytes,
   3225                                                     uint32_t alignmentBaseline,
   3226                                                     flash_read_resource_option_t option)
   3227          {
   3228              status_t status;
   3229              uint32_t maxReadbleAddress;
   3230          
   3231              if ((start & (alignmentBaseline - 1)) || (lengthInBytes & (alignmentBaseline - 1)))
   3232              {
   3233                  return kStatus_FLASH_AlignmentError;
   3234              }
   3235          
   3236              status = kStatus_FLASH_Success;
   3237          
   3238              maxReadbleAddress = start + lengthInBytes - 1;
   3239              if (option == kFLASH_ResourceOptionVersionId)
   3240              {
   3241                  if ((start != kFLASH_ResourceRangeVersionIdStart) ||
   3242                      ((start + lengthInBytes - 1) != kFLASH_ResourceRangeVersionIdEnd))
   3243                  {
   3244                      status = kStatus_FLASH_InvalidArgument;
   3245                  }
   3246              }
   3247              else if (option == kFLASH_ResourceOptionFlashIfr)
   3248              {
   3249                  if (maxReadbleAddress < kFLASH_ResourceRangePflashIfrSizeInBytes)
   3250                  {
   3251                  }
   3252          #if defined(FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP) && FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP
   3253                  else if ((start >= kFLASH_ResourceRangePflashSwapIfrStart) &&
   3254                           (maxReadbleAddress <= kFLASH_ResourceRangePflashSwapIfrEnd))
   3255                  {
   3256                  }
   3257          #endif /* FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP */
   3258                  else if ((start >= kFLASH_ResourceRangeDflashIfrStart) &&
   3259                           (maxReadbleAddress <= kFLASH_ResourceRangeDflashIfrEnd))
   3260                  {
   3261                  }
   3262                  else
   3263                  {
   3264                      status = kStatus_FLASH_InvalidArgument;
   3265                  }
   3266              }
   3267              else
   3268              {
   3269                  status = kStatus_FLASH_InvalidArgument;
   3270              }
   3271          
   3272              return status;
   3273          }
   3274          #endif /* FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD */
   3275          
   3276          #if defined(FSL_FEATURE_FLASH_HAS_SWAP_CONTROL_CMD) && FSL_FEATURE_FLASH_HAS_SWAP_CONTROL_CMD
   3277          /*! @brief Validates the gived swap control option.*/
   3278          static status_t flash_check_swap_control_option(flash_swap_control_option_t option)
   3279          {
   3280              if ((option == kFLASH_SwapControlOptionIntializeSystem) || (option == kFLASH_SwapControlOptionSetInUpdateState) ||
   3281                  (option == kFLASH_SwapControlOptionSetInCompleteState) || (option == kFLASH_SwapControlOptionReportStatus) ||
   3282                  (option == kFLASH_SwapControlOptionDisableSystem))
   3283              {
   3284                  return kStatus_FLASH_Success;
   3285              }
   3286          
   3287              return kStatus_FLASH_InvalidArgument;
   3288          }
   3289          #endif /* FSL_FEATURE_FLASH_HAS_SWAP_CONTROL_CMD */
   3290          
   3291          #if defined(FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP) && FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP
   3292          /*! @brief Validates the gived address to see if it is equal to swap indicator address in pflash swap IFR.*/
   3293          static status_t flash_validate_swap_indicator_address(flash_config_t *config, uint32_t address)
   3294          {
   3295              flash_swap_ifr_field_data_t flashSwapIfrFieldData;
   3296              uint32_t swapIndicatorAddress;
   3297          
   3298              status_t returnCode;
   3299          #if defined(FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD) && FSL_FEATURE_FLASH_HAS_READ_RESOURCE_CMD
   3300              returnCode =
   3301                  FLASH_ReadResource(config, kFLASH_ResourceRangePflashSwapIfrStart, flashSwapIfrFieldData.flashSwapIfrData,
   3302                                     sizeof(flashSwapIfrFieldData.flashSwapIfrData), kFLASH_ResourceOptionFlashIfr);
   3303          
   3304              if (returnCode != kStatus_FLASH_Success)
   3305              {
   3306                  return returnCode;
   3307              }
   3308          #else
   3309              {
   3310                  /* From RM, the actual info are stored in FCCOB6,7 */
   3311                  uint32_t returnValue[2];
   3312                  returnCode = FLASH_ReadOnce(config, kFLASH_RecordIndexSwapAddr, returnValue, 4);
   3313                  if (returnCode != kStatus_FLASH_Success)
   3314                  {
   3315                      return returnCode;
   3316                  }
   3317                  flashSwapIfrFieldData.flashSwapIfrField.swapIndicatorAddress = (uint16_t)returnValue[0];
   3318                  returnCode = FLASH_ReadOnce(config, kFLASH_RecordIndexSwapEnable, returnValue, 4);
   3319                  if (returnCode != kStatus_FLASH_Success)
   3320                  {
   3321                      return returnCode;
   3322                  }
   3323                  flashSwapIfrFieldData.flashSwapIfrField.swapEnableWord = (uint16_t)returnValue[0];
   3324                  returnCode = FLASH_ReadOnce(config, kFLASH_RecordIndexSwapDisable, returnValue, 4);
   3325                  if (returnCode != kStatus_FLASH_Success)
   3326                  {
   3327                      return returnCode;
   3328                  }
   3329                  flashSwapIfrFieldData.flashSwapIfrField.swapDisableWord = (uint16_t)returnValue[0];
   3330              }
   3331          #endif
   3332          
   3333              /* The high bits value of Swap Indicator Address is stored in Program Flash Swap IFR Field,
   3334               * the low severval bit value of Swap Indicator Address is always 1'b0 */
   3335              swapIndicatorAddress = (uint32_t)flashSwapIfrFieldData.flashSwapIfrField.swapIndicatorAddress *
   3336                                     FSL_FEATURE_FLASH_PFLASH_SWAP_CONTROL_CMD_ADDRESS_ALIGMENT;
   3337              if (address != swapIndicatorAddress)
   3338              {
   3339                  return kStatus_FLASH_SwapIndicatorAddressError;
   3340              }
   3341          
   3342              return returnCode;
   3343          }
   3344          #endif /* FSL_FEATURE_FLASH_HAS_PFLASH_BLOCK_SWAP */
   3345          
   3346          #if defined(FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD) && FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD
   3347          /*! @brief Validates the gived flexram function option.*/
   3348          static inline status_t flasn_check_flexram_function_option_range(flash_flexram_function_option_t option)
   3349          {
   3350              if ((option != kFLASH_FlexramFunctionOptionAvailableAsRam) &&
   3351                  (option != kFLASH_FlexramFunctionOptionAvailableForEeprom))
   3352              {
   3353                  return kStatus_FLASH_InvalidArgument;
   3354              }
   3355          
   3356              return kStatus_FLASH_Success;
   3357          }
   3358          #endif /* FSL_FEATURE_FLASH_HAS_SET_FLEXRAM_FUNCTION_CMD */
   3359          
   3360          /*! @brief Gets the flash protection information (region size, region count).*/
   3361          static status_t flash_get_protection_info(flash_config_t *config, flash_protection_config_t *info)
   3362          {
   3363              uint32_t pflashTotalSize;
   3364          
   3365              if (config == NULL)
   3366              {
   3367                  return kStatus_FLASH_InvalidArgument;
   3368              }
   3369          
   3370              /* Clean up info Structure*/
   3371              memset(info, 0, sizeof(flash_protection_config_t));
   3372          
   3373          /* Note: KW40 has a secondary flash, but it doesn't have independent protection register*/
   3374          #if FLASH_SSD_IS_SECONDARY_FLASH_ENABLED && (!FLASH_SSD_SECONDARY_FLASH_HAS_ITS_OWN_PROTECTION_REGISTER)
   3375              pflashTotalSize = FSL_FEATURE_FLASH_PFLASH_BLOCK_COUNT * FSL_FEATURE_FLASH_PFLASH_BLOCK_SIZE +
   3376                                FSL_FEATURE_FLASH_PFLASH_1_BLOCK_COUNT * FSL_FEATURE_FLASH_PFLASH_1_BLOCK_SIZE;
   3377              info->regionBase = FSL_FEATURE_FLASH_PFLASH_START_ADDRESS;
   3378          #else
   3379              pflashTotalSize = config->PFlashTotalSize;
   3380              info->regionBase = config->PFlashBlockBase;
   3381          #endif
   3382          
   3383          #if FLASH_SSD_IS_SECONDARY_FLASH_ENABLED && FLASH_SSD_SECONDARY_FLASH_HAS_ITS_OWN_PROTECTION_REGISTER
   3384              if (config->FlashMemoryIndex == (uint8_t)kFLASH_MemoryIndexSecondaryFlash)
   3385              {
   3386                  info->regionCount = FSL_FEATURE_FLASH_PFLASH_1_PROTECTION_REGION_COUNT;
   3387              }
   3388              else
   3389          #endif
   3390              {
   3391                  info->regionCount = FSL_FEATURE_FLASH_PFLASH_PROTECTION_REGION_COUNT;
   3392              }
   3393          
   3394              /* Calculate the size of the flash protection region
   3395               * If the flash density is > 32KB, then protection region is 1/32 of total flash density
   3396               * Else if flash density is < 32KB, then flash protection region is set to 1KB */
   3397              if (pflashTotalSize > info->regionCount * 1024)
   3398              {
   3399                  info->regionSize = (pflashTotalSize) / info->regionCount;
   3400              }
   3401              else
   3402              {
   3403                  info->regionSize = 1024;
   3404              }
   3405          
   3406              return kStatus_FLASH_Success;
   3407          }
   3408          
   3409          #if defined(FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL) && FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL
   3410          /*! @brief Gets the flash Execute-Only access information (Segment size, Segment count).*/
   3411          static status_t flash_get_access_info(flash_config_t *config, flash_access_config_t *info)
   3412          {
   3413              if (config == NULL)
   3414              {
   3415                  return kStatus_FLASH_InvalidArgument;
   3416              }
   3417          
   3418              /* Clean up info Structure*/
   3419              memset(info, 0, sizeof(flash_access_config_t));
   3420          
   3421          /* Note: KW40 has a secondary flash, but it doesn't have independent access register*/
   3422          #if FLASH_SSD_IS_SECONDARY_FLASH_ENABLED && (!FLASH_SSD_SECONDARY_FLASH_HAS_ITS_OWN_ACCESS_REGISTER)
   3423              info->SegmentBase = FSL_FEATURE_FLASH_PFLASH_START_ADDRESS;
   3424          #else
   3425              info->SegmentBase = config->PFlashBlockBase;
   3426          #endif
   3427              info->SegmentSize = config->PFlashAccessSegmentSize;
   3428              info->SegmentCount = config->PFlashAccessSegmentCount;
   3429          
   3430              return kStatus_FLASH_Success;
   3431          }
   3432          #endif /* FSL_FEATURE_FLASH_HAS_ACCESS_CONTROL */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      64   FLASH_Erase
        64   -- Indirect call
        64   -> flash_cache_clear_process
        64   -> flash_check_range
        64   -> flash_command_sequence
        64   -> flash_get_matched_operation_info
      16   FLASH_EraseAll
        16   -> flash_cache_clear_process
        16   -> flash_command_sequence
      16   FLASH_EraseAllExecuteOnlySegments
        16   -> flash_cache_clear_process
        16   -> flash_command_sequence
       0   FLASH_GetProperty
       0   FLASH_GetSecurityState
       8   FLASH_Init
         8   -> FLASH_PrepareExecuteInRamFunctions
       0   FLASH_IsExecuteOnly
     200   FLASH_IsProtected
       200   -> flash_check_range
       0   FLASH_PflashGetPrefetchSpeculation
       0   FLASH_PflashGetProtection
       0   FLASH_PflashSetPrefetchSpeculation
       0   FLASH_PflashSetProtection
      16   FLASH_PrepareExecuteInRamFunctions
        16   -- Indirect call
        16   -> __aeabi_memcpy
      64   FLASH_Program
        64   -- Indirect call
        64   -> flash_cache_clear_process
        64   -> flash_check_range
        64   -> flash_command_sequence
        64   -> flash_get_matched_operation_info
      16   FLASH_ProgramOnce
        16   -> flash_cache_clear_process
        16   -> flash_command_sequence
      80   FLASH_ProgramSection
        80   -- Indirect call
        80   -> __aeabi_memcpy
        80   -> flash_cache_clear_process
        80   -> flash_check_range
        80   -> flash_get_matched_operation_info
      16   FLASH_ReadOnce
        16   -> flash_command_sequence
      64   FLASH_ReadResource
        64   -> flash_command_sequence
        64   -> flash_get_matched_operation_info
      16   FLASH_SecurityBypass
        16   -> flash_command_sequence
       0   FLASH_SetCallback
       0   FLASH_SetProperty
      56   FLASH_Swap
        56   -> FLASH_Erase
        56   -> FLASH_ReadResource
        56   -> __aeabi_memset4
        56   -> flash_command_sequence
      16   FLASH_SwapControl
        16   -> flash_command_sequence
      72   FLASH_VerifyErase
        72   -> flash_check_range
        72   -> flash_command_sequence
        72   -> flash_get_matched_operation_info
       0   FLASH_VerifyEraseAll
         0   -> flash_command_sequence
       0   FLASH_VerifyEraseAllExecuteOnlySegments
         0   -> flash_command_sequence
      64   FLASH_VerifyProgram
        64   -> flash_check_range
        64   -> flash_command_sequence
        64   -> flash_get_matched_operation_info
       0   flash_cache_clear
         0   -> flash_cache_clear_process
      16   flash_cache_clear_process
        16   -- Indirect call
       0   flash_check_range
       8   flash_command_sequence
         8   -- Indirect call
      16   flash_get_matched_operation_info
        16   -> __aeabi_memclr4
      16   fmc_flash_cache_clear
        16   -- Indirect call
      16   fmc_flash_prefetch_speculation_clear
        16   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable31
       4  ??DataTable31_1
       4  ??DataTable31_10
       4  ??DataTable31_11
       4  ??DataTable31_12
       4  ??DataTable31_13
       4  ??DataTable31_14
       4  ??DataTable31_2
       4  ??DataTable31_3
       4  ??DataTable31_4
       4  ??DataTable31_5
       4  ??DataTable31_6
       4  ??DataTable31_7
       4  ??DataTable31_8
       4  ??DataTable31_9
      28  ?Subroutine0
       6  ?Subroutine1
       6  ?Subroutine2
       6  ?Subroutine3
      12  ?Subroutine4
       6  ?Subroutine5
     134  FLASH_Erase
      34  FLASH_EraseAll
      32  FLASH_EraseAllExecuteOnlySegments
      82  FLASH_GetProperty
      48  FLASH_GetSecurityState
     118  FLASH_Init
      58  FLASH_IsExecuteOnly
     268  FLASH_IsProtected
      34  FLASH_PflashGetPrefetchSpeculation
      22  FLASH_PflashGetProtection
      58  FLASH_PflashSetPrefetchSpeculation
      28  FLASH_PflashSetProtection
      68  FLASH_PrepareExecuteInRamFunctions
     148  FLASH_Program
      40  FLASH_ProgramOnce
     290  FLASH_ProgramSection
      46  FLASH_ReadOnce
     192  FLASH_ReadResource
      96  FLASH_SecurityBypass
      12  FLASH_SetCallback
      42  FLASH_SetProperty
     326  FLASH_Swap
     102  FLASH_SwapControl
     136  FLASH_VerifyErase
      12  FLASH_VerifyEraseAll
      10  FLASH_VerifyEraseAllExecuteOnlySegments
     116  FLASH_VerifyProgram
       8  callFlashRunCommand
          callFlashCommonBitOperation
       2  flash_cache_clear
      56  flash_cache_clear_process
      44  flash_check_range
      66  flash_command_sequence
      62  flash_get_matched_operation_info
      20  fmc_flash_cache_clear
      20  fmc_flash_prefetch_speculation_clear
       4  kFCCOBx
       4  kFPROTL
      32  kPFlashDensities
      28  s_flashCommonBitOperationFunctionCode
     140  s_flashExecuteInRamFunctionInfo
          s_flashRunCommand
          s_flashCommonBitOperation
      12  s_flashRunCommandFunctionCode

 
   148 bytes in section .bss
     8 bytes in section .rodata
 3 018 bytes in section .text
 
 3 018 bytes of CODE  memory
     8 bytes of CONST memory
   148 bytes of DATA  memory

Errors: none
Warnings: none
