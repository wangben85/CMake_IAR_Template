###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         03/Mar/2020  16:31:25
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_clock.c
#    Command line =  
#        C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_clock.c
#        "-IC:\Program Files (x86)\IAR Systems\Embedded Workbench 8.1\arm\inc"
#        -I..\..\..\..\..\CMSIS\Include -I..\..\..\..\..\devices -I..\..\..
#        -I..\..\..\..\..\devices\MKW24D5\drivers
#        -I..\..\..\..\..\devices\MKW24D5\utilities
#        -I..\..\..\..\..\devices\MKW24D5 -I..\..\iar -I..\.. -I..\
#        -I..\..\..\..\..\rtos\freertos_9.0.0\Source\portable\IAR\ARM_CM3
#        -I..\..\..\..\..\rtos\freertos_9.0.0\Source\include -DNDEBUG
#        -DCPU_MKW24D512VHA5 -DIAR -DFSL_RTOS_FREE_RTOS -DPRINTF_FLOAT_ENABLE=0
#        -DSCANF_FLOAT_ENABLE=0 -DPRINTF_ADVANCED_ENABLE=0
#        -DSCANF_ADVANCED_ENABLE=0 -DTWR_KW24D512 -DTOWER --diag_suppress
#        Pa082,Pa050,Pe167,Pa182 --endian=little --cpu=Cortex-M4 --fpu=None
#        --no_path_in_file_macros --silent -lC . -e --dlib_config "C:/Program
#        Files (x86)/IAR Systems/Embedded Workbench
#        8.1/arm/inc/c/DLib_Config_Normal.h" -Oh --dependencies=ns
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_clock.c.obj.d
#        -o
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_clock.c.obj
#    Locale       =  C
#    List file    =  .\fsl_clock.c.lst
#    Object file  =  
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_clock.c.obj
#
###############################################################################

C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_clock.c
      1          /*
      2           * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3           * Copyright (c) 2016 - 2017 , NXP
      4           * All rights reserved.
      5           *
      6           * Redistribution and use in source and binary forms, with or without modification,
      7           * are permitted provided that the following conditions are met:
      8           *
      9           * o Redistributions of source code must retain the above copyright notice, this list
     10           *   of conditions and the following disclaimer.
     11           *
     12           * o Redistributions in binary form must reproduce the above copyright notice, this
     13           *   list of conditions and the following disclaimer in the documentation and/or
     14           *   other materials provided with the distribution.
     15           *
     16           * o Neither the name of copyright holder nor the names of its
     17           *   contributors may be used to endorse or promote products derived from this
     18           *   software without specific prior written permission.
     19           *
     20           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     21           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     22           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     23           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     24           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     25           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     26           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     27           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     28           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     29           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     30           */
     31          
     32          #include "fsl_clock.h"
     33          
     34          /*******************************************************************************
     35           * Definitions
     36           ******************************************************************************/
     37          
     38          /* Macro definition remap workaround. */
     39          #if (defined(MCG_C2_EREFS_MASK) && !(defined(MCG_C2_EREFS0_MASK)))
     40          #define MCG_C2_EREFS0_MASK MCG_C2_EREFS_MASK
     41          #endif
     42          #if (defined(MCG_C2_HGO_MASK) && !(defined(MCG_C2_HGO0_MASK)))
     43          #define MCG_C2_HGO0_MASK MCG_C2_HGO_MASK
     44          #endif
     45          #if (defined(MCG_C2_RANGE_MASK) && !(defined(MCG_C2_RANGE0_MASK)))
     46          #define MCG_C2_RANGE0_MASK MCG_C2_RANGE_MASK
     47          #endif
     48          #if (defined(MCG_C6_CME_MASK) && !(defined(MCG_C6_CME0_MASK)))
     49          #define MCG_C6_CME0_MASK MCG_C6_CME_MASK
     50          #endif
     51          
     52          /* PLL fixed multiplier when there is not PRDIV and VDIV. */
     53          #define PLL_FIXED_MULT (375U)
     54          /* Max frequency of the reference clock used for internal clock trim. */
     55          #define TRIM_REF_CLK_MIN (8000000U)
     56          /* Min frequency of the reference clock used for internal clock trim. */
     57          #define TRIM_REF_CLK_MAX (16000000U)
     58          /* Max trim value of fast internal reference clock. */
     59          #define TRIM_FIRC_MAX (5000000U)
     60          /* Min trim value of fast internal reference clock. */
     61          #define TRIM_FIRC_MIN (3000000U)
     62          /* Max trim value of fast internal reference clock. */
     63          #define TRIM_SIRC_MAX (39063U)
     64          /* Min trim value of fast internal reference clock. */
     65          #define TRIM_SIRC_MIN (31250U)
     66          
     67          #define MCG_S_IRCST_VAL ((MCG->S & MCG_S_IRCST_MASK) >> MCG_S_IRCST_SHIFT)
     68          #define MCG_S_CLKST_VAL ((MCG->S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT)
     69          #define MCG_S_IREFST_VAL ((MCG->S & MCG_S_IREFST_MASK) >> MCG_S_IREFST_SHIFT)
     70          #define MCG_S_PLLST_VAL ((MCG->S & MCG_S_PLLST_MASK) >> MCG_S_PLLST_SHIFT)
     71          #define MCG_C1_FRDIV_VAL ((MCG->C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT)
     72          #define MCG_C2_LP_VAL ((MCG->C2 & MCG_C2_LP_MASK) >> MCG_C2_LP_SHIFT)
     73          #define MCG_C2_RANGE_VAL ((MCG->C2 & MCG_C2_RANGE_MASK) >> MCG_C2_RANGE_SHIFT)
     74          #define MCG_SC_FCRDIV_VAL ((MCG->SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)
     75          #define MCG_S2_PLLCST_VAL ((MCG->S2 & MCG_S2_PLLCST_MASK) >> MCG_S2_PLLCST_SHIFT)
     76          #define MCG_C7_OSCSEL_VAL ((MCG->C7 & MCG_C7_OSCSEL_MASK) >> MCG_C7_OSCSEL_SHIFT)
     77          #define MCG_C4_DMX32_VAL ((MCG->C4 & MCG_C4_DMX32_MASK) >> MCG_C4_DMX32_SHIFT)
     78          #define MCG_C4_DRST_DRS_VAL ((MCG->C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT)
     79          #define MCG_C7_PLL32KREFSEL_VAL ((MCG->C7 & MCG_C7_PLL32KREFSEL_MASK) >> MCG_C7_PLL32KREFSEL_SHIFT)
     80          #define MCG_C5_PLLREFSEL0_VAL ((MCG->C5 & MCG_C5_PLLREFSEL0_MASK) >> MCG_C5_PLLREFSEL0_SHIFT)
     81          #define MCG_C11_PLLREFSEL1_VAL ((MCG->C11 & MCG_C11_PLLREFSEL1_MASK) >> MCG_C11_PLLREFSEL1_SHIFT)
     82          #define MCG_C11_PRDIV1_VAL ((MCG->C11 & MCG_C11_PRDIV1_MASK) >> MCG_C11_PRDIV1_SHIFT)
     83          #define MCG_C12_VDIV1_VAL ((MCG->C12 & MCG_C12_VDIV1_MASK) >> MCG_C12_VDIV1_SHIFT)
     84          #define MCG_C5_PRDIV0_VAL ((MCG->C5 & MCG_C5_PRDIV0_MASK) >> MCG_C5_PRDIV0_SHIFT)
     85          #define MCG_C6_VDIV0_VAL ((MCG->C6 & MCG_C6_VDIV0_MASK) >> MCG_C6_VDIV0_SHIFT)
     86          
     87          #define OSC_MODE_MASK (MCG_C2_EREFS0_MASK | MCG_C2_HGO0_MASK | MCG_C2_RANGE0_MASK)
     88          
     89          #define SIM_CLKDIV1_OUTDIV1_VAL ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV1_MASK) >> SIM_CLKDIV1_OUTDIV1_SHIFT)
     90          #define SIM_CLKDIV1_OUTDIV2_VAL ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV2_MASK) >> SIM_CLKDIV1_OUTDIV2_SHIFT)
     91          #define SIM_CLKDIV1_OUTDIV4_VAL ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV4_MASK) >> SIM_CLKDIV1_OUTDIV4_SHIFT)
     92          #define SIM_SOPT1_OSC32KSEL_VAL ((SIM->SOPT1 & SIM_SOPT1_OSC32KSEL_MASK) >> SIM_SOPT1_OSC32KSEL_SHIFT)
     93          #define SIM_SOPT2_PLLFLLSEL_VAL ((SIM->SOPT2 & SIM_SOPT2_PLLFLLSEL_MASK) >> SIM_SOPT2_PLLFLLSEL_SHIFT)
     94          
     95          /* MCG_S_CLKST definition. */
     96          enum _mcg_clkout_stat
     97          {
     98              kMCG_ClkOutStatFll, /* FLL.            */
     99              kMCG_ClkOutStatInt, /* Internal clock. */
    100              kMCG_ClkOutStatExt, /* External clock. */
    101              kMCG_ClkOutStatPll  /* PLL.            */
    102          };
    103          
    104          /* MCG_S_PLLST definition. */
    105          enum _mcg_pllst
    106          {
    107              kMCG_PllstFll, /* FLL is used. */
    108              kMCG_PllstPll  /* PLL is used. */
    109          };
    110          
    111          /*******************************************************************************
    112           * Variables
    113           ******************************************************************************/
    114          
    115          /* Slow internal reference clock frequency. */

   \                                 In section .data, align 4
    116          static uint32_t s_slowIrcFreq = 32768U;
   \                     s_slowIrcFreq:
   \        0x0   0x0000'8000        DC32 32768
   \        0x4   0x003D'0900        DC32 4000000
    117          /* Fast internal reference clock frequency. */
    118          static uint32_t s_fastIrcFreq = 4000000U;
    119          
    120          /* External XTAL0 (OSC0) clock frequency. */
    121          uint32_t g_xtal0Freq;
   \                     g_xtal0Freq:
   \        0x8   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
    122          /* External XTAL32K clock frequency. */
    123          uint32_t g_xtal32Freq;
   \                     g_xtal32Freq:
   \        0xC   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
    124          
    125          /*******************************************************************************
    126           * Prototypes
    127           ******************************************************************************/
    128          
    129          /*!
    130           * @brief Get the MCG external reference clock frequency.
    131           *
    132           * Get the current MCG external reference clock frequency in Hz. It is
    133           * the frequency select by MCG_C7[OSCSEL]. This is an internal function.
    134           *
    135           * @return MCG external reference clock frequency in Hz.
    136           */
    137          static uint32_t CLOCK_GetMcgExtClkFreq(void);
    138          
    139          /*!
    140           * @brief Get the MCG FLL external reference clock frequency.
    141           *
    142           * Get the current MCG FLL external reference clock frequency in Hz. It is
    143           * the frequency after by MCG_C1[FRDIV]. This is an internal function.
    144           *
    145           * @return MCG FLL external reference clock frequency in Hz.
    146           */
    147          static uint32_t CLOCK_GetFllExtRefClkFreq(void);
    148          
    149          /*!
    150           * @brief Get the MCG FLL reference clock frequency.
    151           *
    152           * Get the current MCG FLL reference clock frequency in Hz. It is
    153           * the frequency select by MCG_C1[IREFS]. This is an internal function.
    154           *
    155           * @return MCG FLL reference clock frequency in Hz.
    156           */
    157          static uint32_t CLOCK_GetFllRefClkFreq(void);
    158          
    159          /*!
    160           * @brief Get the frequency of clock selected by MCG_C2[IRCS].
    161           *
    162           * This clock's two output:
    163           *  1. MCGOUTCLK when MCG_S[CLKST]=0.
    164           *  2. MCGIRCLK when MCG_C1[IRCLKEN]=1.
    165           *
    166           * @return The frequency in Hz.
    167           */
    168          static uint32_t CLOCK_GetInternalRefClkSelectFreq(void);
    169          
    170          /*!
    171           * @brief Get the MCG PLL/PLL0 reference clock frequency.
    172           *
    173           * Get the current MCG PLL/PLL0 reference clock frequency in Hz.
    174           * This is an internal function.
    175           *
    176           * @return MCG PLL/PLL0 reference clock frequency in Hz.
    177           */
    178          static uint32_t CLOCK_GetPll0RefFreq(void);
    179          
    180          /*!
    181           * @brief Calculate the RANGE value base on crystal frequency.
    182           *
    183           * To setup external crystal oscillator, must set the register bits RANGE
    184           * base on the crystal frequency. This function returns the RANGE base on the
    185           * input frequency. This is an internal function.
    186           *
    187           * @param freq Crystal frequency in Hz.
    188           * @return The RANGE value.
    189           */
    190          static uint8_t CLOCK_GetOscRangeFromFreq(uint32_t freq);
    191          
    192          /*******************************************************************************
    193           * Code
    194           ******************************************************************************/
    195          
    196          #ifndef MCG_USER_CONFIG_FLL_STABLE_DELAY_EN
    197          /*!
    198           * @brief Delay function to wait FLL stable.
    199           *
    200           * Delay function to wait FLL stable in FEI mode or FEE mode, should wait at least
    201           * 1ms. Every time changes FLL setting, should wait this time for FLL stable.
    202           */

   \                                 In section .text, align 2, keep-with-next
    203          void CLOCK_FllStableDelay(void)
    204          {
   \                     CLOCK_FllStableDelay: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
    205              /*
    206                 Should wait at least 1ms. Because in these modes, the core clock is 100MHz
    207                 at most, so this function could obtain the 1ms delay.
    208               */
    209              volatile uint32_t i = 30000U;
   \        0x2   0xF247 0x5030      MOVW     R0,#+30000
   \        0x6   0x9000             STR      R0,[SP, #+0]
   \        0x8   0xE000             B.N      ??CLOCK_FllStableDelay_0
    210              while (i--)
    211              {
    212                  __NOP();
   \                     ??CLOCK_FllStableDelay_1: (+1)
   \        0xA   0xBF00             Nop      
    213              }
   \                     ??CLOCK_FllStableDelay_0: (+1)
   \        0xC   0x9800             LDR      R0,[SP, #+0]
   \        0xE   0x1E41             SUBS     R1,R0,#+1
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0x9100             STR      R1,[SP, #+0]
   \       0x14   0xD1F9             BNE.N    ??CLOCK_FllStableDelay_1
    214          }
   \       0x16   0xB001             ADD      SP,SP,#+4
   \       0x18   0x4770             BX       LR               ;; return
    215          #else  /* With MCG_USER_CONFIG_FLL_STABLE_DELAY_EN defined. */
    216          /* Once user defines the MCG_USER_CONFIG_FLL_STABLE_DELAY_EN to use their own delay function, he has to
    217           * create his own CLOCK_FllStableDelay() function in application code. Since the clock functions in this
    218           * file would call the CLOCK_FllStableDelay() regardness how it is defined.
    219           */
    220          extern void CLOCK_FllStableDelay(void);
    221          #endif /* MCG_USER_CONFIG_FLL_STABLE_DELAY_EN */
    222          

   \                                 In section .text, align 2, keep-with-next
    223          static uint32_t CLOCK_GetMcgExtClkFreq(void)
    224          {
    225              uint32_t freq;
    226          
    227              switch (MCG_C7_OSCSEL_VAL)
   \                     CLOCK_GetMcgExtClkFreq: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable45  ;; 0x4006400c
   \        0x4   0x7801             LDRB     R1,[R0, #+0]
   \        0x6   0xF011 0x0101      ANDS     R1,R1,#0x1
   \        0xA   0xD002             BEQ.N    ??CLOCK_GetMcgExtClkFreq_0
   \        0xC   0x2901             CMP      R1,#+1
   \        0xE   0xD001             BEQ.N    ??CLOCK_GetMcgExtClkFreq_1
   \       0x10   0xE001             B.N      ??CLOCK_GetMcgExtClkFreq_2
    228              {
    229                  case 0U:
    230                      /* Please call CLOCK_SetXtal0Freq base on board setting before using OSC0 clock. */
    231                      assert(g_xtal0Freq);
    232                      freq = g_xtal0Freq;
   \                     ??CLOCK_GetMcgExtClkFreq_0: (+1)
   \       0x12   0x....             B.N      ?Subroutine2
    233                      break;
    234                  case 1U:
    235                      /* Please call CLOCK_SetXtal32Freq base on board setting before using XTAL32K/RTC_CLKIN clock. */
    236                      assert(g_xtal32Freq);
    237                      freq = g_xtal32Freq;
   \                     ??CLOCK_GetMcgExtClkFreq_1: (+1)
   \       0x14   0x....             B.N      ?Subroutine1
    238                      break;
    239                  default:
    240                      freq = 0U;
   \                     ??CLOCK_GetMcgExtClkFreq_2: (+1)
   \       0x16   0x2000             MOVS     R0,#+0
    241                      break;
    242              }
    243          
    244              return freq;
   \       0x18   0x4770             BX       LR               ;; return
    245          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable46_1
   \        0x4   0x6880             LDR      R0,[R0, #+8]
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable46_1
   \        0x4   0x68C0             LDR      R0,[R0, #+12]
   \        0x6   0x4770             BX       LR
    246          
    247          static uint32_t CLOCK_GetFllExtRefClkFreq(void)
    248          {
    249              /* FllExtRef = McgExtRef / FllExtRefDiv */
    250              uint8_t frdiv;
    251              uint8_t range;
    252              uint8_t oscsel;
    253          
    254              uint32_t freq = CLOCK_GetMcgExtClkFreq();
    255          
    256              if (!freq)
    257              {
    258                  return freq;
    259              }
    260          
    261              frdiv = MCG_C1_FRDIV_VAL;
    262              freq >>= frdiv;
    263          
    264              range = MCG_C2_RANGE_VAL;
    265              oscsel = MCG_C7_OSCSEL_VAL;
    266          
    267              /*
    268                 When should use divider 32, 64, 128, 256, 512, 1024, 1280, 1536.
    269                 1. MCG_C7[OSCSEL] selects IRC48M.
    270                 2. MCG_C7[OSCSEL] selects OSC0 and MCG_C2[RANGE] is not 0.
    271              */
    272              if (((0U != range) && (kMCG_OscselOsc == oscsel)))
    273              {
    274                  switch (frdiv)
    275                  {
    276                      case 0:
    277                      case 1:
    278                      case 2:
    279                      case 3:
    280                      case 4:
    281                      case 5:
    282                          freq >>= 5u;
    283                          break;
    284                      case 6:
    285                          /* 64*20=1280 */
    286                          freq /= 20u;
    287                          break;
    288                      case 7:
    289                          /* 128*12=1536 */
    290                          freq /= 12u;
    291                          break;
    292                      default:
    293                          freq = 0u;
    294                          break;
    295                  }
    296              }
    297          
    298              return freq;
    299          }
    300          
    301          static uint32_t CLOCK_GetInternalRefClkSelectFreq(void)
    302          {
    303              if (kMCG_IrcSlow == MCG_S_IRCST_VAL)
    304              {
    305                  /* Slow internal reference clock selected*/
    306                  return s_slowIrcFreq;
    307              }
    308              else
    309              {
    310                  /* Fast internal reference clock selected*/
    311                  return s_fastIrcFreq >> MCG_SC_FCRDIV_VAL;
    312              }
    313          }
    314          

   \                                 In section .text, align 2, keep-with-next
    315          static uint32_t CLOCK_GetFllRefClkFreq(void)
    316          {
    317              /* If use external reference clock. */
    318              if (kMCG_FllSrcExternal == MCG_S_IREFST_VAL)
   \                     CLOCK_GetFllRefClkFreq: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable45_1  ;; 0x40064000
   \        0x4   0x7988             LDRB     R0,[R1, #+6]
   \        0x6   0xF3C0 0x1000      UBFX     R0,R0,#+4,#+1
   \        0xA   0xBB70             CBNZ.N   R0,??CLOCK_GetFllRefClkFreq_0
    319              {
    320                  return CLOCK_GetFllExtRefClkFreq();
   \        0xC   0x7B08             LDRB     R0,[R1, #+12]
   \        0xE   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0x12   0xD01C             BEQ.N    ??CLOCK_GetFllRefClkFreq_1
   \       0x14   0x2801             CMP      R0,#+1
   \       0x16   0xD11E             BNE.N    ??CLOCK_GetFllRefClkFreq_2
   \       0x18   0x.... 0x....      LDR.W    R2,??DataTable45_2
   \       0x1C   0x68D0             LDR      R0,[R2, #+12]
   \                     ??CLOCK_GetFllRefClkFreq_3: (+1)
   \       0x1E   0xB338             CBZ.N    R0,??CLOCK_GetFllRefClkFreq_4
   \       0x20   0x780A             LDRB     R2,[R1, #+0]
   \       0x22   0x784B             LDRB     R3,[R1, #+1]
   \       0x24   0x7B09             LDRB     R1,[R1, #+12]
   \       0x26   0xF3C2 0x02C2      UBFX     R2,R2,#+3,#+3
   \       0x2A   0x40D0             LSRS     R0,R0,R2
   \       0x2C   0xF3C3 0x1301      UBFX     R3,R3,#+4,#+2
   \       0x30   0xB1F3             CBZ.N    R3,??CLOCK_GetFllRefClkFreq_4
   \       0x32   0x07C9             LSLS     R1,R1,#+31
   \       0x34   0xD41C             BMI.N    ??CLOCK_GetFllRefClkFreq_4
   \       0x36   0x2A05             CMP      R2,#+5
   \       0x38   0xD915             BLS.N    ??CLOCK_GetFllRefClkFreq_5
   \       0x3A   0x1F92             SUBS     R2,R2,#+6
   \       0x3C   0xD00D             BEQ.N    ??CLOCK_GetFllRefClkFreq_6
   \       0x3E   0x1E52             SUBS     R2,R2,#+1
   \       0x40   0xD109             BNE.N    ??CLOCK_GetFllRefClkFreq_2
   \       0x42   0x.... 0x....      LDR.W    R3,??DataTable45_3  ;; 0xaaaaaaab
   \       0x46   0xFBA0 0x3203      UMULL    R3,R2,R0,R3
   \       0x4A   0x08D0             LSRS     R0,R2,#+3
   \       0x4C   0x4770             BX       LR
   \                     ??CLOCK_GetFllRefClkFreq_1: (+1)
   \       0x4E   0x.... 0x....      LDR.W    R0,??DataTable45_2
   \       0x52   0x6880             LDR      R0,[R0, #+8]
   \       0x54   0xE7E3             B.N      ??CLOCK_GetFllRefClkFreq_3
   \                     ??CLOCK_GetFllRefClkFreq_2: (+1)
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0x4770             BX       LR
   \                     ??CLOCK_GetFllRefClkFreq_6: (+1)
   \       0x5A   0x.... 0x....      LDR.W    R2,??DataTable45_4  ;; 0xcccccccd
   \       0x5E   0xFBA0 0x2102      UMULL    R2,R1,R0,R2
   \       0x62   0x0908             LSRS     R0,R1,#+4
   \       0x64   0x4770             BX       LR
   \                     ??CLOCK_GetFllRefClkFreq_5: (+1)
   \       0x66   0x0940             LSRS     R0,R0,#+5
    321              }
   \       0x68   0x4770             BX       LR
    322              /* If use internal reference clock. */
    323              else
    324              {
    325                  return s_slowIrcFreq;
   \                     ??CLOCK_GetFllRefClkFreq_0: (+1)
   \       0x6A   0x.... 0x....      LDR.W    R0,??DataTable45_2
   \       0x6E   0x6800             LDR      R0,[R0, #+0]
   \                     ??CLOCK_GetFllRefClkFreq_4: (+1)
   \       0x70   0x4770             BX       LR               ;; return
    326              }
    327          }
    328          
    329          static uint32_t CLOCK_GetPll0RefFreq(void)
    330          {
    331              /* MCG external reference clock. */
    332              return CLOCK_GetMcgExtClkFreq();
    333          }
    334          
    335          static uint8_t CLOCK_GetOscRangeFromFreq(uint32_t freq)
    336          {
    337              uint8_t range;
    338          
    339              if (freq <= 39063U)
    340              {
    341                  range = 0U;
    342              }
    343              else if (freq <= 8000000U)
    344              {
    345                  range = 1U;
    346              }
    347              else
    348              {
    349                  range = 2U;
    350              }
    351          
    352              return range;
    353          }
    354          

   \                                 In section .text, align 2, keep-with-next
    355          uint32_t CLOCK_GetOsc0ErClkFreq(void)
    356          {
    357              if (OSC0->CR & OSC_CR_ERCLKEN_MASK)
   \                     CLOCK_GetOsc0ErClkFreq: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable46  ;; 0x40065000
   \        0x4   0x7801             LDRB     R1,[R0, #+0]
   \        0x6   0x060A             LSLS     R2,R1,#+24
   \        0x8   0xD500             BPL.N    ??CLOCK_GetOsc0ErClkFreq_0
    358              {
    359                  /* Please call CLOCK_SetXtal0Freq base on board setting before using OSC0 clock. */
    360                  assert(g_xtal0Freq);
    361                  return g_xtal0Freq;
   \        0xA   0x....             B.N      ?Subroutine2
    362              }
    363              else
    364              {
    365                  return 0U;
   \                     ??CLOCK_GetOsc0ErClkFreq_0: (+1)
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x4770             BX       LR               ;; return
    366              }
    367          }
    368          

   \                                 In section .text, align 2, keep-with-next
    369          uint32_t CLOCK_GetEr32kClkFreq(void)
    370          {
    371              uint32_t freq;
    372          
    373              switch (SIM_SOPT1_OSC32KSEL_VAL)
   \                     CLOCK_GetEr32kClkFreq: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable45_5  ;; 0x40047000
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0x0C89             LSRS     R1,R1,#+18
   \        0x8   0xF011 0x0103      ANDS     R1,R1,#0x3
   \        0xC   0xD004             BEQ.N    ??CLOCK_GetEr32kClkFreq_0
   \        0xE   0x2902             CMP      R1,#+2
   \       0x10   0xD010             BEQ.N    ??CLOCK_GetEr32kClkFreq_1
   \       0x12   0x2903             CMP      R1,#+3
   \       0x14   0xD00F             BEQ.N    ??CLOCK_GetEr32kClkFreq_2
   \       0x16   0xE011             B.N      ??CLOCK_GetEr32kClkFreq_3
    374              {
    375                  case 0U: /* OSC 32k clock  */
    376                      freq = (CLOCK_GetOsc0ErClkFreq() == 32768U) ? 32768U : 0U;
   \                     ??CLOCK_GetEr32kClkFreq_0: (+1)
   \       0x18   0x.... 0x....      LDR.W    R0,??DataTable46  ;; 0x40065000
   \       0x1C   0x7801             LDRB     R1,[R0, #+0]
   \       0x1E   0x060A             LSLS     R2,R1,#+24
   \       0x20   0xD50C             BPL.N    ??CLOCK_GetEr32kClkFreq_3
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable46_1
   \       0x26   0x6881             LDR      R1,[R0, #+8]
   \       0x28   0xF5B1 0x4F00      CMP      R1,#+32768
   \       0x2C   0xD106             BNE.N    ??CLOCK_GetEr32kClkFreq_3
   \       0x2E   0xF44F 0x4000      MOV      R0,#+32768
   \       0x32   0x4770             BX       LR
    377                      break;
    378                  case 2U: /* RTC 32k clock  */
    379                      /* Please call CLOCK_SetXtal32Freq base on board setting before using XTAL32K/RTC_CLKIN clock. */
    380                      assert(g_xtal32Freq);
    381                      freq = g_xtal32Freq;
   \                     ??CLOCK_GetEr32kClkFreq_1: (+1)
   \       0x34   0x....             B.N      ?Subroutine1
    382                      break;
    383                  case 3U: /* LPO clock      */
    384                      freq = LPO_CLK_FREQ;
   \                     ??CLOCK_GetEr32kClkFreq_2: (+1)
   \       0x36   0xF44F 0x707A      MOV      R0,#+1000
    385                      break;
   \       0x3A   0x4770             BX       LR
    386                  default:
    387                      freq = 0U;
   \                     ??CLOCK_GetEr32kClkFreq_3: (+1)
   \       0x3C   0x2000             MOVS     R0,#+0
    388                      break;
    389              }
    390              return freq;
   \       0x3E   0x4770             BX       LR               ;; return
    391          }
    392          

   \                                 In section .text, align 2, keep-with-next
    393          uint32_t CLOCK_GetPllFllSelClkFreq(void)
    394          {
    395              uint32_t freq;
    396          
    397              switch (SIM_SOPT2_PLLFLLSEL_VAL)
   \                     CLOCK_GetPllFllSelClkFreq: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable46_2  ;; 0x40048004
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0x0C09             LSRS     R1,R1,#+16
   \        0x8   0xF011 0x0101      ANDS     R1,R1,#0x1
   \        0xC   0xD002             BEQ.N    ??CLOCK_GetPllFllSelClkFreq_0
   \        0xE   0x2901             CMP      R1,#+1
   \       0x10   0xD001             BEQ.N    ??CLOCK_GetPllFllSelClkFreq_1
   \       0x12   0xE001             B.N      ??CLOCK_GetPllFllSelClkFreq_2
    398              {
    399                  case 0U: /* FLL. */
    400                      freq = CLOCK_GetFllFreq();
   \                     ??CLOCK_GetPllFllSelClkFreq_0: (+1)
   \       0x14   0x....             B.N      CLOCK_GetFllFreq
    401                      break;
    402                  case 1U: /* PLL. */
    403                      freq = CLOCK_GetPll0Freq();
   \                     ??CLOCK_GetPllFllSelClkFreq_1: (+1)
   \       0x16   0x....             B.N      CLOCK_GetPll0Freq
    404                      break;
    405                  default:
    406                      freq = 0U;
   \                     ??CLOCK_GetPllFllSelClkFreq_2: (+1)
   \       0x18   0x2000             MOVS     R0,#+0
    407                      break;
    408              }
    409          
    410              return freq;
   \       0x1A   0x4770             BX       LR               ;; return
    411          }
    412          

   \                                 In section .text, align 2, keep-with-next
    413          uint32_t CLOCK_GetPlatClkFreq(void)
    414          {
   \                     CLOCK_GetPlatClkFreq: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    415              return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1);
   \        0x2   0x....             B.N      ?Subroutine4
    416          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x.... 0x....      BL       CLOCK_GetOutClkFreq
   \        0x4   0x.... 0x....      LDR.W    R1,??DataTable46_3  ;; 0x40048044
   \        0x8   0x680A             LDR      R2,[R1, #+0]
   \        0xA   0x0F12             LSRS     R2,R2,#+28
   \        0xC   0x1C52             ADDS     R2,R2,#+1
   \        0xE   0xFBB0 0xF0F2      UDIV     R0,R0,R2
   \       0x12   0xBD02             POP      {R1,PC}          ;; return
    417          

   \                                 In section .text, align 2, keep-with-next
    418          uint32_t CLOCK_GetFlashClkFreq(void)
    419          {
   \                     CLOCK_GetFlashClkFreq: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    420              return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV4_VAL + 1);
   \        0x2   0x.... 0x....      BL       CLOCK_GetOutClkFreq
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable46_3  ;; 0x40048044
   \        0xA   0x680A             LDR      R2,[R1, #+0]
   \        0xC   0xF3C2 0x4103      UBFX     R1,R2,#+16,#+4
   \       0x10   0x....             B.N      ?Subroutine5
    421          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x1C49             ADDS     R1,R1,#+1
   \        0x2   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \        0x6   0xBD02             POP      {R1,PC}          ;; return
    422          

   \                                 In section .text, align 2, keep-with-next
    423          uint32_t CLOCK_GetBusClkFreq(void)
    424          {
   \                     CLOCK_GetBusClkFreq: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    425              return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV2_VAL + 1);
   \        0x2   0x.... 0x....      BL       CLOCK_GetOutClkFreq
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable46_3  ;; 0x40048044
   \        0xA   0x680A             LDR      R2,[R1, #+0]
   \        0xC   0xF3C2 0x6103      UBFX     R1,R2,#+24,#+4
   \       0x10                      REQUIRE ?Subroutine5
   \       0x10                      ;; // Fall through to label ?Subroutine5
    426          }
    427          

   \                                 In section .text, align 2, keep-with-next
    428          uint32_t CLOCK_GetCoreSysClkFreq(void)
    429          {
   \                     CLOCK_GetCoreSysClkFreq: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    430              return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1);
   \        0x2                      REQUIRE ?Subroutine4
   \        0x2                      ;; // Fall through to label ?Subroutine4
    431          }
    432          

   \                                 In section .text, align 4, keep-with-next
    433          uint32_t CLOCK_GetFreq(clock_name_t clockName)
    434          {
   \                     CLOCK_GetFreq: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    435              uint32_t freq;
    436          
    437              switch (clockName)
   \        0x2   0x280E             CMP      R0,#+14
   \        0x4   0xD847             BHI.N    ??CLOCK_GetFreq_1
   \        0x6   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??CLOCK_GetFreq_0:
   \        0xA   0x08 0x08          DC8      0x8,0x8,0x9,0x11
   \              0x09 0x11    
   \        0xE   0x19 0x1C          DC8      0x19,0x1C,0x3D,0x1F
   \              0x3D 0x1F    
   \       0x12   0x22 0x34          DC8      0x22,0x34,0x37,0x46
   \              0x37 0x46    
   \       0x16   0x46 0x46          DC8      0x46,0x46,0x3A,0x0
   \              0x3A 0x00    
    438              {
    439                  case kCLOCK_CoreSysClk:
    440                  case kCLOCK_PlatClk:
    441                      freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1);
   \                     ??CLOCK_GetFreq_2: (+1)
   \       0x1A   0x....             B.N      ?Subroutine4
    442                      break;
    443                  case kCLOCK_BusClk:
    444                      freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV2_VAL + 1);
   \                     ??CLOCK_GetFreq_3: (+1)
   \       0x1C   0x.... 0x....      BL       CLOCK_GetOutClkFreq
   \       0x20   0x.... 0x....      LDR.W    R1,??DataTable46_3  ;; 0x40048044
   \       0x24   0x680A             LDR      R2,[R1, #+0]
   \       0x26   0xF3C2 0x6103      UBFX     R1,R2,#+24,#+4
   \       0x2A   0xE006             B.N      ??CLOCK_GetFreq_4
    445                      break;
    446                  case kCLOCK_FlashClk:
    447                      freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV4_VAL + 1);
   \                     ??CLOCK_GetFreq_5: (+1)
   \       0x2C   0x.... 0x....      BL       CLOCK_GetOutClkFreq
   \       0x30   0x.... 0x....      LDR.W    R1,??DataTable46_3  ;; 0x40048044
   \       0x34   0x680A             LDR      R2,[R1, #+0]
   \       0x36   0xF3C2 0x4103      UBFX     R1,R2,#+16,#+4
   \                     ??CLOCK_GetFreq_4: (+1)
   \       0x3A   0x....             B.N      ?Subroutine5
    448                      break;
    449                  case kCLOCK_PllFllSelClk:
    450                      freq = CLOCK_GetPllFllSelClkFreq();
   \                     ??CLOCK_GetFreq_6: (+1)
   \       0x3C   0xE8BD 0x4001      POP      {R0,LR}
   \       0x40   0x....             B.N      CLOCK_GetPllFllSelClkFreq
    451                      break;
    452                  case kCLOCK_Er32kClk:
    453                      freq = CLOCK_GetEr32kClkFreq();
   \                     ??CLOCK_GetFreq_7: (+1)
   \       0x42   0xE8BD 0x4001      POP      {R0,LR}
   \       0x46   0x....             B.N      CLOCK_GetEr32kClkFreq
    454                      break;
    455                  case kCLOCK_McgFixedFreqClk:
    456                      freq = CLOCK_GetFixedFreqClkFreq();
   \                     ??CLOCK_GetFreq_8: (+1)
   \       0x48   0xE8BD 0x4001      POP      {R0,LR}
   \       0x4C   0x....             B.N      CLOCK_GetFixedFreqClkFreq
    457                      break;
    458                  case kCLOCK_McgInternalRefClk:
    459                      freq = CLOCK_GetInternalRefClkFreq();
   \                     ??CLOCK_GetFreq_9: (+1)
   \       0x4E   0x.... 0x....      LDR.W    R1,??DataTable45_1  ;; 0x40064000
   \       0x52   0x7808             LDRB     R0,[R1, #+0]
   \       0x54   0x0782             LSLS     R2,R0,#+30
   \       0x56   0xD51E             BPL.N    ??CLOCK_GetFreq_1
   \       0x58   0x798A             LDRB     R2,[R1, #+6]
   \       0x5A   0x.... 0x....      LDR.W    R0,??DataTable46_1
   \       0x5E   0x07D3             LSLS     R3,R2,#+31
   \       0x60   0xD401             BMI.N    ??CLOCK_GetFreq_10
   \       0x62   0x6800             LDR      R0,[R0, #+0]
   \       0x64   0xBD02             POP      {R1,PC}
   \                     ??CLOCK_GetFreq_10: (+1)
   \       0x66   0x6840             LDR      R0,[R0, #+4]
   \       0x68   0x7A09             LDRB     R1,[R1, #+8]
   \       0x6A   0xF3C1 0x0142      UBFX     R1,R1,#+1,#+3
   \       0x6E   0x40C8             LSRS     R0,R0,R1
   \       0x70   0xBD02             POP      {R1,PC}
    460                      break;
    461                  case kCLOCK_McgFllClk:
    462                      freq = CLOCK_GetFllFreq();
   \                     ??CLOCK_GetFreq_11: (+1)
   \       0x72   0xE8BD 0x4001      POP      {R0,LR}
   \       0x76   0x....             B.N      CLOCK_GetFllFreq
    463                      break;
    464                  case kCLOCK_McgPll0Clk:
    465                      freq = CLOCK_GetPll0Freq();
   \                     ??CLOCK_GetFreq_12: (+1)
   \       0x78   0xE8BD 0x4001      POP      {R0,LR}
   \       0x7C   0x....             B.N      CLOCK_GetPll0Freq
    466                      break;
    467                  case kCLOCK_LpoClk:
    468                      freq = LPO_CLK_FREQ;
   \                     ??CLOCK_GetFreq_13: (+1)
   \       0x7E   0xF44F 0x707A      MOV      R0,#+1000
    469                      break;
   \       0x82   0xBD02             POP      {R1,PC}
    470                  case kCLOCK_Osc0ErClk:
    471                      freq = CLOCK_GetOsc0ErClkFreq();
   \                     ??CLOCK_GetFreq_14: (+1)
   \       0x84   0x.... 0x....      LDR.W    R0,??DataTable46  ;; 0x40065000
   \       0x88   0x7801             LDRB     R1,[R0, #+0]
   \       0x8A   0x060A             LSLS     R2,R1,#+24
   \       0x8C   0xD503             BPL.N    ??CLOCK_GetFreq_1
   \       0x8E   0x.... 0x....      LDR.W    R0,??DataTable46_1
   \       0x92   0x6880             LDR      R0,[R0, #+8]
   \       0x94   0xBD02             POP      {R1,PC}
    472                      break;
    473                  default:
    474                      freq = 0U;
   \                     ??CLOCK_GetFreq_1: (+1)
   \       0x96   0x2000             MOVS     R0,#+0
    475                      break;
    476              }
    477          
    478              return freq;
   \       0x98   0xBD02             POP      {R1,PC}          ;; return
    479          }
    480          

   \                                 In section .text, align 2, keep-with-next
    481          void CLOCK_SetSimConfig(sim_clock_config_t const *config)
    482          {
    483              SIM->CLKDIV1 = config->clkdiv1;
   \                     CLOCK_SetSimConfig: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable46_2  ;; 0x40048004
   \        0x4   0x6842             LDR      R2,[R0, #+4]
   \        0x6   0x640A             STR      R2,[R1, #+64]
    484              CLOCK_SetPllFllSelClock(config->pllFllSel);
   \        0x8   0x680B             LDR      R3,[R1, #+0]
   \        0xA   0x7802             LDRB     R2,[R0, #+0]
   \        0xC   0x0412             LSLS     R2,R2,#+16
   \        0xE   0xF423 0x3380      BIC      R3,R3,#0x10000
   \       0x12   0xF402 0x3280      AND      R2,R2,#0x10000
   \       0x16   0x4313             ORRS     R3,R2,R3
   \       0x18   0x600B             STR      R3,[R1, #+0]
    485              CLOCK_SetEr32kClock(config->er32kSrc);
   \       0x1A   0x.... 0x....      LDR.W    R1,??DataTable45_5  ;; 0x40047000
   \       0x1E   0x680A             LDR      R2,[R1, #+0]
   \       0x20   0x7840             LDRB     R0,[R0, #+1]
   \       0x22   0x0480             LSLS     R0,R0,#+18
   \       0x24   0xF422 0x2240      BIC      R2,R2,#0xC0000
   \       0x28   0xF400 0x2040      AND      R0,R0,#0xC0000
   \       0x2C   0x4302             ORRS     R2,R0,R2
   \       0x2E   0x600A             STR      R2,[R1, #+0]
    486          }
   \       0x30   0x4770             BX       LR               ;; return
    487          

   \                                 In section .text, align 2, keep-with-next
    488          bool CLOCK_EnableUsbfs0Clock(clock_usb_src_t src, uint32_t freq)
    489          {
   \                     CLOCK_EnableUsbfs0Clock: (+1)
   \        0x0   0xB410             PUSH     {R4}
    490              bool ret = true;
    491          
    492              CLOCK_DisableClock(kCLOCK_Usbfs0);
   \        0x2   0x.... 0x....      LDR.W    R3,??DataTable46_2  ;; 0x40048004
   \        0x6   0x6B1C             LDR      R4,[R3, #+48]
   \        0x8   0x4602             MOV      R2,R0
   \        0xA   0xF424 0x2480      BIC      R4,R4,#0x40000
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0x631C             STR      R4,[R3, #+48]
    493          
    494              if (kCLOCK_UsbSrcExt == src)
   \       0x12   0xB922             CBNZ.N   R2,??CLOCK_EnableUsbfs0Clock_0
    495              {
    496                  SIM->SOPT2 &= ~SIM_SOPT2_USBSRC_MASK;
   \       0x14   0x6819             LDR      R1,[R3, #+0]
   \       0x16   0xF421 0x2180      BIC      R1,R1,#0x40000
   \       0x1A   0x6019             STR      R1,[R3, #+0]
   \       0x1C   0xE01F             B.N      ??CLOCK_EnableUsbfs0Clock_1
    497              }
    498              else
    499              {
    500                  switch (freq)
   \                     ??CLOCK_EnableUsbfs0Clock_0: (+1)
   \       0x1E   0x.... 0x....      LDR.W    R4,??DataTable46_4  ;; 0x2dc6c00
   \       0x22   0x42A1             CMP      R1,R4
   \       0x24   0xD012             BEQ.N    ??CLOCK_EnableUsbfs0Clock_2
   \       0x26   0x.... 0x....      LDR.W    R4,??DataTable46_5  ;; 0x44aa200
   \       0x2A   0x42A1             CMP      R1,R4
   \       0x2C   0xD00B             BEQ.N    ??CLOCK_EnableUsbfs0Clock_3
   \       0x2E   0x.... 0x....      LDR.W    R4,??DataTable46_6  ;; 0x5b8d800
   \       0x32   0x42A1             CMP      R1,R4
   \       0x34   0xD005             BEQ.N    ??CLOCK_EnableUsbfs0Clock_4
   \       0x36   0x.... 0x....      LDR.W    R4,??DataTable46_7  ;; 0x7270e00
   \       0x3A   0x42A1             CMP      R1,R4
   \       0x3C   0xD109             BNE.N    ??CLOCK_EnableUsbfs0Clock_5
    501                  {
    502                      case 120000000U:
    503                          SIM->CLKDIV2 = SIM_CLKDIV2_USBDIV(4) | SIM_CLKDIV2_USBFRAC(1);
   \       0x3E   0x2409             MOVS     R4,#+9
   \       0x40   0xE002             B.N      ??CLOCK_EnableUsbfs0Clock_6
    504                          break;
    505                      case 96000000U:
    506                          SIM->CLKDIV2 = SIM_CLKDIV2_USBDIV(1) | SIM_CLKDIV2_USBFRAC(0);
   \                     ??CLOCK_EnableUsbfs0Clock_4: (+1)
   \       0x42   0x2102             MOVS     R1,#+2
   \       0x44   0xE003             B.N      ??CLOCK_EnableUsbfs0Clock_7
    507                          break;
    508                      case 72000000U:
    509                          SIM->CLKDIV2 = SIM_CLKDIV2_USBDIV(2) | SIM_CLKDIV2_USBFRAC(1);
   \                     ??CLOCK_EnableUsbfs0Clock_3: (+1)
   \       0x46   0x2405             MOVS     R4,#+5
   \                     ??CLOCK_EnableUsbfs0Clock_6: (+1)
   \       0x48   0x645C             STR      R4,[R3, #+68]
    510                          break;
   \       0x4A   0xE003             B.N      ??CLOCK_EnableUsbfs0Clock_8
    511                      case 48000000U:
    512                          SIM->CLKDIV2 = SIM_CLKDIV2_USBDIV(0) | SIM_CLKDIV2_USBFRAC(0);
   \                     ??CLOCK_EnableUsbfs0Clock_2: (+1)
   \       0x4C   0x2100             MOVS     R1,#+0
   \                     ??CLOCK_EnableUsbfs0Clock_7: (+1)
   \       0x4E   0x6459             STR      R1,[R3, #+68]
    513                          break;
   \       0x50   0xE000             B.N      ??CLOCK_EnableUsbfs0Clock_8
    514                      default:
    515                          ret = false;
   \                     ??CLOCK_EnableUsbfs0Clock_5: (+1)
   \       0x52   0x2000             MOVS     R0,#+0
    516                          break;
    517                  }
    518          
    519                  SIM->SOPT2 = ((SIM->SOPT2 & ~(SIM_SOPT2_PLLFLLSEL_MASK | SIM_SOPT2_USBSRC_MASK)) | (uint32_t)src);
   \                     ??CLOCK_EnableUsbfs0Clock_8: (+1)
   \       0x54   0x6819             LDR      R1,[R3, #+0]
   \       0x56   0xF421 0x21A0      BIC      R1,R1,#0x50000
   \       0x5A   0x430A             ORRS     R2,R2,R1
   \       0x5C   0x601A             STR      R2,[R3, #+0]
    520              }
    521          
    522              CLOCK_EnableClock(kCLOCK_Usbfs0);
   \                     ??CLOCK_EnableUsbfs0Clock_1: (+1)
   \       0x5E   0x6B19             LDR      R1,[R3, #+48]
   \       0x60   0xF441 0x2180      ORR      R1,R1,#0x40000
   \       0x64   0x6319             STR      R1,[R3, #+48]
    523          
    524              return ret;
   \       0x66   0xBC10             POP      {R4}
   \       0x68   0x4770             BX       LR               ;; return
    525          }
    526          

   \                                 In section .text, align 4, keep-with-next
    527          uint32_t CLOCK_GetOutClkFreq(void)
    528          {
    529              uint32_t mcgoutclk;
    530              uint32_t clkst = MCG_S_CLKST_VAL;
   \                     CLOCK_GetOutClkFreq: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable46_8  ;; 0x40064006
   \        0x4   0x7808             LDRB     R0,[R1, #+0]
    531          
    532              switch (clkst)
   \        0x6   0x0880             LSRS     R0,R0,#+2
   \        0x8   0xF000 0x0003      AND      R0,R0,#0x3
   \        0xC   0x2803             CMP      R0,#+3
   \        0xE   0xD810             BHI.N    ??CLOCK_GetOutClkFreq_1
   \       0x10   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??CLOCK_GetOutClkFreq_0:
   \       0x14   0x03 0x04          DC8      0x3,0x4,0xE,0x2
   \              0x0E 0x02    
    533              {
    534                  case kMCG_ClkOutStatPll:
    535                      mcgoutclk = CLOCK_GetPll0Freq();
   \                     ??CLOCK_GetOutClkFreq_2: (+1)
   \       0x18   0x....             B.N      CLOCK_GetPll0Freq
    536                      break;
    537                  case kMCG_ClkOutStatFll:
    538                      mcgoutclk = CLOCK_GetFllFreq();
   \                     ??CLOCK_GetOutClkFreq_3: (+1)
   \       0x1A   0x....             B.N      CLOCK_GetFllFreq
    539                      break;
    540                  case kMCG_ClkOutStatInt:
    541                      mcgoutclk = CLOCK_GetInternalRefClkSelectFreq();
   \                     ??CLOCK_GetOutClkFreq_4: (+1)
   \       0x1C   0x780A             LDRB     R2,[R1, #+0]
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable46_1
   \       0x22   0x07D3             LSLS     R3,R2,#+31
   \       0x24   0xD401             BMI.N    ??CLOCK_GetOutClkFreq_5
   \       0x26   0x6800             LDR      R0,[R0, #+0]
   \       0x28   0x4770             BX       LR
   \                     ??CLOCK_GetOutClkFreq_5: (+1)
   \       0x2A   0x6840             LDR      R0,[R0, #+4]
   \       0x2C   0x7889             LDRB     R1,[R1, #+2]
   \       0x2E   0x....             B.N      ?Subroutine3
    542                      break;
    543                  case kMCG_ClkOutStatExt:
    544                      mcgoutclk = CLOCK_GetMcgExtClkFreq();
   \                     ??CLOCK_GetOutClkFreq_6: (+1)
   \       0x30   0x....             B.N      CLOCK_GetMcgExtClkFreq
    545                      break;
    546                  default:
    547                      mcgoutclk = 0U;
   \                     ??CLOCK_GetOutClkFreq_1: (+1)
   \       0x32   0x2000             MOVS     R0,#+0
    548                      break;
    549              }
    550              return mcgoutclk;
   \       0x34   0x4770             BX       LR               ;; return
    551          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0xF3C1 0x0142      UBFX     R1,R1,#+1,#+3
   \        0x4   0x40C8             LSRS     R0,R0,R1
   \        0x6   0x4770             BX       LR
    552          

   \                                 In section .text, align 2, keep-with-next
    553          uint32_t CLOCK_GetFllFreq(void)
    554          {
   \                     CLOCK_GetFllFreq: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    555              static const uint16_t fllFactorTable[4][2] = {{640, 732}, {1280, 1464}, {1920, 2197}, {2560, 2929}};
    556          
    557              uint8_t drs, dmx32;
    558              uint32_t freq;
    559          
    560              /* If FLL is not enabled currently, then return 0U. */
    561              if ((MCG->C2 & MCG_C2_LP_MASK) || (MCG->S & MCG_S_PLLST_MASK))
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable46_9  ;; 0x40064001
   \        0x6   0x7820             LDRB     R0,[R4, #+0]
   \        0x8   0x0781             LSLS     R1,R0,#+30
   \        0xA   0xD402             BMI.N    ??CLOCK_GetFllFreq_0
   \        0xC   0x7960             LDRB     R0,[R4, #+5]
   \        0xE   0x0681             LSLS     R1,R0,#+26
   \       0x10   0xD501             BPL.N    ??CLOCK_GetFllFreq_1
    562              {
    563                  return 0U;
   \                     ??CLOCK_GetFllFreq_0: (+1)
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xBD10             POP      {R4,PC}
    564              }
    565          
    566              /* Get FLL reference clock frequency. */
    567              freq = CLOCK_GetFllRefClkFreq();
   \                     ??CLOCK_GetFllFreq_1: (+1)
   \       0x16   0x.... 0x....      BL       CLOCK_GetFllRefClkFreq
    568              if (!freq)
   \       0x1A   0xB158             CBZ.N    R0,??CLOCK_GetFllFreq_2
    569              {
    570                  return freq;
    571              }
    572          
    573              drs = MCG_C4_DRST_DRS_VAL;
   \       0x1C   0x78A1             LDRB     R1,[R4, #+2]
    574              dmx32 = MCG_C4_DMX32_VAL;
   \       0x1E   0x78A2             LDRB     R2,[R4, #+2]
    575          
    576              return freq * fllFactorTable[drs][dmx32];
   \       0x20   0x.... 0x....      ADR.W    R3,`CLOCK_GetFllFreq::fllFactorTable`
   \       0x24   0xF3C1 0x1141      UBFX     R1,R1,#+5,#+2
   \       0x28   0xEB03 0x0381      ADD      R3,R3,R1, LSL #+2
   \       0x2C   0x09D2             LSRS     R2,R2,#+7
   \       0x2E   0xF833 0x1012      LDRH     R1,[R3, R2, LSL #+1]
   \       0x32   0x4348             MULS     R0,R1,R0
   \                     ??CLOCK_GetFllFreq_2: (+1)
   \       0x34   0xBD10             POP      {R4,PC}          ;; return
    577          }

   \                                 In section .text, align 4, keep-with-next
   \                     `CLOCK_GetFllFreq::fllFactorTable`:
   \        0x0   0x0280 0x02DC      DC16 640, 732, 1280, 1464, 1920, 2197, 2560, 2929
   \               0x0500 0x05B
   \              8 0x0780 0x08
   \              95 0x0A00 0x0
   \              B71          
    578          

   \                                 In section .text, align 2, keep-with-next
    579          uint32_t CLOCK_GetInternalRefClkFreq(void)
    580          {
    581              /* If MCGIRCLK is gated. */
    582              if (!(MCG->C1 & MCG_C1_IRCLKEN_MASK))
   \                     CLOCK_GetInternalRefClkFreq: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable45_1  ;; 0x40064000
   \        0x4   0x7808             LDRB     R0,[R1, #+0]
   \        0x6   0x0782             LSLS     R2,R0,#+30
   \        0x8   0xD401             BMI.N    ??CLOCK_GetInternalRefClkFreq_0
    583              {
    584                  return 0U;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x4770             BX       LR
    585              }
    586          
    587              return CLOCK_GetInternalRefClkSelectFreq();
   \                     ??CLOCK_GetInternalRefClkFreq_0: (+1)
   \        0xE   0x798A             LDRB     R2,[R1, #+6]
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable45_2
   \       0x14   0x07D3             LSLS     R3,R2,#+31
   \       0x16   0xD401             BMI.N    ??CLOCK_GetInternalRefClkFreq_1
   \       0x18   0x6800             LDR      R0,[R0, #+0]
   \       0x1A   0x4770             BX       LR
   \                     ??CLOCK_GetInternalRefClkFreq_1: (+1)
   \       0x1C   0x6840             LDR      R0,[R0, #+4]
   \       0x1E   0x7A09             LDRB     R1,[R1, #+8]
   \       0x20                      REQUIRE ?Subroutine3
   \       0x20                      ;; // Fall through to label ?Subroutine3
    588          }
    589          

   \                                 In section .text, align 2, keep-with-next
    590          uint32_t CLOCK_GetFixedFreqClkFreq(void)
    591          {
   \                     CLOCK_GetFixedFreqClkFreq: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    592              uint32_t freq = CLOCK_GetFllRefClkFreq();
   \        0x2   0x.... 0x....      BL       CLOCK_GetFllRefClkFreq
   \        0x6   0x0004             MOVS     R4,R0
    593          
    594              /* MCGFFCLK must be no more than MCGOUTCLK/8. */
    595              if ((freq) && (freq <= (CLOCK_GetOutClkFreq() / 8U)))
   \        0x8   0xD006             BEQ.N    ??CLOCK_GetFixedFreqClkFreq_0
   \        0xA   0x.... 0x....      BL       CLOCK_GetOutClkFreq
   \        0xE   0x08C0             LSRS     R0,R0,#+3
   \       0x10   0x42A0             CMP      R0,R4
   \       0x12   0xD301             BCC.N    ??CLOCK_GetFixedFreqClkFreq_0
    596              {
    597                  return freq;
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0xBD10             POP      {R4,PC}
    598              }
    599              else
    600              {
    601                  return 0U;
   \                     ??CLOCK_GetFixedFreqClkFreq_0: (+1)
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xBD10             POP      {R4,PC}          ;; return
    602              }
    603          }
    604          

   \                                 In section .text, align 2, keep-with-next
    605          uint32_t CLOCK_GetPll0Freq(void)
    606          {
    607              uint32_t mcgpll0clk;
    608          
    609              /* If PLL0 is not enabled, return 0. */
    610              if (!(MCG->S & MCG_S_LOCK0_MASK))
   \                     CLOCK_GetPll0Freq: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable46_10  ;; 0x40064004
   \        0x4   0x7881             LDRB     R1,[R0, #+2]
   \        0x6   0x064A             LSLS     R2,R1,#+25
   \        0x8   0xD401             BMI.N    ??CLOCK_GetPll0Freq_0
    611              {
    612                  return 0U;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x4770             BX       LR
    613              }
    614          
    615              mcgpll0clk = CLOCK_GetPll0RefFreq();
   \                     ??CLOCK_GetPll0Freq_0: (+1)
   \        0xE   0x7A01             LDRB     R1,[R0, #+8]
   \       0x10   0xF011 0x0101      ANDS     R1,R1,#0x1
   \       0x14   0xD005             BEQ.N    ??CLOCK_GetPll0Freq_1
   \       0x16   0x2901             CMP      R1,#+1
   \       0x18   0xD106             BNE.N    ??CLOCK_GetPll0Freq_2
   \       0x1A   0x.... 0x....      LDR.W    R2,??DataTable46_1
   \       0x1E   0x68D1             LDR      R1,[R2, #+12]
   \       0x20   0xE002             B.N      ??CLOCK_GetPll0Freq_2
   \                     ??CLOCK_GetPll0Freq_1: (+1)
   \       0x22   0x.... 0x....      LDR.W    R1,??DataTable46_1
   \       0x26   0x6889             LDR      R1,[R1, #+8]
    616          
    617              /*
    618               * Please call CLOCK_SetXtal0Freq base on board setting before using OSC0 clock.
    619               * Please call CLOCK_SetXtal1Freq base on board setting before using OSC1 clock.
    620               */
    621              assert(mcgpll0clk);
    622          
    623              mcgpll0clk /= (FSL_FEATURE_MCG_PLL_PRDIV_BASE + MCG_C5_PRDIV0_VAL);
   \                     ??CLOCK_GetPll0Freq_2: (+1)
   \       0x28   0x7802             LDRB     R2,[R0, #+0]
    624              mcgpll0clk *= (FSL_FEATURE_MCG_PLL_VDIV_BASE + MCG_C6_VDIV0_VAL);
   \       0x2A   0x7840             LDRB     R0,[R0, #+1]
    625          
    626              return mcgpll0clk;
   \       0x2C   0xF002 0x021F      AND      R2,R2,#0x1F
   \       0x30   0x1C52             ADDS     R2,R2,#+1
   \       0x32   0xF000 0x001F      AND      R0,R0,#0x1F
   \       0x36   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \       0x3A   0x3018             ADDS     R0,R0,#+24
   \       0x3C   0x4348             MULS     R0,R0,R1
   \       0x3E   0x4770             BX       LR               ;; return
    627          }
    628          

   \                                 In section .text, align 2, keep-with-next
    629          status_t CLOCK_SetExternalRefClkConfig(mcg_oscsel_t oscsel)
    630          {
    631              bool needDelay;
    632              uint32_t i;
    633          
    634          #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
    635              /* If change MCG_C7[OSCSEL] and external reference clock is system clock source, return error. */
    636              if ((MCG_C7_OSCSEL_VAL != oscsel) && (!(MCG->S & MCG_S_IREFST_MASK)))
    637              {
    638                  return kStatus_MCG_SourceUsed;
    639              }
    640          #endif /* MCG_CONFIG_CHECK_PARAM */
    641          
    642              if (MCG_C7_OSCSEL_VAL != oscsel)
   \                     CLOCK_SetExternalRefClkConfig: (+1)
   \        0x0   0x.... 0x....      LDR.W    R2,??DataTable45  ;; 0x4006400c
   \        0x4   0x7811             LDRB     R1,[R2, #+0]
    643              {
    644                  /* If change OSCSEL, need to delay, ERR009878. */
    645                  needDelay = true;
    646              }
    647              else
    648              {
    649                  needDelay = false;
    650              }
    651          
    652              MCG->C7 = (MCG->C7 & ~MCG_C7_OSCSEL_MASK) | MCG_C7_OSCSEL(oscsel);
   \        0x6   0x7813             LDRB     R3,[R2, #+0]
   \        0x8   0xF001 0x0101      AND      R1,R1,#0x1
   \        0xC   0x4281             CMP      R1,R0
   \        0xE   0xBF14             ITE      NE 
   \       0x10   0x2101             MOVNE    R1,#+1
   \       0x12   0x2100             MOVEQ    R1,#+0
   \       0x14   0xF003 0x03FE      AND      R3,R3,#0xFE
   \       0x18   0xF000 0x0001      AND      R0,R0,#0x1
   \       0x1C   0x4318             ORRS     R0,R0,R3
   \       0x1E   0x7010             STRB     R0,[R2, #+0]
    653              if (needDelay)
   \       0x20   0xB121             CBZ.N    R1,??CLOCK_SetExternalRefClkConfig_0
    654              {
    655                  /* ERR009878 Delay at least 50 micro-seconds for external clock change valid. */
    656                  i = 1500U;
   \       0x22   0xF240 0x50DC      MOVW     R0,#+1500
    657                  while (i--)
    658                  {
    659                      __NOP();
   \                     ??CLOCK_SetExternalRefClkConfig_1: (+1)
   \       0x26   0xBF00             Nop      
   \       0x28   0x1E40             SUBS     R0,R0,#+1
    660                  }
   \       0x2A   0xD1FC             BNE.N    ??CLOCK_SetExternalRefClkConfig_1
    661              }
    662          
    663              return kStatus_Success;
   \                     ??CLOCK_SetExternalRefClkConfig_0: (+1)
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x4770             BX       LR               ;; return
    664          }
    665          

   \                                 In section .text, align 2, keep-with-next
    666          status_t CLOCK_SetInternalRefClkConfig(uint8_t enableMode, mcg_irc_mode_t ircs, uint8_t fcrdiv)
    667          {
   \                     CLOCK_SetInternalRefClkConfig: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
    668              uint32_t mcgOutClkState = MCG_S_CLKST_VAL;
   \        0x2   0x.... 0x....      LDR.W    R3,??DataTable46_11  ;; 0x40064000
   \        0x6   0x799C             LDRB     R4,[R3, #+6]
    669              mcg_irc_mode_t curIrcs = (mcg_irc_mode_t)MCG_S_IRCST_VAL;
   \        0x8   0x799D             LDRB     R5,[R3, #+6]
    670              uint8_t curFcrdiv = MCG_SC_FCRDIV_VAL;
   \        0xA   0x7A1E             LDRB     R6,[R3, #+8]
    671          
    672          #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
    673              /* If MCGIRCLK is used as system clock source. */
    674              if (kMCG_ClkOutStatInt == mcgOutClkState)
    675              {
    676                  /* If need to change MCGIRCLK source or driver, return error. */
    677                  if (((kMCG_IrcFast == curIrcs) && (fcrdiv != curFcrdiv)) || (ircs != curIrcs))
    678                  {
    679                      return kStatus_MCG_SourceUsed;
    680                  }
    681              }
    682          #endif
    683          
    684              /* If need to update the FCRDIV. */
    685              if (fcrdiv != curFcrdiv)
   \        0xC   0xF3C6 0x0642      UBFX     R6,R6,#+1,#+3
   \       0x10   0x42B2             CMP      R2,R6
   \       0x12   0xF3C4 0x0481      UBFX     R4,R4,#+2,#+2
   \       0x16   0xD015             BEQ.N    ??CLOCK_SetInternalRefClkConfig_0
    686              {
    687                  /* If fast IRC is in use currently, change to slow IRC. */
    688                  if ((kMCG_IrcFast == curIrcs) && ((mcgOutClkState == kMCG_ClkOutStatInt) || (MCG->C1 & MCG_C1_IRCLKEN_MASK)))
   \       0x18   0x07ED             LSLS     R5,R5,#+31
   \       0x1A   0xD50B             BPL.N    ??CLOCK_SetInternalRefClkConfig_1
   \       0x1C   0x2C01             CMP      R4,#+1
   \       0x1E   0xD002             BEQ.N    ??CLOCK_SetInternalRefClkConfig_2
   \       0x20   0x781D             LDRB     R5,[R3, #+0]
   \       0x22   0x07AE             LSLS     R6,R5,#+30
   \       0x24   0xD506             BPL.N    ??CLOCK_SetInternalRefClkConfig_1
    689                  {
    690                      MCG->C2 = ((MCG->C2 & ~MCG_C2_IRCS_MASK) | (MCG_C2_IRCS(kMCG_IrcSlow)));
   \                     ??CLOCK_SetInternalRefClkConfig_2: (+1)
   \       0x26   0x785D             LDRB     R5,[R3, #+1]
   \       0x28   0xF005 0x05FE      AND      R5,R5,#0xFE
   \       0x2C   0x705D             STRB     R5,[R3, #+1]
    691                      while (MCG_S_IRCST_VAL != kMCG_IrcSlow)
   \                     ??CLOCK_SetInternalRefClkConfig_3: (+1)
   \       0x2E   0x799D             LDRB     R5,[R3, #+6]
   \       0x30   0x07EE             LSLS     R6,R5,#+31
   \       0x32   0xD4FC             BMI.N    ??CLOCK_SetInternalRefClkConfig_3
    692                      {
    693                      }
    694                  }
    695                  /* Update FCRDIV. */
    696                  MCG->SC = (MCG->SC & ~(MCG_SC_FCRDIV_MASK | MCG_SC_ATMF_MASK | MCG_SC_LOCS0_MASK)) | MCG_SC_FCRDIV(fcrdiv);
   \                     ??CLOCK_SetInternalRefClkConfig_1: (+1)
   \       0x34   0x0052             LSLS     R2,R2,#+1
   \       0x36   0x7A1D             LDRB     R5,[R3, #+8]
   \       0x38   0xF005 0x05D0      AND      R5,R5,#0xD0
   \       0x3C   0xF002 0x020E      AND      R2,R2,#0xE
   \       0x40   0x432A             ORRS     R2,R2,R5
   \       0x42   0x721A             STRB     R2,[R3, #+8]
    697              }
    698          
    699              /* Set internal reference clock selection. */
    700              MCG->C2 = (MCG->C2 & ~MCG_C2_IRCS_MASK) | (MCG_C2_IRCS(ircs));
   \                     ??CLOCK_SetInternalRefClkConfig_0: (+1)
   \       0x44   0xF001 0x0201      AND      R2,R1,#0x1
   \       0x48   0x785D             LDRB     R5,[R3, #+1]
   \       0x4A   0xF005 0x05FE      AND      R5,R5,#0xFE
   \       0x4E   0x4315             ORRS     R5,R2,R5
   \       0x50   0x705D             STRB     R5,[R3, #+1]
    701              MCG->C1 = (MCG->C1 & ~(MCG_C1_IRCLKEN_MASK | MCG_C1_IREFSTEN_MASK)) | (uint8_t)enableMode;
   \       0x52   0x781D             LDRB     R5,[R3, #+0]
   \       0x54   0xF005 0x05FC      AND      R5,R5,#0xFC
   \       0x58   0x4305             ORRS     R5,R0,R5
    702          
    703              /* If MCGIRCLK is used, need to wait for MCG_S_IRCST. */
    704              if ((mcgOutClkState == kMCG_ClkOutStatInt) || (enableMode & kMCG_IrclkEnable))
   \       0x5A   0x2C01             CMP      R4,#+1
   \       0x5C   0x701D             STRB     R5,[R3, #+0]
   \       0x5E   0xD001             BEQ.N    ??CLOCK_SetInternalRefClkConfig_4
   \       0x60   0x0780             LSLS     R0,R0,#+30
   \       0x62   0xD504             BPL.N    ??CLOCK_SetInternalRefClkConfig_5
    705              {
    706                  while (MCG_S_IRCST_VAL != ircs)
   \                     ??CLOCK_SetInternalRefClkConfig_4: (+1)
   \       0x64   0x799A             LDRB     R2,[R3, #+6]
   \       0x66   0xF002 0x0201      AND      R2,R2,#0x1
   \       0x6A   0x428A             CMP      R2,R1
   \       0x6C   0xD1FA             BNE.N    ??CLOCK_SetInternalRefClkConfig_4
    707                  {
    708                  }
    709              }
    710          
    711              return kStatus_Success;
   \                     ??CLOCK_SetInternalRefClkConfig_5: (+1)
   \       0x6E   0xBC70             POP      {R4-R6}
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0x4770             BX       LR               ;; return
    712          }
    713          

   \                                 In section .text, align 2, keep-with-next
    714          uint32_t CLOCK_CalcPllDiv(uint32_t refFreq, uint32_t desireFreq, uint8_t *prdiv, uint8_t *vdiv)
    715          {
   \                     CLOCK_CalcPllDiv: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4681             MOV      R9,R0
    716              uint8_t ret_prdiv;           /* PRDIV to return. */
    717              uint8_t ret_vdiv;            /* VDIV to return.  */
    718              uint8_t prdiv_min;           /* Min PRDIV value to make reference clock in allowed range. */
    719              uint8_t prdiv_max;           /* Max PRDIV value to make reference clock in allowed range. */
    720              uint8_t prdiv_cur;           /* PRDIV value for iteration.    */
    721              uint8_t vdiv_cur;            /* VDIV value for iteration.     */
    722              uint32_t ret_freq = 0U;      /* PLL output fequency to return. */
    723              uint32_t diff = 0xFFFFFFFFU; /* Difference between desireFreq and return frequency. */
    724              uint32_t ref_div;            /* Reference frequency after PRDIV. */
    725          
    726              /*
    727                 Steps:
    728                 1. Get allowed prdiv with such rules:
    729                    1). refFreq / prdiv >= FSL_FEATURE_MCG_PLL_REF_MIN.
    730                    2). refFreq / prdiv <= FSL_FEATURE_MCG_PLL_REF_MAX.
    731                 2. For each allowed prdiv, there are two candidate vdiv values:
    732                    1). (desireFreq / (refFreq / prdiv)).
    733                    2). (desireFreq / (refFreq / prdiv)) + 1.
    734                    If could get the precise desired frequency, return current prdiv and
    735                    vdiv directly. Otherwise choose the one which is closer to desired
    736                    frequency.
    737               */
    738          
    739              /* Reference frequency is out of range. */
    740              if ((refFreq < FSL_FEATURE_MCG_PLL_REF_MIN) ||
    741                  (refFreq > (FSL_FEATURE_MCG_PLL_REF_MAX * (FSL_FEATURE_MCG_PLL_PRDIV_MAX + FSL_FEATURE_MCG_PLL_PRDIV_BASE))))
   \        0x6   0x.... 0x....      LDR.W    R5,??DataTable46_12  ;; 0xffe17b80
   \        0xA   0x.... 0x....      LDR.W    R6,??DataTable46_13  ;; 0x5d75c81
   \        0xE   0x444D             ADD      R5,R5,R9
   \       0x10   0x42B5             CMP      R5,R6
   \       0x12   0xF04F 0x38FF      MOV      R8,#-1
   \       0x16   0xD240             BCS.N    ??CLOCK_CalcPllDiv_0
    742              {
    743                  return 0U;
    744              }
    745          
    746              /* refFreq/PRDIV must in a range. First get the allowed PRDIV range. */
    747              prdiv_max = refFreq / FSL_FEATURE_MCG_PLL_REF_MIN;
    748              prdiv_min = (refFreq + FSL_FEATURE_MCG_PLL_REF_MAX - 1U) / FSL_FEATURE_MCG_PLL_REF_MAX;
   \       0x18   0x.... 0x....      LDR.W    R5,??DataTable46_14  ;; 0x3d08ff
   \       0x1C   0x.... 0x....      LDR.W    R7,??DataTable46_15  ;; 0x8637bd06
   \       0x20   0x444D             ADD      R5,R5,R9
   \       0x22   0xFBA5 0x7607      UMULL    R7,R6,R5,R7
    749          
    750              /* PRDIV traversal. */
    751              for (prdiv_cur = prdiv_max; prdiv_cur >= prdiv_min; prdiv_cur--)
   \       0x26   0x.... 0x....      LDR.W    R5,??DataTable46_15  ;; 0x8637bd06
   \       0x2A   0x00F7             LSLS     R7,R6,#+3
   \       0x2C   0xFBA9 0xEC05      UMULL    LR,R12,R9,R5
   \       0x30   0xEA4F 0x561C      LSR      R6,R12,#+20
   \       0x34   0x4694             MOV      R12,R2
   \       0x36   0x460D             MOV      R5,R1
   \       0x38   0x469E             MOV      LR,R3
   \       0x3A   0x4622             MOV      R2,R4
   \       0x3C   0xE011             B.N      ??CLOCK_CalcPllDiv_1
    752              {
    753                  /* Reference frequency after PRDIV. */
    754                  ref_div = refFreq / prdiv_cur;
    755          
    756                  vdiv_cur = desireFreq / ref_div;
    757          
    758                  if ((vdiv_cur < FSL_FEATURE_MCG_PLL_VDIV_BASE - 1U) || (vdiv_cur > FSL_FEATURE_MCG_PLL_VDIV_BASE + 31U))
    759                  {
    760                      /* No VDIV is available with this PRDIV. */
    761                      continue;
    762                  }
    763          
    764                  ret_freq = vdiv_cur * ref_div;
    765          
    766                  if (vdiv_cur >= FSL_FEATURE_MCG_PLL_VDIV_BASE)
    767                  {
    768                      if (ret_freq == desireFreq) /* If desire frequency is got. */
    769                      {
    770                          *prdiv = prdiv_cur - FSL_FEATURE_MCG_PLL_PRDIV_BASE;
    771                          *vdiv = vdiv_cur - FSL_FEATURE_MCG_PLL_VDIV_BASE;
    772                          return ret_freq;
    773                      }
    774                      /* New PRDIV/VDIV is closer. */
    775                      if (diff > desireFreq - ret_freq)
   \                     ??CLOCK_CalcPllDiv_2: (+1)
   \       0x3E   0x1AEC             SUBS     R4,R5,R3
   \       0x40   0x4544             CMP      R4,R8
   \       0x42   0xD202             BCS.N    ??CLOCK_CalcPllDiv_3
    776                      {
    777                          diff = desireFreq - ret_freq;
   \       0x44   0x46A0             MOV      R8,R4
    778                          ret_prdiv = prdiv_cur;
   \       0x46   0x4630             MOV      R0,R6
    779                          ret_vdiv = vdiv_cur;
   \       0x48   0x460A             MOV      R2,R1
    780                      }
    781                  }
    782                  vdiv_cur++;
   \                     ??CLOCK_CalcPllDiv_3: (+1)
   \       0x4A   0x1C49             ADDS     R1,R1,#+1
   \       0x4C   0xB2C9             UXTB     R1,R1
    783                  if (vdiv_cur <= (FSL_FEATURE_MCG_PLL_VDIV_BASE + 31U))
   \       0x4E   0x2938             CMP      R1,#+56
   \       0x50   0xBF3E             ITTT     CC 
   \       0x52   0x4453             ADDCC    R3,R10,R3
   \       0x54   0x1B5B             SUBCC    R3,R3,R5
   \       0x56   0x4543             CMPCC    R3,R8
    784                  {
    785                      ret_freq += ref_div;
    786                      /* New PRDIV/VDIV is closer. */
    787                      if (diff > ret_freq - desireFreq)
   \       0x58   0xD202             BCS.N    ??CLOCK_CalcPllDiv_4
    788                      {
    789                          diff = ret_freq - desireFreq;
   \       0x5A   0x4698             MOV      R8,R3
    790                          ret_prdiv = prdiv_cur;
   \       0x5C   0x4630             MOV      R0,R6
    791                          ret_vdiv = vdiv_cur;
   \       0x5E   0x460A             MOV      R2,R1
    792                      }
    793                  }
   \                     ??CLOCK_CalcPllDiv_4: (+1)
   \       0x60   0x1E76             SUBS     R6,R6,#+1
   \                     ??CLOCK_CalcPllDiv_1: (+1)
   \       0x62   0xB2F1             UXTB     R1,R6
   \       0x64   0xEBB1 0x6F17      CMP      R1,R7, LSR #+24
   \       0x68   0xDB1A             BLT.N    ??CLOCK_CalcPllDiv_5
   \       0x6A   0xFBB9 0xFAF1      UDIV     R10,R9,R1
   \       0x6E   0xFBB5 0xF1FA      UDIV     R1,R5,R10
   \       0x72   0xB2C9             UXTB     R1,R1
   \       0x74   0xF1A1 0x0317      SUB      R3,R1,#+23
   \       0x78   0x2B21             CMP      R3,#+33
   \       0x7A   0xD2F1             BCS.N    ??CLOCK_CalcPllDiv_4
   \       0x7C   0x2918             CMP      R1,#+24
   \       0x7E   0xFB0A 0xF301      MUL      R3,R10,R1
   \       0x82   0xDBE2             BLT.N    ??CLOCK_CalcPllDiv_3
   \       0x84   0x42AB             CMP      R3,R5
   \       0x86   0xD1DA             BNE.N    ??CLOCK_CalcPllDiv_2
   \       0x88   0x1E70             SUBS     R0,R6,#+1
   \       0x8A   0xF88C 0x0000      STRB     R0,[R12, #+0]
   \       0x8E   0x3918             SUBS     R1,R1,#+24
   \       0x90   0xF88E 0x1000      STRB     R1,[LR, #+0]
   \       0x94   0x4618             MOV      R0,R3
   \       0x96   0xE8BD 0x87F0      POP      {R4-R10,PC}
    794              }
    795          
    796              if (0xFFFFFFFFU != diff)
    797              {
    798                  /* PRDIV/VDIV found. */
    799                  *prdiv = ret_prdiv - FSL_FEATURE_MCG_PLL_PRDIV_BASE;
    800                  *vdiv = ret_vdiv - FSL_FEATURE_MCG_PLL_VDIV_BASE;
    801                  ret_freq = (refFreq / ret_prdiv) * ret_vdiv;
    802                  return ret_freq;
    803              }
    804              else
    805              {
    806                  /* No proper PRDIV/VDIV found. */
    807                  return 0U;
   \                     ??CLOCK_CalcPllDiv_0: (+1)
   \       0x9A   0x2000             MOVS     R0,#+0
   \       0x9C   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    808              }
   \                     ??CLOCK_CalcPllDiv_5: (+1)
   \       0xA0   0xF118 0x0F01      CMN      R8,#+1
   \       0xA4   0xD0F9             BEQ.N    ??CLOCK_CalcPllDiv_0
   \       0xA6   0x1E41             SUBS     R1,R0,#+1
   \       0xA8   0xB2C0             UXTB     R0,R0
   \       0xAA   0xF88C 0x1000      STRB     R1,[R12, #+0]
   \       0xAE   0xF1A2 0x0318      SUB      R3,R2,#+24
   \       0xB2   0xFBB9 0xF0F0      UDIV     R0,R9,R0
   \       0xB6   0xB2D2             UXTB     R2,R2
   \       0xB8   0xF88E 0x3000      STRB     R3,[LR, #+0]
   \       0xBC   0x4350             MULS     R0,R0,R2
   \       0xBE   0xE8BD 0x87F0      POP      {R4-R10,PC}
    809          }
    810          

   \                                 In section .text, align 2, keep-with-next
    811          void CLOCK_EnablePll0(mcg_pll_config_t const *config)
    812          {
    813              assert(config);
    814          
    815              uint8_t mcg_c5 = 0U;
    816          
    817              mcg_c5 |= MCG_C5_PRDIV0(config->prdiv);
    818              MCG->C5 = mcg_c5; /* Disable the PLL first. */
   \                     CLOCK_EnablePll0: (+1)
   \        0x0   0x7842             LDRB     R2,[R0, #+1]
   \        0x2   0x.... 0x....      LDR.W    R1,??DataTable46_10  ;; 0x40064004
   \        0x6   0xF002 0x021F      AND      R2,R2,#0x1F
   \        0xA   0x700A             STRB     R2,[R1, #+0]
    819          
    820              MCG->C6 = (MCG->C6 & ~MCG_C6_VDIV0_MASK) | MCG_C6_VDIV0(config->vdiv);
   \        0xC   0x784B             LDRB     R3,[R1, #+1]
   \        0xE   0x7882             LDRB     R2,[R0, #+2]
   \       0x10   0xF003 0x03E0      AND      R3,R3,#0xE0
   \       0x14   0xF002 0x021F      AND      R2,R2,#0x1F
   \       0x18   0x4313             ORRS     R3,R2,R3
   \       0x1A   0x704B             STRB     R3,[R1, #+1]
    821          
    822              /* Set enable mode. */
    823              MCG->C5 |= ((uint32_t)kMCG_PllEnableIndependent | (uint32_t)config->enableMode);
   \       0x1C   0x780B             LDRB     R3,[R1, #+0]
   \       0x1E   0x7800             LDRB     R0,[R0, #+0]
   \       0x20   0xF040 0x0040      ORR      R0,R0,#0x40
   \       0x24   0x4303             ORRS     R3,R0,R3
   \       0x26   0x700B             STRB     R3,[R1, #+0]
    824          
    825              /* Wait for PLL lock. */
    826              while (!(MCG->S & MCG_S_LOCK0_MASK))
   \                     ??CLOCK_EnablePll0_0: (+1)
   \       0x28   0x7888             LDRB     R0,[R1, #+2]
   \       0x2A   0x0642             LSLS     R2,R0,#+25
   \       0x2C   0xD5FC             BPL.N    ??CLOCK_EnablePll0_0
    827              {
    828              }
    829          }
   \       0x2E   0x4770             BX       LR               ;; return
    830          

   \                                 In section .text, align 2, keep-with-next
    831          void CLOCK_SetOsc0MonitorMode(mcg_monitor_mode_t mode)
    832          {
    833              /* Clear the previous flag, MCG_SC[LOCS0]. */
    834              MCG->SC &= ~MCG_SC_ATMF_MASK;
   \                     CLOCK_SetOsc0MonitorMode: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable46_9  ;; 0x40064001
   \        0x4   0x79CA             LDRB     R2,[R1, #+7]
   \        0x6   0xF002 0x02DF      AND      R2,R2,#0xDF
    835          
    836              if (kMCG_MonitorNone == mode)
   \        0xA   0x0003             MOVS     R3,R0
   \        0xC   0x71CA             STRB     R2,[R1, #+7]
   \        0xE   0xD103             BNE.N    ??CLOCK_SetOsc0MonitorMode_0
    837              {
    838                  MCG->C6 &= ~MCG_C6_CME0_MASK;
   \       0x10   0x7908             LDRB     R0,[R1, #+4]
   \       0x12   0xF000 0x00DF      AND      R0,R0,#0xDF
   \       0x16   0xE00D             B.N      ??CLOCK_SetOsc0MonitorMode_1
    839              }
    840              else
    841              {
    842                  if (kMCG_MonitorInt == mode)
   \                     ??CLOCK_SetOsc0MonitorMode_0: (+1)
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xD104             BNE.N    ??CLOCK_SetOsc0MonitorMode_2
    843                  {
    844                      MCG->C2 &= ~MCG_C2_LOCRE0_MASK;
   \       0x1C   0x7808             LDRB     R0,[R1, #+0]
   \       0x1E   0xF000 0x007F      AND      R0,R0,#0x7F
   \       0x22   0x7008             STRB     R0,[R1, #+0]
   \       0x24   0xE003             B.N      ??CLOCK_SetOsc0MonitorMode_3
    845                  }
    846                  else
    847                  {
    848                      MCG->C2 |= MCG_C2_LOCRE0_MASK;
   \                     ??CLOCK_SetOsc0MonitorMode_2: (+1)
   \       0x26   0x780A             LDRB     R2,[R1, #+0]
   \       0x28   0xF042 0x0280      ORR      R2,R2,#0x80
   \       0x2C   0x700A             STRB     R2,[R1, #+0]
    849                  }
    850                  MCG->C6 |= MCG_C6_CME0_MASK;
   \                     ??CLOCK_SetOsc0MonitorMode_3: (+1)
   \       0x2E   0x7908             LDRB     R0,[R1, #+4]
   \       0x30   0xF040 0x0020      ORR      R0,R0,#0x20
   \                     ??CLOCK_SetOsc0MonitorMode_1: (+1)
   \       0x34   0x7108             STRB     R0,[R1, #+4]
    851              }
    852          }
   \       0x36   0x4770             BX       LR               ;; return
    853          

   \                                 In section .text, align 2, keep-with-next
    854          void CLOCK_SetRtcOscMonitorMode(mcg_monitor_mode_t mode)
    855          {
    856              uint8_t mcg_c8 = MCG->C8;
   \                     CLOCK_SetRtcOscMonitorMode: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable46_16  ;; 0x4006400d
   \        0x4   0x780A             LDRB     R2,[R1, #+0]
    857          
    858              mcg_c8 &= ~(MCG_C8_CME1_MASK | MCG_C8_LOCRE1_MASK);
    859          
    860              if (kMCG_MonitorNone != mode)
   \        0x6   0x0003             MOVS     R3,R0
   \        0x8   0xF002 0x025F      AND      R2,R2,#0x5F
   \        0xC   0xD005             BEQ.N    ??CLOCK_SetRtcOscMonitorMode_0
    861              {
    862                  if (kMCG_MonitorReset == mode)
   \        0xE   0x2802             CMP      R0,#+2
   \       0x10   0xBF08             IT       EQ 
   \       0x12   0xF042 0x0280      ORREQ    R2,R2,#0x80
    863                  {
    864                      mcg_c8 |= MCG_C8_LOCRE1_MASK;
    865                  }
    866                  mcg_c8 |= MCG_C8_CME1_MASK;
   \       0x16   0xF042 0x0220      ORR      R2,R2,#0x20
    867              }
    868              MCG->C8 = mcg_c8;
   \                     ??CLOCK_SetRtcOscMonitorMode_0: (+1)
   \       0x1A   0x700A             STRB     R2,[R1, #+0]
    869          }
   \       0x1C   0x4770             BX       LR               ;; return
    870          

   \                                 In section .text, align 2, keep-with-next
    871          void CLOCK_SetPll0MonitorMode(mcg_monitor_mode_t mode)
    872          {
    873              uint8_t mcg_c8;
    874          
    875              /* Clear previous flag. */
    876              MCG->S = MCG_S_LOLS0_MASK;
   \                     CLOCK_SetPll0MonitorMode: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable46_17  ;; 0x40064005
   \        0x4   0x2280             MOVS     R2,#+128
    877          
    878              if (kMCG_MonitorNone == mode)
   \        0x6   0x0003             MOVS     R3,R0
   \        0x8   0x704A             STRB     R2,[R1, #+1]
   \        0xA   0xD103             BNE.N    ??CLOCK_SetPll0MonitorMode_0
    879              {
    880                  MCG->C6 &= ~MCG_C6_LOLIE0_MASK;
   \        0xC   0x7808             LDRB     R0,[R1, #+0]
   \        0xE   0xF000 0x007F      AND      R0,R0,#0x7F
   \       0x12   0xE00C             B.N      ??CLOCK_SetPll0MonitorMode_1
    881              }
    882              else
    883              {
    884                  mcg_c8 = MCG->C8;
   \                     ??CLOCK_SetPll0MonitorMode_0: (+1)
   \       0x14   0x7A0A             LDRB     R2,[R1, #+8]
    885          
    886                  mcg_c8 &= ~MCG_C8_LOCS1_MASK;
   \       0x16   0xF002 0x02FE      AND      R2,R2,#0xFE
    887          
    888                  if (kMCG_MonitorInt == mode)
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xBF0C             ITE      EQ 
   \       0x1E   0xF022 0x0240      BICEQ    R2,R2,#0x40
   \       0x22   0xF042 0x0240      ORRNE    R2,R2,#0x40
    889                  {
    890                      mcg_c8 &= ~MCG_C8_LOLRE_MASK;
    891                  }
    892                  else
    893                  {
    894                      mcg_c8 |= MCG_C8_LOLRE_MASK;
    895                  }
    896                  MCG->C8 = mcg_c8;
   \       0x26   0x720A             STRB     R2,[R1, #+8]
    897                  MCG->C6 |= MCG_C6_LOLIE0_MASK;
   \       0x28   0x7808             LDRB     R0,[R1, #+0]
   \       0x2A   0xF040 0x0080      ORR      R0,R0,#0x80
   \                     ??CLOCK_SetPll0MonitorMode_1: (+1)
   \       0x2E   0x7008             STRB     R0,[R1, #+0]
    898              }
    899          }
   \       0x30   0x4770             BX       LR               ;; return
    900          

   \                                 In section .text, align 2, keep-with-next
    901          uint32_t CLOCK_GetStatusFlags(void)
    902          {
    903              uint32_t ret = 0U;
    904              uint8_t mcg_s = MCG->S;
   \                     CLOCK_GetStatusFlags: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable46_8  ;; 0x40064006
   \        0x4   0x780A             LDRB     R2,[R1, #+0]
    905          
    906              if (MCG->SC & MCG_SC_LOCS0_MASK)
   \        0x6   0x788B             LDRB     R3,[R1, #+2]
    907              {
    908                  ret |= kMCG_Osc0LostFlag;
    909              }
    910              if (mcg_s & MCG_S_OSCINIT0_MASK)
    911              {
    912                  ret |= kMCG_Osc0InitFlag;
    913              }
    914              if (MCG->C8 & MCG_C8_LOCS1_MASK)
   \        0x8   0x79C9             LDRB     R1,[R1, #+7]
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xEA5F 0x7CC3      LSLS     R12,R3,#+31
   \       0x10   0xBF48             IT       MI 
   \       0x12   0x2001             MOVMI    R0,#+1
   \       0x14   0x0793             LSLS     R3,R2,#+30
   \       0x16   0xBF48             IT       MI 
   \       0x18   0xF040 0x0002      ORRMI    R0,R0,#0x2
   \       0x1C   0x07CB             LSLS     R3,R1,#+31
   \       0x1E   0xBF48             IT       MI 
   \       0x20   0xF040 0x0010      ORRMI    R0,R0,#0x10
    915              {
    916                  ret |= kMCG_RtcOscLostFlag;
    917              }
    918              if (mcg_s & MCG_S_LOLS0_MASK)
   \       0x24   0x0611             LSLS     R1,R2,#+24
   \       0x26   0xBF48             IT       MI 
   \       0x28   0xF040 0x0020      ORRMI    R0,R0,#0x20
    919              {
    920                  ret |= kMCG_Pll0LostFlag;
    921              }
    922              if (mcg_s & MCG_S_LOCK0_MASK)
   \       0x2C   0x0651             LSLS     R1,R2,#+25
   \       0x2E   0xBF48             IT       MI 
   \       0x30   0xF040 0x0040      ORRMI    R0,R0,#0x40
    923              {
    924                  ret |= kMCG_Pll0LockFlag;
    925              }
    926              return ret;
   \       0x34   0x4770             BX       LR               ;; return
    927          }
    928          

   \                                 In section .text, align 2, keep-with-next
    929          void CLOCK_ClearStatusFlags(uint32_t mask)
    930          {
    931              uint8_t reg;
    932          
    933              if (mask & kMCG_Osc0LostFlag)
   \                     CLOCK_ClearStatusFlags: (+1)
   \        0x0   0x07C1             LSLS     R1,R0,#+31
   \        0x2   0xD505             BPL.N    ??CLOCK_ClearStatusFlags_0
    934              {
    935                  MCG->SC &= ~MCG_SC_ATMF_MASK;
   \        0x4   0x.... 0x....      LDR.W    R1,??DataTable46_8  ;; 0x40064006
   \        0x8   0x788A             LDRB     R2,[R1, #+2]
   \        0xA   0xF002 0x02DF      AND      R2,R2,#0xDF
   \        0xE   0x708A             STRB     R2,[R1, #+2]
    936              }
    937              if (mask & kMCG_RtcOscLostFlag)
   \                     ??CLOCK_ClearStatusFlags_0: (+1)
   \       0x10   0x06C1             LSLS     R1,R0,#+27
   \       0x12   0xD503             BPL.N    ??CLOCK_ClearStatusFlags_1
    938              {
    939                  reg = MCG->C8;
   \       0x14   0x.... 0x....      LDR.W    R1,??DataTable46_8  ;; 0x40064006
   \       0x18   0x79CA             LDRB     R2,[R1, #+7]
    940                  MCG->C8 = reg;
   \       0x1A   0x71CA             STRB     R2,[R1, #+7]
    941              }
    942              if (mask & kMCG_Pll0LostFlag)
   \                     ??CLOCK_ClearStatusFlags_1: (+1)
   \       0x1C   0x0680             LSLS     R0,R0,#+26
   \       0x1E   0xD503             BPL.N    ??CLOCK_ClearStatusFlags_2
    943              {
    944                  MCG->S = MCG_S_LOLS0_MASK;
   \       0x20   0x.... 0x....      LDR.W    R2,??DataTable46_8  ;; 0x40064006
   \       0x24   0x2180             MOVS     R1,#+128
   \       0x26   0x7011             STRB     R1,[R2, #+0]
    945              }
    946          }
   \                     ??CLOCK_ClearStatusFlags_2: (+1)
   \       0x28   0x4770             BX       LR               ;; return
    947          

   \                                 In section .text, align 2, keep-with-next
    948          void CLOCK_InitOsc0(osc_config_t const *config)
    949          {
   \                     CLOCK_InitOsc0: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
    950              uint8_t range = CLOCK_GetOscRangeFromFreq(config->freq);
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF649 0x0298      MOVW     R2,#+39064
   \        0x8   0x4291             CMP      R1,R2
   \        0xA   0xBF38             IT       CC 
   \        0xC   0x2200             MOVCC    R2,#+0
   \        0xE   0xD305             BCC.N    ??CLOCK_InitOsc0_0
   \       0x10   0x.... 0x....      LDR.W    R2,??DataTable46_18  ;; 0x7a1201
   \       0x14   0x4291             CMP      R1,R2
   \       0x16   0xBF34             ITE      CC 
   \       0x18   0x2201             MOVCC    R2,#+1
   \       0x1A   0x2202             MOVCS    R2,#+2
    951          
    952              OSC_SetCapLoad(OSC0, config->capLoad);
   \                     ??CLOCK_InitOsc0_0: (+1)
   \       0x1C   0x.... 0x....      LDR.W    R3,??DataTable46  ;; 0x40065000
   \       0x20   0x781C             LDRB     R4,[R3, #+0]
   \       0x22   0x7901             LDRB     R1,[R0, #+4]
   \       0x24   0xF004 0x04F0      AND      R4,R4,#0xF0
   \       0x28   0x430C             ORRS     R4,R1,R4
   \       0x2A   0x701C             STRB     R4,[R3, #+0]
    953              OSC_SetExtRefClkConfig(OSC0, &config->oscerConfig);
   \       0x2C   0x781C             LDRB     R4,[R3, #+0]
   \       0x2E   0x7981             LDRB     R1,[R0, #+6]
   \       0x30   0xF004 0x045F      AND      R4,R4,#0x5F
   \       0x34   0x430C             ORRS     R4,R1,R4
   \       0x36   0x701C             STRB     R4,[R3, #+0]
    954          
    955              MCG->C2 = ((MCG->C2 & ~OSC_MODE_MASK) | MCG_C2_RANGE(range) | (uint8_t)config->workMode);
   \       0x38   0x.... 0x....      LDR.W    R4,??DataTable46_9  ;; 0x40064001
   \       0x3C   0x7825             LDRB     R5,[R4, #+0]
   \       0x3E   0x7941             LDRB     R1,[R0, #+5]
   \       0x40   0xF005 0x05C3      AND      R5,R5,#0xC3
   \       0x44   0xEA45 0x1502      ORR      R5,R5,R2, LSL #+4
   \       0x48   0x430D             ORRS     R5,R1,R5
   \       0x4A   0x7025             STRB     R5,[R4, #+0]
    956          
    957              if ((kOSC_ModeExt != config->workMode) && (OSC0->CR & OSC_CR_ERCLKEN_MASK))
   \       0x4C   0x7940             LDRB     R0,[R0, #+5]
   \       0x4E   0xB128             CBZ.N    R0,??CLOCK_InitOsc0_1
   \       0x50   0x7819             LDRB     R1,[R3, #+0]
   \       0x52   0x0608             LSLS     R0,R1,#+24
   \       0x54   0xD502             BPL.N    ??CLOCK_InitOsc0_1
    958              {
    959                  /* Wait for stable. */
    960                  while (!(MCG->S & MCG_S_OSCINIT0_MASK))
   \                     ??CLOCK_InitOsc0_2: (+1)
   \       0x56   0x7961             LDRB     R1,[R4, #+5]
   \       0x58   0x0788             LSLS     R0,R1,#+30
   \       0x5A   0xD5FC             BPL.N    ??CLOCK_InitOsc0_2
    961                  {
    962                  }
    963              }
    964          }
   \                     ??CLOCK_InitOsc0_1: (+1)
   \       0x5C   0xBC30             POP      {R4,R5}
   \       0x5E   0x4770             BX       LR               ;; return
    965          

   \                                 In section .text, align 2, keep-with-next
    966          void CLOCK_DeinitOsc0(void)
    967          {
    968              OSC0->CR = 0U;
   \                     CLOCK_DeinitOsc0: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable46  ;; 0x40065000
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x7008             STRB     R0,[R1, #+0]
    969              MCG->C2 &= ~OSC_MODE_MASK;
   \        0x8   0x.... 0x....      LDR.W    R0,??DataTable46_9  ;; 0x40064001
   \        0xC   0x7802             LDRB     R2,[R0, #+0]
   \        0xE   0xF002 0x02C3      AND      R2,R2,#0xC3
   \       0x12   0x7002             STRB     R2,[R0, #+0]
    970          }
   \       0x14   0x4770             BX       LR               ;; return
    971          

   \                                 In section .text, align 2, keep-with-next
    972          status_t CLOCK_TrimInternalRefClk(uint32_t extFreq, uint32_t desireFreq, uint32_t *actualFreq, mcg_atm_select_t atms)
    973          {
   \                     CLOCK_TrimInternalRefClk: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
    974              uint32_t multi; /* extFreq / desireFreq */
    975              uint32_t actv;  /* Auto trim value. */
    976              uint8_t mcg_sc;
    977          
    978              static const uint32_t trimRange[2][2] = {
    979                  /*     Min           Max      */
    980                  {TRIM_SIRC_MIN, TRIM_SIRC_MAX}, /* Slow IRC. */
    981                  {TRIM_FIRC_MIN, TRIM_FIRC_MAX}  /* Fast IRC. */
    982              };
    983          
    984              if ((extFreq > TRIM_REF_CLK_MAX) || (extFreq < TRIM_REF_CLK_MIN))
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable46_19  ;; 0xff85ee00
   \        0x6   0x.... 0x....      LDR.W    R5,??DataTable46_18  ;; 0x7a1201
   \        0xA   0x1824             ADDS     R4,R4,R0
   \        0xC   0x42AC             CMP      R4,R5
   \        0xE   0xBF28             IT       CS 
   \       0x10   0xF240 0x70D2      MOVWCS   R0,#+2002
    985              {
    986                  return kStatus_MCG_AtmBusClockInvalid;
   \       0x14   0xD240             BCS.N    ??CLOCK_TrimInternalRefClk_0
    987              }
    988          
    989              /* Check desired frequency range. */
    990              if ((desireFreq < trimRange[atms][0]) || (desireFreq > trimRange[atms][1]))
   \       0x16   0x.... 0x....      ADR.W    R5,`CLOCK_TrimInternalRefClk::trimRange`
   \       0x1A   0x461C             MOV      R4,R3
   \       0x1C   0xF855 0x6034      LDR      R6,[R5, R4, LSL #+3]
   \       0x20   0x42B1             CMP      R1,R6
   \       0x22   0xBF23             ITTTE    CS 
   \       0x24   0xEB05 0x04C4      ADDCS    R4,R5,R4, LSL #+3
   \       0x28   0x6865             LDRCS    R5,[R4, #+4]
   \       0x2A   0x428D             CMPCS    R5,R1
   \       0x2C   0xF240 0x70D3      MOVWCC   R0,#+2003
    991              {
    992                  return kStatus_MCG_AtmDesiredFreqInvalid;
   \       0x30   0xD332             BCC.N    ??CLOCK_TrimInternalRefClk_0
    993              }
    994          
    995              /*
    996                 Make sure internal reference clock is not used to generate bus clock.
    997                 Here only need to check (MCG_S_IREFST == 1).
    998               */
    999              if (MCG_S_IREFST(kMCG_FllSrcInternal) == (MCG->S & MCG_S_IREFST_MASK))
   \       0x32   0x.... 0x....      LDR.W    R4,??DataTable46_8  ;; 0x40064006
   \       0x36   0x7825             LDRB     R5,[R4, #+0]
   \       0x38   0x06EE             LSLS     R6,R5,#+27
   \       0x3A   0xBF48             IT       MI 
   \       0x3C   0xF240 0x70D4      MOVWMI   R0,#+2004
   1000              {
   1001                  return kStatus_MCG_AtmIrcUsed;
   \       0x40   0xD42A             BMI.N    ??CLOCK_TrimInternalRefClk_0
   1002              }
   1003          
   1004              multi = extFreq / desireFreq;
   \       0x42   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   1005              actv = multi * 21U;
   \       0x46   0x2515             MOVS     R5,#+21
   \       0x48   0x434D             MULS     R5,R5,R1
   1006          
   1007              if (kMCG_AtmSel4m == atms)
   \       0x4A   0x2B01             CMP      R3,#+1
   \       0x4C   0xBF08             IT       EQ 
   \       0x4E   0x01ED             LSLEQ    R5,R5,#+7
   1008              {
   1009                  actv *= 128U;
   1010              }
   1011          
   1012              /* Now begin to start trim. */
   1013              MCG->ATCVL = (uint8_t)actv;
   \       0x50   0x7165             STRB     R5,[R4, #+5]
   1014              MCG->ATCVH = (uint8_t)(actv >> 8U);
   1015          
   1016              mcg_sc = MCG->SC;
   1017              mcg_sc &= ~(MCG_SC_ATMS_MASK | MCG_SC_LOCS0_MASK);
   1018              mcg_sc |= (MCG_SC_ATMF_MASK | MCG_SC_ATMS(atms));
   \       0x52   0x019E             LSLS     R6,R3,#+6
   \       0x54   0x0A2D             LSRS     R5,R5,#+8
   \       0x56   0x7125             STRB     R5,[R4, #+4]
   \       0x58   0xF006 0x0640      AND      R6,R6,#0x40
   \       0x5C   0x78A5             LDRB     R5,[R4, #+2]
   \       0x5E   0xF005 0x05BE      AND      R5,R5,#0xBE
   \       0x62   0x4335             ORRS     R5,R6,R5
   \       0x64   0xF045 0x0520      ORR      R5,R5,#0x20
   1019              MCG->SC = (mcg_sc | MCG_SC_ATME_MASK);
   \       0x68   0xF045 0x0780      ORR      R7,R5,#0x80
   \       0x6C   0x70A7             STRB     R7,[R4, #+2]
   1020          
   1021              /* Wait for finished. */
   1022              while (MCG->SC & MCG_SC_ATME_MASK)
   \                     ??CLOCK_TrimInternalRefClk_1: (+1)
   \       0x6E   0x78A6             LDRB     R6,[R4, #+2]
   \       0x70   0x0637             LSLS     R7,R6,#+24
   \       0x72   0xD4FC             BMI.N    ??CLOCK_TrimInternalRefClk_1
   1023              {
   1024              }
   1025          
   1026              /* Error occurs? */
   1027              if (MCG->SC & MCG_SC_ATMF_MASK)
   \       0x74   0x78A6             LDRB     R6,[R4, #+2]
   \       0x76   0x06B7             LSLS     R7,R6,#+26
   \       0x78   0xD504             BPL.N    ??CLOCK_TrimInternalRefClk_2
   1028              {
   1029                  /* Clear the failed flag. */
   1030                  MCG->SC = mcg_sc;
   \       0x7A   0x70A5             STRB     R5,[R4, #+2]
   1031                  return kStatus_MCG_AtmHardwareFail;
   \       0x7C   0xF240 0x70D5      MOVW     R0,#+2005
   \       0x80   0xBCF0             POP      {R4-R7}
   \       0x82   0x4770             BX       LR
   1032              }
   1033          
   1034              *actualFreq = extFreq / multi;
   \                     ??CLOCK_TrimInternalRefClk_2: (+1)
   \       0x84   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0x88   0x6010             STR      R0,[R2, #+0]
   1035          
   1036              if (kMCG_AtmSel4m == atms)
   \       0x8A   0x2B01             CMP      R3,#+1
   \       0x8C   0x.... 0x....      LDR.W    R1,??DataTable46_1
   \       0x90   0xBF0C             ITE      EQ 
   \       0x92   0x6048             STREQ    R0,[R1, #+4]
   \       0x94   0x6008             STRNE    R0,[R1, #+0]
   1037              {
   1038                  s_fastIrcFreq = *actualFreq;
   1039              }
   1040              else
   1041              {
   1042                  s_slowIrcFreq = *actualFreq;
   1043              }
   1044          
   1045              return kStatus_Success;
   \       0x96   0x2000             MOVS     R0,#+0
   \                     ??CLOCK_TrimInternalRefClk_0: (+1)
   \       0x98   0xBCF0             POP      {R4-R7}
   \       0x9A   0x4770             BX       LR               ;; return
   1046          }

   \                                 In section .text, align 4, keep-with-next
   \                     `CLOCK_TrimInternalRefClk::trimRange`:
   \        0x0   0x0000'7A12        DC32 31250, 39063, 3000000, 5000000
   \              0x0000'9897  
   \              0x002D'C6C0  
   \              0x004C'4B40  
   1047          

   \                                 In section .text, align 4, keep-with-next
   1048          mcg_mode_t CLOCK_GetMode(void)
   1049          {
   \                     CLOCK_GetMode: (+1)
   \        0x0   0xB410             PUSH     {R4}
   1050              mcg_mode_t mode = kMCG_ModeError;
   1051              uint32_t clkst = MCG_S_CLKST_VAL;
   \        0x2   0x.... 0x....      LDR.W    R3,??DataTable46_9  ;; 0x40064001
   \        0x6   0x795C             LDRB     R4,[R3, #+5]
   1052              uint32_t irefst = MCG_S_IREFST_VAL;
   \        0x8   0x795A             LDRB     R2,[R3, #+5]
   1053              uint32_t lp = MCG_C2_LP_VAL;
   \        0xA   0x7819             LDRB     R1,[R3, #+0]
   1054              uint32_t pllst = MCG_S_PLLST_VAL;
   \        0xC   0x795B             LDRB     R3,[R3, #+5]
   1055          
   1056              /*------------------------------------------------------------------
   1057                                     Mode and Registers
   1058              ____________________________________________________________________
   1059          
   1060                Mode   |   CLKST    |   IREFST   |   PLLST   |      LP
   1061              ____________________________________________________________________
   1062          
   1063                FEI    |  00(FLL)   |   1(INT)   |   0(FLL)  |      X
   1064              ____________________________________________________________________
   1065          
   1066                FEE    |  00(FLL)   |   0(EXT)   |   0(FLL)  |      X
   1067              ____________________________________________________________________
   1068          
   1069                FBE    |  10(EXT)   |   0(EXT)   |   0(FLL)  |   0(NORMAL)
   1070              ____________________________________________________________________
   1071          
   1072                FBI    |  01(INT)   |   1(INT)   |   0(FLL)  |   0(NORMAL)
   1073              ____________________________________________________________________
   1074          
   1075                BLPI   |  01(INT)   |   1(INT)   |   0(FLL)  |   1(LOW POWER)
   1076              ____________________________________________________________________
   1077          
   1078                BLPE   |  10(EXT)   |   0(EXT)   |     X     |   1(LOW POWER)
   1079              ____________________________________________________________________
   1080          
   1081                PEE    |  11(PLL)   |   0(EXT)   |   1(PLL)  |      X
   1082              ____________________________________________________________________
   1083          
   1084                PBE    |  10(EXT)   |   0(EXT)   |   1(PLL)  |   O(NORMAL)
   1085              ____________________________________________________________________
   1086          
   1087                PBI    |  01(INT)   |   1(INT)   |   1(PLL)  |   0(NORMAL)
   1088              ____________________________________________________________________
   1089          
   1090                PEI    |  11(PLL)   |   1(INT)   |   1(PLL)  |      X
   1091              ____________________________________________________________________
   1092          
   1093              ----------------------------------------------------------------------*/
   1094          
   1095              switch (clkst)
   \        0xE   0x08A4             LSRS     R4,R4,#+2
   \       0x10   0x2008             MOVS     R0,#+8
   \       0x12   0x095B             LSRS     R3,R3,#+5
   \       0x14   0xF004 0x0403      AND      R4,R4,#0x3
   \       0x18   0x2C03             CMP      R4,#+3
   \       0x1A   0xF3C1 0x0140      UBFX     R1,R1,#+1,#+1
   \       0x1E   0xD81C             BHI.N    ??CLOCK_GetMode_1
   \       0x20   0xE8DF 0xF004      TBB      [PC, R4]
   \                     ??CLOCK_GetMode_0:
   \       0x24   0x02 0x0A          DC8      0x2,0xA,0x10,0x1A
   \              0x10 0x1A    
   1096              {
   1097                  case kMCG_ClkOutStatFll:
   1098                      if (kMCG_FllSrcExternal == irefst)
   \                     ??CLOCK_GetMode_2: (+1)
   \       0x28   0xF3C2 0x1000      UBFX     R0,R2,#+4,#+1
   \       0x2C   0x2800             CMP      R0,#+0
   1099                      {
   1100                          mode = kMCG_ModeFEE;
   1101                      }
   1102                      else
   1103                      {
   1104                          mode = kMCG_ModeFEI;
   1105                      }
   1106                      break;
   1107                  case kMCG_ClkOutStatInt:
   1108                      if (lp)
   1109                      {
   1110                          mode = kMCG_ModeBLPI;
   1111                      }
   1112                      else
   1113                      {
   1114                          {
   1115                              mode = kMCG_ModeFBI;
   1116                          }
   1117                      }
   1118                      break;
   1119                  case kMCG_ClkOutStatExt:
   1120                      if (lp)
   1121                      {
   1122                          mode = kMCG_ModeBLPE;
   1123                      }
   1124                      else
   1125                      {
   1126                          if (kMCG_PllstPll == pllst)
   1127                          {
   1128                              mode = kMCG_ModePBE;
   1129                          }
   1130                          else
   1131                          {
   1132                              mode = kMCG_ModeFBE;
   1133                          }
   1134                      }
   1135                      break;
   1136                  case kMCG_ClkOutStatPll:
   1137                  {
   1138                      mode = kMCG_ModePEE;
   1139                  }
   1140                  break;
   1141                  default:
   1142                      break;
   1143              }
   1144          
   1145              return mode;
   \       0x2E   0xBC10             POP      {R4}
   \       0x30   0xBF14             ITE      NE 
   \       0x32   0x2000             MOVNE    R0,#+0
   \       0x34   0x2003             MOVEQ    R0,#+3
   \       0x36   0x4770             BX       LR
   \                     ??CLOCK_GetMode_3: (+1)
   \       0x38   0x2900             CMP      R1,#+0
   \       0x3A   0xBC10             POP      {R4}
   \       0x3C   0xBF0C             ITE      EQ 
   \       0x3E   0x2001             MOVEQ    R0,#+1
   \       0x40   0x2002             MOVNE    R0,#+2
   \       0x42   0x4770             BX       LR
   \                     ??CLOCK_GetMode_4: (+1)
   \       0x44   0xB111             CBZ.N    R1,??CLOCK_GetMode_5
   \       0x46   0xBC10             POP      {R4}
   \       0x48   0x2005             MOVS     R0,#+5
   \       0x4A   0x4770             BX       LR
   \                     ??CLOCK_GetMode_5: (+1)
   \       0x4C   0x07D8             LSLS     R0,R3,#+31
   \       0x4E   0xBC10             POP      {R4}
   \       0x50   0xBF54             ITE      PL 
   \       0x52   0x2004             MOVPL    R0,#+4
   \       0x54   0x2006             MOVMI    R0,#+6
   \       0x56   0x4770             BX       LR
   \                     ??CLOCK_GetMode_6: (+1)
   \       0x58   0x2007             MOVS     R0,#+7
   \                     ??CLOCK_GetMode_1: (+1)
   \       0x5A   0xBC10             POP      {R4}
   \       0x5C   0x4770             BX       LR               ;; return
   1146          }
   1147          

   \                                 In section .text, align 2, keep-with-next
   1148          status_t CLOCK_SetFeiMode(mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(void))
   1149          {
   \                     CLOCK_SetFeiMode: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   1150              uint8_t mcg_c4;
   1151              bool change_drs = false;
   1152          
   1153          #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
   1154              mcg_mode_t mode = CLOCK_GetMode();
   1155              if (!((kMCG_ModeFEI == mode) || (kMCG_ModeFBI == mode) || (kMCG_ModeFBE == mode) || (kMCG_ModeFEE == mode)))
   1156              {
   1157                  return kStatus_MCG_ModeUnreachable;
   1158              }
   1159          #endif
   1160              mcg_c4 = MCG->C4;
   \        0x2   0x.... 0x....      LDR.W    R5,??DataTable46_11  ;; 0x40064000
   \        0x6   0x78EE             LDRB     R6,[R5, #+3]
   \        0x8   0x4603             MOV      R3,R0
   1161          
   1162              /*
   1163                 Errata: ERR007993
   1164                 Workaround: Invert MCG_C4[DMX32] or change MCG_C4[DRST_DRS] before
   1165                 reference clock source changes, then reset to previous value after
   1166                 reference clock changes.
   1167               */
   1168              if (kMCG_FllSrcExternal == MCG_S_IREFST_VAL)
   \        0xA   0x79A8             LDRB     R0,[R5, #+6]
   \        0xC   0x2400             MOVS     R4,#+0
   \        0xE   0xF3C0 0x1000      UBFX     R0,R0,#+4,#+1
   \       0x12   0xB920             CBNZ.N   R0,??CLOCK_SetFeiMode_0
   1169              {
   1170                  change_drs = true;
   1171                  /* Change the LSB of DRST_DRS. */
   1172                  MCG->C4 ^= (1U << MCG_C4_DRST_DRS_SHIFT);
   \       0x14   0x78E8             LDRB     R0,[R5, #+3]
   \       0x16   0xF080 0x0020      EOR      R0,R0,#0x20
   \       0x1A   0x2401             MOVS     R4,#+1
   \       0x1C   0x70E8             STRB     R0,[R5, #+3]
   1173              }
   1174          
   1175              /* Set CLKS and IREFS. */
   1176              MCG->C1 =
   1177                  ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK))) | (MCG_C1_CLKS(kMCG_ClkOutSrcOut)        /* CLKS = 0 */
   1178                                                                           | MCG_C1_IREFS(kMCG_FllSrcInternal)); /* IREFS = 1 */
   \                     ??CLOCK_SetFeiMode_0: (+1)
   \       0x1E   0x7828             LDRB     R0,[R5, #+0]
   \       0x20   0xF000 0x003B      AND      R0,R0,#0x3B
   \       0x24   0xF040 0x0004      ORR      R0,R0,#0x4
   \       0x28   0x7028             STRB     R0,[R5, #+0]
   1179          
   1180              /* Wait and check status. */
   1181              while (kMCG_FllSrcInternal != MCG_S_IREFST_VAL)
   \                     ??CLOCK_SetFeiMode_1: (+1)
   \       0x2A   0x79A8             LDRB     R0,[R5, #+6]
   \       0x2C   0xF3C0 0x1000      UBFX     R0,R0,#+4,#+1
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD0FA             BEQ.N    ??CLOCK_SetFeiMode_1
   1182              {
   1183              }
   1184          
   1185              /* Errata: ERR007993 */
   1186              if (change_drs)
   \       0x34   0xB104             CBZ.N    R4,??CLOCK_SetFeiMode_2
   1187              {
   1188                  MCG->C4 = mcg_c4;
   \       0x36   0x70EE             STRB     R6,[R5, #+3]
   1189              }
   1190          
   1191              /* In FEI mode, the MCG_C4[DMX32] is set to 0U. */
   1192              MCG->C4 = (mcg_c4 & ~(MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) | (MCG_C4_DMX32(dmx32) | MCG_C4_DRST_DRS(drs));
   \                     ??CLOCK_SetFeiMode_2: (+1)
   \       0x38   0xF006 0x061F      AND      R6,R6,#0x1F
   \       0x3C   0x0149             LSLS     R1,R1,#+5
   \       0x3E   0xEA46 0x16C3      ORR      R6,R6,R3, LSL #+7
   \       0x42   0xF001 0x0160      AND      R1,R1,#0x60
   \       0x46   0x4331             ORRS     R1,R1,R6
   \       0x48   0x70E9             STRB     R1,[R5, #+3]
   1193          
   1194              /* Check MCG_S[CLKST] */
   1195              while (kMCG_ClkOutStatFll != MCG_S_CLKST_VAL)
   \                     ??CLOCK_SetFeiMode_3: (+1)
   \       0x4A   0x79A8             LDRB     R0,[R5, #+6]
   \       0x4C   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD1FA             BNE.N    ??CLOCK_SetFeiMode_3
   1196              {
   1197              }
   1198          
   1199              /* Wait for FLL stable time. */
   1200              if (fllStableDelay)
   \       0x54   0x0010             MOVS     R0,R2
   \       0x56   0xBF18             IT       NE 
   1201              {
   1202                  fllStableDelay();
   \       0x58   0x4790             BLXNE    R2
   1203              }
   1204          
   1205              return kStatus_Success;
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0xBD70             POP      {R4-R6,PC}       ;; return
   1206          }
   1207          

   \                                 In section .text, align 2, keep-with-next
   1208          status_t CLOCK_SetFeeMode(uint8_t frdiv, mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(void))
   1209          {
   \                     CLOCK_SetFeeMode: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   1210              uint8_t mcg_c4;
   1211              bool change_drs = false;
   1212          
   1213          #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
   1214              mcg_mode_t mode = CLOCK_GetMode();
   1215              if (!((kMCG_ModeFEE == mode) || (kMCG_ModeFBI == mode) || (kMCG_ModeFBE == mode) || (kMCG_ModeFEI == mode)))
   1216              {
   1217                  return kStatus_MCG_ModeUnreachable;
   1218              }
   1219          #endif
   1220              mcg_c4 = MCG->C4;
   \        0x2   0x.... 0x....      LDR.W    R6,??DataTable46_11  ;; 0x40064000
   \        0x6   0x78F7             LDRB     R7,[R6, #+3]
   1221          
   1222              /*
   1223                 Errata: ERR007993
   1224                 Workaround: Invert MCG_C4[DMX32] or change MCG_C4[DRST_DRS] before
   1225                 reference clock source changes, then reset to previous value after
   1226                 reference clock changes.
   1227               */
   1228              if (kMCG_FllSrcInternal == MCG_S_IREFST_VAL)
   \        0x8   0x79B5             LDRB     R5,[R6, #+6]
   \        0xA   0x2400             MOVS     R4,#+0
   \        0xC   0xF3C5 0x1500      UBFX     R5,R5,#+4,#+1
   \       0x10   0xB125             CBZ.N    R5,??CLOCK_SetFeeMode_0
   1229              {
   1230                  change_drs = true;
   1231                  /* Change the LSB of DRST_DRS. */
   1232                  MCG->C4 ^= (1U << MCG_C4_DRST_DRS_SHIFT);
   \       0x12   0x78F5             LDRB     R5,[R6, #+3]
   \       0x14   0xF085 0x0520      EOR      R5,R5,#0x20
   \       0x18   0x2401             MOVS     R4,#+1
   \       0x1A   0x70F5             STRB     R5,[R6, #+3]
   1233              }
   1234          
   1235              /* Set CLKS and IREFS. */
   1236              MCG->C1 = ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK)) |
   1237                         (MCG_C1_CLKS(kMCG_ClkOutSrcOut)         /* CLKS = 0 */
   1238                          | MCG_C1_FRDIV(frdiv)                  /* FRDIV */
   1239                          | MCG_C1_IREFS(kMCG_FllSrcExternal))); /* IREFS = 0 */
   \                     ??CLOCK_SetFeeMode_0: (+1)
   \       0x1C   0x00C0             LSLS     R0,R0,#+3
   \       0x1E   0x7835             LDRB     R5,[R6, #+0]
   \       0x20   0xF005 0x0503      AND      R5,R5,#0x3
   \       0x24   0xF000 0x0038      AND      R0,R0,#0x38
   \       0x28   0x4328             ORRS     R0,R0,R5
   \       0x2A   0x7030             STRB     R0,[R6, #+0]
   1240          
   1241              /* If use external crystal as clock source, wait for it stable. */
   1242              if (MCG_C7_OSCSEL(kMCG_OscselOsc) == (MCG->C7 & MCG_C7_OSCSEL_MASK))
   \       0x2C   0x7B30             LDRB     R0,[R6, #+12]
   \       0x2E   0x07C5             LSLS     R5,R0,#+31
   \       0x30   0xD405             BMI.N    ??CLOCK_SetFeeMode_1
   1243              {
   1244                  if (MCG->C2 & MCG_C2_EREFS_MASK)
   \       0x32   0x7870             LDRB     R0,[R6, #+1]
   \       0x34   0x0745             LSLS     R5,R0,#+29
   \       0x36   0xD502             BPL.N    ??CLOCK_SetFeeMode_1
   1245                  {
   1246                      while (!(MCG->S & MCG_S_OSCINIT0_MASK))
   \                     ??CLOCK_SetFeeMode_2: (+1)
   \       0x38   0x79B0             LDRB     R0,[R6, #+6]
   \       0x3A   0x0785             LSLS     R5,R0,#+30
   \       0x3C   0xD5FC             BPL.N    ??CLOCK_SetFeeMode_2
   1247                      {
   1248                      }
   1249                  }
   1250              }
   1251          
   1252              /* Wait and check status. */
   1253              while (kMCG_FllSrcExternal != MCG_S_IREFST_VAL)
   \                     ??CLOCK_SetFeeMode_1: (+1)
   \       0x3E   0x79B0             LDRB     R0,[R6, #+6]
   \       0x40   0xF3C0 0x1000      UBFX     R0,R0,#+4,#+1
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD1FA             BNE.N    ??CLOCK_SetFeeMode_1
   1254              {
   1255              }
   1256          
   1257              /* Errata: ERR007993 */
   1258              if (change_drs)
   \       0x48   0xB104             CBZ.N    R4,??CLOCK_SetFeeMode_3
   1259              {
   1260                  MCG->C4 = mcg_c4;
   \       0x4A   0x70F7             STRB     R7,[R6, #+3]
   1261              }
   1262          
   1263              /* Set DRS and DMX32. */
   1264              mcg_c4 = ((mcg_c4 & ~(MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) | (MCG_C4_DMX32(dmx32) | MCG_C4_DRST_DRS(drs)));
   \                     ??CLOCK_SetFeeMode_3: (+1)
   \       0x4C   0xF007 0x071F      AND      R7,R7,#0x1F
   \       0x50   0x0152             LSLS     R2,R2,#+5
   \       0x52   0xEA47 0x17C1      ORR      R7,R7,R1, LSL #+7
   \       0x56   0xF002 0x0260      AND      R2,R2,#0x60
   \       0x5A   0x433A             ORRS     R2,R2,R7
   \       0x5C   0xB2D2             UXTB     R2,R2
   1265              MCG->C4 = mcg_c4;
   \       0x5E   0x70F2             STRB     R2,[R6, #+3]
   1266          
   1267              /* Wait for DRST_DRS update. */
   1268              while (MCG->C4 != mcg_c4)
   \                     ??CLOCK_SetFeeMode_4: (+1)
   \       0x60   0x78F0             LDRB     R0,[R6, #+3]
   \       0x62   0x4290             CMP      R0,R2
   \       0x64   0xD1FC             BNE.N    ??CLOCK_SetFeeMode_4
   1269              {
   1270              }
   1271          
   1272              /* Check MCG_S[CLKST] */
   1273              while (kMCG_ClkOutStatFll != MCG_S_CLKST_VAL)
   \                     ??CLOCK_SetFeeMode_5: (+1)
   \       0x66   0x79B0             LDRB     R0,[R6, #+6]
   \       0x68   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD1FA             BNE.N    ??CLOCK_SetFeeMode_5
   1274              {
   1275              }
   1276          
   1277              /* Wait for FLL stable time. */
   1278              if (fllStableDelay)
   \       0x70   0x0018             MOVS     R0,R3
   \       0x72   0xBF18             IT       NE 
   1279              {
   1280                  fllStableDelay();
   \       0x74   0x4798             BLXNE    R3
   1281              }
   1282          
   1283              return kStatus_Success;
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1284          }
   1285          

   \                                 In section .text, align 2, keep-with-next
   1286          status_t CLOCK_SetFbiMode(mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(void))
   1287          {
   \                     CLOCK_SetFbiMode: (+1)
   \        0x0   0x4603             MOV      R3,R0
   \        0x2   0xB570             PUSH     {R4-R6,LR}
   1288              uint8_t mcg_c4;
   1289              bool change_drs = false;
   1290          
   1291          #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
   1292              mcg_mode_t mode = CLOCK_GetMode();
   1293          
   1294              if (!((kMCG_ModeFEE == mode) || (kMCG_ModeFBI == mode) || (kMCG_ModeFBE == mode) || (kMCG_ModeFEI == mode) ||
   1295                    (kMCG_ModeBLPI == mode)))
   1296          
   1297              {
   1298                  return kStatus_MCG_ModeUnreachable;
   1299              }
   1300          #endif
   1301          
   1302              mcg_c4 = MCG->C4;
   \        0x4   0x.... 0x....      LDR.W    R5,??DataTable46_11  ;; 0x40064000
   \        0x8   0x78EE             LDRB     R6,[R5, #+3]
   1303          
   1304              MCG->C2 &= ~MCG_C2_LP_MASK; /* Disable lowpower. */
   \        0xA   0x7868             LDRB     R0,[R5, #+1]
   \        0xC   0xF000 0x00FD      AND      R0,R0,#0xFD
   \       0x10   0x7068             STRB     R0,[R5, #+1]
   \       0x12   0x2400             MOVS     R4,#+0
   1305          
   1306              /*
   1307                 Errata: ERR007993
   1308                 Workaround: Invert MCG_C4[DMX32] or change MCG_C4[DRST_DRS] before
   1309                 reference clock source changes, then reset to previous value after
   1310                 reference clock changes.
   1311               */
   1312              if (kMCG_FllSrcExternal == MCG_S_IREFST_VAL)
   \       0x14   0x79A8             LDRB     R0,[R5, #+6]
   \       0x16   0xF3C0 0x1000      UBFX     R0,R0,#+4,#+1
   \       0x1A   0xB920             CBNZ.N   R0,??CLOCK_SetFbiMode_0
   1313              {
   1314                  change_drs = true;
   1315                  /* Change the LSB of DRST_DRS. */
   1316                  MCG->C4 ^= (1U << MCG_C4_DRST_DRS_SHIFT);
   \       0x1C   0x78E8             LDRB     R0,[R5, #+3]
   \       0x1E   0xF080 0x0020      EOR      R0,R0,#0x20
   \       0x22   0x2401             MOVS     R4,#+1
   \       0x24   0x70E8             STRB     R0,[R5, #+3]
   1317              }
   1318          
   1319              /* Set CLKS and IREFS. */
   1320              MCG->C1 =
   1321                  ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK)) | (MCG_C1_CLKS(kMCG_ClkOutSrcInternal)    /* CLKS = 1 */
   1322                                                                          | MCG_C1_IREFS(kMCG_FllSrcInternal))); /* IREFS = 1 */
   \                     ??CLOCK_SetFbiMode_0: (+1)
   \       0x26   0x7828             LDRB     R0,[R5, #+0]
   \       0x28   0xF000 0x003B      AND      R0,R0,#0x3B
   \       0x2C   0xF040 0x0044      ORR      R0,R0,#0x44
   \       0x30   0x7028             STRB     R0,[R5, #+0]
   1323          
   1324              /* Wait and check status. */
   1325              while (kMCG_FllSrcInternal != MCG_S_IREFST_VAL)
   \                     ??CLOCK_SetFbiMode_1: (+1)
   \       0x32   0x79A8             LDRB     R0,[R5, #+6]
   \       0x34   0xF3C0 0x1000      UBFX     R0,R0,#+4,#+1
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD0FA             BEQ.N    ??CLOCK_SetFbiMode_1
   1326              {
   1327              }
   1328          
   1329              /* Errata: ERR007993 */
   1330              if (change_drs)
   \       0x3C   0xB104             CBZ.N    R4,??CLOCK_SetFbiMode_2
   1331              {
   1332                  MCG->C4 = mcg_c4;
   \       0x3E   0x70EE             STRB     R6,[R5, #+3]
   1333              }
   1334          
   1335              while (kMCG_ClkOutStatInt != MCG_S_CLKST_VAL)
   \                     ??CLOCK_SetFbiMode_2: (+1)
   \       0x40   0x79A8             LDRB     R0,[R5, #+6]
   \       0x42   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \       0x46   0x2801             CMP      R0,#+1
   \       0x48   0xD1FA             BNE.N    ??CLOCK_SetFbiMode_2
   1336              {
   1337              }
   1338          
   1339              MCG->C4 = (mcg_c4 & ~(MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) | (MCG_C4_DMX32(dmx32) | MCG_C4_DRST_DRS(drs));
   \       0x4A   0xF006 0x061F      AND      R6,R6,#0x1F
   \       0x4E   0x0149             LSLS     R1,R1,#+5
   \       0x50   0xEA46 0x16C3      ORR      R6,R6,R3, LSL #+7
   \       0x54   0xF001 0x0160      AND      R1,R1,#0x60
   \       0x58   0x4331             ORRS     R1,R1,R6
   \       0x5A   0x70E9             STRB     R1,[R5, #+3]
   1340          
   1341              /* Wait for FLL stable time. */
   1342              if (fllStableDelay)
   \       0x5C   0x0010             MOVS     R0,R2
   \       0x5E   0xBF18             IT       NE 
   1343              {
   1344                  fllStableDelay();
   \       0x60   0x4790             BLXNE    R2
   1345              }
   1346          
   1347              return kStatus_Success;
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0xBD70             POP      {R4-R6,PC}       ;; return
   1348          }
   1349          

   \                                 In section .text, align 2, keep-with-next
   1350          status_t CLOCK_SetFbeMode(uint8_t frdiv, mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(void))
   1351          {
   \                     CLOCK_SetFbeMode: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   1352              uint8_t mcg_c4;
   1353              bool change_drs = false;
   1354          
   1355          #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
   1356              mcg_mode_t mode = CLOCK_GetMode();
   1357              if (!((kMCG_ModeFEE == mode) || (kMCG_ModeFBI == mode) || (kMCG_ModeFBE == mode) || (kMCG_ModeFEI == mode) ||
   1358                    (kMCG_ModePBE == mode) || (kMCG_ModeBLPE == mode)))
   1359              {
   1360                  return kStatus_MCG_ModeUnreachable;
   1361              }
   1362          #endif
   1363          
   1364              /* Change to FLL mode. */
   1365              MCG->C6 &= ~MCG_C6_PLLS_MASK;
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable46_11  ;; 0x40064000
   \        0x6   0x7962             LDRB     R2,[R4, #+5]
   \        0x8   0xF002 0x02BF      AND      R2,R2,#0xBF
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x7162             STRB     R2,[R4, #+5]
   1366              while (MCG->S & MCG_S_PLLST_MASK)
   \                     ??CLOCK_SetFbeMode_0: (+1)
   \       0x10   0x79A2             LDRB     R2,[R4, #+6]
   \       0x12   0x0695             LSLS     R5,R2,#+26
   \       0x14   0xD4FC             BMI.N    ??CLOCK_SetFbeMode_0
   1367              {
   1368              }
   1369          
   1370              /* Set LP bit to enable the FLL */
   1371              MCG->C2 &= ~MCG_C2_LP_MASK;
   \       0x16   0x7862             LDRB     R2,[R4, #+1]
   \       0x18   0xF002 0x02FD      AND      R2,R2,#0xFD
   \       0x1C   0x7062             STRB     R2,[R4, #+1]
   1372          
   1373              mcg_c4 = MCG->C4;
   \       0x1E   0x78E5             LDRB     R5,[R4, #+3]
   1374          
   1375              /*
   1376                 Errata: ERR007993
   1377                 Workaround: Invert MCG_C4[DMX32] or change MCG_C4[DRST_DRS] before
   1378                 reference clock source changes, then reset to previous value after
   1379                 reference clock changes.
   1380               */
   1381              if (kMCG_FllSrcInternal == MCG_S_IREFST_VAL)
   \       0x20   0x79A2             LDRB     R2,[R4, #+6]
   \       0x22   0xF3C2 0x1200      UBFX     R2,R2,#+4,#+1
   \       0x26   0xB122             CBZ.N    R2,??CLOCK_SetFbeMode_1
   1382              {
   1383                  change_drs = true;
   1384                  /* Change the LSB of DRST_DRS. */
   1385                  MCG->C4 ^= (1U << MCG_C4_DRST_DRS_SHIFT);
   \       0x28   0x78E2             LDRB     R2,[R4, #+3]
   \       0x2A   0xF082 0x0220      EOR      R2,R2,#0x20
   \       0x2E   0x2101             MOVS     R1,#+1
   \       0x30   0x70E2             STRB     R2,[R4, #+3]
   1386              }
   1387          
   1388              /* Set CLKS and IREFS. */
   1389              MCG->C1 = ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK)) |
   1390                         (MCG_C1_CLKS(kMCG_ClkOutSrcExternal)    /* CLKS = 2 */
   1391                          | MCG_C1_FRDIV(frdiv)                  /* FRDIV = frdiv */
   1392                          | MCG_C1_IREFS(kMCG_FllSrcExternal))); /* IREFS = 0 */
   \                     ??CLOCK_SetFbeMode_1: (+1)
   \       0x32   0x00C0             LSLS     R0,R0,#+3
   \       0x34   0x7822             LDRB     R2,[R4, #+0]
   \       0x36   0xF002 0x0203      AND      R2,R2,#0x3
   \       0x3A   0xF000 0x0038      AND      R0,R0,#0x38
   \       0x3E   0x4310             ORRS     R0,R0,R2
   \       0x40   0xF040 0x0080      ORR      R0,R0,#0x80
   \       0x44   0x7020             STRB     R0,[R4, #+0]
   1393          
   1394              /* If use external crystal as clock source, wait for it stable. */
   1395              if (MCG_C7_OSCSEL(kMCG_OscselOsc) == (MCG->C7 & MCG_C7_OSCSEL_MASK))
   \       0x46   0x7B20             LDRB     R0,[R4, #+12]
   \       0x48   0x07C2             LSLS     R2,R0,#+31
   \       0x4A   0xD405             BMI.N    ??CLOCK_SetFbeMode_2
   1396              {
   1397                  if (MCG->C2 & MCG_C2_EREFS_MASK)
   \       0x4C   0x7860             LDRB     R0,[R4, #+1]
   \       0x4E   0x0742             LSLS     R2,R0,#+29
   \       0x50   0xD502             BPL.N    ??CLOCK_SetFbeMode_2
   1398                  {
   1399                      while (!(MCG->S & MCG_S_OSCINIT0_MASK))
   \                     ??CLOCK_SetFbeMode_3: (+1)
   \       0x52   0x79A0             LDRB     R0,[R4, #+6]
   \       0x54   0x0782             LSLS     R2,R0,#+30
   \       0x56   0xD5FC             BPL.N    ??CLOCK_SetFbeMode_3
   1400                      {
   1401                      }
   1402                  }
   1403              }
   1404          
   1405              /* Wait for Reference clock Status bit to clear */
   1406              while (kMCG_FllSrcExternal != MCG_S_IREFST_VAL)
   \                     ??CLOCK_SetFbeMode_2: (+1)
   \       0x58   0x79A0             LDRB     R0,[R4, #+6]
   \       0x5A   0xF3C0 0x1000      UBFX     R0,R0,#+4,#+1
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD1FA             BNE.N    ??CLOCK_SetFbeMode_2
   1407              {
   1408              }
   1409          
   1410              /* Errata: ERR007993 */
   1411              if (change_drs)
   \       0x62   0xB101             CBZ.N    R1,??CLOCK_SetFbeMode_4
   1412              {
   1413                  MCG->C4 = mcg_c4;
   \       0x64   0x70E5             STRB     R5,[R4, #+3]
   1414              }
   1415          
   1416              /* Set DRST_DRS and DMX32. */
   1417              mcg_c4 = ((mcg_c4 & ~(MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) | (MCG_C4_DMX32(dmx32) | MCG_C4_DRST_DRS(drs)));
   1418          
   1419              /* Wait for clock status bits to show clock source is ext ref clk */
   1420              while (kMCG_ClkOutStatExt != MCG_S_CLKST_VAL)
   \                     ??CLOCK_SetFbeMode_4: (+1)
   \       0x66   0x79A0             LDRB     R0,[R4, #+6]
   \       0x68   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \       0x6C   0x2802             CMP      R0,#+2
   \       0x6E   0xD1FA             BNE.N    ??CLOCK_SetFbeMode_4
   1421              {
   1422              }
   1423          
   1424              /* Wait for fll stable time. */
   1425              if (fllStableDelay)
   \       0x70   0x0018             MOVS     R0,R3
   \       0x72   0xBF18             IT       NE 
   1426              {
   1427                  fllStableDelay();
   \       0x74   0x4798             BLXNE    R3
   1428              }
   1429          
   1430              return kStatus_Success;
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1431          }
   1432          

   \                                 In section .text, align 2, keep-with-next
   1433          status_t CLOCK_SetBlpiMode(void)
   1434          {
   1435          #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
   1436              if (MCG_S_CLKST_VAL != kMCG_ClkOutStatInt)
   1437              {
   1438                  return kStatus_MCG_ModeUnreachable;
   1439              }
   1440          #endif /* MCG_CONFIG_CHECK_PARAM */
   1441          
   1442              /* Set LP. */
   1443              MCG->C2 |= MCG_C2_LP_MASK;
   \                     CLOCK_SetBlpiMode: (+1)
   \        0x0   0x....             B.N      ?Subroutine0
   1444          
   1445              return kStatus_Success;
   1446          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable46_9  ;; 0x40064001
   \        0x2   0x7801             LDRB     R1,[R0, #+0]
   \        0x4   0xF041 0x0102      ORR      R1,R1,#0x2
   \        0x8   0x7001             STRB     R1,[R0, #+0]
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x4770             BX       LR               ;; return
   1447          

   \                                 In section .text, align 4, keep-with-next
   1448          status_t CLOCK_SetBlpeMode(void)
   1449          {
   1450          #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
   1451              if (MCG_S_CLKST_VAL != kMCG_ClkOutStatExt)
   1452              {
   1453                  return kStatus_MCG_ModeUnreachable;
   1454              }
   1455          #endif
   1456          
   1457              /* Set LP bit to enter BLPE mode. */
   1458              MCG->C2 |= MCG_C2_LP_MASK;
   \                     CLOCK_SetBlpeMode: (+1)
   \        0x0   0xBF00             Nop      
   \        0x2                      REQUIRE ?Subroutine0
   \        0x2                      ;; // Fall through to label ?Subroutine0
   1459          
   1460              return kStatus_Success;
   1461          }
   1462          

   \                                 In section .text, align 2, keep-with-next
   1463          status_t CLOCK_SetPbeMode(mcg_pll_clk_select_t pllcs, mcg_pll_config_t const *config)
   1464          {
   1465              assert(config);
   1466          
   1467              /*
   1468                 This function is designed to change MCG to PBE mode from PEE/BLPE/FBE,
   1469                 but with this workflow, the source mode could be all modes except PEI/PBI.
   1470               */
   1471              MCG->C2 &= ~MCG_C2_LP_MASK; /* Disable lowpower. */
   \                     CLOCK_SetPbeMode: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable46_11  ;; 0x40064000
   \        0x2   0x7842             LDRB     R2,[R0, #+1]
   \        0x4   0xF002 0x02FD      AND      R2,R2,#0xFD
   \        0x8   0x7042             STRB     R2,[R0, #+1]
   1472          
   1473              /* Change to use external clock first. */
   1474              MCG->C1 = ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK)) | MCG_C1_CLKS(kMCG_ClkOutSrcExternal));
   \        0xA   0x7803             LDRB     R3,[R0, #+0]
   \        0xC   0xF003 0x033B      AND      R3,R3,#0x3B
   \       0x10   0xF043 0x0380      ORR      R3,R3,#0x80
   \       0x14   0x7003             STRB     R3,[R0, #+0]
   1475          
   1476              /* Wait for CLKST clock status bits to show clock source is ext ref clk */
   1477              while ((MCG->S & (MCG_S_IREFST_MASK | MCG_S_CLKST_MASK)) !=
   1478                     (MCG_S_IREFST(kMCG_FllSrcExternal) | MCG_S_CLKST(kMCG_ClkOutStatExt)))
   \                     ??CLOCK_SetPbeMode_0: (+1)
   \       0x16   0x7982             LDRB     R2,[R0, #+6]
   \       0x18   0xF002 0x021C      AND      R2,R2,#0x1C
   \       0x1C   0x2A08             CMP      R2,#+8
   \       0x1E   0xD1FA             BNE.N    ??CLOCK_SetPbeMode_0
   1479              {
   1480              }
   1481          
   1482              /* Disable PLL first, then configure PLL. */
   1483              MCG->C6 &= ~MCG_C6_PLLS_MASK;
   \       0x20   0x7942             LDRB     R2,[R0, #+5]
   \       0x22   0xF002 0x02BF      AND      R2,R2,#0xBF
   \       0x26   0x7142             STRB     R2,[R0, #+5]
   1484              while (MCG->S & MCG_S_PLLST_MASK)
   \                     ??CLOCK_SetPbeMode_1: (+1)
   \       0x28   0x7982             LDRB     R2,[R0, #+6]
   \       0x2A   0x0693             LSLS     R3,R2,#+26
   \       0x2C   0xD4FC             BMI.N    ??CLOCK_SetPbeMode_1
   1485              {
   1486              }
   1487          
   1488              /* Configure the PLL. */
   1489              {
   1490                  CLOCK_EnablePll0(config);
   \       0x2E   0x784A             LDRB     R2,[R1, #+1]
   \       0x30   0xF002 0x021F      AND      R2,R2,#0x1F
   \       0x34   0x7102             STRB     R2,[R0, #+4]
   \       0x36   0x7942             LDRB     R2,[R0, #+5]
   \       0x38   0x788B             LDRB     R3,[R1, #+2]
   \       0x3A   0xF002 0x02E0      AND      R2,R2,#0xE0
   \       0x3E   0xF003 0x031F      AND      R3,R3,#0x1F
   \       0x42   0x431A             ORRS     R2,R3,R2
   \       0x44   0x7142             STRB     R2,[R0, #+5]
   \       0x46   0x7902             LDRB     R2,[R0, #+4]
   \       0x48   0x7809             LDRB     R1,[R1, #+0]
   \       0x4A   0xF041 0x0140      ORR      R1,R1,#0x40
   \       0x4E   0x430A             ORRS     R2,R1,R2
   \       0x50   0x7102             STRB     R2,[R0, #+4]
   \                     ??CLOCK_SetPbeMode_2: (+1)
   \       0x52   0x7981             LDRB     R1,[R0, #+6]
   \       0x54   0x064A             LSLS     R2,R1,#+25
   \       0x56   0xD5FC             BPL.N    ??CLOCK_SetPbeMode_2
   1491              }
   1492          
   1493              /* Change to PLL mode. */
   1494              MCG->C6 |= MCG_C6_PLLS_MASK;
   \       0x58   0x7941             LDRB     R1,[R0, #+5]
   \       0x5A   0xF041 0x0140      ORR      R1,R1,#0x40
   \       0x5E   0x7141             STRB     R1,[R0, #+5]
   1495          
   1496              /* Wait for PLL mode changed. */
   1497              while (!(MCG->S & MCG_S_PLLST_MASK))
   \                     ??CLOCK_SetPbeMode_3: (+1)
   \       0x60   0x7981             LDRB     R1,[R0, #+6]
   \       0x62   0x068A             LSLS     R2,R1,#+26
   \       0x64   0xD5FC             BPL.N    ??CLOCK_SetPbeMode_3
   1498              {
   1499              }
   1500          
   1501              return kStatus_Success;
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0x4770             BX       LR               ;; return
   1502          }
   1503          

   \                                 In section .text, align 2, keep-with-next
   1504          status_t CLOCK_SetPeeMode(void)
   1505          {
   1506          #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
   1507              mcg_mode_t mode = CLOCK_GetMode();
   1508              if (kMCG_ModePBE != mode)
   1509              {
   1510                  return kStatus_MCG_ModeUnreachable;
   1511              }
   1512          #endif
   1513          
   1514              /* Change to use PLL/FLL output clock first. */
   1515              MCG->C1 = (MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcOut);
   \                     CLOCK_SetPeeMode: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable46_11  ;; 0x40064000
   \        0x2   0x7801             LDRB     R1,[R0, #+0]
   \        0x4   0xF001 0x013F      AND      R1,R1,#0x3F
   \        0x8   0x7001             STRB     R1,[R0, #+0]
   1516          
   1517              /* Wait for clock status bits to update */
   1518              while (MCG_S_CLKST_VAL != kMCG_ClkOutStatPll)
   \                     ??CLOCK_SetPeeMode_0: (+1)
   \        0xA   0x7981             LDRB     R1,[R0, #+6]
   \        0xC   0xF3C1 0x0181      UBFX     R1,R1,#+2,#+2
   \       0x10   0x2903             CMP      R1,#+3
   \       0x12   0xD1FA             BNE.N    ??CLOCK_SetPeeMode_0
   1519              {
   1520              }
   1521          
   1522              return kStatus_Success;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x4770             BX       LR               ;; return
   1523          }
   1524          

   \                                 In section .text, align 2, keep-with-next
   1525          status_t CLOCK_ExternalModeToFbeModeQuick(void)
   1526          {
   1527          #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
   1528              if (MCG->S & MCG_S_IREFST_MASK)
   1529              {
   1530                  return kStatus_MCG_ModeInvalid;
   1531              }
   1532          #endif /* MCG_CONFIG_CHECK_PARAM */
   1533          
   1534              /* Disable low power */
   1535              MCG->C2 &= ~MCG_C2_LP_MASK;
   \                     CLOCK_ExternalModeToFbeModeQuick: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable46_11  ;; 0x40064000
   \        0x2   0x7841             LDRB     R1,[R0, #+1]
   \        0x4   0xF001 0x01FD      AND      R1,R1,#0xFD
   \        0x8   0x7041             STRB     R1,[R0, #+1]
   1536          
   1537              MCG->C1 = ((MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcExternal));
   \        0xA   0x7802             LDRB     R2,[R0, #+0]
   \        0xC   0xF002 0x023F      AND      R2,R2,#0x3F
   \       0x10   0xF042 0x0280      ORR      R2,R2,#0x80
   \       0x14   0x7002             STRB     R2,[R0, #+0]
   1538              while (MCG_S_CLKST_VAL != kMCG_ClkOutStatExt)
   \                     ??CLOCK_ExternalModeToFbeModeQuick_0: (+1)
   \       0x16   0x7981             LDRB     R1,[R0, #+6]
   \       0x18   0xF3C1 0x0181      UBFX     R1,R1,#+2,#+2
   \       0x1C   0x2902             CMP      R1,#+2
   \       0x1E   0xD1FA             BNE.N    ??CLOCK_ExternalModeToFbeModeQuick_0
   1539              {
   1540              }
   1541          
   1542              /* Disable PLL. */
   1543              MCG->C6 &= ~MCG_C6_PLLS_MASK;
   \       0x20   0x7941             LDRB     R1,[R0, #+5]
   \       0x22   0xF001 0x01BF      AND      R1,R1,#0xBF
   \       0x26   0x7141             STRB     R1,[R0, #+5]
   1544              while (MCG->S & MCG_S_PLLST_MASK)
   \                     ??CLOCK_ExternalModeToFbeModeQuick_1: (+1)
   \       0x28   0x7981             LDRB     R1,[R0, #+6]
   \       0x2A   0x068A             LSLS     R2,R1,#+26
   \       0x2C   0xD4FC             BMI.N    ??CLOCK_ExternalModeToFbeModeQuick_1
   1545              {
   1546              }
   1547          
   1548              return kStatus_Success;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x4770             BX       LR               ;; return
   1549          }
   1550          

   \                                 In section .text, align 2, keep-with-next
   1551          status_t CLOCK_InternalModeToFbiModeQuick(void)
   1552          {
   1553          #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
   1554              if (!(MCG->S & MCG_S_IREFST_MASK))
   1555              {
   1556                  return kStatus_MCG_ModeInvalid;
   1557              }
   1558          #endif
   1559          
   1560              /* Disable low power */
   1561              MCG->C2 &= ~MCG_C2_LP_MASK;
   \                     CLOCK_InternalModeToFbiModeQuick: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable46_11  ;; 0x40064000
   \        0x2   0x7841             LDRB     R1,[R0, #+1]
   \        0x4   0xF001 0x01FD      AND      R1,R1,#0xFD
   \        0x8   0x7041             STRB     R1,[R0, #+1]
   1562          
   1563              MCG->C1 = ((MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcInternal));
   \        0xA   0x7802             LDRB     R2,[R0, #+0]
   \        0xC   0xF002 0x023F      AND      R2,R2,#0x3F
   \       0x10   0xF042 0x0240      ORR      R2,R2,#0x40
   \       0x14   0x7002             STRB     R2,[R0, #+0]
   1564              while (MCG_S_CLKST_VAL != kMCG_ClkOutStatInt)
   \                     ??CLOCK_InternalModeToFbiModeQuick_0: (+1)
   \       0x16   0x7981             LDRB     R1,[R0, #+6]
   \       0x18   0xF3C1 0x0181      UBFX     R1,R1,#+2,#+2
   \       0x1C   0x2901             CMP      R1,#+1
   \       0x1E   0xD1FA             BNE.N    ??CLOCK_InternalModeToFbiModeQuick_0
   1565              {
   1566              }
   1567          
   1568              return kStatus_Success;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x4770             BX       LR               ;; return
   1569          }
   1570          

   \                                 In section .text, align 2, keep-with-next
   1571          status_t CLOCK_BootToFeiMode(mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(void))
   1572          {
   1573              return CLOCK_SetFeiMode(dmx32, drs, fllStableDelay);
   \                     CLOCK_BootToFeiMode: (+1)
   \        0x0   0x....             B.N      CLOCK_SetFeiMode
   1574          }
   1575          

   \                                 In section .text, align 2, keep-with-next
   1576          status_t CLOCK_BootToFeeMode(
   1577              mcg_oscsel_t oscsel, uint8_t frdiv, mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(void))
   1578          {
   \                     CLOCK_BootToFeeMode: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x9F06             LDR      R7,[SP, #+24]
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4615             MOV      R5,R2
   \        0x8   0x461E             MOV      R6,R3
   1579              CLOCK_SetExternalRefClkConfig(oscsel);
   \        0xA   0x.... 0x....      BL       CLOCK_SetExternalRefClkConfig
   1580          
   1581              return CLOCK_SetFeeMode(frdiv, dmx32, drs, fllStableDelay);
   \        0xE   0x463B             MOV      R3,R7
   \       0x10   0x4632             MOV      R2,R6
   \       0x12   0x4629             MOV      R1,R5
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0xB001             ADD      SP,SP,#+4
   \       0x18   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \       0x1C   0x....             B.N      CLOCK_SetFeeMode
   1582          }
   1583          

   \                                 In section .text, align 2, keep-with-next
   1584          status_t CLOCK_BootToBlpiMode(uint8_t fcrdiv, mcg_irc_mode_t ircs, uint8_t ircEnableMode)
   1585          {
   \                     CLOCK_BootToBlpiMode: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x4613             MOV      R3,R2
   1586              /* If reset mode is FEI mode, set MCGIRCLK and always success. */
   1587              CLOCK_SetInternalRefClkConfig(ircEnableMode, ircs, fcrdiv);
   \        0x4   0x4602             MOV      R2,R0
   \        0x6   0x4618             MOV      R0,R3
   \        0x8   0x.... 0x....      BL       CLOCK_SetInternalRefClkConfig
   1588          
   1589              /* If reset mode is not BLPI, first enter FBI mode. */
   1590              MCG->C1 = (MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcInternal);
   \        0xC   0x....             LDR.N    R0,??DataTable46_11  ;; 0x40064000
   \        0xE   0x7801             LDRB     R1,[R0, #+0]
   \       0x10   0xF001 0x013F      AND      R1,R1,#0x3F
   \       0x14   0xF041 0x0140      ORR      R1,R1,#0x40
   \       0x18   0x7001             STRB     R1,[R0, #+0]
   1591              while (MCG_S_CLKST_VAL != kMCG_ClkOutStatInt)
   \                     ??CLOCK_BootToBlpiMode_0: (+1)
   \       0x1A   0x7981             LDRB     R1,[R0, #+6]
   \       0x1C   0xF3C1 0x0181      UBFX     R1,R1,#+2,#+2
   \       0x20   0x2901             CMP      R1,#+1
   \       0x22   0xD1FA             BNE.N    ??CLOCK_BootToBlpiMode_0
   1592              {
   1593              }
   1594          
   1595              /* Enter BLPI mode. */
   1596              MCG->C2 |= MCG_C2_LP_MASK;
   \       0x24   0x7841             LDRB     R1,[R0, #+1]
   \       0x26   0xF041 0x0102      ORR      R1,R1,#0x2
   \       0x2A   0x7041             STRB     R1,[R0, #+1]
   1597          
   1598              return kStatus_Success;
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0xBD02             POP      {R1,PC}          ;; return
   1599          }
   1600          

   \                                 In section .text, align 2, keep-with-next
   1601          status_t CLOCK_BootToBlpeMode(mcg_oscsel_t oscsel)
   1602          {
   1603              CLOCK_SetExternalRefClkConfig(oscsel);
   \                     CLOCK_BootToBlpeMode: (+1)
   \        0x0   0x....             LDR.N    R2,??DataTable46_11  ;; 0x40064000
   \        0x2   0x7B11             LDRB     R1,[R2, #+12]
   \        0x4   0x7B13             LDRB     R3,[R2, #+12]
   \        0x6   0xF001 0x0101      AND      R1,R1,#0x1
   \        0xA   0x4281             CMP      R1,R0
   \        0xC   0xBF14             ITE      NE 
   \        0xE   0x2101             MOVNE    R1,#+1
   \       0x10   0x2100             MOVEQ    R1,#+0
   \       0x12   0xF003 0x03FE      AND      R3,R3,#0xFE
   \       0x16   0xF000 0x0001      AND      R0,R0,#0x1
   \       0x1A   0x4318             ORRS     R0,R0,R3
   \       0x1C   0x7310             STRB     R0,[R2, #+12]
   \       0x1E   0xB121             CBZ.N    R1,??CLOCK_BootToBlpeMode_0
   \       0x20   0xF240 0x50DC      MOVW     R0,#+1500
   \                     ??CLOCK_BootToBlpeMode_1: (+1)
   \       0x24   0xBF00             Nop      
   \       0x26   0x1E40             SUBS     R0,R0,#+1
   \       0x28   0xD1FC             BNE.N    ??CLOCK_BootToBlpeMode_1
   1604          
   1605              /* Set to FBE mode. */
   1606              MCG->C1 =
   1607                  ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK)) | (MCG_C1_CLKS(kMCG_ClkOutSrcExternal)    /* CLKS = 2 */
   1608                                                                          | MCG_C1_IREFS(kMCG_FllSrcExternal))); /* IREFS = 0 */
   \                     ??CLOCK_BootToBlpeMode_0: (+1)
   \       0x2A   0x7810             LDRB     R0,[R2, #+0]
   \       0x2C   0xF000 0x003B      AND      R0,R0,#0x3B
   \       0x30   0xF040 0x0080      ORR      R0,R0,#0x80
   \       0x34   0x7010             STRB     R0,[R2, #+0]
   1609          
   1610              /* If use external crystal as clock source, wait for it stable. */
   1611              if (MCG_C7_OSCSEL(kMCG_OscselOsc) == (MCG->C7 & MCG_C7_OSCSEL_MASK))
   \       0x36   0x7B10             LDRB     R0,[R2, #+12]
   \       0x38   0x07C1             LSLS     R1,R0,#+31
   \       0x3A   0xD405             BMI.N    ??CLOCK_BootToBlpeMode_2
   1612              {
   1613                  if (MCG->C2 & MCG_C2_EREFS_MASK)
   \       0x3C   0x7850             LDRB     R0,[R2, #+1]
   \       0x3E   0x0741             LSLS     R1,R0,#+29
   \       0x40   0xD502             BPL.N    ??CLOCK_BootToBlpeMode_2
   1614                  {
   1615                      while (!(MCG->S & MCG_S_OSCINIT0_MASK))
   \                     ??CLOCK_BootToBlpeMode_3: (+1)
   \       0x42   0x7990             LDRB     R0,[R2, #+6]
   \       0x44   0x0781             LSLS     R1,R0,#+30
   \       0x46   0xD5FC             BPL.N    ??CLOCK_BootToBlpeMode_3
   1616                      {
   1617                      }
   1618                  }
   1619              }
   1620          
   1621              /* Wait for MCG_S[CLKST] and MCG_S[IREFST]. */
   1622              while ((MCG->S & (MCG_S_IREFST_MASK | MCG_S_CLKST_MASK)) !=
   1623                     (MCG_S_IREFST(kMCG_FllSrcExternal) | MCG_S_CLKST(kMCG_ClkOutStatExt)))
   \                     ??CLOCK_BootToBlpeMode_2: (+1)
   \       0x48   0x7990             LDRB     R0,[R2, #+6]
   \       0x4A   0xF000 0x001C      AND      R0,R0,#0x1C
   \       0x4E   0x2808             CMP      R0,#+8
   \       0x50   0xD1FA             BNE.N    ??CLOCK_BootToBlpeMode_2
   1624              {
   1625              }
   1626          
   1627              /* In FBE now, start to enter BLPE. */
   1628              MCG->C2 |= MCG_C2_LP_MASK;
   \       0x52   0x7850             LDRB     R0,[R2, #+1]
   \       0x54   0xF040 0x0002      ORR      R0,R0,#0x2
   \       0x58   0x7050             STRB     R0,[R2, #+1]
   1629          
   1630              return kStatus_Success;
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x4770             BX       LR               ;; return
   1631          }
   1632          

   \                                 In section .text, align 2, keep-with-next
   1633          status_t CLOCK_BootToPeeMode(mcg_oscsel_t oscsel, mcg_pll_clk_select_t pllcs, mcg_pll_config_t const *config)
   1634          {
   \                     CLOCK_BootToPeeMode: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x460C             MOV      R4,R1
   \        0x4   0x4615             MOV      R5,R2
   1635              assert(config);
   1636          
   1637              CLOCK_SetExternalRefClkConfig(oscsel);
   \        0x6   0x.... 0x....      BL       CLOCK_SetExternalRefClkConfig
   1638          
   1639              CLOCK_SetPbeMode(pllcs, config);
   \        0xA   0x4629             MOV      R1,R5
   \        0xC   0x4620             MOV      R0,R4
   \        0xE   0x.... 0x....      BL       CLOCK_SetPbeMode
   1640          
   1641              /* Change to use PLL output clock. */
   1642              MCG->C1 = (MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcOut);
   \       0x12   0x....             LDR.N    R0,??DataTable46_11  ;; 0x40064000
   \       0x14   0x7801             LDRB     R1,[R0, #+0]
   \       0x16   0xF001 0x013F      AND      R1,R1,#0x3F
   \       0x1A   0x7001             STRB     R1,[R0, #+0]
   1643              while (MCG_S_CLKST_VAL != kMCG_ClkOutStatPll)
   \                     ??CLOCK_BootToPeeMode_0: (+1)
   \       0x1C   0x7981             LDRB     R1,[R0, #+6]
   \       0x1E   0xF3C1 0x0181      UBFX     R1,R1,#+2,#+2
   \       0x22   0x2903             CMP      R1,#+3
   \       0x24   0xD1FA             BNE.N    ??CLOCK_BootToPeeMode_0
   1644              {
   1645              }
   1646          
   1647              return kStatus_Success;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1648          }
   1649          
   1650          /*
   1651             The transaction matrix. It defines the path for mode switch, the row is for
   1652             current mode and the column is target mode.
   1653             For example, switch from FEI to PEE:
   1654             1. Current mode FEI, next mode is mcgModeMatrix[FEI][PEE] = FBE, so swith to FBE.
   1655             2. Current mode FBE, next mode is mcgModeMatrix[FBE][PEE] = PBE, so swith to PBE.
   1656             3. Current mode PBE, next mode is mcgModeMatrix[PBE][PEE] = PEE, so swith to PEE.
   1657             Thus the MCG mode has changed from FEI to PEE.
   1658           */

   \                                 In section .text, align 4, keep-with-next
   1659          static const mcg_mode_t mcgModeMatrix[8][8] = {
   \                     mcgModeMatrix:
   \        0x0   0x00 0x01          DC8 0, 1, 1, 3, 4, 4, 4, 4, 0, 1, 2, 3, 4, 4, 4, 4, 1, 1, 2, 1, 1, 1, 1
   \              0x01 0x03    
   \              0x04 0x04    
   \              0x04 0x04    
   \              0x00 0x01    
   \              0x02 0x03    
   \              0x04 0x04    
   \              0x04 0x04    
   \              0x01 0x01    
   \              0x02 0x01    
   \              0x01 0x01    
   \              0x01         
   \       0x17   0x01 0x00          DC8 1, 0, 1, 1, 3, 4, 4, 4, 4, 0, 1, 1, 3, 4, 5, 6, 6, 4, 4, 4, 4, 4, 5
   \              0x01 0x01    
   \              0x03 0x04    
   \              0x04 0x04    
   \              0x04 0x00    
   \              0x01 0x01    
   \              0x03 0x04    
   \              0x05 0x06    
   \              0x06 0x04    
   \              0x04 0x04    
   \              0x04 0x04    
   \              0x05         
   \       0x2E   0x06 0x06          DC8 6, 6, 4, 4, 4, 4, 4, 5, 6, 7, 6, 6, 6, 6, 6, 6, 6, 6
   \              0x04 0x04    
   \              0x04 0x04    
   \              0x04 0x05    
   \              0x06 0x07    
   \              0x06 0x06    
   \              0x06 0x06    
   \              0x06 0x06    
   \              0x06 0x06    
   1660              {kMCG_ModeFEI, kMCG_ModeFBI, kMCG_ModeFBI, kMCG_ModeFEE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE,
   1661               kMCG_ModeFBE}, /* FEI */
   1662              {kMCG_ModeFEI, kMCG_ModeFBI, kMCG_ModeBLPI, kMCG_ModeFEE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE,
   1663               kMCG_ModeFBE}, /* FBI */
   1664              {kMCG_ModeFBI, kMCG_ModeFBI, kMCG_ModeBLPI, kMCG_ModeFBI, kMCG_ModeFBI, kMCG_ModeFBI, kMCG_ModeFBI,
   1665               kMCG_ModeFBI}, /* BLPI */
   1666              {kMCG_ModeFEI, kMCG_ModeFBI, kMCG_ModeFBI, kMCG_ModeFEE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE,
   1667               kMCG_ModeFBE}, /* FEE */
   1668              {kMCG_ModeFEI, kMCG_ModeFBI, kMCG_ModeFBI, kMCG_ModeFEE, kMCG_ModeFBE, kMCG_ModeBLPE, kMCG_ModePBE,
   1669               kMCG_ModePBE}, /* FBE */
   1670              {kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeBLPE, kMCG_ModePBE,
   1671               kMCG_ModePBE}, /* BLPE */
   1672              {kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeBLPE, kMCG_ModePBE,
   1673               kMCG_ModePEE}, /* PBE */
   1674              {kMCG_ModePBE, kMCG_ModePBE, kMCG_ModePBE, kMCG_ModePBE, kMCG_ModePBE, kMCG_ModePBE, kMCG_ModePBE,
   1675               kMCG_ModePBE} /* PEE */
   1676              /*    FEI           FBI           BLPI           FEE           FBE           BLPE           PBE           PEE */
   1677          };
   1678          

   \                                 In section .text, align 4, keep-with-next
   1679          status_t CLOCK_SetMcgConfig(const mcg_config_t *config)
   1680          {
   \                     CLOCK_SetMcgConfig: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   1681              mcg_mode_t next_mode;
   1682              status_t status = kStatus_Success;
   1683          
   1684              mcg_pll_clk_select_t pllcs = kMCG_PllClkSelPll0;
   1685          
   1686              /* If need to change external clock, MCG_C7[OSCSEL]. */
   1687              if (MCG_C7_OSCSEL_VAL != config->oscsel)
   \        0x4   0x....             LDR.N    R6,??DataTable46_11  ;; 0x40064000
   \        0x6   0x4605             MOV      R5,R0
   \        0x8   0x7B30             LDRB     R0,[R6, #+12]
   \        0xA   0x79E9             LDRB     R1,[R5, #+7]
   \        0xC   0x2400             MOVS     R4,#+0
   \        0xE   0xF000 0x0001      AND      R0,R0,#0x1
   \       0x12   0x4288             CMP      R0,R1
   \       0x14   0xD00C             BEQ.N    ??CLOCK_SetMcgConfig_1
   1688              {
   1689                  /* If external clock is in use, change to FEI first. */
   1690                  if (!(MCG->S & MCG_S_IRCST_MASK))
   \       0x16   0x79B0             LDRB     R0,[R6, #+6]
   \       0x18   0x07C1             LSLS     R1,R0,#+31
   \       0x1A   0xD406             BMI.N    ??CLOCK_SetMcgConfig_2
   1691                  {
   1692                      CLOCK_ExternalModeToFbeModeQuick();
   \       0x1C   0x.... 0x....      BL       CLOCK_ExternalModeToFbeModeQuick
   1693                      CLOCK_SetFeiMode(config->dmx32, config->drs, (void (*)(void))0);
   \       0x20   0x7969             LDRB     R1,[R5, #+5]
   \       0x22   0x79A8             LDRB     R0,[R5, #+6]
   \       0x24   0x2200             MOVS     R2,#+0
   \       0x26   0x.... 0x....      BL       CLOCK_SetFeiMode
   1694                  }
   1695          
   1696                  CLOCK_SetExternalRefClkConfig(config->oscsel);
   \                     ??CLOCK_SetMcgConfig_2: (+1)
   \       0x2A   0x79E8             LDRB     R0,[R5, #+7]
   \       0x2C   0x.... 0x....      BL       CLOCK_SetExternalRefClkConfig
   1697              }
   1698          
   1699              /* Re-configure MCGIRCLK, if MCGIRCLK is used as system clock source, then change to FEI/PEI first. */
   1700              if (MCG_S_CLKST_VAL == kMCG_ClkOutStatInt)
   \                     ??CLOCK_SetMcgConfig_1: (+1)
   \       0x30   0x79B0             LDRB     R0,[R6, #+6]
   \       0x32   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \       0x36   0x2801             CMP      R0,#+1
   \       0x38   0xD108             BNE.N    ??CLOCK_SetMcgConfig_3
   1701              {
   1702                  MCG->C2 &= ~MCG_C2_LP_MASK; /* Disable lowpower. */
   \       0x3A   0x7870             LDRB     R0,[R6, #+1]
   1703          
   1704                  {
   1705                      CLOCK_SetFeiMode(config->dmx32, config->drs, CLOCK_FllStableDelay);
   \       0x3C   0x....             LDR.N    R2,??DataTable46_20
   \       0x3E   0xF000 0x00FD      AND      R0,R0,#0xFD
   \       0x42   0x7070             STRB     R0,[R6, #+1]
   \       0x44   0x7969             LDRB     R1,[R5, #+5]
   \       0x46   0x79A8             LDRB     R0,[R5, #+6]
   \       0x48   0x.... 0x....      BL       CLOCK_SetFeiMode
   1706                  }
   1707              }
   1708          
   1709              /* Configure MCGIRCLK. */
   1710              CLOCK_SetInternalRefClkConfig(config->irclkEnableMode, config->ircs, config->fcrdiv);
   \                     ??CLOCK_SetMcgConfig_3: (+1)
   \       0x4C   0x78EA             LDRB     R2,[R5, #+3]
   \       0x4E   0x78A9             LDRB     R1,[R5, #+2]
   \       0x50   0x7868             LDRB     R0,[R5, #+1]
   \       0x52   0x.... 0x....      ADR.W    R9,mcgModeMatrix
   \       0x56   0x.... 0x....      LDR.W    R8,??DataTable46_20
   \       0x5A   0x.... 0x....      BL       CLOCK_SetInternalRefClkConfig
   1711          
   1712              next_mode = CLOCK_GetMode();
   \       0x5E   0x.... 0x....      BL       CLOCK_GetMode
   \       0x62   0x4607             MOV      R7,R0
   1713          
   1714              do
   1715              {
   1716                  next_mode = mcgModeMatrix[next_mode][config->mcgMode];
   \                     ??CLOCK_SetMcgConfig_4: (+1)
   \       0x64   0x7828             LDRB     R0,[R5, #+0]
   \       0x66   0xEB09 0x01C7      ADD      R1,R9,R7, LSL #+3
   \       0x6A   0x5C0F             LDRB     R7,[R1, R0]
   1717          
   1718                  switch (next_mode)
   \       0x6C   0x2F07             CMP      R7,#+7
   \       0x6E   0xD80B             BHI.N    ??CLOCK_SetMcgConfig_5
   \       0x70   0xE8DF 0xF007      TBB      [PC, R7]
   \                     ??CLOCK_SetMcgConfig_0:
   \       0x74   0x04 0x16          DC8      0x4,0x16,0x23,0xF
   \              0x23 0x0F    
   \       0x78   0x1C 0x28          DC8      0x1C,0x28,0x2D,0x43
   \              0x2D 0x43    
   1719                  {
   1720                      case kMCG_ModeFEI:
   1721                          status = CLOCK_SetFeiMode(config->dmx32, config->drs, CLOCK_FllStableDelay);
   \                     ??CLOCK_SetMcgConfig_6: (+1)
   \       0x7C   0x7969             LDRB     R1,[R5, #+5]
   \       0x7E   0x79A8             LDRB     R0,[R5, #+6]
   \       0x80   0x4642             MOV      R2,R8
   \       0x82   0x.... 0x....      BL       CLOCK_SetFeiMode
   \                     ??CLOCK_SetMcgConfig_7: (+1)
   \       0x86   0x4604             MOV      R4,R0
   1722                          break;
   1723                      case kMCG_ModeFEE:
   1724                          status = CLOCK_SetFeeMode(config->frdiv, config->dmx32, config->drs, CLOCK_FllStableDelay);
   1725                          break;
   1726                      case kMCG_ModeFBI:
   1727                          status = CLOCK_SetFbiMode(config->dmx32, config->drs, (void (*)(void))0);
   1728                          break;
   1729                      case kMCG_ModeFBE:
   1730                          status = CLOCK_SetFbeMode(config->frdiv, config->dmx32, config->drs, (void (*)(void))0);
   1731                          break;
   1732                      case kMCG_ModeBLPI:
   1733                          status = CLOCK_SetBlpiMode();
   1734                          break;
   1735                      case kMCG_ModeBLPE:
   1736                          status = CLOCK_SetBlpeMode();
   1737                          break;
   1738                      case kMCG_ModePBE:
   1739                          /* If target mode is not PBE or PEE, then only need to set CLKS = EXT here. */
   1740                          if ((kMCG_ModePEE == config->mcgMode) || (kMCG_ModePBE == config->mcgMode))
   1741                          {
   1742                              {
   1743                                  status = CLOCK_SetPbeMode(pllcs, &config->pll0Config);
   1744                              }
   1745                          }
   1746                          else
   1747                          {
   1748                              MCG->C1 = ((MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcExternal));
   1749                              while (MCG_S_CLKST_VAL != kMCG_ClkOutStatExt)
   1750                              {
   1751                              }
   1752                          }
   1753                          break;
   1754                      case kMCG_ModePEE:
   1755                          status = CLOCK_SetPeeMode();
   1756                          break;
   1757                      default:
   1758                          break;
   1759                  }
   1760                  if (kStatus_Success != status)
   \                     ??CLOCK_SetMcgConfig_5: (+1)
   \       0x88   0x2C00             CMP      R4,#+0
   \       0x8A   0xD040             BEQ.N    ??CLOCK_SetMcgConfig_8
   1761                  {
   1762                      return status;
   \       0x8C   0x4620             MOV      R0,R4
   \       0x8E   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1763                  }
   \                     ??CLOCK_SetMcgConfig_9: (+1)
   \       0x92   0x796A             LDRB     R2,[R5, #+5]
   \       0x94   0x79A9             LDRB     R1,[R5, #+6]
   \       0x96   0x7928             LDRB     R0,[R5, #+4]
   \       0x98   0x4643             MOV      R3,R8
   \       0x9A   0x.... 0x....      BL       CLOCK_SetFeeMode
   \       0x9E   0xE7F2             B.N      ??CLOCK_SetMcgConfig_7
   \                     ??CLOCK_SetMcgConfig_10: (+1)
   \       0xA0   0x7969             LDRB     R1,[R5, #+5]
   \       0xA2   0x79A8             LDRB     R0,[R5, #+6]
   \       0xA4   0x2200             MOVS     R2,#+0
   \       0xA6   0x.... 0x....      BL       CLOCK_SetFbiMode
   \       0xAA   0xE7EC             B.N      ??CLOCK_SetMcgConfig_7
   \                     ??CLOCK_SetMcgConfig_11: (+1)
   \       0xAC   0x796A             LDRB     R2,[R5, #+5]
   \       0xAE   0x79A9             LDRB     R1,[R5, #+6]
   \       0xB0   0x7928             LDRB     R0,[R5, #+4]
   \       0xB2   0x2300             MOVS     R3,#+0
   \       0xB4   0x.... 0x....      BL       CLOCK_SetFbeMode
   \       0xB8   0xE7E5             B.N      ??CLOCK_SetMcgConfig_7
   \                     ??CLOCK_SetMcgConfig_12: (+1)
   \       0xBA   0x7870             LDRB     R0,[R6, #+1]
   \       0xBC   0xF040 0x0002      ORR      R0,R0,#0x2
   \       0xC0   0x7070             STRB     R0,[R6, #+1]
   \       0xC2   0xE023             B.N      ??CLOCK_SetMcgConfig_13
   \                     ??CLOCK_SetMcgConfig_14: (+1)
   \       0xC4   0x7870             LDRB     R0,[R6, #+1]
   \       0xC6   0xF040 0x0002      ORR      R0,R0,#0x2
   \       0xCA   0x7070             STRB     R0,[R6, #+1]
   \       0xCC   0xE01E             B.N      ??CLOCK_SetMcgConfig_13
   \                     ??CLOCK_SetMcgConfig_15: (+1)
   \       0xCE   0x2807             CMP      R0,#+7
   \       0xD0   0xBF18             IT       NE 
   \       0xD2   0x2806             CMPNE    R0,#+6
   \       0xD4   0xD105             BNE.N    ??CLOCK_SetMcgConfig_16
   \       0xD6   0xF105 0x0108      ADD      R1,R5,#+8
   \       0xDA   0x2000             MOVS     R0,#+0
   \       0xDC   0x.... 0x....      BL       CLOCK_SetPbeMode
   \       0xE0   0xE7D1             B.N      ??CLOCK_SetMcgConfig_7
   \                     ??CLOCK_SetMcgConfig_16: (+1)
   \       0xE2   0x7830             LDRB     R0,[R6, #+0]
   \       0xE4   0xF000 0x003F      AND      R0,R0,#0x3F
   \       0xE8   0xF040 0x0080      ORR      R0,R0,#0x80
   \       0xEC   0x7030             STRB     R0,[R6, #+0]
   \                     ??CLOCK_SetMcgConfig_17: (+1)
   \       0xEE   0x79B0             LDRB     R0,[R6, #+6]
   \       0xF0   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \       0xF4   0x2802             CMP      R0,#+2
   \       0xF6   0xD1FA             BNE.N    ??CLOCK_SetMcgConfig_17
   \       0xF8   0xE009             B.N      ??CLOCK_SetMcgConfig_8
   \                     ??CLOCK_SetMcgConfig_18: (+1)
   \       0xFA   0x7830             LDRB     R0,[R6, #+0]
   \       0xFC   0xF000 0x003F      AND      R0,R0,#0x3F
   \      0x100   0x7030             STRB     R0,[R6, #+0]
   \                     ??CLOCK_SetMcgConfig_19: (+1)
   \      0x102   0x79B0             LDRB     R0,[R6, #+6]
   \      0x104   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \      0x108   0x2803             CMP      R0,#+3
   \      0x10A   0xD1FA             BNE.N    ??CLOCK_SetMcgConfig_19
   \                     ??CLOCK_SetMcgConfig_13: (+1)
   \      0x10C   0x2400             MOVS     R4,#+0
   1764              } while (next_mode != config->mcgMode);
   \                     ??CLOCK_SetMcgConfig_8: (+1)
   \      0x10E   0x7828             LDRB     R0,[R5, #+0]
   \      0x110   0x4287             CMP      R7,R0
   \      0x112   0xD1A7             BNE.N    ??CLOCK_SetMcgConfig_4
   1765          
   1766              if (config->pll0Config.enableMode & kMCG_PllEnableIndependent)
   \      0x114   0x7A29             LDRB     R1,[R5, #+8]
   \      0x116   0x0648             LSLS     R0,R1,#+25
   \      0x118   0xD504             BPL.N    ??CLOCK_SetMcgConfig_20
   1767              {
   1768                  CLOCK_EnablePll0(&config->pll0Config);
   \      0x11A   0xF105 0x0008      ADD      R0,R5,#+8
   \      0x11E   0x.... 0x....      BL       CLOCK_EnablePll0
   \      0x122   0xE003             B.N      ??CLOCK_SetMcgConfig_21
   1769              }
   1770              else
   1771              {
   1772                  MCG->C5 &= ~(uint32_t)kMCG_PllEnableIndependent;
   \                     ??CLOCK_SetMcgConfig_20: (+1)
   \      0x124   0x7930             LDRB     R0,[R6, #+4]
   \      0x126   0xF000 0x00BF      AND      R0,R0,#0xBF
   \      0x12A   0x7130             STRB     R0,[R6, #+4]
   1773              }
   1774              return kStatus_Success;
   \                     ??CLOCK_SetMcgConfig_21: (+1)
   \      0x12C   0x2000             MOVS     R0,#+0
   \      0x12E   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1775          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45:
   \        0x0   0x4006'400C        DC32     0x4006400c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_1:
   \        0x0   0x4006'4000        DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_2:
   \        0x0   0x....'....        DC32     s_slowIrcFreq

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_3:
   \        0x0   0xAAAA'AAAB        DC32     0xaaaaaaab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_4:
   \        0x0   0xCCCC'CCCD        DC32     0xcccccccd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_5:
   \        0x0   0x4004'7000        DC32     0x40047000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46:
   \        0x0   0x4006'5000        DC32     0x40065000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_1:
   \        0x0   0x....'....        DC32     s_slowIrcFreq

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_2:
   \        0x0   0x4004'8004        DC32     0x40048004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_3:
   \        0x0   0x4004'8044        DC32     0x40048044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_4:
   \        0x0   0x02DC'6C00        DC32     0x2dc6c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_5:
   \        0x0   0x044A'A200        DC32     0x44aa200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_6:
   \        0x0   0x05B8'D800        DC32     0x5b8d800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_7:
   \        0x0   0x0727'0E00        DC32     0x7270e00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_8:
   \        0x0   0x4006'4006        DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_9:
   \        0x0   0x4006'4001        DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_10:
   \        0x0   0x4006'4004        DC32     0x40064004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_11:
   \        0x0   0x4006'4000        DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_12:
   \        0x0   0xFFE1'7B80        DC32     0xffe17b80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_13:
   \        0x0   0x05D7'5C81        DC32     0x5d75c81

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_14:
   \        0x0   0x003D'08FF        DC32     0x3d08ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_15:
   \        0x0   0x8637'BD06        DC32     0x8637bd06

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_16:
   \        0x0   0x4006'400D        DC32     0x4006400d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_17:
   \        0x0   0x4006'4005        DC32     0x40064005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_18:
   \        0x0   0x007A'1201        DC32     0x7a1201

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_19:
   \        0x0   0xFF85'EE00        DC32     0xff85ee00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_20:
   \        0x0   0x....'....        DC32     CLOCK_FllStableDelay

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CLOCK_BootToBlpeMode
       8   CLOCK_BootToBlpiMode
         8   -> CLOCK_SetInternalRefClkConfig
      24   CLOCK_BootToFeeMode
        24   -> CLOCK_SetExternalRefClkConfig
         0   -> CLOCK_SetFeeMode
       0   CLOCK_BootToFeiMode
         0   -> CLOCK_SetFeiMode
      16   CLOCK_BootToPeeMode
        16   -> CLOCK_SetExternalRefClkConfig
        16   -> CLOCK_SetPbeMode
      32   CLOCK_CalcPllDiv
       0   CLOCK_ClearStatusFlags
       0   CLOCK_DeinitOsc0
       0   CLOCK_EnablePll0
       4   CLOCK_EnableUsbfs0Clock
       0   CLOCK_ExternalModeToFbeModeQuick
       4   CLOCK_FllStableDelay
       8   CLOCK_GetBusClkFreq
         8   -> CLOCK_GetOutClkFreq
       0   CLOCK_GetCoreSysClkFreq
         8   -> CLOCK_GetOutClkFreq
       0   CLOCK_GetEr32kClkFreq
       8   CLOCK_GetFixedFreqClkFreq
         8   -> CLOCK_GetFllRefClkFreq
         8   -> CLOCK_GetOutClkFreq
       8   CLOCK_GetFlashClkFreq
         8   -> CLOCK_GetOutClkFreq
       8   CLOCK_GetFllFreq
         8   -> CLOCK_GetFllRefClkFreq
       0   CLOCK_GetFllRefClkFreq
       8   CLOCK_GetFreq
         0   -> CLOCK_GetEr32kClkFreq
         0   -> CLOCK_GetFixedFreqClkFreq
         0   -> CLOCK_GetFllFreq
         8   -> CLOCK_GetOutClkFreq
         0   -> CLOCK_GetPll0Freq
         0   -> CLOCK_GetPllFllSelClkFreq
       0   CLOCK_GetInternalRefClkFreq
       0   CLOCK_GetMcgExtClkFreq
       4   CLOCK_GetMode
       0   CLOCK_GetOsc0ErClkFreq
       0   CLOCK_GetOutClkFreq
         0   -> CLOCK_GetFllFreq
         0   -> CLOCK_GetMcgExtClkFreq
         0   -> CLOCK_GetPll0Freq
       8   CLOCK_GetPlatClkFreq
         8   -> CLOCK_GetOutClkFreq
       0   CLOCK_GetPll0Freq
       0   CLOCK_GetPllFllSelClkFreq
         0   -> CLOCK_GetFllFreq
         0   -> CLOCK_GetPll0Freq
       0   CLOCK_GetStatusFlags
       8   CLOCK_InitOsc0
       0   CLOCK_InternalModeToFbiModeQuick
       0   CLOCK_SetBlpeMode
       0   CLOCK_SetBlpiMode
       0   CLOCK_SetExternalRefClkConfig
      16   CLOCK_SetFbeMode
        16   -- Indirect call
      16   CLOCK_SetFbiMode
        16   -- Indirect call
      24   CLOCK_SetFeeMode
        24   -- Indirect call
      16   CLOCK_SetFeiMode
        16   -- Indirect call
      12   CLOCK_SetInternalRefClkConfig
      32   CLOCK_SetMcgConfig
        32   -> CLOCK_EnablePll0
        32   -> CLOCK_ExternalModeToFbeModeQuick
        32   -> CLOCK_GetMode
        32   -> CLOCK_SetExternalRefClkConfig
        32   -> CLOCK_SetFbeMode
        32   -> CLOCK_SetFbiMode
        32   -> CLOCK_SetFeeMode
        32   -> CLOCK_SetFeiMode
        32   -> CLOCK_SetInternalRefClkConfig
        32   -> CLOCK_SetPbeMode
       0   CLOCK_SetOsc0MonitorMode
       0   CLOCK_SetPbeMode
       0   CLOCK_SetPeeMode
       0   CLOCK_SetPll0MonitorMode
       0   CLOCK_SetRtcOscMonitorMode
       0   CLOCK_SetSimConfig
      16   CLOCK_TrimInternalRefClk


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable45
       4  ??DataTable45_1
       4  ??DataTable45_2
       4  ??DataTable45_3
       4  ??DataTable45_4
       4  ??DataTable45_5
       4  ??DataTable46
       4  ??DataTable46_1
       4  ??DataTable46_10
       4  ??DataTable46_11
       4  ??DataTable46_12
       4  ??DataTable46_13
       4  ??DataTable46_14
       4  ??DataTable46_15
       4  ??DataTable46_16
       4  ??DataTable46_17
       4  ??DataTable46_18
       4  ??DataTable46_19
       4  ??DataTable46_2
       4  ??DataTable46_20
       4  ??DataTable46_3
       4  ??DataTable46_4
       4  ??DataTable46_5
       4  ??DataTable46_6
       4  ??DataTable46_7
       4  ??DataTable46_8
       4  ??DataTable46_9
      14  ?Subroutine0
       8  ?Subroutine1
       8  ?Subroutine2
       8  ?Subroutine3
      20  ?Subroutine4
       8  ?Subroutine5
      94  CLOCK_BootToBlpeMode
      48  CLOCK_BootToBlpiMode
      30  CLOCK_BootToFeeMode
       2  CLOCK_BootToFeiMode
      42  CLOCK_BootToPeeMode
     194  CLOCK_CalcPllDiv
      42  CLOCK_ClearStatusFlags
      22  CLOCK_DeinitOsc0
      48  CLOCK_EnablePll0
     106  CLOCK_EnableUsbfs0Clock
      50  CLOCK_ExternalModeToFbeModeQuick
      26  CLOCK_FllStableDelay
      16  CLOCK_GetBusClkFreq
       2  CLOCK_GetCoreSysClkFreq
      64  CLOCK_GetEr32kClkFreq
      28  CLOCK_GetFixedFreqClkFreq
      18  CLOCK_GetFlashClkFreq
      54  CLOCK_GetFllFreq
     114  CLOCK_GetFllRefClkFreq
     154  CLOCK_GetFreq
      32  CLOCK_GetInternalRefClkFreq
      26  CLOCK_GetMcgExtClkFreq
      94  CLOCK_GetMode
      16  CLOCK_GetOsc0ErClkFreq
      54  CLOCK_GetOutClkFreq
       4  CLOCK_GetPlatClkFreq
      64  CLOCK_GetPll0Freq
      28  CLOCK_GetPllFllSelClkFreq
      54  CLOCK_GetStatusFlags
      96  CLOCK_InitOsc0
      36  CLOCK_InternalModeToFbiModeQuick
       2  CLOCK_SetBlpeMode
       2  CLOCK_SetBlpiMode
      48  CLOCK_SetExternalRefClkConfig
     122  CLOCK_SetFbeMode
     102  CLOCK_SetFbiMode
     122  CLOCK_SetFeeMode
      94  CLOCK_SetFeiMode
     116  CLOCK_SetInternalRefClkConfig
     306  CLOCK_SetMcgConfig
      56  CLOCK_SetOsc0MonitorMode
     106  CLOCK_SetPbeMode
      24  CLOCK_SetPeeMode
      50  CLOCK_SetPll0MonitorMode
      30  CLOCK_SetRtcOscMonitorMode
      50  CLOCK_SetSimConfig
     156  CLOCK_TrimInternalRefClk
      16  fllFactorTable
      64  mcgModeMatrix
      16  s_slowIrcFreq
          s_fastIrcFreq
          g_xtal0Freq
          g_xtal32Freq
      16  trimRange

 
    16 bytes in section .data
 3 314 bytes in section .text
 
 3 314 bytes of CODE memory
    16 bytes of DATA memory

Errors: none
Warnings: none
