###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         03/Mar/2020  16:31:23
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_uart.c
#    Command line =  
#        C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_uart.c
#        "-IC:\Program Files (x86)\IAR Systems\Embedded Workbench 8.1\arm\inc"
#        -I..\..\..\..\..\CMSIS\Include -I..\..\..\..\..\devices -I..\..\..
#        -I..\..\..\..\..\devices\MKW24D5\drivers
#        -I..\..\..\..\..\devices\MKW24D5\utilities
#        -I..\..\..\..\..\devices\MKW24D5 -I..\..\iar -I..\.. -I..\
#        -I..\..\..\..\..\rtos\freertos_9.0.0\Source\portable\IAR\ARM_CM3
#        -I..\..\..\..\..\rtos\freertos_9.0.0\Source\include -DNDEBUG
#        -DCPU_MKW24D512VHA5 -DIAR -DFSL_RTOS_FREE_RTOS -DPRINTF_FLOAT_ENABLE=0
#        -DSCANF_FLOAT_ENABLE=0 -DPRINTF_ADVANCED_ENABLE=0
#        -DSCANF_ADVANCED_ENABLE=0 -DTWR_KW24D512 -DTOWER --diag_suppress
#        Pa082,Pa050,Pe167,Pa182 --endian=little --cpu=Cortex-M4 --fpu=None
#        --no_path_in_file_macros --silent -lC . -e --dlib_config "C:/Program
#        Files (x86)/IAR Systems/Embedded Workbench
#        8.1/arm/inc/c/DLib_Config_Normal.h" -Oh --dependencies=ns
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_uart.c.obj.d
#        -o
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_uart.c.obj
#    Locale       =  C
#    List file    =  .\fsl_uart.c.lst
#    Object file  =  
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_uart.c.obj
#
###############################################################################

C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_uart.c
      1          /*
      2           * Copyright (c) 2015-2016, Freescale Semiconductor, Inc.
      3           * Copyright 2016-2017 NXP
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of the copyright holder nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "fsl_uart.h"
     32          
     33          /*******************************************************************************
     34           * Definitions
     35           ******************************************************************************/
     36          
     37          /* UART transfer state. */
     38          enum _uart_tansfer_states
     39          {
     40              kUART_TxIdle,         /* TX idle. */
     41              kUART_TxBusy,         /* TX busy. */
     42              kUART_RxIdle,         /* RX idle. */
     43              kUART_RxBusy,         /* RX busy. */
     44              kUART_RxFramingError, /* Rx framing error */
     45              kUART_RxParityError   /* Rx parity error */
     46          };
     47          
     48          /* Typedef for interrupt handler. */
     49          typedef void (*uart_isr_t)(UART_Type *base, uart_handle_t *handle);
     50          
     51          /*******************************************************************************
     52           * Prototypes
     53           ******************************************************************************/
     54          
     55          /*!
     56           * @brief Get the UART instance from peripheral base address.
     57           *
     58           * @param base UART peripheral base address.
     59           * @return UART instance.
     60           */
     61          uint32_t UART_GetInstance(UART_Type *base);
     62          
     63          /*!
     64           * @brief Get the length of received data in RX ring buffer.
     65           *
     66           * @param handle UART handle pointer.
     67           * @return Length of received data in RX ring buffer.
     68           */
     69          static size_t UART_TransferGetRxRingBufferLength(uart_handle_t *handle);
     70          
     71          /*!
     72           * @brief Check whether the RX ring buffer is full.
     73           *
     74           * @param handle UART handle pointer.
     75           * @retval true  RX ring buffer is full.
     76           * @retval false RX ring buffer is not full.
     77           */
     78          static bool UART_TransferIsRxRingBufferFull(uart_handle_t *handle);
     79          
     80          /*!
     81           * @brief Read RX register using non-blocking method.
     82           *
     83           * This function reads data from the TX register directly, upper layer must make
     84           * sure the RX register is full or TX FIFO has data before calling this function.
     85           *
     86           * @param base UART peripheral base address.
     87           * @param data Start addresss of the buffer to store the received data.
     88           * @param length Size of the buffer.
     89           */
     90          static void UART_ReadNonBlocking(UART_Type *base, uint8_t *data, size_t length);
     91          
     92          /*!
     93           * @brief Write to TX register using non-blocking method.
     94           *
     95           * This function writes data to the TX register directly, upper layer must make
     96           * sure the TX register is empty or TX FIFO has empty room before calling this function.
     97           *
     98           * @note This function does not check whether all the data has been sent out to bus,
     99           * so before disable TX, check kUART_TransmissionCompleteFlag to ensure the TX is
    100           * finished.
    101           *
    102           * @param base UART peripheral base address.
    103           * @param data Start addresss of the data to write.
    104           * @param length Size of the buffer to be sent.
    105           */
    106          static void UART_WriteNonBlocking(UART_Type *base, const uint8_t *data, size_t length);
    107          
    108          /*******************************************************************************
    109           * Variables
    110           ******************************************************************************/
    111          /* Array of UART handle. */
    112          #if (defined(UART5))
    113          #define UART_HANDLE_ARRAY_SIZE 6
    114          #else /* UART5 */
    115          #if (defined(UART4))
    116          #define UART_HANDLE_ARRAY_SIZE 5
    117          #else /* UART4 */
    118          #if (defined(UART3))
    119          #define UART_HANDLE_ARRAY_SIZE 4
    120          #else /* UART3 */
    121          #if (defined(UART2))
    122          #define UART_HANDLE_ARRAY_SIZE 3
    123          #else /* UART2 */
    124          #if (defined(UART1))
    125          #define UART_HANDLE_ARRAY_SIZE 2
    126          #else /* UART1 */
    127          #if (defined(UART0))
    128          #define UART_HANDLE_ARRAY_SIZE 1
    129          #else /* UART0 */
    130          #error No UART instance.
    131          #endif /* UART 0 */
    132          #endif /* UART 1 */
    133          #endif /* UART 2 */
    134          #endif /* UART 3 */
    135          #endif /* UART 4 */
    136          #endif /* UART 5 */
    137          static uart_handle_t *s_uartHandle[UART_HANDLE_ARRAY_SIZE];
    138          /* Array of UART peripheral base address. */

   \                                 In section .rodata, align 4, keep-with-next
    139          static UART_Type *const s_uartBases[] = UART_BASE_PTRS;
   \                     s_uartBases:
   \        0x0   0x4006'A000        DC32 4006A000H, 4006B000H, 4006C000H
   \              0x4006'B000  
   \              0x4006'C000  
    140          
    141          /* Array of UART IRQ number. */

   \                                 In section .text, align 4, keep-with-next
    142          static const IRQn_Type s_uartIRQ[] = UART_RX_TX_IRQS;
   \                     s_uartIRQ:
   \        0x0   0x1F 0x21          DC8 31, 33, 35, 0
   \              0x23 0x00    
    143          #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
    144          /* Array of UART clock name. */

   \                                 In section .text, align 4, keep-with-next
    145          static const clock_ip_name_t s_uartClock[] = UART_CLOCKS;
   \                     s_uartClock:
   \        0x0   0x1034'000A        DC32 271843338, 271843339, 271843340
   \              0x1034'000B  
   \              0x1034'000C  

   \                                 In section .bss, align 4
   \                     s_uartHandle:
   \        0x0                      DS8 12
   \        0xC                      DS8 4
    146          #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
    147          
    148          /* UART ISR for transactional APIs. */
    149          static uart_isr_t s_uartIsr;
    150          
    151          /*******************************************************************************
    152           * Code
    153           ******************************************************************************/
    154          

   \                                 In section .text, align 2, keep-with-next
    155          uint32_t UART_GetInstance(UART_Type *base)
    156          {
   \                     UART_GetInstance: (+1)
   \        0x0   0x4601             MOV      R1,R0
    157              uint32_t instance;
    158              uint32_t uartArrayCount = (sizeof(s_uartBases) / sizeof(s_uartBases[0]));
    159          
    160              /* Find the instance index from base address mappings. */
    161              for (instance = 0; instance < uartArrayCount; instance++)
   \        0x2   0x2000             MOVS     R0,#+0
    162              {
    163                  if (s_uartBases[instance] == base)
   \        0x4   0x.... 0x....      LDR.W    R2,??DataTable14  ;; 0x4006a000
   \        0x8   0x4291             CMP      R1,R2
   \        0xA   0xBF1E             ITTT     NE 
   \        0xC   0x2001             MOVNE    R0,#+1
   \        0xE   0x.... 0x....      LDRNE.W  R3,??DataTable14_1  ;; 0x4006b000
   \       0x12   0x4299             CMPNE    R1,R3
   \       0x14   0xD005             BEQ.N    ??UART_GetInstance_0
   \       0x16   0x2002             MOVS     R0,#+2
   \       0x18   0x.... 0x....      LDR.W    R2,??DataTable14_2  ;; 0x4006c000
   \       0x1C   0x4291             CMP      R1,R2
   \       0x1E   0xBF18             IT       NE 
   \       0x20   0x2003             MOVNE    R0,#+3
    164                  {
    165                      break;
    166                  }
    167              }
    168          
    169              assert(instance < uartArrayCount);
    170          
    171              return instance;
   \                     ??UART_GetInstance_0: (+1)
   \       0x22   0x4770             BX       LR               ;; return
    172          }
    173          

   \                                 In section .text, align 2, keep-with-next
    174          static size_t UART_TransferGetRxRingBufferLength(uart_handle_t *handle)
    175          {
    176              assert(handle);
    177          
    178              size_t size;
    179          
    180              if (handle->rxRingBufferTail > handle->rxRingBufferHead)
   \                     UART_TransferGetRxRingBufferLength: (+1)
   \        0x0   0x8C01             LDRH     R1,[R0, #+32]
   \        0x2   0x8C42             LDRH     R2,[R0, #+34]
   \        0x4   0x4291             CMP      R1,R2
   \        0x6   0x8C01             LDRH     R1,[R0, #+32]
   \        0x8   0xBF3C             ITT      CC 
   \        0xA   0x69C2             LDRCC    R2,[R0, #+28]
   \        0xC   0x1851             ADDCC    R1,R2,R1
    181              {
    182                  size = (size_t)(handle->rxRingBufferHead + handle->rxRingBufferSize - handle->rxRingBufferTail);
    183              }
    184              else
    185              {
    186                  size = (size_t)(handle->rxRingBufferHead - handle->rxRingBufferTail);
   \        0xE   0x8C40             LDRH     R0,[R0, #+34]
   \       0x10   0x1A08             SUBS     R0,R1,R0
    187              }
    188          
    189              return size;
   \       0x12   0x4770             BX       LR               ;; return
    190          }
    191          
    192          static bool UART_TransferIsRxRingBufferFull(uart_handle_t *handle)
    193          {
    194              assert(handle);
    195          
    196              bool full;
    197          
    198              if (UART_TransferGetRxRingBufferLength(handle) == (handle->rxRingBufferSize - 1U))
    199              {
    200                  full = true;
    201              }
    202              else
    203              {
    204                  full = false;
    205              }
    206          
    207              return full;
    208          }
    209          

   \                                 In section .text, align 2, keep-with-next
    210          status_t UART_Init(UART_Type *base, const uart_config_t *config, uint32_t srcClock_Hz)
    211          {
   \                     UART_Init: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
    212              assert(config);
    213              assert(config->baudRate_Bps);
    214          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    215              assert(FSL_FEATURE_UART_FIFO_SIZEn(base) >= config->txFifoWatermark);
    216              assert(FSL_FEATURE_UART_FIFO_SIZEn(base) >= config->rxFifoWatermark);
    217          #endif
    218          
    219              uint16_t sbr = 0;
    220              uint8_t temp = 0;
    221              uint32_t baudDiff = 0;
    222          
    223              /* Calculate the baud rate modulo divisor, sbr*/
    224              sbr = srcClock_Hz / (config->baudRate_Bps * 16);
   \        0x2   0x680D             LDR      R5,[R1, #+0]
   \        0x4   0x012B             LSLS     R3,R5,#+4
   \        0x6   0xFBB2 0xF3F3      UDIV     R3,R2,R3
   \        0xA   0xB29B             UXTH     R3,R3
    225              /* set sbrTemp to 1 if the sourceClockInHz can not satisfy the desired baud rate */
    226              if (sbr == 0)
   \        0xC   0xB903             CBNZ.N   R3,??UART_Init_0
    227              {
    228                  sbr = 1;
   \        0xE   0x2301             MOVS     R3,#+1
    229              }
    230          #if defined(FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT) && FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT
    231              /* Determine if a fractional divider is needed to fine tune closer to the
    232               * desired baud, each value of brfa is in 1/32 increments,
    233               * hence the multiply-by-32. */
    234              uint32_t tempBaud = 0;
    235          
    236              uint16_t brfa = (2 * srcClock_Hz / (config->baudRate_Bps)) - 32 * sbr;
   \                     ??UART_Init_0: (+1)
   \       0x10   0x0052             LSLS     R2,R2,#+1
   \       0x12   0xFBB2 0xF4F5      UDIV     R4,R2,R5
   \       0x16   0xEBA4 0x1443      SUB      R4,R4,R3, LSL #+5
    237          
    238              /* Calculate the baud rate based on the temporary SBR values and BRFA */
    239              tempBaud = (srcClock_Hz * 2 / ((sbr * 32 + brfa)));
   \       0x1A   0x015E             LSLS     R6,R3,#+5
   \       0x1C   0xFA16 0xF684      UXTAH    R6,R6,R4
   \       0x20   0xFBB2 0xF2F6      UDIV     R2,R2,R6
    240              baudDiff =
    241                  (tempBaud > config->baudRate_Bps) ? (tempBaud - config->baudRate_Bps) : (config->baudRate_Bps - tempBaud);
   \       0x24   0x4295             CMP      R5,R2
    242          
    243          #else
    244              /* Calculate the baud rate based on the temporary SBR values */
    245              baudDiff = (srcClock_Hz / (sbr * 16)) - config->baudRate_Bps;
    246          
    247              /* Select the better value between sbr and (sbr + 1) */
    248              if (baudDiff > (config->baudRate_Bps - (srcClock_Hz / (16 * (sbr + 1)))))
    249              {
    250                  baudDiff = config->baudRate_Bps - (srcClock_Hz / (16 * (sbr + 1)));
    251                  sbr++;
    252              }
    253          #endif
    254          
    255              /* next, check to see if actual baud rate is within 3% of desired baud rate
    256               * based on the calculate SBR value */
    257              if (baudDiff > ((config->baudRate_Bps / 100) * 3))
   \       0x26   0x.... 0x....      LDR.W    R6,??DataTable14_3  ;; 0xa3d70a3e
   \       0x2A   0xBF34             ITE      CC 
   \       0x2C   0x1B52             SUBCC    R2,R2,R5
   \       0x2E   0x1AAA             SUBCS    R2,R5,R2
   \       0x30   0xFBA5 0xC706      UMULL    R12,R7,R5,R6
   \       0x34   0x09BD             LSRS     R5,R7,#+6
   \       0x36   0xEB05 0x0545      ADD      R5,R5,R5, LSL #+1
   \       0x3A   0x4295             CMP      R5,R2
   \       0x3C   0xBF38             IT       CC 
   \       0x3E   0xF240 0x30F5      MOVWCC   R0,#+1013
    258              {
    259                  /* Unacceptable baud rate difference of more than 3%*/
    260                  return kStatus_UART_BaudrateNotSupport;
   \       0x42   0xD34F             BCC.N    ??UART_Init_1
    261              }
    262          
    263          #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
    264              /* Enable uart clock */
    265              CLOCK_EnableClock(s_uartClock[UART_GetInstance(base)]);
   \       0x44   0x2200             MOVS     R2,#+0
   \       0x46   0x.... 0x....      LDR.W    R5,??DataTable14  ;; 0x4006a000
   \       0x4A   0x42A8             CMP      R0,R5
   \       0x4C   0xBF1E             ITTT     NE 
   \       0x4E   0x2201             MOVNE    R2,#+1
   \       0x50   0x.... 0x....      LDRNE.W  R6,??DataTable14_1  ;; 0x4006b000
   \       0x54   0x42B0             CMPNE    R0,R6
   \       0x56   0xD005             BEQ.N    ??UART_Init_2
   \       0x58   0x2202             MOVS     R2,#+2
   \       0x5A   0x.... 0x....      LDR.W    R5,??DataTable14_2  ;; 0x4006c000
   \       0x5E   0x42A8             CMP      R0,R5
   \       0x60   0xBF18             IT       NE 
   \       0x62   0x2203             MOVNE    R2,#+3
   \                     ??UART_Init_2: (+1)
   \       0x64   0x.... 0x....      ADR.W    R5,s_uartClock
   \       0x68   0xF855 0x2022      LDR      R2,[R5, R2, LSL #+2]
   \       0x6C   0x.... 0x....      LDR.W    R5,??DataTable14_4  ;; 0x40047000
   \       0x70   0xEB05 0x4512      ADD      R5,R5,R2, LSR #+16
   \       0x74   0x2701             MOVS     R7,#+1
   \       0x76   0x682E             LDR      R6,[R5, #+0]
   \       0x78   0xFA07 0xF202      LSL      R2,R7,R2
   \       0x7C   0x4332             ORRS     R2,R2,R6
   \       0x7E   0x602A             STR      R2,[R5, #+0]
    266          #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
    267          
    268              /* Disable UART TX RX before setting. */
    269              base->C2 &= ~(UART_C2_TE_MASK | UART_C2_RE_MASK);
    270          
    271              /* Write the sbr value to the BDH and BDL registers*/
    272              base->BDH = (base->BDH & ~UART_BDH_SBR_MASK) | (uint8_t)(sbr >> 8);
    273              base->BDL = (uint8_t)sbr;
    274          
    275          #if defined(FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT) && FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT
    276              /* Write the brfa value to the register*/
    277              base->C4 = (base->C4 & ~UART_C4_BRFA_MASK) | (brfa & UART_C4_BRFA_MASK);
   \       0x80   0xF004 0x041F      AND      R4,R4,#0x1F
   \       0x84   0x78C2             LDRB     R2,[R0, #+3]
   \       0x86   0xF002 0x02F3      AND      R2,R2,#0xF3
   \       0x8A   0x70C2             STRB     R2,[R0, #+3]
   \       0x8C   0x7805             LDRB     R5,[R0, #+0]
   \       0x8E   0xF005 0x05E0      AND      R5,R5,#0xE0
   \       0x92   0xEA45 0x2523      ORR      R5,R5,R3, ASR #+8
   \       0x96   0x7005             STRB     R5,[R0, #+0]
   \       0x98   0x7043             STRB     R3,[R0, #+1]
   \       0x9A   0x7A83             LDRB     R3,[R0, #+10]
   \       0x9C   0xF003 0x03E0      AND      R3,R3,#0xE0
   \       0xA0   0x431C             ORRS     R4,R4,R3
   \       0xA2   0x7284             STRB     R4,[R0, #+10]
    278          #endif
    279          
    280              /* Set bit count and parity mode. */
    281              temp = base->C1 & ~(UART_C1_PE_MASK | UART_C1_PT_MASK | UART_C1_M_MASK);
   \       0xA4   0x7883             LDRB     R3,[R0, #+2]
    282          
    283              if (kUART_ParityDisabled != config->parityMode)
   \       0xA6   0x790A             LDRB     R2,[R1, #+4]
   \       0xA8   0xF023 0x0313      BIC      R3,R3,#0x13
   \       0xAC   0xB112             CBZ.N    R2,??UART_Init_3
    284              {
    285                  temp |= (UART_C1_M_MASK | (uint8_t)config->parityMode);
   \       0xAE   0xF042 0x0210      ORR      R2,R2,#0x10
   \       0xB2   0x4313             ORRS     R3,R2,R3
    286              }
    287          
    288              base->C1 = temp;
   \                     ??UART_Init_3: (+1)
   \       0xB4   0x7083             STRB     R3,[R0, #+2]
    289          
    290          #if defined(FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_SUPPORT) && FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_SUPPORT
    291              /* Set stop bit per char */
    292              base->BDH = (base->BDH & ~UART_BDH_SBNS_MASK) | UART_BDH_SBNS((uint8_t)config->stopBitCount);
    293          #endif
    294          
    295          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    296              /* Set tx/rx FIFO watermark */
    297              base->TWFIFO = config->txFifoWatermark;
   \       0xB6   0x794A             LDRB     R2,[R1, #+5]
   \       0xB8   0x74C2             STRB     R2,[R0, #+19]
    298              base->RWFIFO = config->rxFifoWatermark;
   \       0xBA   0x798B             LDRB     R3,[R1, #+6]
   \       0xBC   0x7543             STRB     R3,[R0, #+21]
    299          
    300              /* Enable tx/rx FIFO */
    301              base->PFIFO |= (UART_PFIFO_TXFE_MASK | UART_PFIFO_RXFE_MASK);
   \       0xBE   0x7C02             LDRB     R2,[R0, #+16]
   \       0xC0   0xF042 0x0288      ORR      R2,R2,#0x88
   \       0xC4   0x7402             STRB     R2,[R0, #+16]
    302          
    303              /* Flush FIFO */
    304              base->CFIFO |= (UART_CFIFO_TXFLUSH_MASK | UART_CFIFO_RXFLUSH_MASK);
   \       0xC6   0x7C42             LDRB     R2,[R0, #+17]
   \       0xC8   0xF042 0x02C0      ORR      R2,R2,#0xC0
   \       0xCC   0x7442             STRB     R2,[R0, #+17]
    305          #endif
    306          
    307              /* Enable TX/RX base on configure structure. */
    308              temp = base->C2;
   \       0xCE   0x78C3             LDRB     R3,[R0, #+3]
    309          
    310              if (config->enableTx)
   \       0xD0   0x79CA             LDRB     R2,[R1, #+7]
   \       0xD2   0xB10A             CBZ.N    R2,??UART_Init_4
    311              {
    312                  temp |= UART_C2_TE_MASK;
   \       0xD4   0xF043 0x0308      ORR      R3,R3,#0x8
    313              }
    314          
    315              if (config->enableRx)
   \                     ??UART_Init_4: (+1)
   \       0xD8   0x7A09             LDRB     R1,[R1, #+8]
   \       0xDA   0xB109             CBZ.N    R1,??UART_Init_5
    316              {
    317                  temp |= UART_C2_RE_MASK;
   \       0xDC   0xF043 0x0304      ORR      R3,R3,#0x4
    318              }
    319          
    320              base->C2 = temp;
   \                     ??UART_Init_5: (+1)
   \       0xE0   0x70C3             STRB     R3,[R0, #+3]
    321          
    322              return kStatus_Success;
   \       0xE2   0x2000             MOVS     R0,#+0
   \                     ??UART_Init_1: (+1)
   \       0xE4   0xBCF0             POP      {R4-R7}
   \       0xE6   0x4770             BX       LR               ;; return
    323          }
    324          

   \                                 In section .text, align 2, keep-with-next
    325          void UART_Deinit(UART_Type *base)
    326          {
   \                     UART_Deinit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    327          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    328              /* Wait tx FIFO send out*/
    329              while (0 != base->TCFIFO)
   \                     ??UART_Deinit_0: (+1)
   \        0x2   0x7D01             LDRB     R1,[R0, #+20]
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD1FC             BNE.N    ??UART_Deinit_0
    330              {
    331              }
    332          #endif
    333              /* Wait last char shoft out */
    334              while (0 == (base->S1 & UART_S1_TC_MASK))
   \                     ??UART_Deinit_1: (+1)
   \        0x8   0x7901             LDRB     R1,[R0, #+4]
   \        0xA   0x064A             LSLS     R2,R1,#+25
   \        0xC   0xD5FC             BPL.N    ??UART_Deinit_1
    335              {
    336              }
    337          
    338              /* Disable the module. */
    339              base->C2 = 0;
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0x70C1             STRB     R1,[R0, #+3]
    340          
    341          #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
    342              /* Disable uart clock */
    343              CLOCK_DisableClock(s_uartClock[UART_GetInstance(base)]);
   \       0x12   0x.... 0x....      BL       UART_GetInstance
   \       0x16   0x.... 0x....      ADR.W    R1,s_uartClock
   \       0x1A   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \       0x1E   0x.... 0x....      LDR.W    R1,??DataTable14_4  ;; 0x40047000
   \       0x22   0xEB01 0x4110      ADD      R1,R1,R0, LSR #+16
   \       0x26   0x2301             MOVS     R3,#+1
   \       0x28   0x680A             LDR      R2,[R1, #+0]
   \       0x2A   0xFA03 0xF000      LSL      R0,R3,R0
   \       0x2E   0xEA22 0x0000      BIC      R0,R2,R0
   \       0x32   0x6008             STR      R0,[R1, #+0]
    344          #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
    345          }
   \       0x34   0xBD01             POP      {R0,PC}          ;; return
    346          

   \                                 In section .text, align 2, keep-with-next
    347          void UART_GetDefaultConfig(uart_config_t *config)
    348          {
    349              assert(config);
    350          
    351              config->baudRate_Bps = 115200U;
   \                     UART_GetDefaultConfig: (+1)
   \        0x0   0xF44F 0x31E1      MOV      R1,#+115200
   \        0x4   0x6001             STR      R1,[R0, #+0]
    352              config->parityMode = kUART_ParityDisabled;
   \        0x6   0x2200             MOVS     R2,#+0
    353          #if defined(FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_SUPPORT) && FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_SUPPORT
    354              config->stopBitCount = kUART_OneStopBit;
    355          #endif
    356          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    357              config->txFifoWatermark = 0;
    358              config->rxFifoWatermark = 1;
   \        0x8   0x2101             MOVS     R1,#+1
   \        0xA   0x7102             STRB     R2,[R0, #+4]
   \        0xC   0x7142             STRB     R2,[R0, #+5]
   \        0xE   0x7181             STRB     R1,[R0, #+6]
    359          #endif
    360              config->enableTx = false;
   \       0x10   0x71C2             STRB     R2,[R0, #+7]
    361              config->enableRx = false;
   \       0x12   0x7202             STRB     R2,[R0, #+8]
    362          }
   \       0x14   0x4770             BX       LR               ;; return
    363          

   \                                 In section .text, align 2, keep-with-next
    364          status_t UART_SetBaudRate(UART_Type *base, uint32_t baudRate_Bps, uint32_t srcClock_Hz)
    365          {
   \                     UART_SetBaudRate: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
    366              assert(baudRate_Bps);
    367          
    368              uint16_t sbr = 0;
    369              uint32_t baudDiff = 0;
    370              uint8_t oldCtrl;
    371          
    372              /* Calculate the baud rate modulo divisor, sbr*/
    373              sbr = srcClock_Hz / (baudRate_Bps * 16);
   \        0x2   0x010B             LSLS     R3,R1,#+4
   \        0x4   0xFBB2 0xF3F3      UDIV     R3,R2,R3
   \        0x8   0xB29B             UXTH     R3,R3
    374              /* set sbrTemp to 1 if the sourceClockInHz can not satisfy the desired baud rate */
    375              if (sbr == 0)
   \        0xA   0xB903             CBNZ.N   R3,??UART_SetBaudRate_0
    376              {
    377                  sbr = 1;
   \        0xC   0x2301             MOVS     R3,#+1
    378              }
    379          #if defined(FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT) && FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT
    380              /* Determine if a fractional divider is needed to fine tune closer to the
    381               * desired baud, each value of brfa is in 1/32 increments,
    382               * hence the multiply-by-32. */
    383              uint32_t tempBaud = 0;
    384          
    385              uint16_t brfa = (2 * srcClock_Hz / (baudRate_Bps)) - 32 * sbr;
   \                     ??UART_SetBaudRate_0: (+1)
   \        0xE   0x0052             LSLS     R2,R2,#+1
   \       0x10   0xFBB2 0xF4F1      UDIV     R4,R2,R1
   \       0x14   0xEBA4 0x1443      SUB      R4,R4,R3, LSL #+5
    386          
    387              /* Calculate the baud rate based on the temporary SBR values and BRFA */
    388              tempBaud = (srcClock_Hz * 2 / ((sbr * 32 + brfa)));
   \       0x18   0x015D             LSLS     R5,R3,#+5
   \       0x1A   0xFA15 0xF584      UXTAH    R5,R5,R4
   \       0x1E   0xFBB2 0xF2F5      UDIV     R2,R2,R5
    389              baudDiff = (tempBaud > baudRate_Bps) ? (tempBaud - baudRate_Bps) : (baudRate_Bps - tempBaud);
   \       0x22   0x4291             CMP      R1,R2
    390          #else
    391              /* Calculate the baud rate based on the temporary SBR values */
    392              baudDiff = (srcClock_Hz / (sbr * 16)) - baudRate_Bps;
    393          
    394              /* Select the better value between sbr and (sbr + 1) */
    395              if (baudDiff > (baudRate_Bps - (srcClock_Hz / (16 * (sbr + 1)))))
    396              {
    397                  baudDiff = baudRate_Bps - (srcClock_Hz / (16 * (sbr + 1)));
    398                  sbr++;
    399              }
    400          #endif
    401          
    402              /* next, check to see if actual baud rate is within 3% of desired baud rate
    403               * based on the calculate SBR value */
    404              if (baudDiff < ((baudRate_Bps / 100) * 3))
   \       0x24   0x.... 0x....      LDR.W    R7,??DataTable14_3  ;; 0xa3d70a3e
   \       0x28   0xBF34             ITE      CC 
   \       0x2A   0x1A52             SUBCC    R2,R2,R1
   \       0x2C   0x1A8A             SUBCS    R2,R1,R2
   \       0x2E   0xFBA1 0x7607      UMULL    R7,R6,R1,R7
   \       0x32   0x09B1             LSRS     R1,R6,#+6
   \       0x34   0xEB01 0x0141      ADD      R1,R1,R1, LSL #+1
   \       0x38   0x428A             CMP      R2,R1
   \       0x3A   0xD216             BCS.N    ??UART_SetBaudRate_1
    405              {
    406                  /* Store C2 before disable Tx and Rx */
    407                  oldCtrl = base->C2;
   \       0x3C   0x78C2             LDRB     R2,[R0, #+3]
    408          
    409                  /* Disable UART TX RX before setting. */
    410                  base->C2 &= ~(UART_C2_TE_MASK | UART_C2_RE_MASK);
   \       0x3E   0x78C1             LDRB     R1,[R0, #+3]
   \       0x40   0xF001 0x01F3      AND      R1,R1,#0xF3
   \       0x44   0x70C1             STRB     R1,[R0, #+3]
    411          
    412                  /* Write the sbr value to the BDH and BDL registers*/
    413                  base->BDH = (base->BDH & ~UART_BDH_SBR_MASK) | (uint8_t)(sbr >> 8);
    414                  base->BDL = (uint8_t)sbr;
    415          
    416          #if defined(FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT) && FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT
    417                  /* Write the brfa value to the register*/
    418                  base->C4 = (base->C4 & ~UART_C4_BRFA_MASK) | (brfa & UART_C4_BRFA_MASK);
   \       0x46   0xF004 0x041F      AND      R4,R4,#0x1F
   \       0x4A   0x7805             LDRB     R5,[R0, #+0]
   \       0x4C   0xF005 0x05E0      AND      R5,R5,#0xE0
   \       0x50   0xEA45 0x2523      ORR      R5,R5,R3, ASR #+8
   \       0x54   0x7005             STRB     R5,[R0, #+0]
   \       0x56   0x7043             STRB     R3,[R0, #+1]
   \       0x58   0x7A83             LDRB     R3,[R0, #+10]
   \       0x5A   0xF003 0x03E0      AND      R3,R3,#0xE0
   \       0x5E   0x431C             ORRS     R4,R4,R3
   \       0x60   0x7284             STRB     R4,[R0, #+10]
    419          #endif
    420                  /* Restore C2. */
    421                  base->C2 = oldCtrl;
   \       0x62   0x70C2             STRB     R2,[R0, #+3]
    422          
    423                  return kStatus_Success;
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0xBCF0             POP      {R4-R7}
   \       0x68   0x4770             BX       LR
    424              }
    425              else
    426              {
    427                  /* Unacceptable baud rate difference of more than 3%*/
    428                  return kStatus_UART_BaudrateNotSupport;
   \                     ??UART_SetBaudRate_1: (+1)
   \       0x6A   0xBCF0             POP      {R4-R7}
   \       0x6C   0xF240 0x30F5      MOVW     R0,#+1013
   \       0x70   0x4770             BX       LR               ;; return
    429              }
    430          }
    431          

   \                                 In section .text, align 2, keep-with-next
    432          void UART_EnableInterrupts(UART_Type *base, uint32_t mask)
    433          {
    434              mask &= kUART_AllInterruptsEnable;
   \                     UART_EnableInterrupts: (+1)
   \        0x0   0x.... 0x....      LDR.W    R2,??DataTable14_5  ;; 0x70ff0c0
    435          
    436              /* The interrupt mask is combined by control bits from several register: ((CFIFO<<24) | (C3<<16) | (C2<<8) |(BDH))
    437               */
    438              base->BDH |= mask;
   \        0x4   0x7803             LDRB     R3,[R0, #+0]
   \        0x6   0x4011             ANDS     R1,R2,R1
   \        0x8   0x430B             ORRS     R3,R1,R3
   \        0xA   0x7003             STRB     R3,[R0, #+0]
    439              base->C2 |= (mask >> 8);
   \        0xC   0xF890 0xC003      LDRB     R12,[R0, #+3]
   \       0x10   0xEA4C 0x2C11      ORR      R12,R12,R1, LSR #+8
   \       0x14   0xF880 0xC003      STRB     R12,[R0, #+3]
    440              base->C3 |= (mask >> 16);
   \       0x18   0x7983             LDRB     R3,[R0, #+6]
   \       0x1A   0xEA43 0x4311      ORR      R3,R3,R1, LSR #+16
   \       0x1E   0x7183             STRB     R3,[R0, #+6]
    441          
    442          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    443              base->CFIFO |= (mask >> 24);
   \       0x20   0x7C43             LDRB     R3,[R0, #+17]
   \       0x22   0xEA43 0x6111      ORR      R1,R3,R1, LSR #+24
   \       0x26   0x7441             STRB     R1,[R0, #+17]
    444          #endif
    445          }
   \       0x28   0x4770             BX       LR               ;; return
    446          

   \                                 In section .text, align 2, keep-with-next
    447          void UART_DisableInterrupts(UART_Type *base, uint32_t mask)
    448          {
    449              mask &= kUART_AllInterruptsEnable;
   \                     UART_DisableInterrupts: (+1)
   \        0x0   0x.... 0x....      LDR.W    R2,??DataTable14_5  ;; 0x70ff0c0
    450          
    451              /* The interrupt mask is combined by control bits from several register: ((CFIFO<<24) | (C3<<16) | (C2<<8) |(BDH))
    452               */
    453              base->BDH &= ~mask;
   \        0x4   0x7803             LDRB     R3,[R0, #+0]
   \        0x6   0x4011             ANDS     R1,R2,R1
   \        0x8   0x438B             BICS     R3,R3,R1
   \        0xA   0x7003             STRB     R3,[R0, #+0]
    454              base->C2 &= ~(mask >> 8);
   \        0xC   0xF890 0xC003      LDRB     R12,[R0, #+3]
   \       0x10   0xEA2C 0x2C11      BIC      R12,R12,R1, LSR #+8
   \       0x14   0xF880 0xC003      STRB     R12,[R0, #+3]
    455              base->C3 &= ~(mask >> 16);
   \       0x18   0x7983             LDRB     R3,[R0, #+6]
   \       0x1A   0xEA23 0x4311      BIC      R3,R3,R1, LSR #+16
   \       0x1E   0x7183             STRB     R3,[R0, #+6]
    456          
    457          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    458              base->CFIFO &= ~(mask >> 24);
   \       0x20   0x7C43             LDRB     R3,[R0, #+17]
   \       0x22   0xEA23 0x6111      BIC      R1,R3,R1, LSR #+24
   \       0x26   0x7441             STRB     R1,[R0, #+17]
    459          #endif
    460          }
   \       0x28   0x4770             BX       LR               ;; return
    461          

   \                                 In section .text, align 2, keep-with-next
    462          uint32_t UART_GetEnabledInterrupts(UART_Type *base)
    463          {
   \                     UART_GetEnabledInterrupts: (+1)
   \        0x0   0x4601             MOV      R1,R0
    464              uint32_t temp;
    465          
    466              temp = base->BDH | ((uint32_t)(base->C2) << 8) | ((uint32_t)(base->C3) << 16);
   \        0x2   0x7808             LDRB     R0,[R1, #+0]
   \        0x4   0x78CA             LDRB     R2,[R1, #+3]
   \        0x6   0x798B             LDRB     R3,[R1, #+6]
    467          
    468          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    469              temp |= ((uint32_t)(base->CFIFO) << 24);
   \        0x8   0x7C49             LDRB     R1,[R1, #+17]
    470          #endif
    471          
    472              return temp & kUART_AllInterruptsEnable;
   \        0xA   0xEA40 0x2002      ORR      R0,R0,R2, LSL #+8
   \        0xE   0xEA40 0x4003      ORR      R0,R0,R3, LSL #+16
   \       0x12   0xEA40 0x6001      ORR      R0,R0,R1, LSL #+24
   \       0x16   0x.... 0x....      LDR.W    R1,??DataTable14_5  ;; 0x70ff0c0
   \       0x1A   0x4008             ANDS     R0,R1,R0
   \       0x1C   0x4770             BX       LR               ;; return
    473          }
    474          

   \                                 In section .text, align 2, keep-with-next
    475          uint32_t UART_GetStatusFlags(UART_Type *base)
    476          {
   \                     UART_GetStatusFlags: (+1)
   \        0x0   0x4601             MOV      R1,R0
    477              uint32_t status_flag;
    478          
    479              status_flag = base->S1 | ((uint32_t)(base->S2) << 8);
   \        0x2   0x7908             LDRB     R0,[R1, #+4]
   \        0x4   0x794A             LDRB     R2,[R1, #+5]
    480          
    481          #if defined(FSL_FEATURE_UART_HAS_EXTENDED_DATA_REGISTER_FLAGS) && FSL_FEATURE_UART_HAS_EXTENDED_DATA_REGISTER_FLAGS
    482              status_flag |= ((uint32_t)(base->ED) << 16);
   \        0x6   0x7B0B             LDRB     R3,[R1, #+12]
    483          #endif
    484          
    485          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    486              status_flag |= ((uint32_t)(base->SFIFO) << 24);
   \        0x8   0x7C89             LDRB     R1,[R1, #+18]
    487          #endif
    488          
    489              return status_flag;
   \        0xA   0xEA40 0x2002      ORR      R0,R0,R2, LSL #+8
   \        0xE   0xEA40 0x4003      ORR      R0,R0,R3, LSL #+16
   \       0x12   0xEA40 0x6001      ORR      R0,R0,R1, LSL #+24
   \       0x16   0x4770             BX       LR               ;; return
    490          }
    491          

   \                                 In section .text, align 2, keep-with-next
    492          status_t UART_ClearStatusFlags(UART_Type *base, uint32_t mask)
    493          {
   \                     UART_ClearStatusFlags: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    494              uint8_t reg = base->S2;
    495              status_t status;
    496          
    497          #if defined(FSL_FEATURE_UART_HAS_LIN_BREAK_DETECT) && FSL_FEATURE_UART_HAS_LIN_BREAK_DETECT
    498              reg &= ~(UART_S2_RXEDGIF_MASK | UART_S2_LBKDIF_MASK);
    499          #else
    500              reg &= ~UART_S2_RXEDGIF_MASK;
    501          #endif
    502          
    503              base->S2 = reg | (uint8_t)(mask >> 8);
   \        0x2   0x7942             LDRB     R2,[R0, #+5]
   \        0x4   0xF002 0x023F      AND      R2,R2,#0x3F
   \        0x8   0xEA42 0x2211      ORR      R2,R2,R1, LSR #+8
   \        0xC   0x7142             STRB     R2,[R0, #+5]
   \        0xE   0x460C             MOV      R4,R1
    504          
    505          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    506              base->SFIFO = (uint8_t)(mask >> 24);
   \       0x10   0x0E22             LSRS     R2,R4,#+24
   \       0x12   0x7482             STRB     R2,[R0, #+18]
    507          #endif
    508          
    509              if (mask & (kUART_IdleLineFlag | kUART_NoiseErrorFlag | kUART_FramingErrorFlag | kUART_ParityErrorFlag))
   \       0x14   0xF014 0x0F17      TST      R4,#0x17
   \       0x18   0xBF1C             ITT      NE 
   \       0x1A   0x7901             LDRBNE   R1,[R0, #+4]
   \       0x1C   0x79C2             LDRBNE   R2,[R0, #+7]
    510              {
    511                  /* Read base->D to clear the flags. */
    512                  (void)base->S1;
    513                  (void)base->D;
    514              }
    515          
    516              if (mask & kUART_RxOverrunFlag)
   \       0x1E   0x0721             LSLS     R1,R4,#+28
   \       0x20   0xD505             BPL.N    ??UART_ClearStatusFlags_0
    517              {
    518                  /* Read base->D to clear the flags and Flush all data in FIFO. */
    519                  (void)base->S1;
   \       0x22   0x7902             LDRB     R2,[R0, #+4]
    520                  (void)base->D;
   \       0x24   0x79C1             LDRB     R1,[R0, #+7]
    521          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    522                  /* Flush FIFO date, otherwise FIFO pointer will be in unknown state. */
    523                  base->CFIFO |= UART_CFIFO_RXFLUSH_MASK;
   \       0x26   0x7C42             LDRB     R2,[R0, #+17]
   \       0x28   0xF042 0x0240      ORR      R2,R2,#0x40
   \       0x2C   0x7442             STRB     R2,[R0, #+17]
    524          #endif
    525              }
    526          
    527              /* If some flags still pending. */
    528              if (mask & UART_GetStatusFlags(base))
   \                     ??UART_ClearStatusFlags_0: (+1)
   \       0x2E   0x.... 0x....      BL       UART_GetStatusFlags
   \       0x32   0x4204             TST      R4,R0
   \       0x34   0xD002             BEQ.N    ??UART_ClearStatusFlags_1
    529              {
    530                  /* Some flags can only clear or set by the hardware itself, these flags are: kUART_TxDataRegEmptyFlag,
    531                  kUART_TransmissionCompleteFlag, kUART_RxDataRegFullFlag, kUART_RxActiveFlag, kUART_NoiseErrorInRxDataRegFlag,
    532                  kUART_ParityErrorInRxDataRegFlag, kUART_TxFifoEmptyFlag, kUART_RxFifoEmptyFlag. */
    533                  status = kStatus_UART_FlagCannotClearManually;
   \       0x36   0xF240 0x30EE      MOVW     R0,#+1006
   \       0x3A   0xBD10             POP      {R4,PC}
    534              }
    535              else
    536              {
    537                  status = kStatus_Success;
   \                     ??UART_ClearStatusFlags_1: (+1)
   \       0x3C   0x2000             MOVS     R0,#+0
    538              }
    539          
    540              return status;
   \       0x3E   0xBD10             POP      {R4,PC}          ;; return
    541          }
    542          

   \                                 In section .text, align 2, keep-with-next
    543          void UART_WriteBlocking(UART_Type *base, const uint8_t *data, size_t length)
    544          {
   \                     UART_WriteBlocking: (+1)
   \        0x0   0xB14A             CBZ.N    R2,??UART_WriteBlocking_0
   \                     ??UART_WriteBlocking_1: (+1)
   \        0x2   0x1E52             SUBS     R2,R2,#+1
    545              /* This API can only ensure that the data is written into the data buffer but can't
    546              ensure all data in the data buffer are sent into the transmit shift buffer. */
    547              while (length--)
    548              {
    549                  while (!(base->S1 & UART_S1_TDRE_MASK))
   \                     ??UART_WriteBlocking_2: (+1)
   \        0x4   0x7903             LDRB     R3,[R0, #+4]
   \        0x6   0xEA5F 0x6C03      LSLS     R12,R3,#+24
   \        0xA   0xD5FB             BPL.N    ??UART_WriteBlocking_2
    550                  {
    551                  }
    552                  base->D = *(data++);
   \        0xC   0xF811 0x3B01      LDRB     R3,[R1], #+1
   \       0x10   0x71C3             STRB     R3,[R0, #+7]
    553              }
   \       0x12   0x2A00             CMP      R2,#+0
   \       0x14   0xD1F5             BNE.N    ??UART_WriteBlocking_1
    554          }
   \                     ??UART_WriteBlocking_0: (+1)
   \       0x16   0x4770             BX       LR               ;; return
    555          
    556          static void UART_WriteNonBlocking(UART_Type *base, const uint8_t *data, size_t length)
    557          {
    558              assert(data);
    559          
    560              size_t i;
    561          
    562              /* The Non Blocking write data API assume user have ensured there is enough space in
    563              peripheral to write. */
    564              for (i = 0; i < length; i++)
    565              {
    566                  base->D = data[i];
    567              }
    568          }
    569          

   \                                 In section .text, align 2, keep-with-next
    570          status_t UART_ReadBlocking(UART_Type *base, uint8_t *data, size_t length)
    571          {
   \                     UART_ReadBlocking: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
   \        0x2   0x4603             MOV      R3,R0
    572              assert(data);
   \        0x4   0xB31A             CBZ.N    R2,??UART_ReadBlocking_0
   \                     ??UART_ReadBlocking_1: (+1)
   \        0x6   0x1E52             SUBS     R2,R2,#+1
    573          
    574              uint32_t statusFlag;
    575          
    576              while (length--)
    577              {
    578          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    579                  while (!base->RCFIFO)
   \                     ??UART_ReadBlocking_2: (+1)
   \        0x8   0x7D98             LDRB     R0,[R3, #+22]
   \        0xA   0xB9D8             CBNZ.N   R0,??UART_ReadBlocking_3
    580          #else
    581                  while (!(base->S1 & UART_S1_RDRF_MASK))
    582          #endif
    583                  {
    584                      statusFlag = UART_GetStatusFlags(base);
   \        0xC   0x7918             LDRB     R0,[R3, #+4]
   \        0xE   0x795C             LDRB     R4,[R3, #+5]
   \       0x10   0x7B1D             LDRB     R5,[R3, #+12]
   \       0x12   0x7C9C             LDRB     R4,[R3, #+18]
    585          
    586                      if (statusFlag & kUART_RxOverrunFlag)
   \       0x14   0x0705             LSLS     R5,R0,#+28
   \       0x16   0xD409             BMI.N    ??UART_ReadBlocking_4
    587                      {
    588                          return kStatus_UART_RxHardwareOverrun;
    589                      }
    590          
    591                      if (statusFlag & kUART_NoiseErrorFlag)
   \       0x18   0x0744             LSLS     R4,R0,#+29
   \       0x1A   0xD40B             BMI.N    ??UART_ReadBlocking_5
    592                      {
    593                          return kStatus_UART_NoiseError;
    594                      }
    595          
    596                      if (statusFlag & kUART_FramingErrorFlag)
   \       0x1C   0x0785             LSLS     R5,R0,#+30
   \       0x1E   0xD40D             BMI.N    ??UART_ReadBlocking_6
    597                      {
    598                          return kStatus_UART_FramingError;
    599                      }
    600          
    601                      if (statusFlag & kUART_ParityErrorFlag)
   \       0x20   0x07C0             LSLS     R0,R0,#+31
   \       0x22   0xD5F1             BPL.N    ??UART_ReadBlocking_2
    602                      {
    603                          return kStatus_UART_ParityError;
   \       0x24   0xBC30             POP      {R4,R5}
   \       0x26   0xF44F 0x707D      MOV      R0,#+1012
   \       0x2A   0x4770             BX       LR
    604                      }
   \                     ??UART_ReadBlocking_4: (+1)
   \       0x2C   0xBC30             POP      {R4,R5}
   \       0x2E   0xF240 0x30F1      MOVW     R0,#+1009
   \       0x32   0x4770             BX       LR
   \                     ??UART_ReadBlocking_5: (+1)
   \       0x34   0xBC30             POP      {R4,R5}
   \       0x36   0xF240 0x30F2      MOVW     R0,#+1010
   \       0x3A   0x4770             BX       LR
   \                     ??UART_ReadBlocking_6: (+1)
   \       0x3C   0xBC30             POP      {R4,R5}
   \       0x3E   0xF240 0x30F3      MOVW     R0,#+1011
   \       0x42   0x4770             BX       LR
    605                  }
    606                  *(data++) = base->D;
   \                     ??UART_ReadBlocking_3: (+1)
   \       0x44   0x79D8             LDRB     R0,[R3, #+7]
   \       0x46   0xF801 0x0B01      STRB     R0,[R1], #+1
    607              }
   \       0x4A   0x2A00             CMP      R2,#+0
   \       0x4C   0xD1DB             BNE.N    ??UART_ReadBlocking_1
    608          
    609              return kStatus_Success;
   \                     ??UART_ReadBlocking_0: (+1)
   \       0x4E   0xBC30             POP      {R4,R5}
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0x4770             BX       LR               ;; return
    610          }
    611          
    612          static void UART_ReadNonBlocking(UART_Type *base, uint8_t *data, size_t length)
    613          {
    614              assert(data);
    615          
    616              size_t i;
    617          
    618              /* The Non Blocking read data API assume user have ensured there is enough space in
    619              peripheral to write. */
    620              for (i = 0; i < length; i++)
    621              {
    622                  data[i] = base->D;
    623              }
    624          }
    625          

   \                                 In section .text, align 2, keep-with-next
    626          void UART_TransferCreateHandle(UART_Type *base,
    627                                         uart_handle_t *handle,
    628                                         uart_transfer_callback_t callback,
    629                                         void *userData)
    630          {
   \                     UART_TransferCreateHandle: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4616             MOV      R6,R2
   \        0x8   0x461F             MOV      R7,R3
    631              assert(handle);
    632          
    633              uint32_t instance;
    634          
    635              /* Zero the handle. */
    636              memset(handle, 0, sizeof(*handle));
   \        0xA   0x2130             MOVS     R1,#+48
   \        0xC   0x4620             MOV      R0,R4
   \        0xE   0x.... 0x....      BL       __aeabi_memclr4
    637          
    638              /* Set the TX/RX state. */
    639              handle->rxState = kUART_RxIdle;
   \       0x12   0xF104 0x002C      ADD      R0,R4,#+44
   \       0x16   0x2202             MOVS     R2,#+2
   \       0x18   0x7042             STRB     R2,[R0, #+1]
    640              handle->txState = kUART_TxIdle;
   \       0x1A   0x2100             MOVS     R1,#+0
   \       0x1C   0x7001             STRB     R1,[R0, #+0]
    641          
    642              /* Set the callback and user data. */
    643              handle->callback = callback;
   \       0x1E   0x6266             STR      R6,[R4, #+36]
    644              handle->userData = userData;
   \       0x20   0x62A7             STR      R7,[R4, #+40]
    645          
    646          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    647              /* Note:
    648                 Take care of the RX FIFO, RX interrupt request only assert when received bytes
    649                 equal or more than RX water mark, there is potential issue if RX water
    650                 mark larger than 1.
    651                 For example, if RX FIFO water mark is 2, upper layer needs 5 bytes and
    652                 5 bytes are received. the last byte will be saved in FIFO but not trigger
    653                 RX interrupt because the water mark is 2.
    654               */
    655              base->RWFIFO = 1U;
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0x7568             STRB     R0,[R5, #+21]
    656          #endif
    657          
    658              /* Get instance from peripheral base address. */
    659              instance = UART_GetInstance(base);
   \       0x26   0x4628             MOV      R0,R5
   \       0x28   0x.... 0x....      BL       UART_GetInstance
    660          
    661              /* Save the handle in global variables to support the double weak mechanism. */
    662              s_uartHandle[instance] = handle;
   \       0x2C   0x.... 0x....      LDR.W    R1,??DataTable14_6
    663          
    664              s_uartIsr = UART_TransferHandleIRQ;
   \       0x30   0x.... 0x....      ADR.W    R2,UART_TransferHandleIRQ
   \       0x34   0xF841 0x4020      STR      R4,[R1, R0, LSL #+2]
   \       0x38   0x60CA             STR      R2,[R1, #+12]
    665              /* Enable interrupt in NVIC. */
    666              EnableIRQ(s_uartIRQ[instance]);
   \       0x3A   0xF06F 0x027F      MVN      R2,#+127
   \       0x3E   0x.... 0x....      ADR.W    R1,s_uartIRQ
   \       0x42   0x5609             LDRSB    R1,[R1, R0]
   \       0x44   0x4291             CMP      R1,R2
   \       0x46   0xD008             BEQ.N    ??UART_TransferCreateHandle_0
   \       0x48   0x2301             MOVS     R3,#+1
   \       0x4A   0xF001 0x001F      AND      R0,R1,#0x1F
   \       0x4E   0x.... 0x....      LDR.W    R2,??DataTable14_7  ;; 0xe000e100
   \       0x52   0x4083             LSLS     R3,R3,R0
   \       0x54   0x0949             LSRS     R1,R1,#+5
   \       0x56   0xF842 0x3021      STR      R3,[R2, R1, LSL #+2]
    667          }
   \                     ??UART_TransferCreateHandle_0: (+1)
   \       0x5A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    668          

   \                                 In section .text, align 2, keep-with-next
    669          void UART_TransferStartRingBuffer(UART_Type *base, uart_handle_t *handle, uint8_t *ringBuffer, size_t ringBufferSize)
    670          {
   \                     UART_TransferStartRingBuffer: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    671              assert(handle);
    672              assert(ringBuffer);
    673          
    674              /* Setup the ringbuffer address */
    675              handle->rxRingBuffer = ringBuffer;
   \        0x4   0x618A             STR      R2,[R1, #+24]
    676              handle->rxRingBufferSize = ringBufferSize;
   \        0x6   0x61CB             STR      R3,[R1, #+28]
    677              handle->rxRingBufferHead = 0U;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x8408             STRH     R0,[R1, #+32]
    678              handle->rxRingBufferTail = 0U;
   \        0xC   0x8448             STRH     R0,[R1, #+34]
    679          
    680              /* Enable the interrupt to accept the data when user need the ring buffer. */
    681              UART_EnableInterrupts(
    682                  base, kUART_RxDataRegFullInterruptEnable | kUART_RxOverrunInterruptEnable | kUART_FramingErrorInterruptEnable);
   \        0xE   0xF44F 0x2122      MOV      R1,#+663552
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0x.... 0x....      BL       UART_EnableInterrupts
    683              /* Enable parity error interrupt when parity mode is enable*/
    684              if (UART_C1_PE_MASK & base->C1)
   \       0x18   0x78A0             LDRB     R0,[R4, #+2]
   \       0x1A   0x0781             LSLS     R1,R0,#+30
   \       0x1C   0xD505             BPL.N    ??UART_TransferStartRingBuffer_0
    685              {
    686                  UART_EnableInterrupts(base, kUART_ParityErrorInterruptEnable);
   \       0x1E   0x4620             MOV      R0,R4
   \       0x20   0xE8BD 0x4010      POP      {R4,LR}
   \       0x24   0xF44F 0x3180      MOV      R1,#+65536
   \       0x28   0x....             B.N      UART_EnableInterrupts
    687              }
    688          }
   \                     ??UART_TransferStartRingBuffer_0: (+1)
   \       0x2A   0xBD10             POP      {R4,PC}          ;; return
    689          

   \                                 In section .text, align 2, keep-with-next
    690          void UART_TransferStopRingBuffer(UART_Type *base, uart_handle_t *handle)
    691          {
    692              assert(handle);
    693          
    694              if (handle->rxState == kUART_RxIdle)
   \                     UART_TransferStopRingBuffer: (+1)
   \        0x0   0xF891 0x202D      LDRB     R2,[R1, #+45]
   \        0x4   0x2A02             CMP      R2,#+2
   \        0x6   0xD118             BNE.N    ??UART_TransferStopRingBuffer_0
    695              {
    696                  UART_DisableInterrupts(base, kUART_RxDataRegFullInterruptEnable | kUART_RxOverrunInterruptEnable |
    697                                                   kUART_FramingErrorInterruptEnable);
   \        0x8   0x7803             LDRB     R3,[R0, #+0]
   \        0xA   0x7003             STRB     R3,[R0, #+0]
   \        0xC   0x78C2             LDRB     R2,[R0, #+3]
   \        0xE   0xF002 0x02DF      AND      R2,R2,#0xDF
   \       0x12   0x70C2             STRB     R2,[R0, #+3]
   \       0x14   0x7982             LDRB     R2,[R0, #+6]
   \       0x16   0xF002 0x02F5      AND      R2,R2,#0xF5
   \       0x1A   0x7182             STRB     R2,[R0, #+6]
   \       0x1C   0x7C42             LDRB     R2,[R0, #+17]
   \       0x1E   0x7442             STRB     R2,[R0, #+17]
    698                  /* Disable parity error interrupt when parity mode is enable*/
    699                  if (UART_C1_PE_MASK & base->C1)
   \       0x20   0x7883             LDRB     R3,[R0, #+2]
   \       0x22   0x079A             LSLS     R2,R3,#+30
   \       0x24   0xD509             BPL.N    ??UART_TransferStopRingBuffer_0
    700                  {
    701                      UART_DisableInterrupts(base, kUART_ParityErrorInterruptEnable);
   \       0x26   0x7803             LDRB     R3,[R0, #+0]
   \       0x28   0x7003             STRB     R3,[R0, #+0]
   \       0x2A   0x78C2             LDRB     R2,[R0, #+3]
   \       0x2C   0x70C2             STRB     R2,[R0, #+3]
   \       0x2E   0x7983             LDRB     R3,[R0, #+6]
   \       0x30   0xF003 0x03FE      AND      R3,R3,#0xFE
   \       0x34   0x7183             STRB     R3,[R0, #+6]
   \       0x36   0x7C42             LDRB     R2,[R0, #+17]
   \       0x38   0x7442             STRB     R2,[R0, #+17]
    702                  }
    703              }
    704          
    705              handle->rxRingBuffer = NULL;
   \                     ??UART_TransferStopRingBuffer_0: (+1)
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x6188             STR      R0,[R1, #+24]
    706              handle->rxRingBufferSize = 0U;
   \       0x3E   0x61C8             STR      R0,[R1, #+28]
    707              handle->rxRingBufferHead = 0U;
   \       0x40   0x8408             STRH     R0,[R1, #+32]
    708              handle->rxRingBufferTail = 0U;
   \       0x42   0x8448             STRH     R0,[R1, #+34]
    709          }
   \       0x44   0x4770             BX       LR               ;; return
    710          

   \                                 In section .text, align 2, keep-with-next
    711          status_t UART_TransferSendNonBlocking(UART_Type *base, uart_handle_t *handle, uart_transfer_t *xfer)
    712          {
    713              assert(handle);
    714              assert(xfer);
    715              assert(xfer->dataSize);
    716              assert(xfer->data);
    717          
    718              status_t status;
    719          
    720              /* Return error if current TX busy. */
    721              if (kUART_TxBusy == handle->txState)
   \                     UART_TransferSendNonBlocking: (+1)
   \        0x0   0xF891 0x302C      LDRB     R3,[R1, #+44]
   \        0x4   0x2B01             CMP      R3,#+1
   \        0x6   0xD102             BNE.N    ??UART_TransferSendNonBlocking_0
    722              {
    723                  status = kStatus_UART_TxBusy;
   \        0x8   0xF44F 0x707A      MOV      R0,#+1000
   \        0xC   0x4770             BX       LR
    724              }
    725              else
    726              {
    727                  handle->txData = xfer->data;
   \                     ??UART_TransferSendNonBlocking_0: (+1)
   \        0xE   0x6813             LDR      R3,[R2, #+0]
   \       0x10   0x600B             STR      R3,[R1, #+0]
    728                  handle->txDataSize = xfer->dataSize;
    729                  handle->txDataSizeAll = xfer->dataSize;
    730                  handle->txState = kUART_TxBusy;
   \       0x12   0x2301             MOVS     R3,#+1
   \       0x14   0xF8D2 0xC004      LDR      R12,[R2, #+4]
   \       0x18   0xF8C1 0xC004      STR      R12,[R1, #+4]
   \       0x1C   0x6852             LDR      R2,[R2, #+4]
   \       0x1E   0x608A             STR      R2,[R1, #+8]
   \       0x20   0xF881 0x302C      STRB     R3,[R1, #+44]
    731          
    732                  /* Enable transmiter interrupt. */
    733                  UART_EnableInterrupts(base, kUART_TxDataRegEmptyInterruptEnable);
   \       0x24   0x7801             LDRB     R1,[R0, #+0]
   \       0x26   0x7001             STRB     R1,[R0, #+0]
   \       0x28   0x78C2             LDRB     R2,[R0, #+3]
   \       0x2A   0xF042 0x0280      ORR      R2,R2,#0x80
   \       0x2E   0x70C2             STRB     R2,[R0, #+3]
   \       0x30   0x7981             LDRB     R1,[R0, #+6]
   \       0x32   0x7181             STRB     R1,[R0, #+6]
   \       0x34   0x7C42             LDRB     R2,[R0, #+17]
   \       0x36   0x7442             STRB     R2,[R0, #+17]
    734          
    735                  status = kStatus_Success;
   \       0x38   0x2000             MOVS     R0,#+0
    736              }
    737          
    738              return status;
   \       0x3A   0x4770             BX       LR               ;; return
    739          }
    740          

   \                                 In section .text, align 2, keep-with-next
    741          void UART_TransferAbortSend(UART_Type *base, uart_handle_t *handle)
    742          {
    743              assert(handle);
    744          
    745              UART_DisableInterrupts(base, kUART_TxDataRegEmptyInterruptEnable | kUART_TransmissionCompleteInterruptEnable);
   \                     UART_TransferAbortSend: (+1)
   \        0x0   0x7802             LDRB     R2,[R0, #+0]
   \        0x2   0x7002             STRB     R2,[R0, #+0]
   \        0x4   0x78C3             LDRB     R3,[R0, #+3]
   \        0x6   0xF003 0x033F      AND      R3,R3,#0x3F
   \        0xA   0x70C3             STRB     R3,[R0, #+3]
   \        0xC   0x7982             LDRB     R2,[R0, #+6]
   \        0xE   0x7182             STRB     R2,[R0, #+6]
   \       0x10   0x7C43             LDRB     R3,[R0, #+17]
   \       0x12   0x7443             STRB     R3,[R0, #+17]
    746          
    747              handle->txDataSize = 0;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x6048             STR      R0,[R1, #+4]
    748              handle->txState = kUART_TxIdle;
   \       0x18   0xF881 0x002C      STRB     R0,[R1, #+44]
    749          }
   \       0x1C   0x4770             BX       LR               ;; return
    750          

   \                                 In section .text, align 2, keep-with-next
    751          status_t UART_TransferGetSendCount(UART_Type *base, uart_handle_t *handle, uint32_t *count)
    752          {
    753              assert(handle);
    754              assert(count);
    755          
    756              if (kUART_TxIdle == handle->txState)
   \                     UART_TransferGetSendCount: (+1)
   \        0x0   0xF891 0x002C      LDRB     R0,[R1, #+44]
   \        0x4   0xB908             CBNZ.N   R0,??UART_TransferGetSendCount_0
    757              {
    758                  return kStatus_NoTransferInProgress;
   \        0x6   0x2006             MOVS     R0,#+6
   \        0x8   0x4770             BX       LR
    759              }
    760          
    761              *count = handle->txDataSizeAll - handle->txDataSize;
   \                     ??UART_TransferGetSendCount_0: (+1)
   \        0xA   0x688B             LDR      R3,[R1, #+8]
   \        0xC   0x6848             LDR      R0,[R1, #+4]
   \        0xE   0x....             B.N      ?Subroutine0
    762          
    763              return kStatus_Success;
    764          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x1A1B             SUBS     R3,R3,R0
   \        0x2   0x6013             STR      R3,[R2, #+0]
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x4770             BX       LR               ;; return
    765          

   \                                 In section .text, align 2, keep-with-next
    766          status_t UART_TransferReceiveNonBlocking(UART_Type *base,
    767                                                   uart_handle_t *handle,
    768                                                   uart_transfer_t *xfer,
    769                                                   size_t *receivedBytes)
    770          {
   \                     UART_TransferReceiveNonBlocking: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4698             MOV      R8,R3
    771              assert(handle);
    772              assert(xfer);
    773              assert(xfer->data);
    774              assert(xfer->dataSize);
    775          
    776              uint32_t i;
    777              status_t status;
    778              /* How many bytes to copy from ring buffer to user memory. */
    779              size_t bytesToCopy = 0U;
    780              /* How many bytes to receive. */
    781              size_t bytesToReceive;
    782              /* How many bytes currently have received. */
    783              size_t bytesCurrentReceived;
    784          
    785              /* How to get data:
    786                 1. If RX ring buffer is not enabled, then save xfer->data and xfer->dataSize
    787                    to uart handle, enable interrupt to store received data to xfer->data. When
    788                    all data received, trigger callback.
    789                 2. If RX ring buffer is enabled and not empty, get data from ring buffer first.
    790                    If there are enough data in ring buffer, copy them to xfer->data and return.
    791                    If there are not enough data in ring buffer, copy all of them to xfer->data,
    792                    save the xfer->data remained empty space to uart handle, receive data
    793                    to this empty space and trigger callback when finished. */
    794          
    795              if (kUART_RxBusy == handle->rxState)
   \        0x8   0xF895 0x102D      LDRB     R1,[R5, #+45]
   \        0xC   0x2903             CMP      R1,#+3
   \        0xE   0xBF08             IT       EQ 
   \       0x10   0xF240 0x30E9      MOVWEQ   R0,#+1001
    796              {
    797                  status = kStatus_UART_RxBusy;
   \       0x14   0xD063             BEQ.N    ??UART_TransferReceiveNonBlocking_0
    798              }
    799              else
    800              {
    801                  bytesToReceive = xfer->dataSize;
    802                  bytesCurrentReceived = 0U;
   \       0x16   0x4606             MOV      R6,R0
   \       0x18   0x4617             MOV      R7,R2
    803          
    804                  /* If RX ring buffer is used. */
    805                  if (handle->rxRingBuffer)
   \       0x1A   0x69A8             LDR      R0,[R5, #+24]
   \       0x1C   0x687C             LDR      R4,[R7, #+4]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xF04F 0x0900      MOV      R9,#+0
   \       0x24   0xD041             BEQ.N    ??UART_TransferReceiveNonBlocking_1
    806                  {
    807                      /* Disable UART RX IRQ, protect ring buffer. */
    808                      UART_DisableInterrupts(base, kUART_RxDataRegFullInterruptEnable);
   \       0x26   0x7831             LDRB     R1,[R6, #+0]
   \       0x28   0x7031             STRB     R1,[R6, #+0]
   \       0x2A   0x78F0             LDRB     R0,[R6, #+3]
   \       0x2C   0xF000 0x00DF      AND      R0,R0,#0xDF
   \       0x30   0x70F0             STRB     R0,[R6, #+3]
   \       0x32   0x79B0             LDRB     R0,[R6, #+6]
   \       0x34   0x71B0             STRB     R0,[R6, #+6]
    809          
    810                      /* How many bytes in RX ring buffer currently. */
    811                      bytesToCopy = UART_TransferGetRxRingBufferLength(handle);
   \       0x36   0x4628             MOV      R0,R5
   \       0x38   0x7C71             LDRB     R1,[R6, #+17]
   \       0x3A   0x7471             STRB     R1,[R6, #+17]
   \       0x3C   0x.... 0x....      BL       UART_TransferGetRxRingBufferLength
    812          
    813                      if (bytesToCopy)
   \       0x40   0xB1D8             CBZ.N    R0,??UART_TransferReceiveNonBlocking_2
    814                      {
    815                          bytesToCopy = MIN(bytesToReceive, bytesToCopy);
   \       0x42   0x4284             CMP      R4,R0
   \       0x44   0xBF28             IT       CS 
   \       0x46   0x1A24             SUBCS    R4,R4,R0
   \       0x48   0xD202             BCS.N    ??UART_TransferReceiveNonBlocking_3
   \       0x4A   0x0020             MOVS     R0,R4
    816          
    817                          bytesToReceive -= bytesToCopy;
   \       0x4C   0x464C             MOV      R4,R9
    818          
    819                          /* Copy data from ring buffer to user memory. */
    820                          for (i = 0U; i < bytesToCopy; i++)
   \       0x4E   0xD01D             BEQ.N    ??UART_TransferReceiveNonBlocking_4
    821                          {
    822                              xfer->data[bytesCurrentReceived++] = handle->rxRingBuffer[handle->rxRingBufferTail];
   \                     ??UART_TransferReceiveNonBlocking_3: (+1)
   \       0x50   0x69A9             LDR      R1,[R5, #+24]
   \       0x52   0x8C6A             LDRH     R2,[R5, #+34]
   \       0x54   0x5C8B             LDRB     R3,[R1, R2]
   \       0x56   0x6839             LDR      R1,[R7, #+0]
   \       0x58   0xF801 0x3009      STRB     R3,[R1, R9]
   \       0x5C   0xF109 0x0901      ADD      R9,R9,#+1
    823          
    824                              /* Wrap to 0. Not use modulo (%) because it might be large and slow. */
    825                              if (handle->rxRingBufferTail + 1U == handle->rxRingBufferSize)
   \       0x60   0x8C6A             LDRH     R2,[R5, #+34]
   \       0x62   0x69E9             LDR      R1,[R5, #+28]
   \       0x64   0x1C52             ADDS     R2,R2,#+1
   \       0x66   0x428A             CMP      R2,R1
   \       0x68   0xD102             BNE.N    ??UART_TransferReceiveNonBlocking_5
    826                              {
    827                                  handle->rxRingBufferTail = 0U;
   \       0x6A   0x2200             MOVS     R2,#+0
   \       0x6C   0x846A             STRH     R2,[R5, #+34]
   \       0x6E   0xE002             B.N      ??UART_TransferReceiveNonBlocking_6
    828                              }
    829                              else
    830                              {
    831                                  handle->rxRingBufferTail++;
   \                     ??UART_TransferReceiveNonBlocking_5: (+1)
   \       0x70   0x8C69             LDRH     R1,[R5, #+34]
   \       0x72   0x1C49             ADDS     R1,R1,#+1
   \       0x74   0x8469             STRH     R1,[R5, #+34]
    832                              }
    833                          }
   \                     ??UART_TransferReceiveNonBlocking_6: (+1)
   \       0x76   0x1E40             SUBS     R0,R0,#+1
   \       0x78   0xD1EA             BNE.N    ??UART_TransferReceiveNonBlocking_3
    834                      }
    835          
    836                      /* If ring buffer does not have enough data, still need to read more data. */
    837                      if (bytesToReceive)
   \                     ??UART_TransferReceiveNonBlocking_2: (+1)
   \       0x7A   0xB13C             CBZ.N    R4,??UART_TransferReceiveNonBlocking_4
    838                      {
    839                          /* No data in ring buffer, save the request to UART handle. */
    840                          handle->rxData = xfer->data + bytesCurrentReceived;
   \       0x7C   0x6838             LDR      R0,[R7, #+0]
   \       0x7E   0x4448             ADD      R0,R0,R9
   \       0x80   0x60E8             STR      R0,[R5, #+12]
    841                          handle->rxDataSize = bytesToReceive;
   \       0x82   0x612C             STR      R4,[R5, #+16]
    842                          handle->rxDataSizeAll = bytesToReceive;
   \       0x84   0x616C             STR      R4,[R5, #+20]
    843                          handle->rxState = kUART_RxBusy;
   \       0x86   0x2003             MOVS     R0,#+3
   \       0x88   0xF885 0x002D      STRB     R0,[R5, #+45]
    844                      }
    845          
    846                      /* Enable UART RX IRQ if previously enabled. */
    847                      UART_EnableInterrupts(base, kUART_RxDataRegFullInterruptEnable);
   \                     ??UART_TransferReceiveNonBlocking_4: (+1)
   \       0x8C   0xF44F 0x5100      MOV      R1,#+8192
   \       0x90   0x4630             MOV      R0,R6
   \       0x92   0x.... 0x....      BL       UART_EnableInterrupts
    848          
    849                      /* Call user callback since all data are received. */
    850                      if (0 == bytesToReceive)
   \       0x96   0xB9E4             CBNZ.N   R4,??UART_TransferReceiveNonBlocking_7
    851                      {
    852                          if (handle->callback)
   \       0x98   0x6A6C             LDR      R4,[R5, #+36]
   \       0x9A   0xB1D4             CBZ.N    R4,??UART_TransferReceiveNonBlocking_7
    853                          {
    854                              handle->callback(base, handle, kStatus_UART_RxIdle, handle->userData);
   \       0x9C   0x6AAB             LDR      R3,[R5, #+40]
   \       0x9E   0xF240 0x32EB      MOVW     R2,#+1003
   \       0xA2   0x4629             MOV      R1,R5
   \       0xA4   0x4630             MOV      R0,R6
   \       0xA6   0x47A0             BLX      R4
   \       0xA8   0xE013             B.N      ??UART_TransferReceiveNonBlocking_7
    855                          }
    856                      }
    857                  }
    858                  /* Ring buffer not used. */
    859                  else
    860                  {
    861                      handle->rxData = xfer->data + bytesCurrentReceived;
   \                     ??UART_TransferReceiveNonBlocking_1: (+1)
   \       0xAA   0x6838             LDR      R0,[R7, #+0]
   \       0xAC   0x60E8             STR      R0,[R5, #+12]
    862                      handle->rxDataSize = bytesToReceive;
   \       0xAE   0x612C             STR      R4,[R5, #+16]
    863                      handle->rxDataSizeAll = bytesToReceive;
   \       0xB0   0x616C             STR      R4,[R5, #+20]
    864                      handle->rxState = kUART_RxBusy;
   \       0xB2   0x2003             MOVS     R0,#+3
   \       0xB4   0xF885 0x002D      STRB     R0,[R5, #+45]
    865          
    866                      /* Enable RX/Rx overrun/framing error interrupt. */
    867                      UART_EnableInterrupts(base, kUART_RxDataRegFullInterruptEnable | kUART_RxOverrunInterruptEnable |
    868                                                      kUART_FramingErrorInterruptEnable);
   \       0xB8   0xF44F 0x2122      MOV      R1,#+663552
   \       0xBC   0x4630             MOV      R0,R6
   \       0xBE   0x.... 0x....      BL       UART_EnableInterrupts
    869                      /* Enable parity error interrupt when parity mode is enable*/
    870                      if (UART_C1_PE_MASK & base->C1)
   \       0xC2   0x78B0             LDRB     R0,[R6, #+2]
   \       0xC4   0x0781             LSLS     R1,R0,#+30
   \       0xC6   0xD504             BPL.N    ??UART_TransferReceiveNonBlocking_7
    871                      {
    872                          UART_EnableInterrupts(base, kUART_ParityErrorInterruptEnable);
   \       0xC8   0xF44F 0x3180      MOV      R1,#+65536
   \       0xCC   0x4630             MOV      R0,R6
   \       0xCE   0x.... 0x....      BL       UART_EnableInterrupts
    873                      }
    874                  }
    875          
    876                  /* Return the how many bytes have read. */
    877                  if (receivedBytes)
   \                     ??UART_TransferReceiveNonBlocking_7: (+1)
   \       0xD2   0xF1B8 0x0F00      CMP      R8,#+0
   \       0xD6   0xBF18             IT       NE 
   \       0xD8   0xF8C8 0x9000      STRNE    R9,[R8, #+0]
    878                  {
    879                      *receivedBytes = bytesCurrentReceived;
    880                  }
    881          
    882                  status = kStatus_Success;
   \       0xDC   0x2000             MOVS     R0,#+0
    883              }
    884          
    885              return status;
   \                     ??UART_TransferReceiveNonBlocking_0: (+1)
   \       0xDE   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    886          }
    887          

   \                                 In section .text, align 2, keep-with-next
    888          void UART_TransferAbortReceive(UART_Type *base, uart_handle_t *handle)
    889          {
    890              assert(handle);
    891          
    892              /* Only abort the receive to handle->rxData, the RX ring buffer is still working. */
    893              if (!handle->rxRingBuffer)
   \                     UART_TransferAbortReceive: (+1)
   \        0x0   0x698A             LDR      R2,[R1, #+24]
   \        0x2   0xB9C2             CBNZ.N   R2,??UART_TransferAbortReceive_0
    894              {
    895                  /* Disable RX interrupt. */
    896                  UART_DisableInterrupts(base, kUART_RxDataRegFullInterruptEnable | kUART_RxOverrunInterruptEnable |
    897                                                   kUART_FramingErrorInterruptEnable);
   \        0x4   0x7803             LDRB     R3,[R0, #+0]
   \        0x6   0x7003             STRB     R3,[R0, #+0]
   \        0x8   0x78C2             LDRB     R2,[R0, #+3]
   \        0xA   0xF002 0x02DF      AND      R2,R2,#0xDF
   \        0xE   0x70C2             STRB     R2,[R0, #+3]
   \       0x10   0x7982             LDRB     R2,[R0, #+6]
   \       0x12   0xF002 0x02F5      AND      R2,R2,#0xF5
   \       0x16   0x7182             STRB     R2,[R0, #+6]
   \       0x18   0x7C42             LDRB     R2,[R0, #+17]
   \       0x1A   0x7442             STRB     R2,[R0, #+17]
    898                  /* Disable parity error interrupt when parity mode is enable*/
    899                  if (UART_C1_PE_MASK & base->C1)
   \       0x1C   0x7883             LDRB     R3,[R0, #+2]
   \       0x1E   0x079A             LSLS     R2,R3,#+30
   \       0x20   0xD509             BPL.N    ??UART_TransferAbortReceive_0
    900                  {
    901                      UART_DisableInterrupts(base, kUART_ParityErrorInterruptEnable);
   \       0x22   0x7803             LDRB     R3,[R0, #+0]
   \       0x24   0x7003             STRB     R3,[R0, #+0]
   \       0x26   0x78C2             LDRB     R2,[R0, #+3]
   \       0x28   0x70C2             STRB     R2,[R0, #+3]
   \       0x2A   0x7983             LDRB     R3,[R0, #+6]
   \       0x2C   0xF003 0x03FE      AND      R3,R3,#0xFE
   \       0x30   0x7183             STRB     R3,[R0, #+6]
   \       0x32   0x7C42             LDRB     R2,[R0, #+17]
   \       0x34   0x7442             STRB     R2,[R0, #+17]
    902                  }
    903              }
    904          
    905              handle->rxDataSize = 0U;
   \                     ??UART_TransferAbortReceive_0: (+1)
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x6108             STR      R0,[R1, #+16]
    906              handle->rxState = kUART_RxIdle;
   \       0x3A   0x2202             MOVS     R2,#+2
   \       0x3C   0xF881 0x202D      STRB     R2,[R1, #+45]
    907          }
   \       0x40   0x4770             BX       LR               ;; return
    908          

   \                                 In section .text, align 2, keep-with-next
    909          status_t UART_TransferGetReceiveCount(UART_Type *base, uart_handle_t *handle, uint32_t *count)
    910          {
    911              assert(handle);
    912              assert(count);
    913          
    914              if (kUART_RxIdle == handle->rxState)
   \                     UART_TransferGetReceiveCount: (+1)
   \        0x0   0xF891 0x002D      LDRB     R0,[R1, #+45]
   \        0x4   0x2802             CMP      R0,#+2
   \        0x6   0xD101             BNE.N    ??UART_TransferGetReceiveCount_0
    915              {
    916                  return kStatus_NoTransferInProgress;
   \        0x8   0x2006             MOVS     R0,#+6
   \        0xA   0x4770             BX       LR
    917              }
    918          
    919              if (!count)
   \                     ??UART_TransferGetReceiveCount_0: (+1)
   \        0xC   0xB90A             CBNZ.N   R2,??UART_TransferGetReceiveCount_1
    920              {
    921                  return kStatus_InvalidArgument;
   \        0xE   0x2004             MOVS     R0,#+4
   \       0x10   0x4770             BX       LR
    922              }
    923          
    924              *count = handle->rxDataSizeAll - handle->rxDataSize;
   \                     ??UART_TransferGetReceiveCount_1: (+1)
   \       0x12   0x694B             LDR      R3,[R1, #+20]
   \       0x14   0x6908             LDR      R0,[R1, #+16]
   \       0x16                      REQUIRE ?Subroutine0
   \       0x16                      ;; // Fall through to label ?Subroutine0
    925          
    926              return kStatus_Success;
    927          }
    928          

   \                                 In section .text, align 4, keep-with-next
    929          void UART_TransferHandleIRQ(UART_Type *base, uart_handle_t *handle)
    930          {
   \                     UART_TransferHandleIRQ: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x460E             MOV      R6,R1
    931              assert(handle);
    932          
    933              uint8_t count;
    934              uint8_t tempCount;
    935          
    936              /* If RX framing error */
    937              if (UART_S1_FE_MASK & base->S1)
   \        0x8   0x7938             LDRB     R0,[R7, #+4]
   \        0xA   0x0781             LSLS     R1,R0,#+30
   \        0xC   0xD401             BMI.N    ??UART_TransferHandleIRQ_0
   \        0xE   0xE015             B.N      ??UART_TransferHandleIRQ_1
    938              {
    939                  /* Read base->D to clear framing error flag, otherwise the RX does not work. */
    940                  while (base->S1 & UART_S1_RDRF_MASK)
    941                  {
    942                      (void)base->D;
   \                     ??UART_TransferHandleIRQ_2: (+1)
   \       0x10   0x79F8             LDRB     R0,[R7, #+7]
    943                  }
   \                     ??UART_TransferHandleIRQ_0: (+1)
   \       0x12   0x7939             LDRB     R1,[R7, #+4]
   \       0x14   0x0688             LSLS     R0,R1,#+26
   \       0x16   0xD4FB             BMI.N    ??UART_TransferHandleIRQ_2
    944          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    945                  /* Flush FIFO date, otherwise FIFO pointer will be in unknown state. */
    946                  base->CFIFO |= UART_CFIFO_RXFLUSH_MASK;
   \       0x18   0x7C79             LDRB     R1,[R7, #+17]
   \       0x1A   0xF041 0x0140      ORR      R1,R1,#0x40
   \       0x1E   0x7479             STRB     R1,[R7, #+17]
    947          #endif
    948          
    949                  handle->rxState = kUART_RxFramingError;
   \       0x20   0x2004             MOVS     R0,#+4
   \       0x22   0xF106 0x012C      ADD      R1,R6,#+44
    950                  handle->rxDataSize = 0U;
   \       0x26   0x2200             MOVS     R2,#+0
   \       0x28   0x7048             STRB     R0,[R1, #+1]
   \       0x2A   0x6132             STR      R2,[R6, #+16]
    951                  /* Trigger callback. */
    952                  if (handle->callback)
   \       0x2C   0x6A74             LDR      R4,[R6, #+36]
   \       0x2E   0xB12C             CBZ.N    R4,??UART_TransferHandleIRQ_1
    953                  {
    954                      handle->callback(base, handle, kStatus_UART_FramingError, handle->userData);
   \       0x30   0x6AB3             LDR      R3,[R6, #+40]
   \       0x32   0xF240 0x32F3      MOVW     R2,#+1011
   \       0x36   0x4631             MOV      R1,R6
   \       0x38   0x4638             MOV      R0,R7
   \       0x3A   0x47A0             BLX      R4
    955                  }
    956              }
    957          
    958              /* If RX parity error */
    959              if (UART_S1_PF_MASK & base->S1)
   \                     ??UART_TransferHandleIRQ_1: (+1)
   \       0x3C   0x793B             LDRB     R3,[R7, #+4]
   \       0x3E   0x07D8             LSLS     R0,R3,#+31
   \       0x40   0xD401             BMI.N    ??UART_TransferHandleIRQ_3
   \       0x42   0xE015             B.N      ??UART_TransferHandleIRQ_4
    960              {
    961                  /* Read base->D to clear parity error flag, otherwise the RX does not work. */
    962                  while (base->S1 & UART_S1_RDRF_MASK)
    963                  {
    964                      (void)base->D;
   \                     ??UART_TransferHandleIRQ_5: (+1)
   \       0x44   0x79F9             LDRB     R1,[R7, #+7]
    965                  }
   \                     ??UART_TransferHandleIRQ_3: (+1)
   \       0x46   0x7938             LDRB     R0,[R7, #+4]
   \       0x48   0x0681             LSLS     R1,R0,#+26
   \       0x4A   0xD4FB             BMI.N    ??UART_TransferHandleIRQ_5
    966          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    967                  /* Flush FIFO date, otherwise FIFO pointer will be in unknown state. */
    968                  base->CFIFO |= UART_CFIFO_RXFLUSH_MASK;
   \       0x4C   0x7C78             LDRB     R0,[R7, #+17]
   \       0x4E   0xF040 0x0040      ORR      R0,R0,#0x40
   \       0x52   0x7478             STRB     R0,[R7, #+17]
    969          #endif
    970          
    971                  handle->rxState = kUART_RxParityError;
   \       0x54   0x2105             MOVS     R1,#+5
   \       0x56   0xF106 0x002C      ADD      R0,R6,#+44
    972                  handle->rxDataSize = 0U;
   \       0x5A   0x2200             MOVS     R2,#+0
   \       0x5C   0x7041             STRB     R1,[R0, #+1]
   \       0x5E   0x6132             STR      R2,[R6, #+16]
    973                  /* Trigger callback. */
    974                  if (handle->callback)
   \       0x60   0x6A74             LDR      R4,[R6, #+36]
   \       0x62   0xB12C             CBZ.N    R4,??UART_TransferHandleIRQ_4
    975                  {
    976                      handle->callback(base, handle, kStatus_UART_ParityError, handle->userData);
   \       0x64   0x6AB3             LDR      R3,[R6, #+40]
   \       0x66   0xF44F 0x727D      MOV      R2,#+1012
   \       0x6A   0x4631             MOV      R1,R6
   \       0x6C   0x4638             MOV      R0,R7
   \       0x6E   0x47A0             BLX      R4
    977                  }
    978              }
    979          
    980              /* If RX overrun. */
    981              if (UART_S1_OR_MASK & base->S1)
   \                     ??UART_TransferHandleIRQ_4: (+1)
   \       0x70   0x7938             LDRB     R0,[R7, #+4]
   \       0x72   0x0701             LSLS     R1,R0,#+28
   \       0x74   0xD401             BMI.N    ??UART_TransferHandleIRQ_6
   \       0x76   0xE00F             B.N      ??UART_TransferHandleIRQ_7
    982              {
    983                  /* Read base->D to clear overrun flag, otherwise the RX does not work. */
    984                  while (base->S1 & UART_S1_RDRF_MASK)
    985                  {
    986                      (void)base->D;
   \                     ??UART_TransferHandleIRQ_8: (+1)
   \       0x78   0x79F8             LDRB     R0,[R7, #+7]
    987                  }
   \                     ??UART_TransferHandleIRQ_6: (+1)
   \       0x7A   0x7939             LDRB     R1,[R7, #+4]
   \       0x7C   0x0688             LSLS     R0,R1,#+26
   \       0x7E   0xD4FB             BMI.N    ??UART_TransferHandleIRQ_8
    988          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    989                  /* Flush FIFO date, otherwise FIFO pointer will be in unknown state. */
    990                  base->CFIFO |= UART_CFIFO_RXFLUSH_MASK;
   \       0x80   0x7C79             LDRB     R1,[R7, #+17]
   \       0x82   0xF041 0x0140      ORR      R1,R1,#0x40
   \       0x86   0x7479             STRB     R1,[R7, #+17]
    991          #endif
    992                  /* Trigger callback. */
    993                  if (handle->callback)
   \       0x88   0x6A74             LDR      R4,[R6, #+36]
   \       0x8A   0xB12C             CBZ.N    R4,??UART_TransferHandleIRQ_7
    994                  {
    995                      handle->callback(base, handle, kStatus_UART_RxHardwareOverrun, handle->userData);
   \       0x8C   0x6AB3             LDR      R3,[R6, #+40]
   \       0x8E   0xF240 0x32F1      MOVW     R2,#+1009
   \       0x92   0x4631             MOV      R1,R6
   \       0x94   0x4638             MOV      R0,R7
   \       0x96   0x47A0             BLX      R4
    996                  }
    997              }
    998          
    999              /* Receive data register full */
   1000              if ((UART_S1_RDRF_MASK & base->S1) && (UART_C2_RIE_MASK & base->C2))
   \                     ??UART_TransferHandleIRQ_7: (+1)
   \       0x98   0x7938             LDRB     R0,[R7, #+4]
   \       0x9A   0x0681             LSLS     R1,R0,#+26
   \       0x9C   0xD54D             BPL.N    ??UART_TransferHandleIRQ_9
   \       0x9E   0x78F8             LDRB     R0,[R7, #+3]
   \       0xA0   0x0681             LSLS     R1,R0,#+26
   \       0xA2   0xD54A             BPL.N    ??UART_TransferHandleIRQ_9
   1001              {
   1002          /* Get the size that can be stored into buffer for this interrupt. */
   1003          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
   1004                  count = base->RCFIFO;
   \       0xA4   0x7DBC             LDRB     R4,[R7, #+22]
   \       0xA6   0xF106 0x082C      ADD      R8,R6,#+44
   \       0xAA   0xF240 0x39EB      MOVW     R9,#+1003
   \       0xAE   0xE018             B.N      ??UART_TransferHandleIRQ_10
   1005          #else
   1006                  count = 1;
   1007          #endif
   1008          
   1009                  /* If handle->rxDataSize is not 0, first save data to handle->rxData. */
   1010                  while ((count) && (handle->rxDataSize))
   1011                  {
   \                     ??UART_TransferHandleIRQ_11: (+1)
   \       0xB0   0x79FB             LDRB     R3,[R7, #+7]
   \       0xB2   0xF802 0x3B01      STRB     R3,[R2], #+1
   \       0xB6   0x1E40             SUBS     R0,R0,#+1
   \       0xB8   0xD1FA             BNE.N    ??UART_TransferHandleIRQ_11
   1012          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
   1013                      tempCount = MIN(handle->rxDataSize, count);
   1014          #else
   1015                      tempCount = 1;
   1016          #endif
   1017          
   1018                      /* Using non block API to read the data from the registers. */
   1019                      UART_ReadNonBlocking(base, handle->rxData, tempCount);
   1020                      handle->rxData += tempCount;
   \                     ??UART_TransferHandleIRQ_12: (+1)
   \       0xBA   0x68F0             LDR      R0,[R6, #+12]
   \       0xBC   0x4408             ADD      R0,R0,R1
   \       0xBE   0x60F0             STR      R0,[R6, #+12]
   1021                      handle->rxDataSize -= tempCount;
   1022                      count -= tempCount;
   \       0xC0   0x1A64             SUBS     R4,R4,R1
   \       0xC2   0x6932             LDR      R2,[R6, #+16]
   \       0xC4   0x1A52             SUBS     R2,R2,R1
   \       0xC6   0x6132             STR      R2,[R6, #+16]
   \       0xC8   0xB2E4             UXTB     R4,R4
   1023          
   1024                      /* If all the data required for upper layer is ready, trigger callback. */
   1025                      if (!handle->rxDataSize)
   \       0xCA   0x6930             LDR      R0,[R6, #+16]
   \       0xCC   0xB948             CBNZ.N   R0,??UART_TransferHandleIRQ_10
   1026                      {
   1027                          handle->rxState = kUART_RxIdle;
   \       0xCE   0x2102             MOVS     R1,#+2
   \       0xD0   0xF888 0x1001      STRB     R1,[R8, #+1]
   1028          
   1029                          if (handle->callback)
   \       0xD4   0x6A75             LDR      R5,[R6, #+36]
   \       0xD6   0xB125             CBZ.N    R5,??UART_TransferHandleIRQ_10
   1030                          {
   1031                              handle->callback(base, handle, kStatus_UART_RxIdle, handle->userData);
   \       0xD8   0x6AB3             LDR      R3,[R6, #+40]
   \       0xDA   0x464A             MOV      R2,R9
   \       0xDC   0x4631             MOV      R1,R6
   \       0xDE   0x4638             MOV      R0,R7
   \       0xE0   0x47A8             BLX      R5
   1032                          }
   1033                      }
   \                     ??UART_TransferHandleIRQ_10: (+1)
   \       0xE2   0x2C00             CMP      R4,#+0
   \       0xE4   0xBF1C             ITT      NE 
   \       0xE6   0x6930             LDRNE    R0,[R6, #+16]
   \       0xE8   0x2800             CMPNE    R0,#+0
   \       0xEA   0xF000 0x80C2      BEQ.W    ??UART_TransferHandleIRQ_13
   \       0xEE   0x6930             LDR      R0,[R6, #+16]
   \       0xF0   0x42A0             CMP      R0,R4
   \       0xF2   0xBF2E             ITEE     CS 
   \       0xF4   0x4621             MOVCS    R1,R4
   \       0xF6   0x6931             LDRCC    R1,[R6, #+16]
   \       0xF8   0xB2C9             UXTBCC   R1,R1
   \       0xFA   0x68F2             LDR      R2,[R6, #+12]
   \       0xFC   0x2900             CMP      R1,#+0
   \       0xFE   0xD0DC             BEQ.N    ??UART_TransferHandleIRQ_12
   \      0x100   0x4608             MOV      R0,R1
   \      0x102   0xE7D5             B.N      ??UART_TransferHandleIRQ_11
   1034                  }
   1035          
   1036                  /* If use RX ring buffer, receive data to ring buffer. */
   1037                  if (handle->rxRingBuffer)
   1038                  {
   1039                      while (count--)
   1040                      {
   1041                          /* If RX ring buffer is full, trigger callback to notify over run. */
   1042                          if (UART_TransferIsRxRingBufferFull(handle))
   1043                          {
   1044                              if (handle->callback)
   1045                              {
   1046                                  handle->callback(base, handle, kStatus_UART_RxRingBufferOverrun, handle->userData);
   1047                              }
   1048                          }
   1049          
   1050                          /* If ring buffer is still full after callback function, the oldest data is overrided. */
   1051                          if (UART_TransferIsRxRingBufferFull(handle))
   1052                          {
   1053                              /* Increase handle->rxRingBufferTail to make room for new data. */
   1054                              if (handle->rxRingBufferTail + 1U == handle->rxRingBufferSize)
   1055                              {
   1056                                  handle->rxRingBufferTail = 0U;
   1057                              }
   1058                              else
   1059                              {
   1060                                  handle->rxRingBufferTail++;
   1061                              }
   1062                          }
   1063          
   1064                          /* Read data. */
   1065                          handle->rxRingBuffer[handle->rxRingBufferHead] = base->D;
   1066          
   1067                          /* Increase handle->rxRingBufferHead. */
   1068                          if (handle->rxRingBufferHead + 1U == handle->rxRingBufferSize)
   1069                          {
   1070                              handle->rxRingBufferHead = 0U;
   1071                          }
   1072                          else
   1073                          {
   1074                              handle->rxRingBufferHead++;
   1075                          }
   1076                      }
   1077                  }
   1078          
   1079                  else if (!handle->rxDataSize)
   \                     ??UART_TransferHandleIRQ_14: (+1)
   \      0x104   0x6930             LDR      R0,[R6, #+16]
   \      0x106   0xB9C0             CBNZ.N   R0,??UART_TransferHandleIRQ_9
   1080                  {
   1081                      /* Disable RX interrupt/overrun interrupt/fram error interrupt */
   1082                      UART_DisableInterrupts(base, kUART_RxDataRegFullInterruptEnable | kUART_RxOverrunInterruptEnable |
   1083                                                       kUART_FramingErrorInterruptEnable);
   \      0x108   0x7839             LDRB     R1,[R7, #+0]
   \      0x10A   0x7039             STRB     R1,[R7, #+0]
   \      0x10C   0x78F8             LDRB     R0,[R7, #+3]
   \      0x10E   0xF000 0x00DF      AND      R0,R0,#0xDF
   \      0x112   0x70F8             STRB     R0,[R7, #+3]
   \      0x114   0x79B8             LDRB     R0,[R7, #+6]
   \      0x116   0xF000 0x00F5      AND      R0,R0,#0xF5
   \      0x11A   0x71B8             STRB     R0,[R7, #+6]
   \      0x11C   0x7C78             LDRB     R0,[R7, #+17]
   \      0x11E   0x7478             STRB     R0,[R7, #+17]
   1084          
   1085                      /* Disable parity error interrupt when parity mode is enable*/
   1086                      if (UART_C1_PE_MASK & base->C1)
   \      0x120   0x78B9             LDRB     R1,[R7, #+2]
   \      0x122   0x0788             LSLS     R0,R1,#+30
   \      0x124   0xD509             BPL.N    ??UART_TransferHandleIRQ_9
   1087                      {
   1088                          UART_DisableInterrupts(base, kUART_ParityErrorInterruptEnable);
   \      0x126   0x7839             LDRB     R1,[R7, #+0]
   \      0x128   0x7039             STRB     R1,[R7, #+0]
   \      0x12A   0x78F8             LDRB     R0,[R7, #+3]
   \      0x12C   0x70F8             STRB     R0,[R7, #+3]
   \      0x12E   0x79B9             LDRB     R1,[R7, #+6]
   \      0x130   0xF001 0x01FE      AND      R1,R1,#0xFE
   \      0x134   0x71B9             STRB     R1,[R7, #+6]
   \      0x136   0x7C78             LDRB     R0,[R7, #+17]
   \      0x138   0x7478             STRB     R0,[R7, #+17]
   1089                      }
   1090                  }
   1091                  else
   1092                  {
   1093                  }
   1094              }
   1095          
   1096              /* If framing error or parity error happened, stop the RX interrupt when ues no ring buffer */
   1097              if (((handle->rxState == kUART_RxFramingError) || (handle->rxState == kUART_RxParityError)) &&
   1098                  (!handle->rxRingBuffer))
   \                     ??UART_TransferHandleIRQ_9: (+1)
   \      0x13A   0xF106 0x082C      ADD      R8,R6,#+44
   \      0x13E   0xF898 0x0001      LDRB     R0,[R8, #+1]
   \      0x142   0x2804             CMP      R0,#+4
   \      0x144   0xBF1C             ITT      NE 
   \      0x146   0xF898 0x0001      LDRBNE   R0,[R8, #+1]
   \      0x14A   0x2805             CMPNE    R0,#+5
   \      0x14C   0xD11A             BNE.N    ??UART_TransferHandleIRQ_15
   \      0x14E   0x69B0             LDR      R0,[R6, #+24]
   \      0x150   0xB9C0             CBNZ.N   R0,??UART_TransferHandleIRQ_15
   1099              {
   1100                  UART_DisableInterrupts(base, kUART_RxDataRegFullInterruptEnable | kUART_RxOverrunInterruptEnable |
   1101                                                   kUART_FramingErrorInterruptEnable);
   \      0x152   0x7839             LDRB     R1,[R7, #+0]
   \      0x154   0x7039             STRB     R1,[R7, #+0]
   \      0x156   0x78F8             LDRB     R0,[R7, #+3]
   \      0x158   0xF000 0x00DF      AND      R0,R0,#0xDF
   \      0x15C   0x70F8             STRB     R0,[R7, #+3]
   \      0x15E   0x79B8             LDRB     R0,[R7, #+6]
   \      0x160   0xF000 0x00F5      AND      R0,R0,#0xF5
   \      0x164   0x71B8             STRB     R0,[R7, #+6]
   \      0x166   0x7C78             LDRB     R0,[R7, #+17]
   \      0x168   0x7478             STRB     R0,[R7, #+17]
   1102          
   1103                  /* Disable parity error interrupt when parity mode is enable*/
   1104                  if (UART_C1_PE_MASK & base->C1)
   \      0x16A   0x78B9             LDRB     R1,[R7, #+2]
   \      0x16C   0x0788             LSLS     R0,R1,#+30
   \      0x16E   0xD509             BPL.N    ??UART_TransferHandleIRQ_15
   1105                  {
   1106                      UART_DisableInterrupts(base, kUART_ParityErrorInterruptEnable);
   \      0x170   0x7839             LDRB     R1,[R7, #+0]
   \      0x172   0x7039             STRB     R1,[R7, #+0]
   \      0x174   0x78F8             LDRB     R0,[R7, #+3]
   \      0x176   0x70F8             STRB     R0,[R7, #+3]
   \      0x178   0x79B9             LDRB     R1,[R7, #+6]
   \      0x17A   0xF001 0x01FE      AND      R1,R1,#0xFE
   \      0x17E   0x71B9             STRB     R1,[R7, #+6]
   \      0x180   0x7C78             LDRB     R0,[R7, #+17]
   \      0x182   0x7478             STRB     R0,[R7, #+17]
   1107                  }
   1108              }
   1109          
   1110              /* Send data register empty and the interrupt is enabled. */
   1111              if ((base->S1 & UART_S1_TDRE_MASK) && (base->C2 & UART_C2_TIE_MASK))
   \                     ??UART_TransferHandleIRQ_15: (+1)
   \      0x184   0x7938             LDRB     R0,[R7, #+4]
   \      0x186   0x0601             LSLS     R1,R0,#+24
   \      0x188   0xD577             BPL.N    ??UART_TransferHandleIRQ_16
   \      0x18A   0x78F8             LDRB     R0,[R7, #+3]
   \      0x18C   0x0601             LSLS     R1,R0,#+24
   \      0x18E   0xD574             BPL.N    ??UART_TransferHandleIRQ_16
   1112              {
   1113          /* Get the bytes that available at this moment. */
   1114          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
   1115                  count = FSL_FEATURE_UART_FIFO_SIZEn(base) - base->TCFIFO;
   \      0x190   0x....             LDR.N    R0,??DataTable14  ;; 0x4006a000
   \      0x192   0x4287             CMP      R7,R0
   \      0x194   0xD133             BNE.N    ??UART_TransferHandleIRQ_17
   \      0x196   0x2008             MOVS     R0,#+8
   \      0x198   0xE038             B.N      ??UART_TransferHandleIRQ_18
   \                     ??UART_TransferHandleIRQ_19: (+1)
   \      0x19A   0x8430             STRH     R0,[R6, #+32]
   \                     ??UART_TransferHandleIRQ_20: (+1)
   \      0x19C   0x2C00             CMP      R4,#+0
   \      0x19E   0xD0CC             BEQ.N    ??UART_TransferHandleIRQ_9
   \      0x1A0   0x4630             MOV      R0,R6
   \      0x1A2   0x.... 0x....      BL       UART_TransferGetRxRingBufferLength
   \      0x1A6   0x69F1             LDR      R1,[R6, #+28]
   \      0x1A8   0x1E49             SUBS     R1,R1,#+1
   \      0x1AA   0x1E64             SUBS     R4,R4,#+1
   \      0x1AC   0x4288             CMP      R0,R1
   \      0x1AE   0xB2E4             UXTB     R4,R4
   \      0x1B0   0xD107             BNE.N    ??UART_TransferHandleIRQ_21
   \      0x1B2   0x6A75             LDR      R5,[R6, #+36]
   \      0x1B4   0xB12D             CBZ.N    R5,??UART_TransferHandleIRQ_21
   \      0x1B6   0x6AB3             LDR      R3,[R6, #+40]
   \      0x1B8   0xF44F 0x727C      MOV      R2,#+1008
   \      0x1BC   0x4631             MOV      R1,R6
   \      0x1BE   0x4638             MOV      R0,R7
   \      0x1C0   0x47A8             BLX      R5
   \                     ??UART_TransferHandleIRQ_21: (+1)
   \      0x1C2   0x4630             MOV      R0,R6
   \      0x1C4   0x.... 0x....      BL       UART_TransferGetRxRingBufferLength
   \      0x1C8   0x69F1             LDR      R1,[R6, #+28]
   \      0x1CA   0x1E4A             SUBS     R2,R1,#+1
   \      0x1CC   0x4290             CMP      R0,R2
   \      0x1CE   0xD109             BNE.N    ??UART_TransferHandleIRQ_22
   \      0x1D0   0x8C70             LDRH     R0,[R6, #+34]
   \      0x1D2   0x1C40             ADDS     R0,R0,#+1
   \      0x1D4   0x4288             CMP      R0,R1
   \      0x1D6   0xD102             BNE.N    ??UART_TransferHandleIRQ_23
   \      0x1D8   0x2100             MOVS     R1,#+0
   \      0x1DA   0x8471             STRH     R1,[R6, #+34]
   \      0x1DC   0xE002             B.N      ??UART_TransferHandleIRQ_22
   \                     ??UART_TransferHandleIRQ_23: (+1)
   \      0x1DE   0x8C70             LDRH     R0,[R6, #+34]
   \      0x1E0   0x1C40             ADDS     R0,R0,#+1
   \      0x1E2   0x8470             STRH     R0,[R6, #+34]
   \                     ??UART_TransferHandleIRQ_22: (+1)
   \      0x1E4   0x8C30             LDRH     R0,[R6, #+32]
   \      0x1E6   0x79F9             LDRB     R1,[R7, #+7]
   \      0x1E8   0x69B2             LDR      R2,[R6, #+24]
   \      0x1EA   0x5411             STRB     R1,[R2, R0]
   \      0x1EC   0x8C30             LDRH     R0,[R6, #+32]
   \      0x1EE   0x69F1             LDR      R1,[R6, #+28]
   \      0x1F0   0x1C40             ADDS     R0,R0,#+1
   \      0x1F2   0x4288             CMP      R0,R1
   \      0x1F4   0xBF1A             ITTE     NE 
   \      0x1F6   0x8C30             LDRHNE   R0,[R6, #+32]
   \      0x1F8   0x1C40             ADDNE    R0,R0,#+1
   \      0x1FA   0x2000             MOVEQ    R0,#+0
   \      0x1FC   0xE7CD             B.N      ??UART_TransferHandleIRQ_19
   \                     ??UART_TransferHandleIRQ_17: (+1)
   \      0x1FE   0x....             LDR.N    R0,??DataTable14_1  ;; 0x4006b000
   \      0x200   0x4287             CMP      R7,R0
   \      0x202   0xBF1B             ITTET    NE 
   \      0x204   0x....             LDRNE.N  R1,??DataTable14_2  ;; 0x4006c000
   \      0x206   0x428F             CMPNE    R7,R1
   \      0x208   0x2001             MOVEQ    R0,#+1
   \      0x20A   0x20FF             MOVNE    R0,#+255
   \                     ??UART_TransferHandleIRQ_18: (+1)
   \      0x20C   0x7D3C             LDRB     R4,[R7, #+20]
   \      0x20E   0x1B04             SUBS     R4,R0,R4
   \      0x210   0xB2E4             UXTB     R4,R4
   \      0x212   0xF240 0x39EA      MOVW     R9,#+1002
   \      0x216   0xE01C             B.N      ??UART_TransferHandleIRQ_24
   1116          #else
   1117                  count = 1;
   1118          #endif
   1119          
   1120                  while ((count) && (handle->txDataSize))
   1121                  {
   \                     ??UART_TransferHandleIRQ_25: (+1)
   \      0x218   0xF812 0x3B01      LDRB     R3,[R2], #+1
   \      0x21C   0x71FB             STRB     R3,[R7, #+7]
   \      0x21E   0x1E40             SUBS     R0,R0,#+1
   \      0x220   0xD1FA             BNE.N    ??UART_TransferHandleIRQ_25
   1122          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
   1123                      tempCount = MIN(handle->txDataSize, count);
   1124          #else
   1125                      tempCount = 1;
   1126          #endif
   1127          
   1128                      /* Using non block API to write the data to the registers. */
   1129                      UART_WriteNonBlocking(base, handle->txData, tempCount);
   1130                      handle->txData += tempCount;
   \                     ??UART_TransferHandleIRQ_26: (+1)
   \      0x222   0x6830             LDR      R0,[R6, #+0]
   \      0x224   0x4408             ADD      R0,R0,R1
   \      0x226   0x6030             STR      R0,[R6, #+0]
   1131                      handle->txDataSize -= tempCount;
   1132                      count -= tempCount;
   \      0x228   0x1A64             SUBS     R4,R4,R1
   \      0x22A   0x6872             LDR      R2,[R6, #+4]
   \      0x22C   0x1A52             SUBS     R2,R2,R1
   \      0x22E   0x6072             STR      R2,[R6, #+4]
   \      0x230   0xB2E4             UXTB     R4,R4
   1133          
   1134                      /* If all the data are written to data register, TX finished. */
   1135                      if (!handle->txDataSize)
   \      0x232   0x6870             LDR      R0,[R6, #+4]
   \      0x234   0xB968             CBNZ.N   R0,??UART_TransferHandleIRQ_24
   1136                      {
   1137                          handle->txState = kUART_TxIdle;
   \      0x236   0x2100             MOVS     R1,#+0
   \      0x238   0xF888 0x1000      STRB     R1,[R8, #+0]
   1138          
   1139                          /* Disable TX register empty interrupt. */
   1140                          base->C2 = (base->C2 & ~UART_C2_TIE_MASK);
   \      0x23C   0x78F8             LDRB     R0,[R7, #+3]
   \      0x23E   0xF000 0x007F      AND      R0,R0,#0x7F
   \      0x242   0x70F8             STRB     R0,[R7, #+3]
   1141          
   1142                          /* Trigger callback. */
   1143                          if (handle->callback)
   \      0x244   0x6A75             LDR      R5,[R6, #+36]
   \      0x246   0xB125             CBZ.N    R5,??UART_TransferHandleIRQ_24
   1144                          {
   1145                              handle->callback(base, handle, kStatus_UART_TxIdle, handle->userData);
   \      0x248   0x6AB3             LDR      R3,[R6, #+40]
   \      0x24A   0x464A             MOV      R2,R9
   \      0x24C   0x4631             MOV      R1,R6
   \      0x24E   0x4638             MOV      R0,R7
   \      0x250   0x47A8             BLX      R5
   1146                          }
   1147                      }
   \                     ??UART_TransferHandleIRQ_24: (+1)
   \      0x252   0x2C00             CMP      R4,#+0
   \      0x254   0xBF1C             ITT      NE 
   \      0x256   0x6870             LDRNE    R0,[R6, #+4]
   \      0x258   0x2800             CMPNE    R0,#+0
   \      0x25A   0xD00E             BEQ.N    ??UART_TransferHandleIRQ_16
   \      0x25C   0x6870             LDR      R0,[R6, #+4]
   \      0x25E   0x42A0             CMP      R0,R4
   \      0x260   0xBF2E             ITEE     CS 
   \      0x262   0x4621             MOVCS    R1,R4
   \      0x264   0x6871             LDRCC    R1,[R6, #+4]
   \      0x266   0xB2C9             UXTBCC   R1,R1
   \      0x268   0x6832             LDR      R2,[R6, #+0]
   \      0x26A   0x2900             CMP      R1,#+0
   \      0x26C   0xD0D9             BEQ.N    ??UART_TransferHandleIRQ_26
   \      0x26E   0x4608             MOV      R0,R1
   \      0x270   0xE7D2             B.N      ??UART_TransferHandleIRQ_25
   \                     ??UART_TransferHandleIRQ_13: (+1)
   \      0x272   0x69B0             LDR      R0,[R6, #+24]
   \      0x274   0x2800             CMP      R0,#+0
   \      0x276   0xD191             BNE.N    ??UART_TransferHandleIRQ_20
   \      0x278   0xE744             B.N      ??UART_TransferHandleIRQ_14
   1148                  }
   1149              }
   1150          }
   \                     ??UART_TransferHandleIRQ_16: (+1)
   \      0x27A   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   1151          

   \                                 In section .text, align 2, keep-with-next
   1152          void UART_TransferHandleErrorIRQ(UART_Type *base, uart_handle_t *handle)
   1153          {
   1154              /* To be implemented by User. */
   1155          }
   \                     UART_TransferHandleErrorIRQ: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   1156          
   1157          #if defined(UART0)
   1158          #if ((!(defined(FSL_FEATURE_SOC_LPSCI_COUNT))) || \
   1159               ((defined(FSL_FEATURE_SOC_LPSCI_COUNT)) && (FSL_FEATURE_SOC_LPSCI_COUNT == 0)))

   \                                 In section .text, align 2, keep-with-next
   1160          void UART0_DriverIRQHandler(void)
   1161          {
   1162              s_uartIsr(UART0, s_uartHandle[0]);
   \                     UART0_DriverIRQHandler: (+1)
   \        0x0   0x....             B.N      ?Subroutine1
   1163          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x....             LDR.N    R2,??DataTable14_6
   \        0x2   0x....             LDR.N    R0,??DataTable14  ;; 0x4006a000
   \        0x4   0x6811             LDR      R1,[R2, #+0]
   \        0x6   0x68D2             LDR      R2,[R2, #+12]
   \        0x8   0x4710             BX       R2
   1164          

   \                                 In section .text, align 4, keep-with-next
   1165          void UART0_RX_TX_DriverIRQHandler(void)
   1166          {
   1167              UART0_DriverIRQHandler();
   \                     UART0_RX_TX_DriverIRQHandler: (+1)
   \        0x0   0xBF00             Nop      
   \        0x2                      REQUIRE ?Subroutine1
   \        0x2                      ;; // Fall through to label ?Subroutine1
   1168          }
   1169          #endif
   1170          #endif
   1171          
   1172          #if defined(UART1)

   \                                 In section .text, align 2, keep-with-next
   1173          void UART1_DriverIRQHandler(void)
   1174          {
   1175              s_uartIsr(UART1, s_uartHandle[1]);
   \                     UART1_DriverIRQHandler: (+1)
   \        0x0   0x....             B.N      ?Subroutine2
   1176          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x....             LDR.N    R2,??DataTable14_6
   \        0x2   0x....             LDR.N    R0,??DataTable14_1  ;; 0x4006b000
   \        0x4   0x6851             LDR      R1,[R2, #+4]
   \        0x6   0x68D2             LDR      R2,[R2, #+12]
   \        0x8   0x4710             BX       R2
   1177          

   \                                 In section .text, align 4, keep-with-next
   1178          void UART1_RX_TX_DriverIRQHandler(void)
   1179          {
   1180              UART1_DriverIRQHandler();
   \                     UART1_RX_TX_DriverIRQHandler: (+1)
   \        0x0   0xBF00             Nop      
   \        0x2                      REQUIRE ?Subroutine2
   \        0x2                      ;; // Fall through to label ?Subroutine2
   1181          }
   1182          #endif
   1183          
   1184          #if defined(UART2)

   \                                 In section .text, align 2, keep-with-next
   1185          void UART2_DriverIRQHandler(void)
   1186          {
   1187              s_uartIsr(UART2, s_uartHandle[2]);
   \                     UART2_DriverIRQHandler: (+1)
   \        0x0   0x....             B.N      ?Subroutine3
   1188          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x....             LDR.N    R2,??DataTable14_6
   \        0x2   0x....             LDR.N    R0,??DataTable14_2  ;; 0x4006c000
   \        0x4   0x6891             LDR      R1,[R2, #+8]
   \        0x6   0x68D2             LDR      R2,[R2, #+12]
   \        0x8   0x4710             BX       R2
   1189          

   \                                 In section .text, align 4, keep-with-next
   1190          void UART2_RX_TX_DriverIRQHandler(void)
   1191          {
   1192              UART2_DriverIRQHandler();
   \                     UART2_RX_TX_DriverIRQHandler: (+1)
   \        0x0   0xBF00             Nop      
   \        0x2                      REQUIRE ?Subroutine3
   \        0x2                      ;; // Fall through to label ?Subroutine3
   1193          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0x4006'A000        DC32     0x4006a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \        0x0   0x4006'B000        DC32     0x4006b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \        0x0   0x4006'C000        DC32     0x4006c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \        0x0   0xA3D7'0A3E        DC32     0xa3d70a3e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \        0x0   0x4004'7000        DC32     0x40047000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \        0x0   0x070F'F0C0        DC32     0x70ff0c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \        0x0   0x....'....        DC32     s_uartHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \        0x0   0xE000'E100        DC32     0xe000e100
   1194          #endif
   1195          
   1196          #if defined(UART3)
   1197          void UART3_DriverIRQHandler(void)
   1198          {
   1199              s_uartIsr(UART3, s_uartHandle[3]);
   1200          }
   1201          
   1202          void UART3_RX_TX_DriverIRQHandler(void)
   1203          {
   1204              UART3_DriverIRQHandler();
   1205          }
   1206          #endif
   1207          
   1208          #if defined(UART4)
   1209          void UART4_DriverIRQHandler(void)
   1210          {
   1211              s_uartIsr(UART4, s_uartHandle[4]);
   1212          }
   1213          
   1214          void UART4_RX_TX_DriverIRQHandler(void)
   1215          {
   1216              UART4_DriverIRQHandler();
   1217          }
   1218          #endif
   1219          
   1220          #if defined(UART5)
   1221          void UART5_DriverIRQHandler(void)
   1222          {
   1223              s_uartIsr(UART5, s_uartHandle[5]);
   1224          }
   1225          
   1226          void UART5_RX_TX_DriverIRQHandler(void)
   1227          {
   1228              UART5_DriverIRQHandler();
   1229          }
   1230          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   UART0_DriverIRQHandler
         0   -- Indirect call
       0   UART0_RX_TX_DriverIRQHandler
         0   -- Indirect call
       0   UART1_DriverIRQHandler
         0   -- Indirect call
       0   UART1_RX_TX_DriverIRQHandler
         0   -- Indirect call
       0   UART2_DriverIRQHandler
         0   -- Indirect call
       0   UART2_RX_TX_DriverIRQHandler
         0   -- Indirect call
       8   UART_ClearStatusFlags
         8   -> UART_GetStatusFlags
       8   UART_Deinit
         8   -> UART_GetInstance
       0   UART_DisableInterrupts
       0   UART_EnableInterrupts
       0   UART_GetDefaultConfig
       0   UART_GetEnabledInterrupts
       0   UART_GetInstance
       0   UART_GetStatusFlags
      16   UART_Init
       8   UART_ReadBlocking
      16   UART_SetBaudRate
       0   UART_TransferAbortReceive
       0   UART_TransferAbortSend
      24   UART_TransferCreateHandle
        24   -> UART_GetInstance
        24   -> __aeabi_memclr4
       0   UART_TransferGetReceiveCount
       0   UART_TransferGetRxRingBufferLength
       0   UART_TransferGetSendCount
       0   UART_TransferHandleErrorIRQ
      32   UART_TransferHandleIRQ
        32   -- Indirect call
        32   -> UART_TransferGetRxRingBufferLength
      32   UART_TransferReceiveNonBlocking
        32   -- Indirect call
        32   -> UART_EnableInterrupts
        32   -> UART_TransferGetRxRingBufferLength
       0   UART_TransferSendNonBlocking
       8   UART_TransferStartRingBuffer
         0   -> UART_EnableInterrupts
         8   -> UART_EnableInterrupts
       0   UART_TransferStopRingBuffer
       0   UART_WriteBlocking


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       8  ?Subroutine0
      10  ?Subroutine1
      10  ?Subroutine2
      10  ?Subroutine3
       2  UART0_DriverIRQHandler
       2  UART0_RX_TX_DriverIRQHandler
       2  UART1_DriverIRQHandler
       2  UART1_RX_TX_DriverIRQHandler
       2  UART2_DriverIRQHandler
       2  UART2_RX_TX_DriverIRQHandler
      64  UART_ClearStatusFlags
      54  UART_Deinit
      42  UART_DisableInterrupts
      42  UART_EnableInterrupts
      22  UART_GetDefaultConfig
      30  UART_GetEnabledInterrupts
      36  UART_GetInstance
      24  UART_GetStatusFlags
     232  UART_Init
      84  UART_ReadBlocking
     114  UART_SetBaudRate
      66  UART_TransferAbortReceive
      30  UART_TransferAbortSend
      92  UART_TransferCreateHandle
      22  UART_TransferGetReceiveCount
      20  UART_TransferGetRxRingBufferLength
      16  UART_TransferGetSendCount
       2  UART_TransferHandleErrorIRQ
     638  UART_TransferHandleIRQ
     226  UART_TransferReceiveNonBlocking
      60  UART_TransferSendNonBlocking
      44  UART_TransferStartRingBuffer
      70  UART_TransferStopRingBuffer
      24  UART_WriteBlocking
      12  s_uartBases
      12  s_uartClock
      16  s_uartHandle
          s_uartIsr
       4  s_uartIRQ

 
    16 bytes in section .bss
    12 bytes in section .rodata
 2 152 bytes in section .text
 
 2 152 bytes of CODE  memory
    12 bytes of CONST memory
    16 bytes of DATA  memory

Errors: none
Warnings: none
