###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         03/Mar/2020  16:31:27
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\tasks.c
#    Command line =  
#        C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\tasks.c
#        "-IC:\Program Files (x86)\IAR Systems\Embedded Workbench 8.1\arm\inc"
#        -I..\..\..\..\..\CMSIS\Include -I..\..\..\..\..\devices -I..\..\..
#        -I..\..\..\..\..\devices\MKW24D5\drivers
#        -I..\..\..\..\..\devices\MKW24D5\utilities
#        -I..\..\..\..\..\devices\MKW24D5 -I..\..\iar -I..\.. -I..\
#        -I..\..\..\..\..\rtos\freertos_9.0.0\Source\portable\IAR\ARM_CM3
#        -I..\..\..\..\..\rtos\freertos_9.0.0\Source\include -DNDEBUG
#        -DCPU_MKW24D512VHA5 -DIAR -DFSL_RTOS_FREE_RTOS -DPRINTF_FLOAT_ENABLE=0
#        -DSCANF_FLOAT_ENABLE=0 -DPRINTF_ADVANCED_ENABLE=0
#        -DSCANF_ADVANCED_ENABLE=0 -DTWR_KW24D512 -DTOWER --diag_suppress
#        Pa082,Pa050,Pe167,Pa182 --endian=little --cpu=Cortex-M4 --fpu=None
#        --no_path_in_file_macros --silent -lC . -e --dlib_config "C:/Program
#        Files (x86)/IAR Systems/Embedded Workbench
#        8.1/arm/inc/c/DLib_Config_Normal.h" -Oh --dependencies=ns
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\tasks.c.obj.d
#        -o
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\tasks.c.obj
#    Locale       =  C
#    List file    =  .\tasks.c.lst
#    Object file  =  
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\tasks.c.obj
#
###############################################################################

C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\tasks.c
      1          /*
      2              FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
      3              All rights reserved
      4          
      5              VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              This file is part of the FreeRTOS distribution.
      8          
      9              FreeRTOS is free software; you can redistribute it and/or modify it under
     10              the terms of the GNU General Public License (version 2) as published by the
     11              Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
     12          
     13              ***************************************************************************
     14              >>!   NOTE: The modification to the GPL is included to allow you to     !<<
     15              >>!   distribute a combined work that includes FreeRTOS without being   !<<
     16              >>!   obliged to provide the source code for proprietary components     !<<
     17              >>!   outside of the FreeRTOS kernel.                                   !<<
     18              ***************************************************************************
     19          
     20              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
     21              WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     22              FOR A PARTICULAR PURPOSE.  Full license text is available on the following
     23              link: http://www.freertos.org/a00114.html
     24          
     25              ***************************************************************************
     26               *                                                                       *
     27               *    FreeRTOS provides completely free yet professionally developed,    *
     28               *    robust, strictly quality controlled, supported, and cross          *
     29               *    platform software that is more than just the market leader, it     *
     30               *    is the industry's de facto standard.                               *
     31               *                                                                       *
     32               *    Help yourself get started quickly while simultaneously helping     *
     33               *    to support the FreeRTOS project by purchasing a FreeRTOS           *
     34               *    tutorial book, reference manual, or both:                          *
     35               *    http://www.FreeRTOS.org/Documentation                              *
     36               *                                                                       *
     37              ***************************************************************************
     38          
     39              http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
     40              the FAQ page "My application does not run, what could be wrong?".  Have you
     41              defined configASSERT()?
     42          
     43              http://www.FreeRTOS.org/support - In return for receiving this top quality
     44              embedded software for free we request you assist our global community by
     45              participating in the support forum.
     46          
     47              http://www.FreeRTOS.org/training - Investing in training allows your team to
     48              be as productive as possible as early as possible.  Now you can receive
     49              FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
     50              Ltd, and the world's leading authority on the world's leading RTOS.
     51          
     52              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     53              including FreeRTOS+Trace - an indispensable productivity tool, a DOS
     54              compatible FAT file system, and our tiny thread aware UDP/IP stack.
     55          
     56              http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
     57              Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
     58          
     59              http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
     60              Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
     61              licenses offer ticketed support, indemnification and commercial middleware.
     62          
     63              http://www.SafeRTOS.com - High Integrity Systems also provide a safety
     64              engineered and independently SIL3 certified version for use in safety and
     65              mission critical applications that require provable dependability.
     66          
     67              1 tab == 4 spaces!
     68          */
     69          
     70          /* Standard includes. */
     71          #include <stdlib.h>
     72          #include <string.h>
     73          
     74          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     75          all the API functions to use the MPU wrappers.  That should only be done when
     76          task.h is included from an application file. */
     77          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     78          
     79          /* FreeRTOS includes. */
     80          #include "FreeRTOS.h"
     81          #include "task.h"
     82          #include "timers.h"
     83          #include "StackMacros.h"
     84          
     85          /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
     86          MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
     87          header files above, but not in this file, in order to generate the correct
     88          privileged Vs unprivileged linkage and placement. */
     89          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
     90          
     91          /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
     92          functions but without including stdio.h here. */
     93          #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
     94          	/* At the bottom of this file are two optional functions that can be used
     95          	to generate human readable text from the raw data generated by the
     96          	uxTaskGetSystemState() function.  Note the formatting functions are provided
     97          	for convenience only, and are NOT considered part of the kernel. */
     98          	#include <stdio.h>
     99          #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
    100          
    101          #if( configUSE_PREEMPTION == 0 )
    102          	/* If the cooperative scheduler is being used then a yield should not be
    103          	performed just because a higher priority task has been woken. */
    104          	#define taskYIELD_IF_USING_PREEMPTION()
    105          #else
    106          	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
    107          #endif
    108          
    109          /* Values that can be assigned to the ucNotifyState member of the TCB. */
    110          #define taskNOT_WAITING_NOTIFICATION	( ( uint8_t ) 0 )
    111          #define taskWAITING_NOTIFICATION		( ( uint8_t ) 1 )
    112          #define taskNOTIFICATION_RECEIVED		( ( uint8_t ) 2 )
    113          
    114          /*
    115           * The value used to fill the stack of a task when the task is created.  This
    116           * is used purely for checking the high water mark for tasks.
    117           */
    118          #define tskSTACK_FILL_BYTE	( 0xa5U )
    119          
    120          /* Sometimes the FreeRTOSConfig.h settings only allow a task to be created using
    121          dynamically allocated RAM, in which case when any task is deleted it is known
    122          that both the task's stack and TCB need to be freed.  Sometimes the
    123          FreeRTOSConfig.h settings only allow a task to be created using statically
    124          allocated RAM, in which case when any task is deleted it is known that neither
    125          the task's stack or TCB should be freed.  Sometimes the FreeRTOSConfig.h
    126          settings allow a task to be created using either statically or dynamically
    127          allocated RAM, in which case a member of the TCB is used to record whether the
    128          stack and/or TCB were allocated statically or dynamically, so when a task is
    129          deleted the RAM that was allocated dynamically is freed again and no attempt is
    130          made to free the RAM that was allocated statically.
    131          tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is only true if it is possible for a
    132          task to be created using either statically or dynamically allocated RAM.  Note
    133          that if portUSING_MPU_WRAPPERS is 1 then a protected task can be created with
    134          a statically allocated stack and a dynamically allocated TCB. */
    135          #define tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE ( ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) || ( portUSING_MPU_WRAPPERS == 1 ) )
    136          #define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB 		( ( uint8_t ) 0 )
    137          #define tskSTATICALLY_ALLOCATED_STACK_ONLY 			( ( uint8_t ) 1 )
    138          #define tskSTATICALLY_ALLOCATED_STACK_AND_TCB		( ( uint8_t ) 2 )
    139          
    140          /*
    141           * Macros used by vListTask to indicate which state a task is in.
    142           */
    143          #define tskBLOCKED_CHAR		( 'B' )
    144          #define tskREADY_CHAR		( 'R' )
    145          #define tskDELETED_CHAR		( 'D' )
    146          #define tskSUSPENDED_CHAR	( 'S' )
    147          
    148          /*
    149           * Some kernel aware debuggers require the data the debugger needs access to be
    150           * global, rather than file scope.
    151           */
    152          #ifdef portREMOVE_STATIC_QUALIFIER
    153          	#define static
    154          #endif
    155          
    156          #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
    157          
    158          	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
    159          	performed in a generic way that is not optimised to any particular
    160          	microcontroller architecture. */
    161          
    162          	/* uxTopReadyPriority holds the priority of the highest priority ready
    163          	state task. */
    164          	#define taskRECORD_READY_PRIORITY( uxPriority )														\
    165          	{																									\
    166          		if( ( uxPriority ) > uxTopReadyPriority )														\
    167          		{																								\
    168          			uxTopReadyPriority = ( uxPriority );														\
    169          		}																								\
    170          	} /* taskRECORD_READY_PRIORITY */
    171          
    172          	/*-----------------------------------------------------------*/
    173          
    174          	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
    175          	{																									\
    176          	UBaseType_t uxTopPriority = uxTopReadyPriority;														\
    177          																										\
    178          		/* Find the highest priority queue that contains ready tasks. */								\
    179          		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) )							\
    180          		{																								\
    181          			configASSERT( uxTopPriority );																\
    182          			--uxTopPriority;																			\
    183          		}																								\
    184          																										\
    185          		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
    186          		the	same priority get an equal share of the processor time. */									\
    187          		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );			\
    188          		uxTopReadyPriority = uxTopPriority;																\
    189          	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
    190          
    191          	/*-----------------------------------------------------------*/
    192          
    193          	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
    194          	they are only required when a port optimised method of task selection is
    195          	being used. */
    196          	#define taskRESET_READY_PRIORITY( uxPriority )
    197          	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
    198          
    199          #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
    200          
    201          	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
    202          	performed in a way that is tailored to the particular microcontroller
    203          	architecture being used. */
    204          
    205          	/* A port optimised version is provided.  Call the port defined macros. */
    206          	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )
    207          
    208          	/*-----------------------------------------------------------*/
    209          
    210          	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
    211          	{																								\
    212          	UBaseType_t uxTopPriority;																		\
    213          																									\
    214          		/* Find the highest priority list that contains ready tasks. */								\
    215          		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
    216          		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
    217          		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
    218          	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
    219          
    220          	/*-----------------------------------------------------------*/
    221          
    222          	/* A port optimised version is provided, call it only if the TCB being reset
    223          	is being referenced from a ready list.  If it is referenced from a delayed
    224          	or suspended list then it won't be in a ready list. */
    225          	#define taskRESET_READY_PRIORITY( uxPriority )														\
    226          	{																									\
    227          		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
    228          		{																								\
    229          			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
    230          		}																								\
    231          	}
    232          
    233          #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
    234          
    235          /*-----------------------------------------------------------*/
    236          
    237          /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
    238          count overflows. */
    239          #define taskSWITCH_DELAYED_LISTS()																	\
    240          {																									\
    241          	List_t *pxTemp;																					\
    242          																									\
    243          	/* The delayed tasks list should be empty when the lists are switched. */						\
    244          	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
    245          																									\
    246          	pxTemp = pxDelayedTaskList;																		\
    247          	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
    248          	pxOverflowDelayedTaskList = pxTemp;																\
    249          	xNumOfOverflows++;																				\
    250          	prvResetNextTaskUnblockTime();																	\
    251          }
    252          
    253          /*-----------------------------------------------------------*/
    254          
    255          /*
    256           * Place the task represented by pxTCB into the appropriate ready list for
    257           * the task.  It is inserted at the end of the list.
    258           */
    259          #define prvAddTaskToReadyList( pxTCB )																\
    260          	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
    261          	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
    262          	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) ); \
    263          	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
    264          /*-----------------------------------------------------------*/
    265          
    266          /*
    267           * Several functions take an TaskHandle_t parameter that can optionally be NULL,
    268           * where NULL is used to indicate that the handle of the currently executing
    269           * task should be used in place of the parameter.  This macro simply checks to
    270           * see if the parameter is NULL and returns a pointer to the appropriate TCB.
    271           */
    272          #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( TCB_t * ) ( pxHandle ) )
    273          
    274          /* The item value of the event list item is normally used to hold the priority
    275          of the task to which it belongs (coded to allow it to be held in reverse
    276          priority order).  However, it is occasionally borrowed for other purposes.  It
    277          is important its value is not updated due to a task priority change while it is
    278          being used for another purpose.  The following bit definition is used to inform
    279          the scheduler that the value should not be changed - in which case it is the
    280          responsibility of whichever module is using the value to ensure it gets set back
    281          to its original value when it is released. */
    282          #if( configUSE_16_BIT_TICKS == 1 )
    283          	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
    284          #else
    285          	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
    286          #endif
    287          
    288          /*
    289           * Task control block.  A task control block (TCB) is allocated for each task,
    290           * and stores task state information, including a pointer to the task's context
    291           * (the task's run time environment, including register values)
    292           */
    293          typedef struct tskTaskControlBlock
    294          {
    295          	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */
    296          
    297          	#if ( portUSING_MPU_WRAPPERS == 1 )
    298          		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
    299          	#endif
    300          
    301          	ListItem_t			xStateListItem;	/*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */
    302          	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
    303          	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
    304          	StackType_t			*pxStack;			/*< Points to the start of the stack. */
    305          	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.  Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    306          
    307          	#if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
    308          		StackType_t		*pxEndOfStack;		/*< Points to the highest valid address for the stack. */
    309          	#endif
    310          
    311          	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
    312          		UBaseType_t		uxCriticalNesting;	/*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */
    313          	#endif
    314          
    315          	#if ( configUSE_TRACE_FACILITY == 1 )
    316          		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
    317          		UBaseType_t		uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. */
    318          	#endif
    319          
    320          	#if ( configUSE_MUTEXES == 1 )
    321          		UBaseType_t		uxBasePriority;		/*< The priority last assigned to the task - used by the priority inheritance mechanism. */
    322          		UBaseType_t		uxMutexesHeld;
    323          	#endif
    324          
    325          	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
    326          		TaskHookFunction_t pxTaskTag;
    327          	#endif
    328          
    329          	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
    330          		void *pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
    331          	#endif
    332          
    333          	#if( configGENERATE_RUN_TIME_STATS == 1 )
    334          		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state. */
    335          	#endif
    336          
    337          	#if ( configUSE_NEWLIB_REENTRANT == 1 )
    338          		/* Allocate a Newlib reent structure that is specific to this task.
    339          		Note Newlib support has been included by popular demand, but is not
    340          		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
    341          		responsible for resulting newlib operation.  User must be familiar with
    342          		newlib and must provide system-wide implementations of the necessary
    343          		stubs. Be warned that (at the time of writing) the current newlib design
    344          		implements a system-wide malloc() that must be provided with locks. */
    345          		struct	_reent xNewLib_reent;
    346          	#endif
    347          
    348          	#if( configUSE_TASK_NOTIFICATIONS == 1 )
    349          		volatile uint32_t ulNotifiedValue;
    350          		volatile uint8_t ucNotifyState;
    351          	#endif
    352          
    353          	/* See the comments above the definition of
    354          	tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
    355          	#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
    356          		uint8_t	ucStaticallyAllocated; 		/*< Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */
    357          	#endif
    358          
    359          	#if( INCLUDE_xTaskAbortDelay == 1 )
    360          		uint8_t ucDelayAborted;
    361          	#endif
    362          
    363          } tskTCB;
    364          
    365          /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
    366          below to enable the use of older kernel aware debuggers. */
    367          typedef tskTCB TCB_t;
    368          
    369          /*lint -e956 A manual analysis and inspection has been used to determine which
    370          static variables must be declared volatile. */
    371          

   \                                 In section .bss, align 4
    372          PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
    373          
    374          /* Lists for ready and blocked tasks. --------------------*/
    375          PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks. */
   \                     pxReadyTasksLists:
   \        0x0                      DS8 100
   \                     pxCurrentTCB:
   \       0x64                      DS8 4
   \       0x68                      DS8 4
   \       0x6C                      DS8 4
   \       0x70                      DS8 4
   \       0x74                      DS8 4
   \       0x78                      DS8 4
   \       0x7C                      DS8 4
   \       0x80                      DS8 20
   \       0x94                      DS8 20
    376          PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
    377          PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
    378          PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list currently being used. */
    379          PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */

   \                                 In section .bss, align 4
    380          PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */
   \                     xPendingReadyList:
   \        0x0                      DS8 20
   \       0x14                      DS8 20
   \       0x28                      DS8 4
   \       0x2C                      DS8 20
   \       0x40                      DS8 4
   \       0x44                      DS8 4
   \       0x48                      DS8 4
   \       0x4C                      DS8 4
   \       0x50                      DS8 4
   \       0x54                      DS8 4
   \       0x58                      DS8 4
    381          
    382          #if( INCLUDE_vTaskDelete == 1 )
    383          
    384          	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but their memory not yet freed. */
    385          	PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
    386          
    387          #endif
    388          
    389          #if ( INCLUDE_vTaskSuspend == 1 )
    390          
    391          	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
    392          
    393          #endif
    394          
    395          /* Other file private variables. --------------------------------*/
    396          PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
    397          PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) 0U;
    398          PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
    399          PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
    400          PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
    401          PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
    402          PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
    403          PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
    404          PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; /* Initialised to portMAX_DELAY before the scheduler starts. */
    405          PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle					= NULL;			/*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */
    406          
    407          /* Context switches are held pending while the scheduler is suspended.  Also,
    408          interrupts must not manipulate the xStateListItem of a TCB, or any of the
    409          lists the xStateListItem can be referenced from, if the scheduler is suspended.
    410          If an interrupt needs to unblock a task while the scheduler is suspended then it
    411          moves the task's event list item into the xPendingReadyList, ready for the
    412          kernel to move the task from the pending ready list into the real ready list
    413          when the scheduler is unsuspended.  The pending ready list itself can only be
    414          accessed from a critical section. */
    415          PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
    416          
    417          #if ( configGENERATE_RUN_TIME_STATS == 1 )
    418          
    419          	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter the last time a task was switched in. */
    420          	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution time as defined by the run time counter clock. */
    421          
    422          #endif
    423          
    424          /*lint +e956 */
    425          
    426          /*-----------------------------------------------------------*/
    427          
    428          /* Callback function prototypes. --------------------------*/
    429          #if(  configCHECK_FOR_STACK_OVERFLOW > 0 )
    430          	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
    431          #endif
    432          
    433          #if( configUSE_TICK_HOOK > 0 )
    434          	extern void vApplicationTickHook( void );
    435          #endif
    436          
    437          #if( configSUPPORT_STATIC_ALLOCATION == 1 )
    438          	extern void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize );
    439          #endif
    440          
    441          /* File private functions. --------------------------------*/
    442          
    443          /**
    444           * Utility task that simply returns pdTRUE if the task referenced by xTask is
    445           * currently in the Suspended state, or pdFALSE if the task referenced by xTask
    446           * is in any other state.
    447           */
    448          #if ( INCLUDE_vTaskSuspend == 1 )
    449          	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
    450          #endif /* INCLUDE_vTaskSuspend */
    451          
    452          /*
    453           * Utility to ready all the lists used by the scheduler.  This is called
    454           * automatically upon the creation of the first task.
    455           */
    456          static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
    457          
    458          /*
    459           * The idle task, which as all tasks is implemented as a never ending loop.
    460           * The idle task is automatically created and added to the ready lists upon
    461           * creation of the first user task.
    462           *
    463           * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
    464           * language extensions.  The equivalent prototype for this function is:
    465           *
    466           * void prvIdleTask( void *pvParameters );
    467           *
    468           */
    469          static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
    470          
    471          /*
    472           * Utility to free all memory allocated by the scheduler to hold a TCB,
    473           * including the stack pointed to by the TCB.
    474           *
    475           * This does not free memory allocated by the task itself (i.e. memory
    476           * allocated by calls to pvPortMalloc from within the tasks application code).
    477           */
    478          #if ( INCLUDE_vTaskDelete == 1 )
    479          
    480          	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
    481          
    482          #endif
    483          
    484          /*
    485           * Used only by the idle task.  This checks to see if anything has been placed
    486           * in the list of tasks waiting to be deleted.  If so the task is cleaned up
    487           * and its TCB deleted.
    488           */
    489          static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
    490          
    491          /*
    492           * The currently executing task is entering the Blocked state.  Add the task to
    493           * either the current or the overflow delayed task list.
    494           */
    495          static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely ) PRIVILEGED_FUNCTION;
    496          
    497          /*
    498           * Fills an TaskStatus_t structure with information on each task that is
    499           * referenced from the pxList list (which may be a ready list, a delayed list,
    500           * a suspended list, etc.).
    501           *
    502           * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
    503           * NORMAL APPLICATION CODE.
    504           */
    505          #if ( configUSE_TRACE_FACILITY == 1 )
    506          
    507          	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState ) PRIVILEGED_FUNCTION;
    508          
    509          #endif
    510          
    511          /*
    512           * Searches pxList for a task with name pcNameToQuery - returning a handle to
    513           * the task if it is found, or NULL if the task is not found.
    514           */
    515          #if ( INCLUDE_xTaskGetHandle == 1 )
    516          
    517          	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] ) PRIVILEGED_FUNCTION;
    518          
    519          #endif
    520          
    521          /*
    522           * When a task is created, the stack of the task is filled with a known value.
    523           * This function determines the 'high water mark' of the task stack by
    524           * determining how much of the stack remains at the original preset value.
    525           */
    526          #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
    527          
    528          	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
    529          
    530          #endif
    531          
    532          /*
    533           * Return the amount of time, in ticks, that will pass before the kernel will
    534           * next move a task from the Blocked state to the Running state.
    535           *
    536           * This conditional compilation should use inequality to 0, not equality to 1.
    537           * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
    538           * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
    539           * set to a value other than 1.
    540           */
    541          #if ( configUSE_TICKLESS_IDLE != 0 )
    542          
    543          	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
    544          
    545          #endif
    546          
    547          /*
    548           * Set xNextTaskUnblockTime to the time at which the next Blocked state task
    549           * will exit the Blocked state.
    550           */
    551          static void prvResetNextTaskUnblockTime( void );
    552          
    553          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
    554          
    555          	/*
    556          	 * Helper function used to pad task names with spaces when printing out
    557          	 * human readable tables of task information.
    558          	 */
    559          	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName ) PRIVILEGED_FUNCTION;
    560          
    561          #endif
    562          
    563          /*
    564           * Called after a Task_t structure has been allocated either statically or
    565           * dynamically to fill in the structure's members.
    566           */
    567          static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
    568          									const char * const pcName,
    569          									const uint32_t ulStackDepth,
    570          									void * const pvParameters,
    571          									UBaseType_t uxPriority,
    572          									TaskHandle_t * const pxCreatedTask,
    573          									TCB_t *pxNewTCB,
    574          									const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    575          
    576          /*
    577           * Called after a new task has been created and initialised to place the task
    578           * under the control of the scheduler.
    579           */
    580          static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB ) PRIVILEGED_FUNCTION;
    581          
    582          /*-----------------------------------------------------------*/
    583          
    584          #if( configSUPPORT_STATIC_ALLOCATION == 1 )
    585          
    586          	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
    587          									const char * const pcName,
    588          									const uint32_t ulStackDepth,
    589          									void * const pvParameters,
    590          									UBaseType_t uxPriority,
    591          									StackType_t * const puxStackBuffer,
    592          									StaticTask_t * const pxTaskBuffer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    593          	{
    594          	TCB_t *pxNewTCB;
    595          	TaskHandle_t xReturn;
    596          
    597          		configASSERT( puxStackBuffer != NULL );
    598          		configASSERT( pxTaskBuffer != NULL );
    599          
    600          		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
    601          		{
    602          			/* The memory used for the task's TCB and stack are passed into this
    603          			function - use them. */
    604          			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
    605          			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
    606          
    607          			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
    608          			{
    609          				/* Tasks can be created statically or dynamically, so note this
    610          				task was created statically in case the task is later deleted. */
    611          				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
    612          			}
    613          			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    614          
    615          			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
    616          			prvAddNewTaskToReadyList( pxNewTCB );
    617          		}
    618          		else
    619          		{
    620          			xReturn = NULL;
    621          		}
    622          
    623          		return xReturn;
    624          	}
    625          
    626          #endif /* SUPPORT_STATIC_ALLOCATION */
    627          /*-----------------------------------------------------------*/
    628          
    629          #if( portUSING_MPU_WRAPPERS == 1 )
    630          
    631          	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask )
    632          	{
    633          	TCB_t *pxNewTCB;
    634          	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    635          
    636          		configASSERT( pxTaskDefinition->puxStackBuffer );
    637          
    638          		if( pxTaskDefinition->puxStackBuffer != NULL )
    639          		{
    640          			/* Allocate space for the TCB.  Where the memory comes from depends
    641          			on the implementation of the port malloc function and whether or
    642          			not static allocation is being used. */
    643          			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    644          
    645          			if( pxNewTCB != NULL )
    646          			{
    647          				/* Store the stack location in the TCB. */
    648          				pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
    649          
    650          				/* Tasks can be created statically or dynamically, so note
    651          				this task had a statically allocated stack in case it is
    652          				later deleted.  The TCB was allocated dynamically. */
    653          				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
    654          
    655          				prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
    656          										pxTaskDefinition->pcName,
    657          										( uint32_t ) pxTaskDefinition->usStackDepth,
    658          										pxTaskDefinition->pvParameters,
    659          										pxTaskDefinition->uxPriority,
    660          										pxCreatedTask, pxNewTCB,
    661          										pxTaskDefinition->xRegions );
    662          
    663          				prvAddNewTaskToReadyList( pxNewTCB );
    664          				xReturn = pdPASS;
    665          			}
    666          		}
    667          
    668          		return xReturn;
    669          	}
    670          
    671          #endif /* portUSING_MPU_WRAPPERS */
    672          /*-----------------------------------------------------------*/
    673          
    674          #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    675          

   \                                 In section .text, align 2, keep-with-next
    676          	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
    677          							const char * const pcName,
    678          							const uint16_t usStackDepth,
    679          							void * const pvParameters,
    680          							UBaseType_t uxPriority,
    681          							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    682          	{
   \                     xTaskCreate: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x4617             MOV      R7,R2
   \        0x8   0xB084             SUB      SP,SP,#+16
   \        0xA   0x4688             MOV      R8,R1
   \        0xC   0x4699             MOV      R9,R3
    683          	TCB_t *pxNewTCB;
    684          	BaseType_t xReturn;
    685          
    686          		/* If the stack grows down then allocate the stack then the TCB so the stack
    687          		does not grow into the TCB.  Likewise if the stack grows up then allocate
    688          		the TCB then the stack. */
    689          		#if( portSTACK_GROWTH > 0 )
    690          		{
    691          			/* Allocate space for the TCB.  Where the memory comes from depends on
    692          			the implementation of the port malloc function and whether or not static
    693          			allocation is being used. */
    694          			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    695          
    696          			if( pxNewTCB != NULL )
    697          			{
    698          				/* Allocate space for the stack used by the task being created.
    699          				The base of the stack memory stored in the TCB so the task can
    700          				be deleted later if required. */
    701          				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    702          
    703          				if( pxNewTCB->pxStack == NULL )
    704          				{
    705          					/* Could not allocate the stack.  Delete the allocated TCB. */
    706          					vPortFree( pxNewTCB );
    707          					pxNewTCB = NULL;
    708          				}
    709          			}
    710          		}
    711          		#else /* portSTACK_GROWTH */
    712          		{
    713          		StackType_t *pxStack;
    714          
    715          			/* Allocate space for the stack used by the task being created. */
    716          			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   \        0xE   0x00B8             LSLS     R0,R7,#+2
   \       0x10   0x.... 0x....      BL       pvPortMalloc
   \       0x14   0x0005             MOVS     R5,R0
    717          
    718          			if( pxStack != NULL )
   \       0x16   0xD01A             BEQ.N    ??xTaskCreate_0
    719          			{
    720          				/* Allocate space for the TCB. */
    721          				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
   \       0x18   0x2078             MOVS     R0,#+120
   \       0x1A   0x.... 0x....      BL       pvPortMalloc
   \       0x1E   0x0004             MOVS     R4,R0
    722          
    723          				if( pxNewTCB != NULL )
   \       0x20   0xD012             BEQ.N    ??xTaskCreate_1
   \       0x22   0x990D             LDR      R1,[SP, #+52]
   \       0x24   0x980C             LDR      R0,[SP, #+48]
    724          				{
    725          					/* Store the stack location in the TCB. */
    726          					pxNewTCB->pxStack = pxStack;
   \       0x26   0x6325             STR      R5,[R4, #+48]
    727          				}
    728          				else
    729          				{
    730          					/* The stack cannot be used as the TCB was not created.  Free
    731          					it again. */
    732          					vPortFree( pxStack );
    733          				}
    734          			}
    735          			else
    736          			{
    737          				pxNewTCB = NULL;
    738          			}
    739          		}
    740          		#endif /* portSTACK_GROWTH */
    741          
    742          		if( pxNewTCB != NULL )
    743          		{
    744          			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
    745          			{
    746          				/* Tasks can be created statically or dynamically, so note this
    747          				task was created dynamically in case it is later deleted. */
    748          				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
    749          			}
    750          			#endif /* configSUPPORT_STATIC_ALLOCATION */
    751          
    752          			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
   \       0x28   0x2200             MOVS     R2,#+0
   \       0x2A   0x9203             STR      R2,[SP, #+12]
   \       0x2C   0x9101             STR      R1,[SP, #+4]
   \       0x2E   0x9000             STR      R0,[SP, #+0]
   \       0x30   0x9402             STR      R4,[SP, #+8]
   \       0x32   0x464B             MOV      R3,R9
   \       0x34   0x463A             MOV      R2,R7
   \       0x36   0x4641             MOV      R1,R8
   \       0x38   0x4630             MOV      R0,R6
   \       0x3A   0x.... 0x....      BL       prvInitialiseNewTask
    753          			prvAddNewTaskToReadyList( pxNewTCB );
   \       0x3E   0x4620             MOV      R0,R4
   \       0x40   0x.... 0x....      BL       prvAddNewTaskToReadyList
    754          			xReturn = pdPASS;
   \       0x44   0x2001             MOVS     R0,#+1
    755          		}
    756          		else
    757          		{
    758          			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    759          		}
    760          
    761          		return xReturn;
   \       0x46   0x....             B.N      ?Subroutine0
   \                     ??xTaskCreate_1: (+1)
   \       0x48   0x4628             MOV      R0,R5
   \       0x4A   0x.... 0x....      BL       vPortFree
   \                     ??xTaskCreate_0: (+1)
   \       0x4E   0xF04F 0x30FF      MOV      R0,#-1
   \       0x52                      REQUIRE ?Subroutine0
   \       0x52                      ;; // Fall through to label ?Subroutine0
    762          	}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xB005             ADD      SP,SP,#+20
   \        0x2   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    763          
    764          #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    765          /*-----------------------------------------------------------*/
    766          

   \                                 In section .text, align 2, keep-with-next
    767          static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
    768          									const char * const pcName,
    769          									const uint32_t ulStackDepth,
    770          									void * const pvParameters,
    771          									UBaseType_t uxPriority,
    772          									TaskHandle_t * const pxCreatedTask,
    773          									TCB_t *pxNewTCB,
    774          									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    775          {
   \                     prvInitialiseNewTask: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x9E0A             LDR      R6,[SP, #+40]
   \        0x6   0x4680             MOV      R8,R0
   \        0x8   0x460D             MOV      R5,R1
   \        0xA   0x4614             MOV      R4,R2
    776          StackType_t *pxTopOfStack;
    777          UBaseType_t x;
    778          
    779          	#if( portUSING_MPU_WRAPPERS == 1 )
    780          		/* Should the task be created in privileged mode? */
    781          		BaseType_t xRunPrivileged;
    782          		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
    783          		{
    784          			xRunPrivileged = pdTRUE;
    785          		}
    786          		else
    787          		{
    788          			xRunPrivileged = pdFALSE;
    789          		}
    790          		uxPriority &= ~portPRIVILEGE_BIT;
    791          	#endif /* portUSING_MPU_WRAPPERS == 1 */
    792          
    793          	/* Avoid dependency on memset() if it is not required. */
    794          	#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
    795          	{
    796          		/* Fill the stack with a known value to assist debugging. */
    797          		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
   \        0xC   0x6B30             LDR      R0,[R6, #+48]
   \        0xE   0x4699             MOV      R9,R3
   \       0x10   0x22A5             MOVS     R2,#+165
   \       0x12   0x00A1             LSLS     R1,R4,#+2
   \       0x14   0x.... 0x....      BL       __aeabi_memset4
    798          	}
    799          	#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
    800          
    801          	/* Calculate the top of stack address.  This depends on whether the stack
    802          	grows from high memory to low (as per the 80x86) or vice versa.
    803          	portSTACK_GROWTH is used to make the result positive or negative as required
    804          	by the port. */
    805          	#if( portSTACK_GROWTH < 0 )
    806          	{
    807          		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    808          		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
   \       0x18   0x6B31             LDR      R1,[R6, #+48]
   \       0x1A   0xEB01 0x0284      ADD      R2,R1,R4, LSL #+2
   \       0x1E   0x1F10             SUBS     R0,R2,#+4
   \       0x20   0x08C0             LSRS     R0,R0,#+3
    809          
    810          		/* Check the alignment of the calculated top of stack is correct. */
    811          		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
    812          		#if( configRECORD_STACK_HIGH_ADDRESS == 1 )
    813          		{
    814          			/* Also record the stack's high address, which may assist
    815          			debugging. */
    816          			pxNewTCB->pxEndOfStack = pxTopOfStack;
   \       0x22   0xF106 0x0448      ADD      R4,R6,#+72
   \       0x26   0xEA4F 0x0AC0      LSL      R10,R0,#+3
   \       0x2A   0xF8C4 0xA000      STR      R10,[R4, #+0]
    817          		}
    818          		#endif /* configRECORD_STACK_HIGH_ADDRESS */
    819          	}
    820          	#else /* portSTACK_GROWTH */
    821          	{
    822          		pxTopOfStack = pxNewTCB->pxStack;
    823          
    824          		/* Check the alignment of the stack buffer is correct. */
    825          		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
    826          
    827          		/* The other extreme of the stack space is required if stack checking is
    828          		performed. */
    829          		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    830          	}
    831          	#endif /* portSTACK_GROWTH */
    832          
    833          	/* Store the task name in the TCB. */
    834          	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   \       0x2E   0x2100             MOVS     R1,#+0
   \       0x30   0xF106 0x0234      ADD      R2,R6,#+52
    835          	{
    836          		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
   \                     ??prvInitialiseNewTask_0: (+1)
   \       0x34   0x782B             LDRB     R3,[R5, #+0]
   \       0x36   0x7013             STRB     R3,[R2, #+0]
    837          
    838          		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
    839          		configMAX_TASK_NAME_LEN characters just in case the memory after the
    840          		string is not accessible (extremely unlikely). */
    841          		if( pcName[ x ] == 0x00 )
   \       0x38   0x7828             LDRB     R0,[R5, #+0]
   \       0x3A   0xB180             CBZ.N    R0,??prvInitialiseNewTask_1
   \       0x3C   0x786B             LDRB     R3,[R5, #+1]
   \       0x3E   0x7053             STRB     R3,[R2, #+1]
   \       0x40   0x7868             LDRB     R0,[R5, #+1]
   \       0x42   0xB160             CBZ.N    R0,??prvInitialiseNewTask_1
   \       0x44   0x78AB             LDRB     R3,[R5, #+2]
   \       0x46   0x7093             STRB     R3,[R2, #+2]
   \       0x48   0x78A8             LDRB     R0,[R5, #+2]
   \       0x4A   0xB140             CBZ.N    R0,??prvInitialiseNewTask_1
   \       0x4C   0x78EB             LDRB     R3,[R5, #+3]
   \       0x4E   0x70D3             STRB     R3,[R2, #+3]
   \       0x50   0x78E8             LDRB     R0,[R5, #+3]
   \       0x52   0xB120             CBZ.N    R0,??prvInitialiseNewTask_1
    842          		{
    843          			break;
    844          		}
    845          		else
    846          		{
    847          			mtCOVERAGE_TEST_MARKER();
    848          		}
    849          	}
   \       0x54   0x1D09             ADDS     R1,R1,#+4
   \       0x56   0x1D2D             ADDS     R5,R5,#+4
   \       0x58   0x1D12             ADDS     R2,R2,#+4
   \       0x5A   0x2914             CMP      R1,#+20
   \       0x5C   0xD3EA             BCC.N    ??prvInitialiseNewTask_0
   \                     ??prvInitialiseNewTask_1: (+1)
   \       0x5E   0x9F08             LDR      R7,[SP, #+32]
    850          
    851          	/* Ensure the name string is terminated in the case that the string length
    852          	was greater or equal to configMAX_TASK_NAME_LEN. */
    853          	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
   \       0x60   0x2000             MOVS     R0,#+0
   \       0x62   0xF886 0x0047      STRB     R0,[R6, #+71]
    854          
    855          	/* This is used as an array index so must ensure it's not too large.  First
    856          	remove the privilege bit if one is present. */
    857          	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   \       0x66   0x2F04             CMP      R7,#+4
    858          	{
    859          		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   \       0x68   0x9D09             LDR      R5,[SP, #+36]
   \       0x6A   0xBF88             IT       HI 
   \       0x6C   0x2704             MOVHI    R7,#+4
    860          	}
    861          	else
    862          	{
    863          		mtCOVERAGE_TEST_MARKER();
    864          	}
    865          
    866          	pxNewTCB->uxPriority = uxPriority;
   \       0x6E   0x62F7             STR      R7,[R6, #+44]
    867          	#if ( configUSE_MUTEXES == 1 )
    868          	{
    869          		pxNewTCB->uxBasePriority = uxPriority;
   \       0x70   0x60E7             STR      R7,[R4, #+12]
    870          		pxNewTCB->uxMutexesHeld = 0;
   \       0x72   0x6120             STR      R0,[R4, #+16]
    871          	}
    872          	#endif /* configUSE_MUTEXES */
    873          
    874          	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
   \       0x74   0xF1C7 0x0705      RSB      R7,R7,#+5
   \       0x78   0x1D30             ADDS     R0,R6,#+4
   \       0x7A   0x.... 0x....      BL       vListInitialiseItem
    875          	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
   \       0x7E   0xF106 0x0018      ADD      R0,R6,#+24
   \       0x82   0x.... 0x....      BL       vListInitialiseItem
    876          
    877          	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
    878          	back to	the containing TCB from a generic item in a list. */
    879          	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
   \       0x86   0x6136             STR      R6,[R6, #+16]
    880          
    881          	/* Event lists are always in priority order. */
    882          	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   \       0x88   0x61B7             STR      R7,[R6, #+24]
    883          	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
   \       0x8A   0x6276             STR      R6,[R6, #+36]
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0x6160             STR      R0,[R4, #+20]
    884          
    885          	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
    886          	{
    887          		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
    888          	}
    889          	#endif /* portCRITICAL_NESTING_IN_TCB */
    890          
    891          	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
    892          	{
    893          		pxNewTCB->pxTaskTag = NULL;
    894          	}
    895          	#endif /* configUSE_APPLICATION_TASK_TAG */
    896          
    897          	#if ( configGENERATE_RUN_TIME_STATS == 1 )
    898          	{
    899          		pxNewTCB->ulRunTimeCounter = 0UL;
    900          	}
    901          	#endif /* configGENERATE_RUN_TIME_STATS */
    902          
    903          	#if ( portUSING_MPU_WRAPPERS == 1 )
    904          	{
    905          		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
    906          	}
    907          	#else
    908          	{
    909          		/* Avoid compiler warning about unreferenced parameter. */
    910          		( void ) xRegions;
    911          	}
    912          	#endif
    913          
    914          	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
    915          	{
    916          		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
    917          		{
    918          			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
   \       0x90   0x61A0             STR      R0,[R4, #+24]
   \       0x92   0x61E0             STR      R0,[R4, #+28]
   \       0x94   0x6220             STR      R0,[R4, #+32]
   \       0x96   0x6260             STR      R0,[R4, #+36]
    919          		}
    920          	}
    921          	#endif
    922          
    923          	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
    924          	{
    925          		pxNewTCB->ulNotifiedValue = 0;
   \       0x98   0x62A0             STR      R0,[R4, #+40]
    926          		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   \       0x9A   0xF886 0x0074      STRB     R0,[R6, #+116]
    927          	}
    928          	#endif
    929          
    930          	#if ( configUSE_NEWLIB_REENTRANT == 1 )
    931          	{
    932          		/* Initialise this task's Newlib reent structure. */
    933          		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
    934          	}
    935          	#endif
    936          
    937          	#if( INCLUDE_xTaskAbortDelay == 1 )
    938          	{
    939          		pxNewTCB->ucDelayAborted = pdFALSE;
    940          	}
    941          	#endif
    942          
    943          	/* Initialize the TCB stack to look as if the task was already running,
    944          	but had been interrupted by the scheduler.  The return address is set
    945          	to the start of the task function. Once the stack has been initialised
    946          	the	top of stack variable is updated. */
    947          	#if( portUSING_MPU_WRAPPERS == 1 )
    948          	{
    949          		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
    950          	}
    951          	#else /* portUSING_MPU_WRAPPERS */
    952          	{
    953          		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
   \       0x9E   0x464A             MOV      R2,R9
   \       0xA0   0x4641             MOV      R1,R8
   \       0xA2   0x4650             MOV      R0,R10
   \       0xA4   0x.... 0x....      BL       pxPortInitialiseStack
   \       0xA8   0x6030             STR      R0,[R6, #+0]
    954          	}
    955          	#endif /* portUSING_MPU_WRAPPERS */
    956          
    957          	if( ( void * ) pxCreatedTask != NULL )
   \       0xAA   0xB105             CBZ.N    R5,??prvInitialiseNewTask_2
    958          	{
    959          		/* Pass the handle out in an anonymous way.  The handle can be used to
    960          		change the created task's priority, delete the created task, etc.*/
    961          		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
   \       0xAC   0x602E             STR      R6,[R5, #+0]
    962          	}
    963          	else
    964          	{
    965          		mtCOVERAGE_TEST_MARKER();
    966          	}
    967          }
   \                     ??prvInitialiseNewTask_2: (+1)
   \       0xAE   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    968          /*-----------------------------------------------------------*/
    969          

   \                                 In section .text, align 2, keep-with-next
    970          static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
    971          {
   \                     prvAddNewTaskToReadyList: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
    972          	/* Ensure interrupts don't access the task lists while the lists are being
    973          	updated. */
    974          	taskENTER_CRITICAL();
   \        0x6   0x.... 0x....      BL       vPortEnterCritical
    975          	{
    976          		uxCurrentNumberOfTasks++;
   \        0xA   0x.... 0x....      LDR.W    R5,??DataTable36
   \        0xE   0x6F28             LDR      R0,[R5, #+112]
   \       0x10   0x1C40             ADDS     R0,R0,#+1
   \       0x12   0x6728             STR      R0,[R5, #+112]
    977          		if( pxCurrentTCB == NULL )
   \       0x14   0x6E68             LDR      R0,[R5, #+100]
   \       0x16   0xBB88             CBNZ.N   R0,??prvAddNewTaskToReadyList_0
    978          		{
    979          			/* There are no other tasks, or all the other tasks are in
    980          			the suspended state - make this the current task. */
    981          			pxCurrentTCB = pxNewTCB;
   \       0x18   0x666C             STR      R4,[R5, #+100]
    982          
    983          			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
   \       0x1A   0x6F28             LDR      R0,[R5, #+112]
   \       0x1C   0x2801             CMP      R0,#+1
   \       0x1E   0xD137             BNE.N    ??prvAddNewTaskToReadyList_1
    984          			{
    985          				/* This is the first task to be created so do the preliminary
    986          				initialisation required.  We will not recover if this call
    987          				fails, but we will report the failure. */
    988          				prvInitialiseTaskLists();
   \       0x20   0x4628             MOV      R0,R5
   \       0x22   0x.... 0x....      BL       vListInitialise
   \       0x26   0xF105 0x0014      ADD      R0,R5,#+20
   \       0x2A   0x.... 0x....      BL       vListInitialise
   \       0x2E   0xF105 0x0028      ADD      R0,R5,#+40
   \       0x32   0x.... 0x....      BL       vListInitialise
   \       0x36   0xF105 0x003C      ADD      R0,R5,#+60
   \       0x3A   0x.... 0x....      BL       vListInitialise
   \       0x3E   0xF105 0x0050      ADD      R0,R5,#+80
   \       0x42   0x.... 0x....      BL       vListInitialise
   \       0x46   0xF105 0x0780      ADD      R7,R5,#+128
   \       0x4A   0x4638             MOV      R0,R7
   \       0x4C   0x.... 0x....      BL       vListInitialise
   \       0x50   0xF105 0x0894      ADD      R8,R5,#+148
   \       0x54   0x4640             MOV      R0,R8
   \       0x56   0x.... 0x....      BL       vListInitialise
   \       0x5A   0x.... 0x....      LDR.W    R6,??DataTable36_1
   \       0x5E   0x4630             MOV      R0,R6
   \       0x60   0x.... 0x....      BL       vListInitialise
   \       0x64   0xF106 0x0014      ADD      R0,R6,#+20
   \       0x68   0x.... 0x....      BL       vListInitialise
   \       0x6C   0xF106 0x002C      ADD      R0,R6,#+44
   \       0x70   0x.... 0x....      BL       vListInitialise
   \       0x74   0x66AF             STR      R7,[R5, #+104]
   \       0x76   0xF8C5 0x806C      STR      R8,[R5, #+108]
    989          			}
    990          			else
    991          			{
    992          				mtCOVERAGE_TEST_MARKER();
    993          			}
    994          		}
   \       0x7A   0xE009             B.N      ??prvAddNewTaskToReadyList_1
    995          		else
    996          		{
    997          			/* If the scheduler is not already running, make this task the
    998          			current task if it is the highest priority task to be created
    999          			so far. */
   1000          			if( xSchedulerRunning == pdFALSE )
   \                     ??prvAddNewTaskToReadyList_0: (+1)
   \       0x7C   0x.... 0x....      LDR.W    R1,??DataTable36_1
   \       0x80   0x6C48             LDR      R0,[R1, #+68]
   \       0x82   0xB928             CBNZ.N   R0,??prvAddNewTaskToReadyList_1
   1001          			{
   1002          				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
   \       0x84   0x6AE0             LDR      R0,[R4, #+44]
   \       0x86   0x6E69             LDR      R1,[R5, #+100]
   \       0x88   0x6ACA             LDR      R2,[R1, #+44]
   \       0x8A   0x4290             CMP      R0,R2
   \       0x8C   0xBF28             IT       CS 
   \       0x8E   0x666C             STRCS    R4,[R5, #+100]
   1003          				{
   1004          					pxCurrentTCB = pxNewTCB;
   1005          				}
   1006          				else
   1007          				{
   1008          					mtCOVERAGE_TEST_MARKER();
   1009          				}
   1010          			}
   1011          			else
   1012          			{
   1013          				mtCOVERAGE_TEST_MARKER();
   1014          			}
   1015          		}
   1016          
   1017          		uxTaskNumber++;
   \                     ??prvAddNewTaskToReadyList_1: (+1)
   \       0x90   0x.... 0x....      LDR.W    R6,??DataTable36_1
   \       0x94   0x6D30             LDR      R0,[R6, #+80]
   \       0x96   0x1C40             ADDS     R0,R0,#+1
   \       0x98   0x6530             STR      R0,[R6, #+80]
   1018          
   1019          		#if ( configUSE_TRACE_FACILITY == 1 )
   1020          		{
   1021          			/* Add a counter into the TCB for tracing only. */
   1022          			pxNewTCB->uxTCBNumber = uxTaskNumber;
   \       0x9A   0x64E0             STR      R0,[R4, #+76]
   1023          		}
   1024          		#endif /* configUSE_TRACE_FACILITY */
   1025          		traceTASK_CREATE( pxNewTCB );
   1026          
   1027          		prvAddTaskToReadyList( pxNewTCB );
   \       0x9C   0x2201             MOVS     R2,#+1
   \       0x9E   0x6AE0             LDR      R0,[R4, #+44]
   \       0xA0   0x6F69             LDR      R1,[R5, #+116]
   \       0xA2   0x4082             LSLS     R2,R2,R0
   \       0xA4   0x4311             ORRS     R1,R2,R1
   \       0xA6   0x6769             STR      R1,[R5, #+116]
   \       0xA8   0xEB00 0x0380      ADD      R3,R0,R0, LSL #+2
   \       0xAC   0x1D21             ADDS     R1,R4,#+4
   \       0xAE   0xEB05 0x0083      ADD      R0,R5,R3, LSL #+2
   \       0xB2   0x.... 0x....      BL       vListInsertEnd
   1028          
   1029          		portSETUP_TCB( pxNewTCB );
   1030          	}
   1031          	taskEXIT_CRITICAL();
   \       0xB6   0x.... 0x....      BL       vPortExitCritical
   1032          
   1033          	if( xSchedulerRunning != pdFALSE )
   \       0xBA   0x6C70             LDR      R0,[R6, #+68]
   \       0xBC   0xB168             CBZ.N    R0,??prvAddNewTaskToReadyList_2
   1034          	{
   1035          		/* If the created task is of a higher priority than the current task
   1036          		then it should run now. */
   1037          		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
   \       0xBE   0x6E68             LDR      R0,[R5, #+100]
   \       0xC0   0x6AC1             LDR      R1,[R0, #+44]
   \       0xC2   0x6AE0             LDR      R0,[R4, #+44]
   \       0xC4   0x4281             CMP      R1,R0
   \       0xC6   0xD208             BCS.N    ??prvAddNewTaskToReadyList_2
   1038          		{
   1039          			taskYIELD_IF_USING_PREEMPTION();
   \       0xC8   0x.... 0x....      LDR.W    R2,??DataTable37  ;; 0xe000ed04
   \       0xCC   0xF04F 0x5180      MOV      R1,#+268435456
   \       0xD0   0x6011             STR      R1,[R2, #+0]
   \       0xD2   0xF3BF 0x8F4F      DSB      SY
   \       0xD6   0xF3BF 0x8F6F      ISB      SY
   1040          		}
   1041          		else
   1042          		{
   1043          			mtCOVERAGE_TEST_MARKER();
   1044          		}
   1045          	}
   1046          	else
   1047          	{
   1048          		mtCOVERAGE_TEST_MARKER();
   1049          	}
   1050          }
   \                     ??prvAddNewTaskToReadyList_2: (+1)
   \       0xDA   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1051          /*-----------------------------------------------------------*/
   1052          
   1053          #if ( INCLUDE_vTaskDelete == 1 )
   1054          

   \                                 In section .text, align 2, keep-with-next
   1055          	void vTaskDelete( TaskHandle_t xTaskToDelete )
   1056          	{
   \                     vTaskDelete: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   1057          	TCB_t *pxTCB;
   1058          
   1059          		taskENTER_CRITICAL();
   \        0x4   0x.... 0x....      BL       vPortEnterCritical
   1060          		{
   1061          			/* If null is passed in here then it is the calling task that is
   1062          			being deleted. */
   1063          			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
   \        0x8   0x.... 0x....      LDR.W    R5,??DataTable36
   \        0xC   0xB904             CBNZ.N   R4,??vTaskDelete_0
   \        0xE   0x6E6C             LDR      R4,[R5, #+100]
   1064          
   1065          			/* Remove task from the ready list. */
   1066          			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   \                     ??vTaskDelete_0: (+1)
   \       0x10   0x1D20             ADDS     R0,R4,#+4
   \       0x12   0x.... 0x....      BL       uxListRemove
   \       0x16   0xB960             CBNZ.N   R0,??vTaskDelete_1
   1067          			{
   1068          				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   \       0x18   0x6AE1             LDR      R1,[R4, #+44]
   \       0x1A   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \       0x1E   0x0092             LSLS     R2,R2,#+2
   \       0x20   0x58A8             LDR      R0,[R5, R2]
   \       0x22   0xB930             CBNZ.N   R0,??vTaskDelete_1
   \       0x24   0x6F68             LDR      R0,[R5, #+116]
   \       0x26   0x2201             MOVS     R2,#+1
   \       0x28   0xFA02 0xF101      LSL      R1,R2,R1
   \       0x2C   0xEA20 0x0101      BIC      R1,R0,R1
   \       0x30   0x6769             STR      R1,[R5, #+116]
   1069          			}
   1070          			else
   1071          			{
   1072          				mtCOVERAGE_TEST_MARKER();
   1073          			}
   1074          
   1075          			/* Is the task waiting on an event also? */
   1076          			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   \                     ??vTaskDelete_1: (+1)
   \       0x32   0x6AA0             LDR      R0,[R4, #+40]
   \       0x34   0xB118             CBZ.N    R0,??vTaskDelete_2
   1077          			{
   1078          				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   \       0x36   0xF104 0x0018      ADD      R0,R4,#+24
   \       0x3A   0x.... 0x....      BL       uxListRemove
   1079          			}
   1080          			else
   1081          			{
   1082          				mtCOVERAGE_TEST_MARKER();
   1083          			}
   1084          
   1085          			/* Increment the uxTaskNumber also so kernel aware debuggers can
   1086          			detect that the task lists need re-generating.  This is done before
   1087          			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
   1088          			not return. */
   1089          			uxTaskNumber++;
   \                     ??vTaskDelete_2: (+1)
   \       0x3E   0x.... 0x....      LDR.W    R6,??DataTable36_1
   \       0x42   0x6D30             LDR      R0,[R6, #+80]
   \       0x44   0x1C40             ADDS     R0,R0,#+1
   \       0x46   0x6530             STR      R0,[R6, #+80]
   1090          
   1091          			if( pxTCB == pxCurrentTCB )
   \       0x48   0x6E68             LDR      R0,[R5, #+100]
   \       0x4A   0x4284             CMP      R4,R0
   \       0x4C   0xD108             BNE.N    ??vTaskDelete_3
   1092          			{
   1093          				/* A task is deleting itself.  This cannot complete within the
   1094          				task itself, as a context switch to another task is required.
   1095          				Place the task in the termination list.  The idle task will
   1096          				check the termination list and free up any memory allocated by
   1097          				the scheduler for the TCB and stack of the deleted task. */
   1098          				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
   \       0x4E   0x1D21             ADDS     R1,R4,#+4
   \       0x50   0xF106 0x0014      ADD      R0,R6,#+20
   \       0x54   0x.... 0x....      BL       vListInsertEnd
   1099          
   1100          				/* Increment the ucTasksDeleted variable so the idle task knows
   1101          				there is a task that has been deleted and that it should therefore
   1102          				check the xTasksWaitingTermination list. */
   1103          				++uxDeletedTasksWaitingCleanUp;
   \       0x58   0x6AB0             LDR      R0,[R6, #+40]
   \       0x5A   0x1C40             ADDS     R0,R0,#+1
   \       0x5C   0x62B0             STR      R0,[R6, #+40]
   \       0x5E   0xE00A             B.N      ??vTaskDelete_4
   1104          
   1105          				/* The pre-delete hook is primarily for the Windows simulator,
   1106          				in which Windows specific clean up operations are performed,
   1107          				after which it is not possible to yield away from this task -
   1108          				hence xYieldPending is used to latch that a context switch is
   1109          				required. */
   1110          				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
   1111          			}
   1112          			else
   1113          			{
   1114          				--uxCurrentNumberOfTasks;
   \                     ??vTaskDelete_3: (+1)
   \       0x60   0x6F28             LDR      R0,[R5, #+112]
   \       0x62   0x1E40             SUBS     R0,R0,#+1
   \       0x64   0x6728             STR      R0,[R5, #+112]
   1115          				prvDeleteTCB( pxTCB );
   \       0x66   0x6B20             LDR      R0,[R4, #+48]
   \       0x68   0x.... 0x....      BL       vPortFree
   \       0x6C   0x4620             MOV      R0,R4
   \       0x6E   0x.... 0x....      BL       vPortFree
   1116          
   1117          				/* Reset the next expected unblock time in case it referred to
   1118          				the task that has just been deleted. */
   1119          				prvResetNextTaskUnblockTime();
   \       0x72   0x.... 0x....      BL       prvResetNextTaskUnblockTime
   1120          			}
   1121          
   1122          			traceTASK_DELETE( pxTCB );
   1123          		}
   1124          		taskEXIT_CRITICAL();
   \                     ??vTaskDelete_4: (+1)
   \       0x76   0x.... 0x....      BL       vPortExitCritical
   1125          
   1126          		/* Force a reschedule if it is the currently running task that has just
   1127          		been deleted. */
   1128          		if( xSchedulerRunning != pdFALSE )
   \       0x7A   0x6C70             LDR      R0,[R6, #+68]
   \       0x7C   0xB1A8             CBZ.N    R0,??vTaskDelete_5
   1129          		{
   1130          			if( pxTCB == pxCurrentTCB )
   \       0x7E   0x6E69             LDR      R1,[R5, #+100]
   \       0x80   0x428C             CMP      R4,R1
   \       0x82   0xD112             BNE.N    ??vTaskDelete_5
   1131          			{
   1132          				configASSERT( uxSchedulerSuspended == 0 );
   \       0x84   0x6FE8             LDR      R0,[R5, #+124]
   \       0x86   0xB138             CBZ.N    R0,??vTaskDelete_6
   \       0x88   0x2120             MOVS     R1,#+32
   \       0x8A   0xF381 0x8811      MSR      BASEPRI,R1
   \       0x8E   0xF3BF 0x8F4F      DSB      SY
   \       0x92   0xF3BF 0x8F6F      ISB      SY
   \                     ??vTaskDelete_7: (+1)
   \       0x96   0xE7FE             B.N      ??vTaskDelete_7
   1133          				portYIELD_WITHIN_API();
   \                     ??vTaskDelete_6: (+1)
   \       0x98   0x.... 0x....      LDR.W    R1,??DataTable37  ;; 0xe000ed04
   \       0x9C   0xF04F 0x5080      MOV      R0,#+268435456
   \       0xA0   0x6008             STR      R0,[R1, #+0]
   \       0xA2   0xF3BF 0x8F4F      DSB      SY
   \       0xA6   0xF3BF 0x8F6F      ISB      SY
   1134          			}
   1135          			else
   1136          			{
   1137          				mtCOVERAGE_TEST_MARKER();
   1138          			}
   1139          		}
   1140          	}
   \                     ??vTaskDelete_5: (+1)
   \       0xAA   0xBD70             POP      {R4-R6,PC}       ;; return
   1141          
   1142          #endif /* INCLUDE_vTaskDelete */
   1143          /*-----------------------------------------------------------*/
   1144          
   1145          #if ( INCLUDE_vTaskDelayUntil == 1 )
   1146          

   \                                 In section .text, align 2, keep-with-next
   1147          	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
   1148          	{
   \                     vTaskDelayUntil: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x460A             MOV      R2,R1
   1149          	TickType_t xTimeToWake;
   1150          	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
   1151          
   1152          		configASSERT( pxPreviousWakeTime );
   \        0x4   0xB938             CBNZ.N   R0,??vTaskDelayUntil_0
   \        0x6   0x2020             MOVS     R0,#+32
   \        0x8   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xC   0xF3BF 0x8F4F      DSB      SY
   \       0x10   0xF3BF 0x8F6F      ISB      SY
   \                     ??vTaskDelayUntil_1: (+1)
   \       0x14   0xE7FE             B.N      ??vTaskDelayUntil_1
   1153          		configASSERT( ( xTimeIncrement > 0U ) );
   \                     ??vTaskDelayUntil_0: (+1)
   \       0x16   0xB93A             CBNZ.N   R2,??vTaskDelayUntil_2
   \       0x18   0x2020             MOVS     R0,#+32
   \       0x1A   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x1E   0xF3BF 0x8F4F      DSB      SY
   \       0x22   0xF3BF 0x8F6F      ISB      SY
   \                     ??vTaskDelayUntil_3: (+1)
   \       0x26   0xE7FE             B.N      ??vTaskDelayUntil_3
   1154          		configASSERT( uxSchedulerSuspended == 0 );
   \                     ??vTaskDelayUntil_2: (+1)
   \       0x28   0x.... 0x....      LDR.W    R3,??DataTable36
   \       0x2C   0x6FD9             LDR      R1,[R3, #+124]
   \       0x2E   0xB139             CBZ.N    R1,??vTaskDelayUntil_4
   \       0x30   0x2020             MOVS     R0,#+32
   \       0x32   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x36   0xF3BF 0x8F4F      DSB      SY
   \       0x3A   0xF3BF 0x8F6F      ISB      SY
   \                     ??vTaskDelayUntil_5: (+1)
   \       0x3E   0xE7FE             B.N      ??vTaskDelayUntil_5
   1155          
   1156          		vTaskSuspendAll();
   \                     ??vTaskDelayUntil_4: (+1)
   \       0x40   0x6FD9             LDR      R1,[R3, #+124]
   \       0x42   0x1C49             ADDS     R1,R1,#+1
   \       0x44   0x67D9             STR      R1,[R3, #+124]
   1157          		{
   1158          			/* Minor optimisation.  The tick count cannot change in this
   1159          			block. */
   1160          			const TickType_t xConstTickCount = xTickCount;
   \       0x46   0x.... 0x....      LDR.W    R3,??DataTable36_1
   \       0x4A   0x6C1B             LDR      R3,[R3, #+64]
   1161          
   1162          			/* Generate the tick time at which the task wants to wake. */
   1163          			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
   \       0x4C   0x6801             LDR      R1,[R0, #+0]
   \       0x4E   0x1852             ADDS     R2,R2,R1
   1164          
   1165          			if( xConstTickCount < *pxPreviousWakeTime )
   \       0x50   0x428B             CMP      R3,R1
   \       0x52   0xD203             BCS.N    ??vTaskDelayUntil_6
   1166          			{
   1167          				/* The tick count has overflowed since this function was
   1168          				lasted called.  In this case the only time we should ever
   1169          				actually delay is if the wake time has also	overflowed,
   1170          				and the wake time is greater than the tick time.  When this
   1171          				is the case it is as if neither time had overflowed. */
   1172          				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
   \       0x54   0x428A             CMP      R2,R1
   \       0x56   0xD303             BCC.N    ??vTaskDelayUntil_7
   \                     ??vTaskDelayUntil_8: (+1)
   \       0x58   0x6002             STR      R2,[R0, #+0]
   \       0x5A   0xE008             B.N      ??vTaskDelayUntil_9
   1173          				{
   1174          					xShouldDelay = pdTRUE;
   1175          				}
   1176          				else
   1177          				{
   1178          					mtCOVERAGE_TEST_MARKER();
   1179          				}
   1180          			}
   1181          			else
   1182          			{
   1183          				/* The tick time has not overflowed.  In this case we will
   1184          				delay if either the wake time has overflowed, and/or the
   1185          				tick time is less than the wake time. */
   1186          				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
   \                     ??vTaskDelayUntil_6: (+1)
   \       0x5C   0x428A             CMP      R2,R1
   \       0x5E   0xD301             BCC.N    ??vTaskDelayUntil_10
   \                     ??vTaskDelayUntil_7: (+1)
   \       0x60   0x4293             CMP      R3,R2
   \       0x62   0xD2F9             BCS.N    ??vTaskDelayUntil_8
   1187          				{
   1188          					xShouldDelay = pdTRUE;
   \                     ??vTaskDelayUntil_10: (+1)
   \       0x64   0x6002             STR      R2,[R0, #+0]
   1189          				}
   1190          				else
   1191          				{
   1192          					mtCOVERAGE_TEST_MARKER();
   1193          				}
   1194          			}
   1195          
   1196          			/* Update the wake time ready for the next call. */
   1197          			*pxPreviousWakeTime = xTimeToWake;
   1198          
   1199          			if( xShouldDelay != pdFALSE )
   1200          			{
   1201          				traceTASK_DELAY_UNTIL( xTimeToWake );
   1202          
   1203          				/* prvAddCurrentTaskToDelayedList() needs the block time, not
   1204          				the time to wake, so subtract the current tick count. */
   1205          				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
   \       0x66   0x2100             MOVS     R1,#+0
   \       0x68   0x1AD0             SUBS     R0,R2,R3
   \       0x6A   0x.... 0x....      BL       prvAddCurrentTaskToDelayedList
   1206          			}
   1207          			else
   1208          			{
   1209          				mtCOVERAGE_TEST_MARKER();
   1210          			}
   1211          		}
   1212          		xAlreadyYielded = xTaskResumeAll();
   1213          
   1214          		/* Force a reschedule if xTaskResumeAll has not already done so, we may
   1215          		have put ourselves to sleep. */
   1216          		if( xAlreadyYielded == pdFALSE )
   \                     ??vTaskDelayUntil_9: (+1)
   \       0x6E   0x.... 0x....      BL       xTaskResumeAll
   \       0x72   0xB940             CBNZ.N   R0,??vTaskDelayUntil_11
   1217          		{
   1218          			portYIELD_WITHIN_API();
   \       0x74   0x.... 0x....      LDR.W    R1,??DataTable37  ;; 0xe000ed04
   \       0x78   0xF04F 0x5080      MOV      R0,#+268435456
   \       0x7C   0x6008             STR      R0,[R1, #+0]
   \       0x7E   0xF3BF 0x8F4F      DSB      SY
   \       0x82   0xF3BF 0x8F6F      ISB      SY
   1219          		}
   1220          		else
   1221          		{
   1222          			mtCOVERAGE_TEST_MARKER();
   1223          		}
   1224          	}
   \                     ??vTaskDelayUntil_11: (+1)
   \       0x86   0xBD01             POP      {R0,PC}          ;; return
   1225          
   1226          #endif /* INCLUDE_vTaskDelayUntil */
   1227          /*-----------------------------------------------------------*/
   1228          
   1229          #if ( INCLUDE_vTaskDelay == 1 )
   1230          

   \                                 In section .text, align 2, keep-with-next
   1231          	void vTaskDelay( const TickType_t xTicksToDelay )
   1232          	{
   \                     vTaskDelay: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1233          	BaseType_t xAlreadyYielded = pdFALSE;
   1234          
   1235          		/* A delay time of zero just forces a reschedule. */
   1236          		if( xTicksToDelay > ( TickType_t ) 0U )
   \        0x2   0xB1A0             CBZ.N    R0,??vTaskDelay_0
   1237          		{
   1238          			configASSERT( uxSchedulerSuspended == 0 );
   \        0x4   0x.... 0x....      LDR.W    R2,??DataTable36
   \        0x8   0x6FD1             LDR      R1,[R2, #+124]
   \        0xA   0xB139             CBZ.N    R1,??vTaskDelay_1
   \        0xC   0x2020             MOVS     R0,#+32
   \        0xE   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x12   0xF3BF 0x8F4F      DSB      SY
   \       0x16   0xF3BF 0x8F6F      ISB      SY
   \                     ??vTaskDelay_2: (+1)
   \       0x1A   0xE7FE             B.N      ??vTaskDelay_2
   1239          			vTaskSuspendAll();
   \                     ??vTaskDelay_1: (+1)
   \       0x1C   0x6FD1             LDR      R1,[R2, #+124]
   \       0x1E   0x1C49             ADDS     R1,R1,#+1
   \       0x20   0x67D1             STR      R1,[R2, #+124]
   1240          			{
   1241          				traceTASK_DELAY();
   1242          
   1243          				/* A task that is removed from the event list while the
   1244          				scheduler is suspended will not get placed in the ready
   1245          				list or removed from the blocked list until the scheduler
   1246          				is resumed.
   1247          
   1248          				This task cannot be in an event list as it is the currently
   1249          				executing task. */
   1250          				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
   \       0x22   0x2100             MOVS     R1,#+0
   \       0x24   0x.... 0x....      BL       prvAddCurrentTaskToDelayedList
   1251          			}
   1252          			xAlreadyYielded = xTaskResumeAll();
   1253          		}
   1254          		else
   1255          		{
   1256          			mtCOVERAGE_TEST_MARKER();
   1257          		}
   1258          
   1259          		/* Force a reschedule if xTaskResumeAll has not already done so, we may
   1260          		have put ourselves to sleep. */
   1261          		if( xAlreadyYielded == pdFALSE )
   \       0x28   0x.... 0x....      BL       xTaskResumeAll
   \       0x2C   0xB940             CBNZ.N   R0,??vTaskDelay_3
   1262          		{
   1263          			portYIELD_WITHIN_API();
   \                     ??vTaskDelay_0: (+1)
   \       0x2E   0x.... 0x....      LDR.W    R1,??DataTable37  ;; 0xe000ed04
   \       0x32   0xF04F 0x5080      MOV      R0,#+268435456
   \       0x36   0x6008             STR      R0,[R1, #+0]
   \       0x38   0xF3BF 0x8F4F      DSB      SY
   \       0x3C   0xF3BF 0x8F6F      ISB      SY
   1264          		}
   1265          		else
   1266          		{
   1267          			mtCOVERAGE_TEST_MARKER();
   1268          		}
   1269          	}
   \                     ??vTaskDelay_3: (+1)
   \       0x40   0xBD01             POP      {R0,PC}          ;; return
   1270          
   1271          #endif /* INCLUDE_vTaskDelay */
   1272          /*-----------------------------------------------------------*/
   1273          
   1274          #if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) )
   1275          

   \                                 In section .text, align 2, keep-with-next
   1276          	eTaskState eTaskGetState( TaskHandle_t xTask )
   1277          	{
   \                     eTaskGetState: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   1278          	eTaskState eReturn;
   1279          	List_t *pxStateList;
   1280          	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
   1281          
   1282          		configASSERT( pxTCB );
   \        0x4   0xD107             BNE.N    ??eTaskGetState_0
   \        0x6   0x2020             MOVS     R0,#+32
   \        0x8   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xC   0xF3BF 0x8F4F      DSB      SY
   \       0x10   0xF3BF 0x8F6F      ISB      SY
   \                     ??eTaskGetState_1: (+1)
   \       0x14   0xE7FE             B.N      ??eTaskGetState_1
   1283          
   1284          		if( pxTCB == pxCurrentTCB )
   \                     ??eTaskGetState_0: (+1)
   \       0x16   0x.... 0x....      LDR.W    R6,??DataTable36
   \       0x1A   0x6E70             LDR      R0,[R6, #+100]
   \       0x1C   0x4285             CMP      R5,R0
   \       0x1E   0xD101             BNE.N    ??eTaskGetState_2
   1285          		{
   1286          			/* The task calling this function is querying its own state. */
   1287          			eReturn = eRunning;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xBD70             POP      {R4-R6,PC}
   1288          		}
   1289          		else
   1290          		{
   1291          			taskENTER_CRITICAL();
   \                     ??eTaskGetState_2: (+1)
   \       0x24   0x.... 0x....      BL       vPortEnterCritical
   1292          			{
   1293          				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
   \       0x28   0x696C             LDR      R4,[R5, #+20]
   1294          			}
   1295          			taskEXIT_CRITICAL();
   \       0x2A   0x.... 0x....      BL       vPortExitCritical
   1296          
   1297          			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
   \       0x2E   0x6EB0             LDR      R0,[R6, #+104]
   \       0x30   0x4284             CMP      R4,R0
   \       0x32   0xBF1C             ITT      NE 
   \       0x34   0x6EF1             LDRNE    R1,[R6, #+108]
   \       0x36   0x428C             CMPNE    R4,R1
   \       0x38   0xD009             BEQ.N    ??eTaskGetState_3
   1298          			{
   1299          				/* The task being queried is referenced from one of the Blocked
   1300          				lists. */
   1301          				eReturn = eBlocked;
   1302          			}
   1303          
   1304          			#if ( INCLUDE_vTaskSuspend == 1 )
   1305          				else if( pxStateList == &xSuspendedTaskList )
   \       0x3A   0x.... 0x....      LDR.W    R0,??DataTable36_1
   \       0x3E   0xF100 0x012C      ADD      R1,R0,#+44
   \       0x42   0x428C             CMP      R4,R1
   \       0x44   0xD105             BNE.N    ??eTaskGetState_4
   1306          				{
   1307          					/* The task being queried is referenced from the suspended
   1308          					list.  Is it genuinely suspended or is it block
   1309          					indefinitely? */
   1310          					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
   \       0x46   0x6AA8             LDR      R0,[R5, #+40]
   \       0x48   0xB908             CBNZ.N   R0,??eTaskGetState_3
   1311          					{
   1312          						eReturn = eSuspended;
   \       0x4A   0x2003             MOVS     R0,#+3
   \       0x4C   0xBD70             POP      {R4-R6,PC}
   1313          					}
   1314          					else
   1315          					{
   1316          						eReturn = eBlocked;
   \                     ??eTaskGetState_3: (+1)
   \       0x4E   0x2002             MOVS     R0,#+2
   \       0x50   0xBD70             POP      {R4-R6,PC}
   1317          					}
   1318          				}
   1319          			#endif
   1320          
   1321          			#if ( INCLUDE_vTaskDelete == 1 )
   1322          				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
   \                     ??eTaskGetState_4: (+1)
   \       0x52   0x3014             ADDS     R0,R0,#+20
   \       0x54   0x4284             CMP      R4,R0
   \       0x56   0xBF18             IT       NE 
   \       0x58   0x2C00             CMPNE    R4,#+0
   \       0x5A   0xD101             BNE.N    ??eTaskGetState_5
   1323          				{
   1324          					/* The task being queried is referenced from the deleted
   1325          					tasks list, or it is not referenced from any lists at
   1326          					all. */
   1327          					eReturn = eDeleted;
   \       0x5C   0x2004             MOVS     R0,#+4
   \       0x5E   0xBD70             POP      {R4-R6,PC}
   1328          				}
   1329          			#endif
   1330          
   1331          			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
   1332          			{
   1333          				/* If the task is not in any other state, it must be in the
   1334          				Ready (including pending ready) state. */
   1335          				eReturn = eReady;
   \                     ??eTaskGetState_5: (+1)
   \       0x60   0x2001             MOVS     R0,#+1
   1336          			}
   1337          		}
   1338          
   1339          		return eReturn;
   \       0x62   0xBD70             POP      {R4-R6,PC}       ;; return
   1340          	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
   1341          
   1342          #endif /* INCLUDE_eTaskGetState */
   1343          /*-----------------------------------------------------------*/
   1344          
   1345          #if ( INCLUDE_uxTaskPriorityGet == 1 )
   1346          

   \                                 In section .text, align 2, keep-with-next
   1347          	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
   1348          	{
   \                     uxTaskPriorityGet: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   1349          	TCB_t *pxTCB;
   1350          	UBaseType_t uxReturn;
   1351          
   1352          		taskENTER_CRITICAL();
   \        0x4   0x.... 0x....      BL       vPortEnterCritical
   1353          		{
   1354          			/* If null is passed in here then it is the priority of the that
   1355          			called uxTaskPriorityGet() that is being queried. */
   1356          			pxTCB = prvGetTCBFromHandle( xTask );
   \        0x8   0xB914             CBNZ.N   R4,??uxTaskPriorityGet_0
   \        0xA   0x.... 0x....      LDR.W    R0,??DataTable36
   \        0xE   0x6E44             LDR      R4,[R0, #+100]
   1357          			uxReturn = pxTCB->uxPriority;
   \                     ??uxTaskPriorityGet_0: (+1)
   \       0x10   0x6AE4             LDR      R4,[R4, #+44]
   1358          		}
   1359          		taskEXIT_CRITICAL();
   \       0x12   0x.... 0x....      B.W      ?Subroutine1
   1360          
   1361          		return uxReturn;
   1362          	}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x.... 0x....      BL       vPortExitCritical
   \        0x4   0x4620             MOV      R0,R4
   \        0x6   0xBD10             POP      {R4,PC}          ;; return
   1363          
   1364          #endif /* INCLUDE_uxTaskPriorityGet */
   1365          /*-----------------------------------------------------------*/
   1366          
   1367          #if ( INCLUDE_uxTaskPriorityGet == 1 )
   1368          

   \                                 In section .text, align 2, keep-with-next
   1369          	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
   1370          	{
   \                     uxTaskPriorityGetFromISR: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   1371          	TCB_t *pxTCB;
   1372          	UBaseType_t uxReturn, uxSavedInterruptState;
   1373          
   1374          		/* RTOS ports that support interrupt nesting have the concept of a
   1375          		maximum	system call (or maximum API call) interrupt priority.
   1376          		Interrupts that are	above the maximum system call priority are keep
   1377          		permanently enabled, even when the RTOS kernel is in a critical section,
   1378          		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   1379          		is defined in FreeRTOSConfig.h then
   1380          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1381          		failure if a FreeRTOS API function is called from an interrupt that has
   1382          		been assigned a priority above the configured maximum system call
   1383          		priority.  Only FreeRTOS functions that end in FromISR can be called
   1384          		from interrupts	that have been assigned a priority at or (logically)
   1385          		below the maximum system call interrupt priority.  FreeRTOS maintains a
   1386          		separate interrupt safe API to ensure interrupt entry is as fast and as
   1387          		simple as possible.  More information (albeit Cortex-M specific) is
   1388          		provided on the following link:
   1389          		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1390          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   \        0x4   0x.... 0x....      BL       vPortValidateInterruptPriority
   1391          
   1392          		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
   \        0x8   0xF3EF 0x8111      MRS      R1,BASEPRI
   \        0xC   0x2020             MOVS     R0,#+32
   \        0xE   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x12   0xF3BF 0x8F4F      DSB      SY
   \       0x16   0xF3BF 0x8F6F      ISB      SY
   1393          		{
   1394          			/* If null is passed in here then it is the priority of the calling
   1395          			task that is being queried. */
   1396          			pxTCB = prvGetTCBFromHandle( xTask );
   \       0x1A   0xB914             CBNZ.N   R4,??uxTaskPriorityGetFromISR_0
   \       0x1C   0x.... 0x....      LDR.W    R0,??DataTable36
   \       0x20   0x6E44             LDR      R4,[R0, #+100]
   1397          			uxReturn = pxTCB->uxPriority;
   \                     ??uxTaskPriorityGetFromISR_0: (+1)
   \       0x22   0x6AE0             LDR      R0,[R4, #+44]
   1398          		}
   1399          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
   \       0x24   0xF381 0x8811      MSR      BASEPRI,R1
   1400          
   1401          		return uxReturn;
   \       0x28   0xBD10             POP      {R4,PC}          ;; return
   1402          	}
   1403          
   1404          #endif /* INCLUDE_uxTaskPriorityGet */
   1405          /*-----------------------------------------------------------*/
   1406          
   1407          #if ( INCLUDE_vTaskPrioritySet == 1 )
   1408          

   \                                 In section .text, align 2, keep-with-next
   1409          	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
   1410          	{
   \                     vTaskPrioritySet: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x460F             MOV      R7,R1
   1411          	TCB_t *pxTCB;
   1412          	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
   1413          	BaseType_t xYieldRequired = pdFALSE;
   \        0x6   0x2400             MOVS     R4,#+0
   1414          
   1415          		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
   \        0x8   0x2F05             CMP      R7,#+5
   \        0xA   0x4605             MOV      R5,R0
   \        0xC   0xD307             BCC.N    ??vTaskPrioritySet_0
   \        0xE   0x2020             MOVS     R0,#+32
   \       0x10   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x14   0xF3BF 0x8F4F      DSB      SY
   \       0x18   0xF3BF 0x8F6F      ISB      SY
   \                     ??vTaskPrioritySet_1: (+1)
   \       0x1C   0xE7FE             B.N      ??vTaskPrioritySet_1
   1416          
   1417          		/* Ensure the new priority is valid. */
   1418          		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   1419          		{
   1420          			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   1421          		}
   1422          		else
   1423          		{
   1424          			mtCOVERAGE_TEST_MARKER();
   1425          		}
   1426          
   1427          		taskENTER_CRITICAL();
   \                     ??vTaskPrioritySet_0: (+1)
   \       0x1E   0x.... 0x....      BL       vPortEnterCritical
   1428          		{
   1429          			/* If null is passed in here then it is the priority of the calling
   1430          			task that is being changed. */
   1431          			pxTCB = prvGetTCBFromHandle( xTask );
   \       0x22   0x.... 0x....      LDR.W    R6,??DataTable36
   \       0x26   0xB905             CBNZ.N   R5,??vTaskPrioritySet_2
   \       0x28   0x6E75             LDR      R5,[R6, #+100]
   1432          
   1433          			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
   1434          
   1435          			#if ( configUSE_MUTEXES == 1 )
   1436          			{
   1437          				uxCurrentBasePriority = pxTCB->uxBasePriority;
   \                     ??vTaskPrioritySet_2: (+1)
   \       0x2A   0x6D68             LDR      R0,[R5, #+84]
   1438          			}
   1439          			#else
   1440          			{
   1441          				uxCurrentBasePriority = pxTCB->uxPriority;
   1442          			}
   1443          			#endif
   1444          
   1445          			if( uxCurrentBasePriority != uxNewPriority )
   \       0x2C   0x42B8             CMP      R0,R7
   \       0x2E   0xD03E             BEQ.N    ??vTaskPrioritySet_3
   1446          			{
   1447          				/* The priority change may have readied a task of higher
   1448          				priority than the calling task. */
   1449          				if( uxNewPriority > uxCurrentBasePriority )
   \       0x30   0x6E71             LDR      R1,[R6, #+100]
   \       0x32   0xD206             BCS.N    ??vTaskPrioritySet_4
   1450          				{
   1451          					if( pxTCB != pxCurrentTCB )
   \       0x34   0x428D             CMP      R5,R1
   \       0x36   0xD007             BEQ.N    ??vTaskPrioritySet_5
   1452          					{
   1453          						/* The priority of a task other than the currently
   1454          						running task is being raised.  Is the priority being
   1455          						raised above that of the running task? */
   1456          						if( uxNewPriority >= pxCurrentTCB->uxPriority )
   \       0x38   0x6E72             LDR      R2,[R6, #+100]
   \       0x3A   0x6AD1             LDR      R1,[R2, #+44]
   \       0x3C   0x428F             CMP      R7,R1
   \       0x3E   0xD303             BCC.N    ??vTaskPrioritySet_5
   1457          						{
   1458          							xYieldRequired = pdTRUE;
   \       0x40   0xE001             B.N      ??vTaskPrioritySet_6
   1459          						}
   1460          						else
   1461          						{
   1462          							mtCOVERAGE_TEST_MARKER();
   1463          						}
   1464          					}
   1465          					else
   1466          					{
   1467          						/* The priority of the running task is being raised,
   1468          						but the running task must already be the highest
   1469          						priority task able to run so no yield is required. */
   1470          					}
   1471          				}
   1472          				else if( pxTCB == pxCurrentTCB )
   \                     ??vTaskPrioritySet_4: (+1)
   \       0x42   0x428D             CMP      R5,R1
   \       0x44   0xD100             BNE.N    ??vTaskPrioritySet_5
   1473          				{
   1474          					/* Setting the priority of the running task down means
   1475          					there may now be another task of higher priority that
   1476          					is ready to execute. */
   1477          					xYieldRequired = pdTRUE;
   \                     ??vTaskPrioritySet_6: (+1)
   \       0x46   0x2401             MOVS     R4,#+1
   1478          				}
   1479          				else
   1480          				{
   1481          					/* Setting the priority of any other task down does not
   1482          					require a yield as the running task must be above the
   1483          					new priority of the task being modified. */
   1484          				}
   1485          
   1486          				/* Remember the ready list the task might be referenced from
   1487          				before its uxPriority member is changed so the
   1488          				taskRESET_READY_PRIORITY() macro can function correctly. */
   1489          				uxPriorityUsedOnEntry = pxTCB->uxPriority;
   \                     ??vTaskPrioritySet_5: (+1)
   \       0x48   0xF8D5 0x802C      LDR      R8,[R5, #+44]
   1490          
   1491          				#if ( configUSE_MUTEXES == 1 )
   1492          				{
   1493          					/* Only change the priority being used if the task is not
   1494          					currently using an inherited priority. */
   1495          					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
   \       0x4C   0x4540             CMP      R0,R8
   \       0x4E   0xBF08             IT       EQ 
   \       0x50   0x62EF             STREQ    R7,[R5, #+44]
   1496          					{
   1497          						pxTCB->uxPriority = uxNewPriority;
   1498          					}
   1499          					else
   1500          					{
   1501          						mtCOVERAGE_TEST_MARKER();
   1502          					}
   1503          
   1504          					/* The base priority gets set whatever. */
   1505          					pxTCB->uxBasePriority = uxNewPriority;
   1506          				}
   1507          				#else
   1508          				{
   1509          					pxTCB->uxPriority = uxNewPriority;
   1510          				}
   1511          				#endif
   1512          
   1513          				/* Only reset the event list item value if the value is not
   1514          				being used for anything else. */
   1515          				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   \       0x52   0x69A8             LDR      R0,[R5, #+24]
   \       0x54   0x656F             STR      R7,[R5, #+84]
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xBF5C             ITT      PL 
   \       0x5A   0xF1C7 0x0705      RSBPL    R7,R7,#+5
   \       0x5E   0x61AF             STRPL    R7,[R5, #+24]
   1516          				{
   1517          					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1518          				}
   1519          				else
   1520          				{
   1521          					mtCOVERAGE_TEST_MARKER();
   1522          				}
   1523          
   1524          				/* If the task is in the blocked or suspended list we need do
   1525          				nothing more than change it's priority variable. However, if
   1526          				the task is in a ready list it needs to be removed and placed
   1527          				in the list appropriate to its new priority. */
   1528          				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
   \       0x60   0x6968             LDR      R0,[R5, #+20]
   \       0x62   0xEB08 0x0188      ADD      R1,R8,R8, LSL #+2
   \       0x66   0xEB06 0x0181      ADD      R1,R6,R1, LSL #+2
   \       0x6A   0x4288             CMP      R0,R1
   \       0x6C   0xD115             BNE.N    ??vTaskPrioritySet_7
   1529          				{
   1530          					/* The task is currently in its ready list - remove before adding
   1531          					it to it's new ready list.  As we are in a critical section we
   1532          					can do this even if the scheduler is suspended. */
   1533          					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   \       0x6E   0x1D28             ADDS     R0,R5,#+4
   \       0x70   0x.... 0x....      BL       uxListRemove
   \       0x74   0x2701             MOVS     R7,#+1
   \       0x76   0xB920             CBNZ.N   R0,??vTaskPrioritySet_8
   1534          					{
   1535          						/* It is known that the task is in its ready list so
   1536          						there is no need to check again and the port level
   1537          						reset macro can be called directly. */
   1538          						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
   \       0x78   0x6F70             LDR      R0,[R6, #+116]
   \       0x7A   0xFA07 0xF108      LSL      R1,R7,R8
   \       0x7E   0x4388             BICS     R0,R0,R1
   \       0x80   0x6770             STR      R0,[R6, #+116]
   1539          					}
   1540          					else
   1541          					{
   1542          						mtCOVERAGE_TEST_MARKER();
   1543          					}
   1544          					prvAddTaskToReadyList( pxTCB );
   \                     ??vTaskPrioritySet_8: (+1)
   \       0x82   0x6AE8             LDR      R0,[R5, #+44]
   \       0x84   0x6F71             LDR      R1,[R6, #+116]
   \       0x86   0x4087             LSLS     R7,R7,R0
   \       0x88   0x430F             ORRS     R7,R7,R1
   \       0x8A   0xEB00 0x0280      ADD      R2,R0,R0, LSL #+2
   \       0x8E   0x6777             STR      R7,[R6, #+116]
   \       0x90   0x1D29             ADDS     R1,R5,#+4
   \       0x92   0xEB06 0x0082      ADD      R0,R6,R2, LSL #+2
   \       0x96   0x.... 0x....      BL       vListInsertEnd
   1545          				}
   1546          				else
   1547          				{
   1548          					mtCOVERAGE_TEST_MARKER();
   1549          				}
   1550          
   1551          				if( xYieldRequired != pdFALSE )
   \                     ??vTaskPrioritySet_7: (+1)
   \       0x9A   0xB144             CBZ.N    R4,??vTaskPrioritySet_3
   1552          				{
   1553          					taskYIELD_IF_USING_PREEMPTION();
   \       0x9C   0x.... 0x....      LDR.W    R1,??DataTable37  ;; 0xe000ed04
   \       0xA0   0xF04F 0x5080      MOV      R0,#+268435456
   \       0xA4   0x6008             STR      R0,[R1, #+0]
   \       0xA6   0xF3BF 0x8F4F      DSB      SY
   \       0xAA   0xF3BF 0x8F6F      ISB      SY
   1554          				}
   1555          				else
   1556          				{
   1557          					mtCOVERAGE_TEST_MARKER();
   1558          				}
   1559          
   1560          				/* Remove compiler warning about unused variables when the port
   1561          				optimised task selection is not being used. */
   1562          				( void ) uxPriorityUsedOnEntry;
   1563          			}
   1564          		}
   1565          		taskEXIT_CRITICAL();
   \                     ??vTaskPrioritySet_3: (+1)
   \       0xAE   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0xB2   0x.... 0x....      B.W      vPortExitCritical
   1566          	}
   1567          
   1568          #endif /* INCLUDE_vTaskPrioritySet */
   1569          /*-----------------------------------------------------------*/
   1570          
   1571          #if ( INCLUDE_vTaskSuspend == 1 )
   1572          

   \                                 In section .text, align 2, keep-with-next
   1573          	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
   1574          	{
   \                     vTaskSuspend: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   1575          	TCB_t *pxTCB;
   1576          
   1577          		taskENTER_CRITICAL();
   \        0x4   0x.... 0x....      BL       vPortEnterCritical
   1578          		{
   1579          			/* If null is passed in here then it is the running task that is
   1580          			being suspended. */
   1581          			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
   \        0x8   0x.... 0x....      LDR.W    R5,??DataTable36
   \        0xC   0xB904             CBNZ.N   R4,??vTaskSuspend_0
   \        0xE   0x6E6C             LDR      R4,[R5, #+100]
   1582          
   1583          			traceTASK_SUSPEND( pxTCB );
   1584          
   1585          			/* Remove task from the ready/delayed list and place in the
   1586          			suspended list. */
   1587          			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   \                     ??vTaskSuspend_0: (+1)
   \       0x10   0x1D20             ADDS     R0,R4,#+4
   \       0x12   0x.... 0x....      BL       uxListRemove
   \       0x16   0xB960             CBNZ.N   R0,??vTaskSuspend_1
   1588          			{
   1589          				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   \       0x18   0x6AE1             LDR      R1,[R4, #+44]
   \       0x1A   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \       0x1E   0x0092             LSLS     R2,R2,#+2
   \       0x20   0x58A8             LDR      R0,[R5, R2]
   \       0x22   0xB930             CBNZ.N   R0,??vTaskSuspend_1
   \       0x24   0x6F68             LDR      R0,[R5, #+116]
   \       0x26   0x2201             MOVS     R2,#+1
   \       0x28   0xFA02 0xF101      LSL      R1,R2,R1
   \       0x2C   0xEA20 0x0101      BIC      R1,R0,R1
   \       0x30   0x6769             STR      R1,[R5, #+116]
   1590          			}
   1591          			else
   1592          			{
   1593          				mtCOVERAGE_TEST_MARKER();
   1594          			}
   1595          
   1596          			/* Is the task waiting on an event also? */
   1597          			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   \                     ??vTaskSuspend_1: (+1)
   \       0x32   0x6AA0             LDR      R0,[R4, #+40]
   \       0x34   0xB118             CBZ.N    R0,??vTaskSuspend_2
   1598          			{
   1599          				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   \       0x36   0xF104 0x0018      ADD      R0,R4,#+24
   \       0x3A   0x.... 0x....      BL       uxListRemove
   1600          			}
   1601          			else
   1602          			{
   1603          				mtCOVERAGE_TEST_MARKER();
   1604          			}
   1605          
   1606          			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
   \                     ??vTaskSuspend_2: (+1)
   \       0x3E   0x.... 0x....      LDR.W    R6,??DataTable36_1
   \       0x42   0x1D21             ADDS     R1,R4,#+4
   \       0x44   0xF106 0x002C      ADD      R0,R6,#+44
   \       0x48   0x.... 0x....      BL       vListInsertEnd
   1607          		}
   1608          		taskEXIT_CRITICAL();
   \       0x4C   0x.... 0x....      BL       vPortExitCritical
   1609          
   1610          		if( xSchedulerRunning != pdFALSE )
   \       0x50   0x6C70             LDR      R0,[R6, #+68]
   \       0x52   0xB128             CBZ.N    R0,??vTaskSuspend_3
   1611          		{
   1612          			/* Reset the next expected unblock time in case it referred to the
   1613          			task that is now in the Suspended state. */
   1614          			taskENTER_CRITICAL();
   \       0x54   0x.... 0x....      BL       vPortEnterCritical
   1615          			{
   1616          				prvResetNextTaskUnblockTime();
   \       0x58   0x.... 0x....      BL       prvResetNextTaskUnblockTime
   1617          			}
   1618          			taskEXIT_CRITICAL();
   \       0x5C   0x.... 0x....      BL       vPortExitCritical
   1619          		}
   1620          		else
   1621          		{
   1622          			mtCOVERAGE_TEST_MARKER();
   1623          		}
   1624          
   1625          		if( pxTCB == pxCurrentTCB )
   \                     ??vTaskSuspend_3: (+1)
   \       0x60   0x6E69             LDR      R1,[R5, #+100]
   \       0x62   0x428C             CMP      R4,R1
   \       0x64   0xD11F             BNE.N    ??vTaskSuspend_4
   1626          		{
   1627          			if( xSchedulerRunning != pdFALSE )
   \       0x66   0x6C70             LDR      R0,[R6, #+68]
   \       0x68   0xB198             CBZ.N    R0,??vTaskSuspend_5
   1628          			{
   1629          				/* The current task has just been suspended. */
   1630          				configASSERT( uxSchedulerSuspended == 0 );
   \       0x6A   0x6FE8             LDR      R0,[R5, #+124]
   \       0x6C   0xB138             CBZ.N    R0,??vTaskSuspend_6
   \       0x6E   0x2120             MOVS     R1,#+32
   \       0x70   0xF381 0x8811      MSR      BASEPRI,R1
   \       0x74   0xF3BF 0x8F4F      DSB      SY
   \       0x78   0xF3BF 0x8F6F      ISB      SY
   \                     ??vTaskSuspend_7: (+1)
   \       0x7C   0xE7FE             B.N      ??vTaskSuspend_7
   1631          				portYIELD_WITHIN_API();
   \                     ??vTaskSuspend_6: (+1)
   \       0x7E   0x.... 0x....      LDR.W    R1,??DataTable37  ;; 0xe000ed04
   \       0x82   0xF04F 0x5080      MOV      R0,#+268435456
   \       0x86   0x6008             STR      R0,[R1, #+0]
   \       0x88   0xF3BF 0x8F4F      DSB      SY
   \       0x8C   0xF3BF 0x8F6F      ISB      SY
   \       0x90   0xBD70             POP      {R4-R6,PC}
   1632          			}
   1633          			else
   1634          			{
   1635          				/* The scheduler is not running, but the task that was pointed
   1636          				to by pxCurrentTCB has just been suspended and pxCurrentTCB
   1637          				must be adjusted to point to a different task. */
   1638          				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
   \                     ??vTaskSuspend_5: (+1)
   \       0x92   0x6AF0             LDR      R0,[R6, #+44]
   \       0x94   0x6F29             LDR      R1,[R5, #+112]
   \       0x96   0x4288             CMP      R0,R1
   \       0x98   0xD102             BNE.N    ??vTaskSuspend_8
   1639          				{
   1640          					/* No other tasks are ready, so set pxCurrentTCB back to
   1641          					NULL so when the next task is created pxCurrentTCB will
   1642          					be set to point to it no matter what its relative priority
   1643          					is. */
   1644          					pxCurrentTCB = NULL;
   \       0x9A   0x2000             MOVS     R0,#+0
   \       0x9C   0x6668             STR      R0,[R5, #+100]
   \       0x9E   0xBD70             POP      {R4-R6,PC}
   1645          				}
   1646          				else
   1647          				{
   1648          					vTaskSwitchContext();
   \                     ??vTaskSuspend_8: (+1)
   \       0xA0   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0xA4   0x....             B.N      vTaskSwitchContext
   1649          				}
   1650          			}
   1651          		}
   1652          		else
   1653          		{
   1654          			mtCOVERAGE_TEST_MARKER();
   1655          		}
   1656          	}
   \                     ??vTaskSuspend_4: (+1)
   \       0xA6   0xBD70             POP      {R4-R6,PC}       ;; return
   1657          
   1658          #endif /* INCLUDE_vTaskSuspend */
   1659          /*-----------------------------------------------------------*/
   1660          
   1661          #if ( INCLUDE_vTaskSuspend == 1 )
   1662          

   \                                 In section .text, align 2, keep-with-next
   1663          	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
   1664          	{
   \                     prvTaskIsTaskSuspended: (+1)
   \        0x0   0x4601             MOV      R1,R0
   1665          	BaseType_t xReturn = pdFALSE;
   \        0x2   0x2000             MOVS     R0,#+0
   1666          	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
   1667          
   1668          		/* Accesses xPendingReadyList so must be called from a critical
   1669          		section. */
   1670          
   1671          		/* It does not make sense to check if the calling task is suspended. */
   1672          		configASSERT( xTask );
   \        0x4   0xB939             CBNZ.N   R1,??prvTaskIsTaskSuspended_0
   \        0x6   0x2020             MOVS     R0,#+32
   \        0x8   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xC   0xF3BF 0x8F4F      DSB      SY
   \       0x10   0xF3BF 0x8F6F      ISB      SY
   \                     ??prvTaskIsTaskSuspended_1: (+1)
   \       0x14   0xE7FE             B.N      ??prvTaskIsTaskSuspended_1
   1673          
   1674          		/* Is the task being resumed actually in the suspended list? */
   1675          		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
   \                     ??prvTaskIsTaskSuspended_0: (+1)
   \       0x16   0x.... 0x....      LDR.W    R2,??DataTable36_1
   \       0x1A   0x694B             LDR      R3,[R1, #+20]
   \       0x1C   0xF102 0x0C2C      ADD      R12,R2,#+44
   \       0x20   0x4563             CMP      R3,R12
   \       0x22   0xD104             BNE.N    ??prvTaskIsTaskSuspended_2
   1676          		{
   1677          			/* Has the task already been resumed from within an ISR? */
   1678          			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
   \       0x24   0x6A89             LDR      R1,[R1, #+40]
   \       0x26   0x4291             CMP      R1,R2
   \       0x28   0xD001             BEQ.N    ??prvTaskIsTaskSuspended_2
   1679          			{
   1680          				/* Is it in the suspended list because it is in the	Suspended
   1681          				state, or because is is blocked with no timeout? */
   1682          				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
   \       0x2A   0xB901             CBNZ.N   R1,??prvTaskIsTaskSuspended_2
   1683          				{
   1684          					xReturn = pdTRUE;
   \       0x2C   0x2001             MOVS     R0,#+1
   1685          				}
   1686          				else
   1687          				{
   1688          					mtCOVERAGE_TEST_MARKER();
   1689          				}
   1690          			}
   1691          			else
   1692          			{
   1693          				mtCOVERAGE_TEST_MARKER();
   1694          			}
   1695          		}
   1696          		else
   1697          		{
   1698          			mtCOVERAGE_TEST_MARKER();
   1699          		}
   1700          
   1701          		return xReturn;
   \                     ??prvTaskIsTaskSuspended_2: (+1)
   \       0x2E   0x4770             BX       LR               ;; return
   1702          	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
   1703          
   1704          #endif /* INCLUDE_vTaskSuspend */
   1705          /*-----------------------------------------------------------*/
   1706          
   1707          #if ( INCLUDE_vTaskSuspend == 1 )
   1708          

   \                                 In section .text, align 2, keep-with-next
   1709          	void vTaskResume( TaskHandle_t xTaskToResume )
   1710          	{
   \                     vTaskResume: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1711          	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
   1712          
   1713          		/* It does not make sense to resume the calling task. */
   1714          		configASSERT( xTaskToResume );
   \        0x4   0xD107             BNE.N    ??vTaskResume_0
   \        0x6   0x2020             MOVS     R0,#+32
   \        0x8   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xC   0xF3BF 0x8F4F      DSB      SY
   \       0x10   0xF3BF 0x8F6F      ISB      SY
   \                     ??vTaskResume_1: (+1)
   \       0x14   0xE7FE             B.N      ??vTaskResume_1
   1715          
   1716          		/* The parameter cannot be NULL as it is impossible to resume the
   1717          		currently executing task. */
   1718          		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
   \                     ??vTaskResume_0: (+1)
   \       0x16   0x.... 0x....      LDR.W    R5,??DataTable36
   \       0x1A   0x6E68             LDR      R0,[R5, #+100]
   \       0x1C   0x4284             CMP      R4,R0
   \       0x1E   0xD027             BEQ.N    ??vTaskResume_2
   1719          		{
   1720          			taskENTER_CRITICAL();
   \       0x20   0x.... 0x....      BL       vPortEnterCritical
   1721          			{
   1722          				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
   \       0x24   0x4620             MOV      R0,R4
   \       0x26   0x.... 0x....      BL       prvTaskIsTaskSuspended
   \       0x2A   0xB1E8             CBZ.N    R0,??vTaskResume_3
   1723          				{
   1724          					traceTASK_RESUME( pxTCB );
   1725          
   1726          					/* As we are in a critical section we can access the ready
   1727          					lists even if the scheduler is suspended. */
   1728          					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
   \       0x2C   0x1D20             ADDS     R0,R4,#+4
   \       0x2E   0x.... 0x....      BL       uxListRemove
   1729          					prvAddTaskToReadyList( pxTCB );
   \       0x32   0x6AE0             LDR      R0,[R4, #+44]
   \       0x34   0x6F69             LDR      R1,[R5, #+116]
   \       0x36   0x2201             MOVS     R2,#+1
   \       0x38   0x4082             LSLS     R2,R2,R0
   \       0x3A   0x4311             ORRS     R1,R2,R1
   \       0x3C   0x6769             STR      R1,[R5, #+116]
   \       0x3E   0xEB00 0x0380      ADD      R3,R0,R0, LSL #+2
   \       0x42   0x1D21             ADDS     R1,R4,#+4
   \       0x44   0xEB05 0x0083      ADD      R0,R5,R3, LSL #+2
   \       0x48   0x.... 0x....      BL       vListInsertEnd
   1730          
   1731          					/* We may have just resumed a higher priority task. */
   1732          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   \       0x4C   0x6AE0             LDR      R0,[R4, #+44]
   \       0x4E   0x6E69             LDR      R1,[R5, #+100]
   \       0x50   0x6ACA             LDR      R2,[R1, #+44]
   \       0x52   0x4290             CMP      R0,R2
   \       0x54   0xD308             BCC.N    ??vTaskResume_3
   1733          					{
   1734          						/* This yield may not cause the task just resumed to run,
   1735          						but will leave the lists in the correct state for the
   1736          						next yield. */
   1737          						taskYIELD_IF_USING_PREEMPTION();
   \       0x56   0x.... 0x....      LDR.W    R1,??DataTable37  ;; 0xe000ed04
   \       0x5A   0xF04F 0x5080      MOV      R0,#+268435456
   \       0x5E   0x6008             STR      R0,[R1, #+0]
   \       0x60   0xF3BF 0x8F4F      DSB      SY
   \       0x64   0xF3BF 0x8F6F      ISB      SY
   1738          					}
   1739          					else
   1740          					{
   1741          						mtCOVERAGE_TEST_MARKER();
   1742          					}
   1743          				}
   1744          				else
   1745          				{
   1746          					mtCOVERAGE_TEST_MARKER();
   1747          				}
   1748          			}
   1749          			taskEXIT_CRITICAL();
   \                     ??vTaskResume_3: (+1)
   \       0x68   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \       0x6C   0x.... 0x....      B.W      vPortExitCritical
   1750          		}
   1751          		else
   1752          		{
   1753          			mtCOVERAGE_TEST_MARKER();
   1754          		}
   1755          	}
   \                     ??vTaskResume_2: (+1)
   \       0x70   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1756          
   1757          #endif /* INCLUDE_vTaskSuspend */
   1758          
   1759          /*-----------------------------------------------------------*/
   1760          
   1761          #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
   1762          

   \                                 In section .text, align 2, keep-with-next
   1763          	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
   1764          	{
   \                     xTaskResumeFromISR: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   1765          	BaseType_t xYieldRequired = pdFALSE;
   \        0x4   0x2500             MOVS     R5,#+0
   1766          	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
   1767          	UBaseType_t uxSavedInterruptStatus;
   1768          
   1769          		configASSERT( xTaskToResume );
   \        0x6   0x2720             MOVS     R7,#+32
   \        0x8   0xB934             CBNZ.N   R4,??xTaskResumeFromISR_0
   \        0xA   0xF387 0x8811      MSR      BASEPRI,R7
   \        0xE   0xF3BF 0x8F4F      DSB      SY
   \       0x12   0xF3BF 0x8F6F      ISB      SY
   \                     ??xTaskResumeFromISR_1: (+1)
   \       0x16   0xE7FE             B.N      ??xTaskResumeFromISR_1
   1770          
   1771          		/* RTOS ports that support interrupt nesting have the concept of a
   1772          		maximum	system call (or maximum API call) interrupt priority.
   1773          		Interrupts that are	above the maximum system call priority are keep
   1774          		permanently enabled, even when the RTOS kernel is in a critical section,
   1775          		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   1776          		is defined in FreeRTOSConfig.h then
   1777          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1778          		failure if a FreeRTOS API function is called from an interrupt that has
   1779          		been assigned a priority above the configured maximum system call
   1780          		priority.  Only FreeRTOS functions that end in FromISR can be called
   1781          		from interrupts	that have been assigned a priority at or (logically)
   1782          		below the maximum system call interrupt priority.  FreeRTOS maintains a
   1783          		separate interrupt safe API to ensure interrupt entry is as fast and as
   1784          		simple as possible.  More information (albeit Cortex-M specific) is
   1785          		provided on the following link:
   1786          		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1787          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   \                     ??xTaskResumeFromISR_0: (+1)
   \       0x18   0x.... 0x....      BL       vPortValidateInterruptPriority
   1788          
   1789          		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \       0x1C   0xF3EF 0x8611      MRS      R6,BASEPRI
   \       0x20   0xF387 0x8811      MSR      BASEPRI,R7
   \       0x24   0xF3BF 0x8F4F      DSB      SY
   \       0x28   0xF3BF 0x8F6F      ISB      SY
   1790          		{
   1791          			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
   \       0x2C   0x4620             MOV      R0,R4
   \       0x2E   0x.... 0x....      BL       prvTaskIsTaskSuspended
   \       0x32   0xB1F0             CBZ.N    R0,??xTaskResumeFromISR_2
   1792          			{
   1793          				traceTASK_RESUME_FROM_ISR( pxTCB );
   1794          
   1795          				/* Check the ready lists can be accessed. */
   1796          				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   \       0x34   0x.... 0x....      LDR.W    R7,??DataTable36
   \       0x38   0x6FF8             LDR      R0,[R7, #+124]
   \       0x3A   0xB9A0             CBNZ.N   R0,??xTaskResumeFromISR_3
   1797          				{
   1798          					/* Ready lists can be accessed so move the task from the
   1799          					suspended list to the ready list directly. */
   1800          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   \       0x3C   0x6AE0             LDR      R0,[R4, #+44]
   \       0x3E   0x6E79             LDR      R1,[R7, #+100]
   \       0x40   0x6ACA             LDR      R2,[R1, #+44]
   \       0x42   0x4290             CMP      R0,R2
   \       0x44   0xBF28             IT       CS 
   \       0x46   0x2501             MOVCS    R5,#+1
   1801          					{
   1802          						xYieldRequired = pdTRUE;
   1803          					}
   1804          					else
   1805          					{
   1806          						mtCOVERAGE_TEST_MARKER();
   1807          					}
   1808          
   1809          					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   \       0x48   0x1D20             ADDS     R0,R4,#+4
   \       0x4A   0x.... 0x....      BL       uxListRemove
   1810          					prvAddTaskToReadyList( pxTCB );
   \       0x4E   0x6AE0             LDR      R0,[R4, #+44]
   \       0x50   0x6F79             LDR      R1,[R7, #+116]
   \       0x52   0x2201             MOVS     R2,#+1
   \       0x54   0x4082             LSLS     R2,R2,R0
   \       0x56   0x4311             ORRS     R1,R2,R1
   \       0x58   0x6779             STR      R1,[R7, #+116]
   \       0x5A   0xEB00 0x0380      ADD      R3,R0,R0, LSL #+2
   \       0x5E   0x1D21             ADDS     R1,R4,#+4
   \       0x60   0xEB07 0x0083      ADD      R0,R7,R3, LSL #+2
   \       0x64   0xE003             B.N      ??xTaskResumeFromISR_4
   1811          				}
   1812          				else
   1813          				{
   1814          					/* The delayed or ready lists cannot be accessed so the task
   1815          					is held in the pending ready list until the scheduler is
   1816          					unsuspended. */
   1817          					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   \                     ??xTaskResumeFromISR_3: (+1)
   \       0x66   0xF104 0x0118      ADD      R1,R4,#+24
   \       0x6A   0x.... 0x....      LDR.W    R0,??DataTable36_1
   \                     ??xTaskResumeFromISR_4: (+1)
   \       0x6E   0x.... 0x....      BL       vListInsertEnd
   1818          				}
   1819          			}
   1820          			else
   1821          			{
   1822          				mtCOVERAGE_TEST_MARKER();
   1823          			}
   1824          		}
   1825          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xTaskResumeFromISR_2: (+1)
   \       0x72   0xF386 0x8811      MSR      BASEPRI,R6
   1826          
   1827          		return xYieldRequired;
   \       0x76   0x4628             MOV      R0,R5
   \       0x78   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1828          	}
   1829          
   1830          #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
   1831          /*-----------------------------------------------------------*/
   1832          

   \                                 In section .text, align 4, keep-with-next
   1833          void vTaskStartScheduler( void )
   1834          {
   \                     vTaskStartScheduler: (+1)
   \        0x0   0xE92D 0x403E      PUSH.W   {R1-R5,LR}
   1835          BaseType_t xReturn;
   1836          
   1837          	/* Add the idle task at the lowest priority. */
   1838          	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
   1839          	{
   1840          		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
   1841          		StackType_t *pxIdleTaskStackBuffer = NULL;
   1842          		uint32_t ulIdleTaskStackSize;
   1843          
   1844          		/* The Idle task is created using user provided RAM - obtain the
   1845          		address of the RAM then create the idle task. */
   1846          		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
   1847          		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
   1848          												"IDLE",
   1849          												ulIdleTaskStackSize,
   1850          												( void * ) NULL,
   1851          												( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
   1852          												pxIdleTaskStackBuffer,
   1853          												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
   1854          
   1855          		if( xIdleTaskHandle != NULL )
   1856          		{
   1857          			xReturn = pdPASS;
   1858          		}
   1859          		else
   1860          		{
   1861          			xReturn = pdFAIL;
   1862          		}
   1863          	}
   1864          	#else
   1865          	{
   1866          		/* The Idle task is being created using dynamically allocated RAM. */
   1867          		xReturn = xTaskCreate(	prvIdleTask,
   1868          								"IDLE", configMINIMAL_STACK_SIZE,
   1869          								( void * ) NULL,
   1870          								( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
   1871          								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
   \        0x4   0x.... 0x....      LDR.W    R4,??DataTable36_1
   \        0x8   0x....             ADR.N    R1,?_0
   \        0xA   0xF104 0x0058      ADD      R0,R4,#+88
   \        0xE   0x9001             STR      R0,[SP, #+4]
   \       0x10   0x2500             MOVS     R5,#+0
   \       0x12   0x9500             STR      R5,[SP, #+0]
   \       0x14   0x2300             MOVS     R3,#+0
   \       0x16   0xF44F 0x7280      MOV      R2,#+256
   \       0x1A   0x.... 0x....      ADR.W    R0,prvIdleTask
   \       0x1E   0x.... 0x....      BL       xTaskCreate
   1872          	}
   1873          	#endif /* configSUPPORT_STATIC_ALLOCATION */
   1874          
   1875          	#if ( configUSE_TIMERS == 1 )
   1876          	{
   1877          		if( xReturn == pdPASS )
   \       0x22   0x2801             CMP      R0,#+1
   \       0x24   0xBF08             IT       EQ 
   1878          		{
   1879          			xReturn = xTimerCreateTimerTask();
   \       0x26   0x.... 0x....      BLEQ     xTimerCreateTimerTask
   1880          		}
   1881          		else
   1882          		{
   1883          			mtCOVERAGE_TEST_MARKER();
   1884          		}
   1885          	}
   1886          	#endif /* configUSE_TIMERS */
   1887          
   1888          	if( xReturn == pdPASS )
   \       0x2A   0x2801             CMP      R0,#+1
   \       0x2C   0xD113             BNE.N    ??vTaskStartScheduler_0
   1889          	{
   1890          		/* Interrupts are turned off here, to ensure a tick does not occur
   1891          		before or during the call to xPortStartScheduler().  The stacks of
   1892          		the created tasks contain a status word with interrupts switched on
   1893          		so interrupts will automatically get re-enabled when the first task
   1894          		starts to run. */
   1895          		portDISABLE_INTERRUPTS();
   \       0x2E   0x2020             MOVS     R0,#+32
   \       0x30   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x34   0xF3BF 0x8F4F      DSB      SY
   \       0x38   0xF3BF 0x8F6F      ISB      SY
   1896          
   1897          		#if ( configUSE_NEWLIB_REENTRANT == 1 )
   1898          		{
   1899          			/* Switch Newlib's _impure_ptr variable to point to the _reent
   1900          			structure specific to the task that will run first. */
   1901          			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
   1902          		}
   1903          		#endif /* configUSE_NEWLIB_REENTRANT */
   1904          
   1905          		xNextTaskUnblockTime = portMAX_DELAY;
   \       0x3C   0xF04F 0x30FF      MOV      R0,#-1
   \       0x40   0x6560             STR      R0,[R4, #+84]
   1906          		xSchedulerRunning = pdTRUE;
   \       0x42   0x2101             MOVS     R1,#+1
   \       0x44   0x6461             STR      R1,[R4, #+68]
   1907          		xTickCount = ( TickType_t ) 0U;
   \       0x46   0x6425             STR      R5,[R4, #+64]
   1908          
   1909          		/* If configGENERATE_RUN_TIME_STATS is defined then the following
   1910          		macro must be defined to configure the timer/counter used to generate
   1911          		the run time counter time base. */
   1912          		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
   1913          
   1914          		/* Setting up the timer tick is hardware specific and thus in the
   1915          		portable interface. */
   1916          		if( xPortStartScheduler() != pdFALSE )
   \       0x48   0xB003             ADD      SP,SP,#+12
   \       0x4A   0xE8BD 0x4030      POP      {R4,R5,LR}
   \       0x4E   0x.... 0x....      B.W      xPortStartScheduler
   1917          		{
   1918          			/* Should not reach here as if the scheduler is running the
   1919          			function will not return. */
   1920          		}
   1921          		else
   1922          		{
   1923          			/* Should only reach here if a task calls xTaskEndScheduler(). */
   1924          		}
   1925          	}
   1926          	else
   1927          	{
   1928          		/* This line will only be reached if the kernel could not be started,
   1929          		because there was not enough FreeRTOS heap to create the idle task
   1930          		or the timer task. */
   1931          		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
   1932          	}
   1933          
   1934          	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
   1935          	meaning xIdleTaskHandle is not used anywhere else. */
   1936          	( void ) xIdleTaskHandle;
   1937          }
   \                     ??vTaskStartScheduler_1: (+1)
   \       0x52   0xB003             ADD      SP,SP,#+12
   \       0x54   0xBD30             POP      {R4,R5,PC}       ;; return
   \                     ??vTaskStartScheduler_0: (+1)
   \       0x56   0xF110 0x0F01      CMN      R0,#+1
   \       0x5A   0xD1FA             BNE.N    ??vTaskStartScheduler_1
   \       0x5C   0x2020             MOVS     R0,#+32
   \       0x5E   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x62   0xF3BF 0x8F4F      DSB      SY
   \       0x66   0xF3BF 0x8F6F      ISB      SY
   \                     ??vTaskStartScheduler_2: (+1)
   \       0x6A   0xE7FE             B.N      ??vTaskStartScheduler_2
   1938          /*-----------------------------------------------------------*/
   1939          

   \                                 In section .text, align 2, keep-with-next
   1940          void vTaskEndScheduler( void )
   1941          {
   1942          	/* Stop the scheduler interrupts and call the portable scheduler end
   1943          	routine so the original ISRs can be restored if necessary.  The port
   1944          	layer must ensure interrupts enable	bit is left in the correct state. */
   1945          	portDISABLE_INTERRUPTS();
   \                     vTaskEndScheduler: (+1)
   \        0x0   0x2020             MOVS     R0,#+32
   \        0x2   0xF380 0x8811      MSR      BASEPRI,R0
   \        0x6   0xF3BF 0x8F4F      DSB      SY
   \        0xA   0xF3BF 0x8F6F      ISB      SY
   1946          	xSchedulerRunning = pdFALSE;
   \        0xE   0x.... 0x....      LDR.W    R1,??DataTable36_1
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x6448             STR      R0,[R1, #+68]
   1947          	vPortEndScheduler();
   \       0x16   0x.... 0x....      B.W      vPortEndScheduler
   1948          }
   1949          /*----------------------------------------------------------*/
   1950          

   \                                 In section .text, align 2, keep-with-next
   1951          void vTaskSuspendAll( void )
   1952          {
   1953          	/* A critical section is not required as the variable is of type
   1954          	BaseType_t.  Please read Richard Barry's reply in the following link to a
   1955          	post in the FreeRTOS support forum before reporting this as a bug! -
   1956          	http://goo.gl/wu4acr */
   1957          	++uxSchedulerSuspended;
   \                     vTaskSuspendAll: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable36
   \        0x4   0x6FC1             LDR      R1,[R0, #+124]
   \        0x6   0x1C49             ADDS     R1,R1,#+1
   \        0x8   0x67C1             STR      R1,[R0, #+124]
   1958          }
   \        0xA   0x4770             BX       LR               ;; return
   1959          /*----------------------------------------------------------*/
   1960          
   1961          #if ( configUSE_TICKLESS_IDLE != 0 )
   1962          
   1963          	static TickType_t prvGetExpectedIdleTime( void )
   1964          	{
   1965          	TickType_t xReturn;
   1966          	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
   1967          
   1968          		/* uxHigherPriorityReadyTasks takes care of the case where
   1969          		configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
   1970          		task that are in the Ready state, even though the idle task is
   1971          		running. */
   1972          		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
   1973          		{
   1974          			if( uxTopReadyPriority > tskIDLE_PRIORITY )
   1975          			{
   1976          				uxHigherPriorityReadyTasks = pdTRUE;
   1977          			}
   1978          		}
   1979          		#else
   1980          		{
   1981          			const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
   1982          
   1983          			/* When port optimised task selection is used the uxTopReadyPriority
   1984          			variable is used as a bit map.  If bits other than the least
   1985          			significant bit are set then there are tasks that have a priority
   1986          			above the idle priority that are in the Ready state.  This takes
   1987          			care of the case where the co-operative scheduler is in use. */
   1988          			if( uxTopReadyPriority > uxLeastSignificantBit )
   1989          			{
   1990          				uxHigherPriorityReadyTasks = pdTRUE;
   1991          			}
   1992          		}
   1993          		#endif
   1994          
   1995          		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
   1996          		{
   1997          			xReturn = 0;
   1998          		}
   1999          		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
   2000          		{
   2001          			/* There are other idle priority tasks in the ready state.  If
   2002          			time slicing is used then the very next tick interrupt must be
   2003          			processed. */
   2004          			xReturn = 0;
   2005          		}
   2006          		else if( uxHigherPriorityReadyTasks != pdFALSE )
   2007          		{
   2008          			/* There are tasks in the Ready state that have a priority above the
   2009          			idle priority.  This path can only be reached if
   2010          			configUSE_PREEMPTION is 0. */
   2011          			xReturn = 0;
   2012          		}
   2013          		else
   2014          		{
   2015          			xReturn = xNextTaskUnblockTime - xTickCount;
   2016          		}
   2017          
   2018          		return xReturn;
   2019          	}
   2020          
   2021          #endif /* configUSE_TICKLESS_IDLE */
   2022          /*----------------------------------------------------------*/
   2023          

   \                                 In section .text, align 2, keep-with-next
   2024          BaseType_t xTaskResumeAll( void )
   2025          {
   \                     xTaskResumeAll: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   2026          TCB_t *pxTCB = NULL;
   2027          BaseType_t xAlreadyYielded = pdFALSE;
   2028          
   2029          	/* If uxSchedulerSuspended is zero then this function does not match a
   2030          	previous call to vTaskSuspendAll(). */
   2031          	configASSERT( uxSchedulerSuspended );
   \        0x2   0x.... 0x....      LDR.W    R6,??DataTable36
   \        0x6   0x6FF0             LDR      R0,[R6, #+124]
   \        0x8   0x2400             MOVS     R4,#+0
   \        0xA   0x2500             MOVS     R5,#+0
   \        0xC   0xB938             CBNZ.N   R0,??xTaskResumeAll_0
   \        0xE   0x2120             MOVS     R1,#+32
   \       0x10   0xF381 0x8811      MSR      BASEPRI,R1
   \       0x14   0xF3BF 0x8F4F      DSB      SY
   \       0x18   0xF3BF 0x8F6F      ISB      SY
   \                     ??xTaskResumeAll_1: (+1)
   \       0x1C   0xE7FE             B.N      ??xTaskResumeAll_1
   2032          
   2033          	/* It is possible that an ISR caused a task to be removed from an event
   2034          	list while the scheduler was suspended.  If this was the case then the
   2035          	removed task will have been added to the xPendingReadyList.  Once the
   2036          	scheduler has been resumed it is safe to move all the pending ready
   2037          	tasks from this list into their appropriate ready list. */
   2038          	taskENTER_CRITICAL();
   \                     ??xTaskResumeAll_0: (+1)
   \       0x1E   0x.... 0x....      BL       vPortEnterCritical
   2039          	{
   2040          		--uxSchedulerSuspended;
   \       0x22   0x6FF0             LDR      R0,[R6, #+124]
   \       0x24   0x1E40             SUBS     R0,R0,#+1
   \       0x26   0x67F0             STR      R0,[R6, #+124]
   2041          
   2042          		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   \       0x28   0x6FF0             LDR      R0,[R6, #+124]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD13E             BNE.N    ??xTaskResumeAll_2
   2043          		{
   2044          			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
   \       0x2E   0x6F30             LDR      R0,[R6, #+112]
   \       0x30   0x.... 0x....      LDR.W    R7,??DataTable36_1
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD11D             BNE.N    ??xTaskResumeAll_3
   \       0x38   0xE038             B.N      ??xTaskResumeAll_2
   2045          			{
   2046          				/* Move any readied tasks from the pending list into the
   2047          				appropriate ready list. */
   2048          				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   2049          				{
   2050          					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
   \                     ??xTaskResumeAll_4: (+1)
   \       0x3A   0x68F8             LDR      R0,[R7, #+12]
   \       0x3C   0x68C4             LDR      R4,[R0, #+12]
   2051          					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   \       0x3E   0xF104 0x0018      ADD      R0,R4,#+24
   \       0x42   0x.... 0x....      BL       uxListRemove
   2052          					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   \       0x46   0x1D20             ADDS     R0,R4,#+4
   \       0x48   0x.... 0x....      BL       uxListRemove
   2053          					prvAddTaskToReadyList( pxTCB );
   \       0x4C   0x6AE0             LDR      R0,[R4, #+44]
   \       0x4E   0x6F71             LDR      R1,[R6, #+116]
   \       0x50   0x2201             MOVS     R2,#+1
   \       0x52   0x4082             LSLS     R2,R2,R0
   \       0x54   0x4311             ORRS     R1,R2,R1
   \       0x56   0x6771             STR      R1,[R6, #+116]
   \       0x58   0xEB00 0x0380      ADD      R3,R0,R0, LSL #+2
   \       0x5C   0x1D21             ADDS     R1,R4,#+4
   \       0x5E   0xEB06 0x0083      ADD      R0,R6,R3, LSL #+2
   \       0x62   0x.... 0x....      BL       vListInsertEnd
   2054          
   2055          					/* If the moved task has a priority higher than the current
   2056          					task then a yield must be performed. */
   2057          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   \       0x66   0x6AE0             LDR      R0,[R4, #+44]
   \       0x68   0x6E71             LDR      R1,[R6, #+100]
   \       0x6A   0x6ACA             LDR      R2,[R1, #+44]
   \       0x6C   0x4290             CMP      R0,R2
   \       0x6E   0xBF24             ITT      CS 
   \       0x70   0x2001             MOVCS    R0,#+1
   \       0x72   0x67B0             STRCS    R0,[R6, #+120]
   2058          					{
   2059          						xYieldPending = pdTRUE;
   2060          					}
   2061          					else
   2062          					{
   2063          						mtCOVERAGE_TEST_MARKER();
   2064          					}
   2065          				}
   \                     ??xTaskResumeAll_3: (+1)
   \       0x74   0x6838             LDR      R0,[R7, #+0]
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD1DF             BNE.N    ??xTaskResumeAll_4
   2066          
   2067          				if( pxTCB != NULL )
   \       0x7A   0xB10C             CBZ.N    R4,??xTaskResumeAll_5
   2068          				{
   2069          					/* A task was unblocked while the scheduler was suspended,
   2070          					which may have prevented the next unblock time from being
   2071          					re-calculated, in which case re-calculate it now.  Mainly
   2072          					important for low power tickless implementations, where
   2073          					this can prevent an unnecessary exit from low power
   2074          					state. */
   2075          					prvResetNextTaskUnblockTime();
   \       0x7C   0x.... 0x....      BL       prvResetNextTaskUnblockTime
   2076          				}
   2077          
   2078          				/* If any ticks occurred while the scheduler was suspended then
   2079          				they should be processed now.  This ensures the tick count does
   2080          				not	slip, and that any delayed tasks are resumed at the correct
   2081          				time. */
   2082          				{
   2083          					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
   \                     ??xTaskResumeAll_5: (+1)
   \       0x80   0x6CBC             LDR      R4,[R7, #+72]
   2084          
   2085          					if( uxPendedCounts > ( UBaseType_t ) 0U )
   \       0x82   0xB13C             CBZ.N    R4,??xTaskResumeAll_6
   2086          					{
   2087          						do
   2088          						{
   2089          							if( xTaskIncrementTick() != pdFALSE )
   \                     ??xTaskResumeAll_7: (+1)
   \       0x84   0x.... 0x....      BL       xTaskIncrementTick
   \       0x88   0xB108             CBZ.N    R0,??xTaskResumeAll_8
   2090          							{
   2091          								xYieldPending = pdTRUE;
   \       0x8A   0x2001             MOVS     R0,#+1
   \       0x8C   0x67B0             STR      R0,[R6, #+120]
   2092          							}
   2093          							else
   2094          							{
   2095          								mtCOVERAGE_TEST_MARKER();
   2096          							}
   2097          							--uxPendedCounts;
   \                     ??xTaskResumeAll_8: (+1)
   \       0x8E   0x1E64             SUBS     R4,R4,#+1
   2098          						} while( uxPendedCounts > ( UBaseType_t ) 0U );
   \       0x90   0xD1F8             BNE.N    ??xTaskResumeAll_7
   2099          
   2100          						uxPendedTicks = 0;
   \       0x92   0x64BD             STR      R5,[R7, #+72]
   2101          					}
   2102          					else
   2103          					{
   2104          						mtCOVERAGE_TEST_MARKER();
   2105          					}
   2106          				}
   2107          
   2108          				if( xYieldPending != pdFALSE )
   \                     ??xTaskResumeAll_6: (+1)
   \       0x94   0x6FB0             LDR      R0,[R6, #+120]
   \       0x96   0xB148             CBZ.N    R0,??xTaskResumeAll_2
   2109          				{
   2110          					#if( configUSE_PREEMPTION != 0 )
   2111          					{
   2112          						xAlreadyYielded = pdTRUE;
   2113          					}
   2114          					#endif
   2115          					taskYIELD_IF_USING_PREEMPTION();
   \       0x98   0x.... 0x....      LDR.W    R1,??DataTable37  ;; 0xe000ed04
   \       0x9C   0xF04F 0x5080      MOV      R0,#+268435456
   \       0xA0   0x2501             MOVS     R5,#+1
   \       0xA2   0x6008             STR      R0,[R1, #+0]
   \       0xA4   0xF3BF 0x8F4F      DSB      SY
   \       0xA8   0xF3BF 0x8F6F      ISB      SY
   2116          				}
   2117          				else
   2118          				{
   2119          					mtCOVERAGE_TEST_MARKER();
   2120          				}
   2121          			}
   2122          		}
   2123          		else
   2124          		{
   2125          			mtCOVERAGE_TEST_MARKER();
   2126          		}
   2127          	}
   2128          	taskEXIT_CRITICAL();
   \                     ??xTaskResumeAll_2: (+1)
   \       0xAC   0x.... 0x....      BL       vPortExitCritical
   2129          
   2130          	return xAlreadyYielded;
   \       0xB0   0x4628             MOV      R0,R5
   \       0xB2   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2131          }
   2132          /*-----------------------------------------------------------*/
   2133          

   \                                 In section .text, align 2, keep-with-next
   2134          TickType_t xTaskGetTickCount( void )
   2135          {
   2136          TickType_t xTicks;
   2137          
   2138          	/* Critical section required if running on a 16 bit processor. */
   2139          	portTICK_TYPE_ENTER_CRITICAL();
   2140          	{
   2141          		xTicks = xTickCount;
   2142          	}
   2143          	portTICK_TYPE_EXIT_CRITICAL();
   2144          
   2145          	return xTicks;
   \                     xTaskGetTickCount: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable52
   \        0x4   0x6C00             LDR      R0,[R0, #+64]
   \        0x6   0x4770             BX       LR               ;; return
   2146          }
   2147          /*-----------------------------------------------------------*/
   2148          

   \                                 In section .text, align 2, keep-with-next
   2149          TickType_t xTaskGetTickCountFromISR( void )
   2150          {
   \                     xTaskGetTickCountFromISR: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   2151          TickType_t xReturn;
   2152          UBaseType_t uxSavedInterruptStatus;
   2153          
   2154          	/* RTOS ports that support interrupt nesting have the concept of a maximum
   2155          	system call (or maximum API call) interrupt priority.  Interrupts that are
   2156          	above the maximum system call priority are kept permanently enabled, even
   2157          	when the RTOS kernel is in a critical section, but cannot make any calls to
   2158          	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
   2159          	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   2160          	failure if a FreeRTOS API function is called from an interrupt that has been
   2161          	assigned a priority above the configured maximum system call priority.
   2162          	Only FreeRTOS functions that end in FromISR can be called from interrupts
   2163          	that have been assigned a priority at or (logically) below the maximum
   2164          	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
   2165          	safe API to ensure interrupt entry is as fast and as simple as possible.
   2166          	More information (albeit Cortex-M specific) is provided on the following
   2167          	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   2168          	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   \        0x2   0x.... 0x....      BL       vPortValidateInterruptPriority
   2169          
   2170          	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
   2171          	{
   2172          		xReturn = xTickCount;
   2173          	}
   2174          	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   2175          
   2176          	return xReturn;
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable52
   \        0xA   0x6C00             LDR      R0,[R0, #+64]
   \        0xC   0xBD02             POP      {R1,PC}          ;; return
   2177          }
   2178          /*-----------------------------------------------------------*/
   2179          

   \                                 In section .text, align 2, keep-with-next
   2180          UBaseType_t uxTaskGetNumberOfTasks( void )
   2181          {
   2182          	/* A critical section is not required because the variables are of type
   2183          	BaseType_t. */
   2184          	return uxCurrentNumberOfTasks;
   \                     uxTaskGetNumberOfTasks: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable52_1
   \        0x4   0x6F00             LDR      R0,[R0, #+112]
   \        0x6   0x4770             BX       LR               ;; return
   2185          }
   2186          /*-----------------------------------------------------------*/
   2187          

   \                                 In section .text, align 2, keep-with-next
   2188          char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
   2189          {
   2190          TCB_t *pxTCB;
   2191          
   2192          	/* If null is passed in here then the name of the calling task is being
   2193          	queried. */
   2194          	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
   \                     pcTaskGetName: (+1)
   \        0x0   0xB958             CBNZ.N   R0,??pcTaskGetName_0
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable52_1
   \        0x6   0x6E40             LDR      R0,[R0, #+100]
   2195          	configASSERT( pxTCB );
   \        0x8   0xB938             CBNZ.N   R0,??pcTaskGetName_0
   \        0xA   0x2020             MOVS     R0,#+32
   \        0xC   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x10   0xF3BF 0x8F4F      DSB      SY
   \       0x14   0xF3BF 0x8F6F      ISB      SY
   \                     ??pcTaskGetName_1: (+1)
   \       0x18   0xE7FE             B.N      ??pcTaskGetName_1
   2196          	return &( pxTCB->pcTaskName[ 0 ] );
   \                     ??pcTaskGetName_0: (+1)
   \       0x1A   0x3034             ADDS     R0,R0,#+52
   \       0x1C   0x4770             BX       LR               ;; return
   2197          }
   2198          /*-----------------------------------------------------------*/
   2199          
   2200          #if ( INCLUDE_xTaskGetHandle == 1 )
   2201          
   2202          	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] )
   2203          	{
   2204          	TCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;
   2205          	UBaseType_t x;
   2206          	char cNextChar;
   2207          
   2208          		/* This function is called with the scheduler suspended. */
   2209          
   2210          		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
   2211          		{
   2212          			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
   2213          
   2214          			do
   2215          			{
   2216          				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
   2217          
   2218          				/* Check each character in the name looking for a match or
   2219          				mismatch. */
   2220          				for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   2221          				{
   2222          					cNextChar = pxNextTCB->pcTaskName[ x ];
   2223          
   2224          					if( cNextChar != pcNameToQuery[ x ] )
   2225          					{
   2226          						/* Characters didn't match. */
   2227          						break;
   2228          					}
   2229          					else if( cNextChar == 0x00 )
   2230          					{
   2231          						/* Both strings terminated, a match must have been
   2232          						found. */
   2233          						pxReturn = pxNextTCB;
   2234          						break;
   2235          					}
   2236          					else
   2237          					{
   2238          						mtCOVERAGE_TEST_MARKER();
   2239          					}
   2240          				}
   2241          
   2242          				if( pxReturn != NULL )
   2243          				{
   2244          					/* The handle has been found. */
   2245          					break;
   2246          				}
   2247          
   2248          			} while( pxNextTCB != pxFirstTCB );
   2249          		}
   2250          		else
   2251          		{
   2252          			mtCOVERAGE_TEST_MARKER();
   2253          		}
   2254          
   2255          		return pxReturn;
   2256          	}
   2257          
   2258          #endif /* INCLUDE_xTaskGetHandle */
   2259          /*-----------------------------------------------------------*/
   2260          
   2261          #if ( INCLUDE_xTaskGetHandle == 1 )
   2262          
   2263          	TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
   2264          	{
   2265          	UBaseType_t uxQueue = configMAX_PRIORITIES;
   2266          	TCB_t* pxTCB;
   2267          
   2268          		/* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
   2269          		configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
   2270          
   2271          		vTaskSuspendAll();
   2272          		{
   2273          			/* Search the ready lists. */
   2274          			do
   2275          			{
   2276          				uxQueue--;
   2277          				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNameToQuery );
   2278          
   2279          				if( pxTCB != NULL )
   2280          				{
   2281          					/* Found the handle. */
   2282          					break;
   2283          				}
   2284          
   2285          			} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   2286          
   2287          			/* Search the delayed lists. */
   2288          			if( pxTCB == NULL )
   2289          			{
   2290          				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
   2291          			}
   2292          
   2293          			if( pxTCB == NULL )
   2294          			{
   2295          				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery );
   2296          			}
   2297          
   2298          			#if ( INCLUDE_vTaskSuspend == 1 )
   2299          			{
   2300          				if( pxTCB == NULL )
   2301          				{
   2302          					/* Search the suspended list. */
   2303          					pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
   2304          				}
   2305          			}
   2306          			#endif
   2307          
   2308          			#if( INCLUDE_vTaskDelete == 1 )
   2309          			{
   2310          				if( pxTCB == NULL )
   2311          				{
   2312          					/* Search the deleted list. */
   2313          					pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
   2314          				}
   2315          			}
   2316          			#endif
   2317          		}
   2318          		( void ) xTaskResumeAll();
   2319          
   2320          		return ( TaskHandle_t ) pxTCB;
   2321          	}
   2322          
   2323          #endif /* INCLUDE_xTaskGetHandle */
   2324          /*-----------------------------------------------------------*/
   2325          
   2326          #if ( configUSE_TRACE_FACILITY == 1 )
   2327          

   \                                 In section .text, align 2, keep-with-next
   2328          	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
   2329          	{
   \                     uxTaskGetSystemState: (+1)
   \        0x0   0xE92D 0x4FF5      PUSH     {R0,R2,R4-R11,LR}
   \        0x4   0xB081             SUB      SP,SP,#+4
   2330          	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
   \        0x6   0x2005             MOVS     R0,#+5
   \        0x8   0x9000             STR      R0,[SP, #+0]
   \        0xA   0xF04F 0x0B00      MOV      R11,#+0
   2331          
   2332          		vTaskSuspendAll();
   \        0xE   0x.... 0x....      LDR.W    R6,??DataTable36
   \       0x12   0x6FF0             LDR      R0,[R6, #+124]
   \       0x14   0x1C40             ADDS     R0,R0,#+1
   \       0x16   0x67F0             STR      R0,[R6, #+124]
   2333          		{
   2334          			/* Is there a space in the array for each task in the system? */
   2335          			if( uxArraySize >= uxCurrentNumberOfTasks )
   \       0x18   0x6F30             LDR      R0,[R6, #+112]
   \       0x1A   0x4281             CMP      R1,R0
   \       0x1C   0xF0C0 0x8090      BCC.W    ??uxTaskGetSystemState_0
   2336          			{
   2337          				/* Fill in an TaskStatus_t structure with information on each
   2338          				task in the Ready state. */
   2339          				do
   2340          				{
   2341          					uxQueue--;
   \                     ??uxTaskGetSystemState_1: (+1)
   \       0x20   0x9900             LDR      R1,[SP, #+0]
   \       0x22   0x1E49             SUBS     R1,R1,#+1
   \       0x24   0x9100             STR      R1,[SP, #+0]
   2342          					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
   \       0x26   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \       0x2A   0x0091             LSLS     R1,R2,#+2
   \       0x2C   0xF04F 0x0900      MOV      R9,#+0
   \       0x30   0x5870             LDR      R0,[R6, R1]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD050             BEQ.N    ??uxTaskGetSystemState_2
   \       0x36   0x1877             ADDS     R7,R6,R1
   \       0x38   0xF107 0x0108      ADD      R1,R7,#+8
   \       0x3C   0x6878             LDR      R0,[R7, #+4]
   \       0x3E   0x6840             LDR      R0,[R0, #+4]
   \       0x40   0x6078             STR      R0,[R7, #+4]
   \       0x42   0x4288             CMP      R0,R1
   \       0x44   0xBF04             ITT      EQ 
   \       0x46   0x6840             LDREQ    R0,[R0, #+4]
   \       0x48   0x6078             STREQ    R0,[R7, #+4]
   \       0x4A   0x6878             LDR      R0,[R7, #+4]
   \       0x4C   0xF8D0 0xA00C      LDR      R10,[R0, #+12]
   \       0x50   0x9801             LDR      R0,[SP, #+4]
   \       0x52   0xF100 0x0108      ADD      R1,R0,#+8
   \       0x56   0xEB0B 0x02CB      ADD      R2,R11,R11, LSL #+3
   \       0x5A   0xEB01 0x0582      ADD      R5,R1,R2, LSL #+2
   \                     ??uxTaskGetSystemState_3: (+1)
   \       0x5E   0x6878             LDR      R0,[R7, #+4]
   \       0x60   0x6840             LDR      R0,[R0, #+4]
   \       0x62   0x6078             STR      R0,[R7, #+4]
   \       0x64   0xF107 0x0108      ADD      R1,R7,#+8
   \       0x68   0x4288             CMP      R0,R1
   \       0x6A   0xBF04             ITT      EQ 
   \       0x6C   0x6840             LDREQ    R0,[R0, #+4]
   \       0x6E   0x6078             STREQ    R0,[R7, #+4]
   \       0x70   0x6878             LDR      R0,[R7, #+4]
   \       0x72   0xF8D0 0x800C      LDR      R8,[R0, #+12]
   \       0x76   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x7A   0xBF0C             ITE      EQ 
   \       0x7C   0x6E74             LDREQ    R4,[R6, #+100]
   \       0x7E   0x4644             MOVNE    R4,R8
   \       0x80   0xF104 0x0034      ADD      R0,R4,#+52
   \       0x84   0xF845 0x4C08      STR      R4,[R5, #-8]
   \       0x88   0xF845 0x0C04      STR      R0,[R5, #-4]
   \       0x8C   0x6AE1             LDR      R1,[R4, #+44]
   \       0x8E   0x60A9             STR      R1,[R5, #+8]
   \       0x90   0x6B20             LDR      R0,[R4, #+48]
   \       0x92   0x6168             STR      R0,[R5, #+20]
   \       0x94   0x6CE1             LDR      R1,[R4, #+76]
   \       0x96   0x6029             STR      R1,[R5, #+0]
   \       0x98   0x7928             LDRB     R0,[R5, #+4]
   \       0x9A   0x2803             CMP      R0,#+3
   \       0x9C   0xD108             BNE.N    ??uxTaskGetSystemState_4
   \       0x9E   0x6FF0             LDR      R0,[R6, #+124]
   \       0xA0   0x1C40             ADDS     R0,R0,#+1
   \       0xA2   0x67F0             STR      R0,[R6, #+124]
   \       0xA4   0x6AA0             LDR      R0,[R4, #+40]
   \       0xA6   0xB108             CBZ.N    R0,??uxTaskGetSystemState_5
   \       0xA8   0x2102             MOVS     R1,#+2
   \       0xAA   0x7129             STRB     R1,[R5, #+4]
   \                     ??uxTaskGetSystemState_5: (+1)
   \       0xAC   0x.... 0x....      BL       xTaskResumeAll
   \                     ??uxTaskGetSystemState_4: (+1)
   \       0xB0   0x2100             MOVS     R1,#+0
   \       0xB2   0x6D60             LDR      R0,[R4, #+84]
   \       0xB4   0x60E8             STR      R0,[R5, #+12]
   \       0xB6   0x6129             STR      R1,[R5, #+16]
   \       0xB8   0x2001             MOVS     R0,#+1
   \       0xBA   0x7128             STRB     R0,[R5, #+4]
   \       0xBC   0x6B20             LDR      R0,[R4, #+48]
   \       0xBE   0xE000             B.N      ??uxTaskGetSystemState_6
   \                     ??uxTaskGetSystemState_7: (+1)
   \       0xC0   0x1C49             ADDS     R1,R1,#+1
   \                     ??uxTaskGetSystemState_6: (+1)
   \       0xC2   0xF810 0x2B01      LDRB     R2,[R0], #+1
   \       0xC6   0x2AA5             CMP      R2,#+165
   \       0xC8   0xD0FA             BEQ.N    ??uxTaskGetSystemState_7
   \       0xCA   0x0889             LSRS     R1,R1,#+2
   \       0xCC   0x8329             STRH     R1,[R5, #+24]
   \       0xCE   0x3524             ADDS     R5,R5,#+36
   \       0xD0   0x45D0             CMP      R8,R10
   \       0xD2   0xF109 0x0901      ADD      R9,R9,#+1
   \       0xD6   0xD1C2             BNE.N    ??uxTaskGetSystemState_3
   2343          
   2344          				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   \                     ??uxTaskGetSystemState_2: (+1)
   \       0xD8   0x9800             LDR      R0,[SP, #+0]
   \       0xDA   0x2800             CMP      R0,#+0
   \       0xDC   0x44CB             ADD      R11,R9,R11
   \       0xDE   0xD19F             BNE.N    ??uxTaskGetSystemState_1
   \       0xE0   0x9C02             LDR      R4,[SP, #+8]
   2345          
   2346          				/* Fill in an TaskStatus_t structure with information on each
   2347          				task in the Blocked state. */
   2348          				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
   \       0xE2   0x6EB1             LDR      R1,[R6, #+104]
   \       0xE4   0x9801             LDR      R0,[SP, #+4]
   \       0xE6   0xEB0B 0x03CB      ADD      R3,R11,R11, LSL #+3
   \       0xEA   0x2202             MOVS     R2,#+2
   \       0xEC   0xEB00 0x0083      ADD      R0,R0,R3, LSL #+2
   \       0xF0   0x.... 0x....      BL       prvListTasksWithinSingleList
   2349          				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
   \       0xF4   0x6EF1             LDR      R1,[R6, #+108]
   \       0xF6   0x.... 0x....      LDR.W    R6,??DataTable36_1
   \       0xFA   0x4483             ADD      R11,R0,R11
   \       0xFC   0x9801             LDR      R0,[SP, #+4]
   \       0xFE   0xEB0B 0x03CB      ADD      R3,R11,R11, LSL #+3
   \      0x102   0x2202             MOVS     R2,#+2
   \      0x104   0xEB00 0x0083      ADD      R0,R0,R3, LSL #+2
   \      0x108   0x.... 0x....      BL       prvListTasksWithinSingleList
   \      0x10C   0x4483             ADD      R11,R0,R11
   2350          
   2351          				#if( INCLUDE_vTaskDelete == 1 )
   2352          				{
   2353          					/* Fill in an TaskStatus_t structure with information on
   2354          					each task that has been deleted but not yet cleaned up. */
   2355          					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
   \      0x10E   0x9801             LDR      R0,[SP, #+4]
   \      0x110   0xEB0B 0x03CB      ADD      R3,R11,R11, LSL #+3
   \      0x114   0x2204             MOVS     R2,#+4
   \      0x116   0xF106 0x0114      ADD      R1,R6,#+20
   \      0x11A   0xEB00 0x0083      ADD      R0,R0,R3, LSL #+2
   \      0x11E   0x.... 0x....      BL       prvListTasksWithinSingleList
   \      0x122   0x4483             ADD      R11,R0,R11
   2356          				}
   2357          				#endif
   2358          
   2359          				#if ( INCLUDE_vTaskSuspend == 1 )
   2360          				{
   2361          					/* Fill in an TaskStatus_t structure with information on
   2362          					each task in the Suspended state. */
   2363          					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
   \      0x124   0x9801             LDR      R0,[SP, #+4]
   \      0x126   0xEB0B 0x03CB      ADD      R3,R11,R11, LSL #+3
   \      0x12A   0x2203             MOVS     R2,#+3
   \      0x12C   0xF106 0x012C      ADD      R1,R6,#+44
   \      0x130   0xEB00 0x0083      ADD      R0,R0,R3, LSL #+2
   \      0x134   0x.... 0x....      BL       prvListTasksWithinSingleList
   \      0x138   0x4483             ADD      R11,R0,R11
   2364          				}
   2365          				#endif
   2366          
   2367          				#if ( configGENERATE_RUN_TIME_STATS == 1)
   2368          				{
   2369          					if( pulTotalRunTime != NULL )
   2370          					{
   2371          						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
   2372          							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
   2373          						#else
   2374          							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   2375          						#endif
   2376          					}
   2377          				}
   2378          				#else
   2379          				{
   2380          					if( pulTotalRunTime != NULL )
   \      0x13A   0xB10C             CBZ.N    R4,??uxTaskGetSystemState_0
   2381          					{
   2382          						*pulTotalRunTime = 0;
   \      0x13C   0x2000             MOVS     R0,#+0
   \      0x13E   0x6020             STR      R0,[R4, #+0]
   2383          					}
   2384          				}
   2385          				#endif
   2386          			}
   2387          			else
   2388          			{
   2389          				mtCOVERAGE_TEST_MARKER();
   2390          			}
   2391          		}
   2392          		( void ) xTaskResumeAll();
   \                     ??uxTaskGetSystemState_0: (+1)
   \      0x140   0x.... 0x....      BL       xTaskResumeAll
   2393          
   2394          		return uxTask;
   \      0x144   0x4658             MOV      R0,R11
   \      0x146   0xB003             ADD      SP,SP,#+12
   \      0x148   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   2395          	}
   2396          
   2397          #endif /* configUSE_TRACE_FACILITY */
   2398          /*----------------------------------------------------------*/
   2399          
   2400          #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
   2401          
   2402          	TaskHandle_t xTaskGetIdleTaskHandle( void )
   2403          	{
   2404          		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
   2405          		started, then xIdleTaskHandle will be NULL. */
   2406          		configASSERT( ( xIdleTaskHandle != NULL ) );
   2407          		return xIdleTaskHandle;
   2408          	}
   2409          
   2410          #endif /* INCLUDE_xTaskGetIdleTaskHandle */
   2411          /*----------------------------------------------------------*/
   2412          
   2413          /* This conditional compilation should use inequality to 0, not equality to 1.
   2414          This is to ensure vTaskStepTick() is available when user defined low power mode
   2415          implementations require configUSE_TICKLESS_IDLE to be set to a value other than
   2416          1. */
   2417          #if ( configUSE_TICKLESS_IDLE != 0 )
   2418          
   2419          	void vTaskStepTick( const TickType_t xTicksToJump )
   2420          	{
   2421          		/* Correct the tick count value after a period during which the tick
   2422          		was suppressed.  Note this does *not* call the tick hook function for
   2423          		each stepped tick. */
   2424          		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
   2425          		xTickCount += xTicksToJump;
   2426          		traceINCREASE_TICK_COUNT( xTicksToJump );
   2427          	}
   2428          
   2429          #endif /* configUSE_TICKLESS_IDLE */
   2430          /*----------------------------------------------------------*/
   2431          
   2432          #if ( INCLUDE_xTaskAbortDelay == 1 )
   2433          
   2434          	BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
   2435          	{
   2436          	TCB_t *pxTCB = ( TCB_t * ) xTask;
   2437          	BaseType_t xReturn = pdFALSE;
   2438          
   2439          		configASSERT( pxTCB );
   2440          
   2441          		vTaskSuspendAll();
   2442          		{
   2443          			/* A task can only be prematurely removed from the Blocked state if
   2444          			it is actually in the Blocked state. */
   2445          			if( eTaskGetState( xTask ) == eBlocked )
   2446          			{
   2447          				/* Remove the reference to the task from the blocked list.  An
   2448          				interrupt won't touch the xStateListItem because the
   2449          				scheduler is suspended. */
   2450          				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   2451          
   2452          				/* Is the task waiting on an event also?  If so remove it from
   2453          				the event list too.  Interrupts can touch the event list item,
   2454          				even though the scheduler is suspended, so a critical section
   2455          				is used. */
   2456          				taskENTER_CRITICAL();
   2457          				{
   2458          					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   2459          					{
   2460          						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   2461          						pxTCB->ucDelayAborted = pdTRUE;
   2462          					}
   2463          					else
   2464          					{
   2465          						mtCOVERAGE_TEST_MARKER();
   2466          					}
   2467          				}
   2468          				taskEXIT_CRITICAL();
   2469          
   2470          				/* Place the unblocked task into the appropriate ready list. */
   2471          				prvAddTaskToReadyList( pxTCB );
   2472          
   2473          				/* A task being unblocked cannot cause an immediate context
   2474          				switch if preemption is turned off. */
   2475          				#if (  configUSE_PREEMPTION == 1 )
   2476          				{
   2477          					/* Preemption is on, but a context switch should only be
   2478          					performed if the unblocked task has a priority that is
   2479          					equal to or higher than the currently executing task. */
   2480          					if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   2481          					{
   2482          						/* Pend the yield to be performed when the scheduler
   2483          						is unsuspended. */
   2484          						xYieldPending = pdTRUE;
   2485          					}
   2486          					else
   2487          					{
   2488          						mtCOVERAGE_TEST_MARKER();
   2489          					}
   2490          				}
   2491          				#endif /* configUSE_PREEMPTION */
   2492          			}
   2493          			else
   2494          			{
   2495          				mtCOVERAGE_TEST_MARKER();
   2496          			}
   2497          		}
   2498          		xTaskResumeAll();
   2499          
   2500          		return xReturn;
   2501          	}
   2502          
   2503          #endif /* INCLUDE_xTaskAbortDelay */
   2504          /*----------------------------------------------------------*/
   2505          

   \                                 In section .text, align 2, keep-with-next
   2506          BaseType_t xTaskIncrementTick( void )
   2507          {
   \                     xTaskIncrementTick: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   2508          TCB_t * pxTCB;
   2509          TickType_t xItemValue;
   2510          BaseType_t xSwitchRequired = pdFALSE;
   2511          
   2512          	/* Called by the portable layer each time a tick interrupt occurs.
   2513          	Increments the tick then checks to see if the new tick value will cause any
   2514          	tasks to be unblocked. */
   2515          	traceTASK_INCREMENT_TICK( xTickCount );
   2516          	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   \        0x4   0x.... 0x....      LDR.W    R6,??DataTable36
   \        0x8   0x.... 0x....      LDR.W    R7,??DataTable36_1
   \        0xC   0x6FF0             LDR      R0,[R6, #+124]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xF04F 0x0800      MOV      R8,#+0
   \       0x14   0xD146             BNE.N    ??xTaskIncrementTick_0
   2517          	{
   2518          		/* Minor optimisation.  The tick count cannot change in this
   2519          		block. */
   2520          		const TickType_t xConstTickCount = xTickCount + 1;
   \       0x16   0x6C3C             LDR      R4,[R7, #+64]
   \       0x18   0x1C64             ADDS     R4,R4,#+1
   2521          
   2522          		/* Increment the RTOS tick, switching the delayed and overflowed
   2523          		delayed lists if it wraps to 0. */
   2524          		xTickCount = xConstTickCount;
   \       0x1A   0x643C             STR      R4,[R7, #+64]
   2525          
   2526          		if( xConstTickCount == ( TickType_t ) 0U )
   \       0x1C   0xD113             BNE.N    ??xTaskIncrementTick_1
   2527          		{
   2528          			taskSWITCH_DELAYED_LISTS();
   \       0x1E   0x6EB1             LDR      R1,[R6, #+104]
   \       0x20   0x6808             LDR      R0,[R1, #+0]
   \       0x22   0xB138             CBZ.N    R0,??xTaskIncrementTick_2
   \       0x24   0x2120             MOVS     R1,#+32
   \       0x26   0xF381 0x8811      MSR      BASEPRI,R1
   \       0x2A   0xF3BF 0x8F4F      DSB      SY
   \       0x2E   0xF3BF 0x8F6F      ISB      SY
   \                     ??xTaskIncrementTick_3: (+1)
   \       0x32   0xE7FE             B.N      ??xTaskIncrementTick_3
   \                     ??xTaskIncrementTick_2: (+1)
   \       0x34   0x6EB0             LDR      R0,[R6, #+104]
   \       0x36   0x6EF1             LDR      R1,[R6, #+108]
   \       0x38   0x66B1             STR      R1,[R6, #+104]
   \       0x3A   0x66F0             STR      R0,[R6, #+108]
   \       0x3C   0x6CF8             LDR      R0,[R7, #+76]
   \       0x3E   0x1C40             ADDS     R0,R0,#+1
   \       0x40   0x64F8             STR      R0,[R7, #+76]
   \       0x42   0x.... 0x....      BL       prvResetNextTaskUnblockTime
   2529          		}
   2530          		else
   2531          		{
   2532          			mtCOVERAGE_TEST_MARKER();
   2533          		}
   2534          
   2535          		/* See if this tick has made a timeout expire.  Tasks are stored in
   2536          		the	queue in the order of their wake time - meaning once one task
   2537          		has been found whose block time has not expired there is no need to
   2538          		look any further down the list. */
   2539          		if( xConstTickCount >= xNextTaskUnblockTime )
   \                     ??xTaskIncrementTick_1: (+1)
   \       0x46   0x6D78             LDR      R0,[R7, #+84]
   \       0x48   0x4284             CMP      R4,R0
   \       0x4A   0xD32E             BCC.N    ??xTaskIncrementTick_4
   \       0x4C   0xE01C             B.N      ??xTaskIncrementTick_5
   2540          		{
   2541          			for( ;; )
   2542          			{
   2543          				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   2544          				{
   2545          					/* The delayed list is empty.  Set xNextTaskUnblockTime
   2546          					to the maximum possible value so it is extremely
   2547          					unlikely that the
   2548          					if( xTickCount >= xNextTaskUnblockTime ) test will pass
   2549          					next time through. */
   2550          					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   2551          					break;
   2552          				}
   2553          				else
   2554          				{
   2555          					/* The delayed list is not empty, get the value of the
   2556          					item at the head of the delayed list.  This is the time
   2557          					at which the task at the head of the delayed list must
   2558          					be removed from the Blocked state. */
   2559          					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   2560          					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
   2561          
   2562          					if( xConstTickCount < xItemValue )
   2563          					{
   2564          						/* It is not time to unblock this item yet, but the
   2565          						item value is the time at which the task at the head
   2566          						of the blocked list must be removed from the Blocked
   2567          						state -	so record the item value in
   2568          						xNextTaskUnblockTime. */
   2569          						xNextTaskUnblockTime = xItemValue;
   2570          						break;
   2571          					}
   2572          					else
   2573          					{
   2574          						mtCOVERAGE_TEST_MARKER();
   2575          					}
   2576          
   2577          					/* It is time to remove the item from the Blocked state. */
   2578          					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   \                     ??xTaskIncrementTick_6: (+1)
   \       0x4E   0x1D28             ADDS     R0,R5,#+4
   \       0x50   0x.... 0x....      BL       uxListRemove
   2579          
   2580          					/* Is the task waiting on an event also?  If so remove
   2581          					it from the event list. */
   2582          					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   \       0x54   0x6AA8             LDR      R0,[R5, #+40]
   \       0x56   0xB118             CBZ.N    R0,??xTaskIncrementTick_7
   2583          					{
   2584          						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   \       0x58   0xF105 0x0018      ADD      R0,R5,#+24
   \       0x5C   0x.... 0x....      BL       uxListRemove
   2585          					}
   2586          					else
   2587          					{
   2588          						mtCOVERAGE_TEST_MARKER();
   2589          					}
   2590          
   2591          					/* Place the unblocked task into the appropriate ready
   2592          					list. */
   2593          					prvAddTaskToReadyList( pxTCB );
   \                     ??xTaskIncrementTick_7: (+1)
   \       0x60   0x6AE8             LDR      R0,[R5, #+44]
   \       0x62   0x6F71             LDR      R1,[R6, #+116]
   \       0x64   0x2201             MOVS     R2,#+1
   \       0x66   0x4082             LSLS     R2,R2,R0
   \       0x68   0x4311             ORRS     R1,R2,R1
   \       0x6A   0x6771             STR      R1,[R6, #+116]
   \       0x6C   0xEB00 0x0380      ADD      R3,R0,R0, LSL #+2
   \       0x70   0x1D29             ADDS     R1,R5,#+4
   \       0x72   0xEB06 0x0083      ADD      R0,R6,R3, LSL #+2
   \       0x76   0x.... 0x....      BL       vListInsertEnd
   2594          
   2595          					/* A task being unblocked cannot cause an immediate
   2596          					context switch if preemption is turned off. */
   2597          					#if (  configUSE_PREEMPTION == 1 )
   2598          					{
   2599          						/* Preemption is on, but a context switch should
   2600          						only be performed if the unblocked task has a
   2601          						priority that is equal to or higher than the
   2602          						currently executing task. */
   2603          						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   \       0x7A   0x6AE8             LDR      R0,[R5, #+44]
   \       0x7C   0x6E71             LDR      R1,[R6, #+100]
   \       0x7E   0x6ACA             LDR      R2,[R1, #+44]
   \       0x80   0x4290             CMP      R0,R2
   \       0x82   0xBF28             IT       CS 
   \       0x84   0xF04F 0x0801      MOVCS    R8,#+1
   2604          						{
   2605          							xSwitchRequired = pdTRUE;
   2606          						}
   2607          						else
   2608          						{
   2609          							mtCOVERAGE_TEST_MARKER();
   2610          						}
   2611          					}
   \                     ??xTaskIncrementTick_5: (+1)
   \       0x88   0x6EB1             LDR      R1,[R6, #+104]
   \       0x8A   0x6808             LDR      R0,[R1, #+0]
   \       0x8C   0xB130             CBZ.N    R0,??xTaskIncrementTick_8
   \       0x8E   0x6EB0             LDR      R0,[R6, #+104]
   \       0x90   0x68C1             LDR      R1,[R0, #+12]
   \       0x92   0x68CD             LDR      R5,[R1, #+12]
   \       0x94   0x6868             LDR      R0,[R5, #+4]
   \       0x96   0x4284             CMP      R4,R0
   \       0x98   0xD2D9             BCS.N    ??xTaskIncrementTick_6
   \       0x9A   0xE001             B.N      ??xTaskIncrementTick_9
   2612          					#endif /* configUSE_PREEMPTION */
   2613          				}
   \                     ??xTaskIncrementTick_8: (+1)
   \       0x9C   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??xTaskIncrementTick_9: (+1)
   \       0xA0   0x6578             STR      R0,[R7, #+84]
   \       0xA2   0xE002             B.N      ??xTaskIncrementTick_4
   2614          			}
   2615          		}
   2616          
   2617          		/* Tasks of equal priority to the currently running task will share
   2618          		processing time (time slice) if preemption is on, and the application
   2619          		writer has not explicitly turned time slicing off. */
   2620          		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
   2621          		{
   2622          			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
   2623          			{
   2624          				xSwitchRequired = pdTRUE;
   2625          			}
   2626          			else
   2627          			{
   2628          				mtCOVERAGE_TEST_MARKER();
   2629          			}
   2630          		}
   2631          		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
   2632          
   2633          		#if ( configUSE_TICK_HOOK == 1 )
   2634          		{
   2635          			/* Guard against the tick hook being called when the pended tick
   2636          			count is being unwound (when the scheduler is being unlocked). */
   2637          			if( uxPendedTicks == ( UBaseType_t ) 0U )
   2638          			{
   2639          				vApplicationTickHook();
   2640          			}
   2641          			else
   2642          			{
   2643          				mtCOVERAGE_TEST_MARKER();
   2644          			}
   2645          		}
   2646          		#endif /* configUSE_TICK_HOOK */
   2647          	}
   2648          	else
   2649          	{
   2650          		++uxPendedTicks;
   \                     ??xTaskIncrementTick_0: (+1)
   \       0xA4   0x6CB8             LDR      R0,[R7, #+72]
   \       0xA6   0x1C40             ADDS     R0,R0,#+1
   \       0xA8   0x64B8             STR      R0,[R7, #+72]
   2651          
   2652          		/* The tick hook gets called at regular intervals, even if the
   2653          		scheduler is locked. */
   2654          		#if ( configUSE_TICK_HOOK == 1 )
   2655          		{
   2656          			vApplicationTickHook();
   2657          		}
   2658          		#endif
   2659          	}
   2660          
   2661          	#if ( configUSE_PREEMPTION == 1 )
   2662          	{
   2663          		if( xYieldPending != pdFALSE )
   \                     ??xTaskIncrementTick_4: (+1)
   \       0xAA   0x6FB0             LDR      R0,[R6, #+120]
   \       0xAC   0xB108             CBZ.N    R0,??xTaskIncrementTick_10
   2664          		{
   2665          			xSwitchRequired = pdTRUE;
   \       0xAE   0xF04F 0x0801      MOV      R8,#+1
   2666          		}
   2667          		else
   2668          		{
   2669          			mtCOVERAGE_TEST_MARKER();
   2670          		}
   2671          	}
   2672          	#endif /* configUSE_PREEMPTION */
   2673          
   2674          	return xSwitchRequired;
   \                     ??xTaskIncrementTick_10: (+1)
   \       0xB2   0x4640             MOV      R0,R8
   \       0xB4   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2675          }
   2676          /*-----------------------------------------------------------*/
   2677          
   2678          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2679          
   2680          	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
   2681          	{
   2682          	TCB_t *xTCB;
   2683          
   2684          		/* If xTask is NULL then it is the task hook of the calling task that is
   2685          		getting set. */
   2686          		if( xTask == NULL )
   2687          		{
   2688          			xTCB = ( TCB_t * ) pxCurrentTCB;
   2689          		}
   2690          		else
   2691          		{
   2692          			xTCB = ( TCB_t * ) xTask;
   2693          		}
   2694          
   2695          		/* Save the hook function in the TCB.  A critical section is required as
   2696          		the value can be accessed from an interrupt. */
   2697          		taskENTER_CRITICAL();
   2698          			xTCB->pxTaskTag = pxHookFunction;
   2699          		taskEXIT_CRITICAL();
   2700          	}
   2701          
   2702          #endif /* configUSE_APPLICATION_TASK_TAG */
   2703          /*-----------------------------------------------------------*/
   2704          
   2705          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2706          
   2707          	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
   2708          	{
   2709          	TCB_t *xTCB;
   2710          	TaskHookFunction_t xReturn;
   2711          
   2712          		/* If xTask is NULL then we are setting our own task hook. */
   2713          		if( xTask == NULL )
   2714          		{
   2715          			xTCB = ( TCB_t * ) pxCurrentTCB;
   2716          		}
   2717          		else
   2718          		{
   2719          			xTCB = ( TCB_t * ) xTask;
   2720          		}
   2721          
   2722          		/* Save the hook function in the TCB.  A critical section is required as
   2723          		the value can be accessed from an interrupt. */
   2724          		taskENTER_CRITICAL();
   2725          		{
   2726          			xReturn = xTCB->pxTaskTag;
   2727          		}
   2728          		taskEXIT_CRITICAL();
   2729          
   2730          		return xReturn;
   2731          	}
   2732          
   2733          #endif /* configUSE_APPLICATION_TASK_TAG */
   2734          /*-----------------------------------------------------------*/
   2735          
   2736          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2737          
   2738          	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
   2739          	{
   2740          	TCB_t *xTCB;
   2741          	BaseType_t xReturn;
   2742          
   2743          		/* If xTask is NULL then we are calling our own task hook. */
   2744          		if( xTask == NULL )
   2745          		{
   2746          			xTCB = ( TCB_t * ) pxCurrentTCB;
   2747          		}
   2748          		else
   2749          		{
   2750          			xTCB = ( TCB_t * ) xTask;
   2751          		}
   2752          
   2753          		if( xTCB->pxTaskTag != NULL )
   2754          		{
   2755          			xReturn = xTCB->pxTaskTag( pvParameter );
   2756          		}
   2757          		else
   2758          		{
   2759          			xReturn = pdFAIL;
   2760          		}
   2761          
   2762          		return xReturn;
   2763          	}
   2764          
   2765          #endif /* configUSE_APPLICATION_TASK_TAG */
   2766          /*-----------------------------------------------------------*/
   2767          

   \                                 In section .text, align 2, keep-with-next
   2768          void vTaskSwitchContext( void )
   2769          {
   2770          	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
   \                     vTaskSwitchContext: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable36
   \        0x2   0x6FC8             LDR      R0,[R1, #+124]
   \        0x4   0xB110             CBZ.N    R0,??vTaskSwitchContext_0
   2771          	{
   2772          		/* The scheduler is currently suspended - do not allow a context
   2773          		switch. */
   2774          		xYieldPending = pdTRUE;
   \        0x6   0x2201             MOVS     R2,#+1
   \        0x8   0x678A             STR      R2,[R1, #+120]
   \        0xA   0x4770             BX       LR
   2775          	}
   2776          	else
   2777          	{
   2778          		xYieldPending = pdFALSE;
   \                     ??vTaskSwitchContext_0: (+1)
   \        0xC   0x6788             STR      R0,[R1, #+120]
   2779          		traceTASK_SWITCHED_OUT();
   2780          
   2781          		#if ( configGENERATE_RUN_TIME_STATS == 1 )
   2782          		{
   2783          				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
   2784          					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
   2785          				#else
   2786          					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   2787          				#endif
   2788          
   2789          				/* Add the amount of time the task has been running to the
   2790          				accumulated time so far.  The time the task started running was
   2791          				stored in ulTaskSwitchedInTime.  Note that there is no overflow
   2792          				protection here so count values are only valid until the timer
   2793          				overflows.  The guard against negative values is to protect
   2794          				against suspect run time stat counter implementations - which
   2795          				are provided by the application, not the kernel. */
   2796          				if( ulTotalRunTime > ulTaskSwitchedInTime )
   2797          				{
   2798          					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
   2799          				}
   2800          				else
   2801          				{
   2802          					mtCOVERAGE_TEST_MARKER();
   2803          				}
   2804          				ulTaskSwitchedInTime = ulTotalRunTime;
   2805          		}
   2806          		#endif /* configGENERATE_RUN_TIME_STATS */
   2807          
   2808          		/* Check for stack overflow, if configured. */
   2809          		taskCHECK_FOR_STACK_OVERFLOW();
   2810          
   2811          		/* Select a new task to run using either the generic C or port
   2812          		optimised asm code. */
   2813          		taskSELECT_HIGHEST_PRIORITY_TASK();
   \        0xE   0x6F4A             LDR      R2,[R1, #+116]
   \       0x10   0xFAB2 0xF082      CLZ      R0,R2
   \       0x14   0xF1C0 0x001F      RSB      R0,R0,#+31
   \       0x18   0xEB00 0x0380      ADD      R3,R0,R0, LSL #+2
   \       0x1C   0x009A             LSLS     R2,R3,#+2
   \       0x1E   0x5888             LDR      R0,[R1, R2]
   \       0x20   0xB938             CBNZ.N   R0,??vTaskSwitchContext_1
   \       0x22   0x2120             MOVS     R1,#+32
   \       0x24   0xF381 0x8811      MSR      BASEPRI,R1
   \       0x28   0xF3BF 0x8F4F      DSB      SY
   \       0x2C   0xF3BF 0x8F6F      ISB      SY
   \                     ??vTaskSwitchContext_2: (+1)
   \       0x30   0xE7FE             B.N      ??vTaskSwitchContext_2
   \                     ??vTaskSwitchContext_1: (+1)
   \       0x32   0x1888             ADDS     R0,R1,R2
   \       0x34   0xF100 0x0308      ADD      R3,R0,#+8
   \       0x38   0x6842             LDR      R2,[R0, #+4]
   \       0x3A   0x6852             LDR      R2,[R2, #+4]
   \       0x3C   0x6042             STR      R2,[R0, #+4]
   \       0x3E   0x429A             CMP      R2,R3
   \       0x40   0xBF04             ITT      EQ 
   \       0x42   0x6852             LDREQ    R2,[R2, #+4]
   \       0x44   0x6042             STREQ    R2,[R0, #+4]
   \       0x46   0x6840             LDR      R0,[R0, #+4]
   \       0x48   0x68C2             LDR      R2,[R0, #+12]
   \       0x4A   0x664A             STR      R2,[R1, #+100]
   2814          		traceTASK_SWITCHED_IN();
   2815          
   2816          		#if ( configUSE_NEWLIB_REENTRANT == 1 )
   2817          		{
   2818          			/* Switch Newlib's _impure_ptr variable to point to the _reent
   2819          			structure specific to this task. */
   2820          			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
   2821          		}
   2822          		#endif /* configUSE_NEWLIB_REENTRANT */
   2823          	}
   2824          }
   \       0x4C   0x4770             BX       LR               ;; return
   2825          /*-----------------------------------------------------------*/
   2826          

   \                                 In section .text, align 2, keep-with-next
   2827          void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
   2828          {
   \                     vTaskPlaceOnEventList: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x460C             MOV      R4,R1
   2829          	configASSERT( pxEventList );
   \        0x4   0xB938             CBNZ.N   R0,??vTaskPlaceOnEventList_0
   \        0x6   0x2020             MOVS     R0,#+32
   \        0x8   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xC   0xF3BF 0x8F4F      DSB      SY
   \       0x10   0xF3BF 0x8F6F      ISB      SY
   \                     ??vTaskPlaceOnEventList_1: (+1)
   \       0x14   0xE7FE             B.N      ??vTaskPlaceOnEventList_1
   2830          
   2831          	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
   2832          	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
   2833          
   2834          	/* Place the event list item of the TCB in the appropriate event list.
   2835          	This is placed in the list in priority order so the highest priority task
   2836          	is the first to be woken by the event.  The queue that contains the event
   2837          	list is locked, preventing simultaneous access from interrupts. */
   2838          	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   \                     ??vTaskPlaceOnEventList_0: (+1)
   \       0x16   0x....             LDR.N    R2,??DataTable36
   \       0x18   0x6E53             LDR      R3,[R2, #+100]
   \       0x1A   0xF103 0x0118      ADD      R1,R3,#+24
   \       0x1E   0x.... 0x....      BL       vListInsert
   2839          
   2840          	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   \       0x22   0x....             B.N      ?Subroutine2
   2841          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x4620             MOV      R0,R4
   \        0x2   0xE8BD 0x4010      POP      {R4,LR}
   \        0x6   0x2101             MOVS     R1,#+1
   \        0x8   0x.... 0x....      B.W      prvAddCurrentTaskToDelayedList
   2842          /*-----------------------------------------------------------*/
   2843          

   \                                 In section .text, align 2, keep-with-next
   2844          void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
   2845          {
   \                     vTaskPlaceOnUnorderedEventList: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4614             MOV      R4,R2
   2846          	configASSERT( pxEventList );
   \        0x4   0xB938             CBNZ.N   R0,??vTaskPlaceOnUnorderedEventList_0
   \        0x6   0x2020             MOVS     R0,#+32
   \        0x8   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xC   0xF3BF 0x8F4F      DSB      SY
   \       0x10   0xF3BF 0x8F6F      ISB      SY
   \                     ??vTaskPlaceOnUnorderedEventList_1: (+1)
   \       0x14   0xE7FE             B.N      ??vTaskPlaceOnUnorderedEventList_1
   2847          
   2848          	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
   2849          	the event groups implementation. */
   2850          	configASSERT( uxSchedulerSuspended != 0 );
   \                     ??vTaskPlaceOnUnorderedEventList_0: (+1)
   \       0x16   0x....             LDR.N    R3,??DataTable36
   \       0x18   0x6FDA             LDR      R2,[R3, #+124]
   \       0x1A   0xB93A             CBNZ.N   R2,??vTaskPlaceOnUnorderedEventList_2
   \       0x1C   0x2020             MOVS     R0,#+32
   \       0x1E   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x22   0xF3BF 0x8F4F      DSB      SY
   \       0x26   0xF3BF 0x8F6F      ISB      SY
   \                     ??vTaskPlaceOnUnorderedEventList_3: (+1)
   \       0x2A   0xE7FE             B.N      ??vTaskPlaceOnUnorderedEventList_3
   2851          
   2852          	/* Store the item value in the event list item.  It is safe to access the
   2853          	event list item here as interrupts won't access the event list item of a
   2854          	task that is not in the Blocked state. */
   2855          	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
   \                     ??vTaskPlaceOnUnorderedEventList_2: (+1)
   \       0x2C   0x6E5A             LDR      R2,[R3, #+100]
   \       0x2E   0xF041 0x4100      ORR      R1,R1,#0x80000000
   \       0x32   0x6191             STR      R1,[R2, #+24]
   2856          
   2857          	/* Place the event list item of the TCB at the end of the appropriate event
   2858          	list.  It is safe to access the event list here because it is part of an
   2859          	event group implementation - and interrupts don't access event groups
   2860          	directly (instead they access them indirectly by pending function calls to
   2861          	the task level). */
   2862          	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   \       0x34   0x6E5B             LDR      R3,[R3, #+100]
   \       0x36   0xF103 0x0118      ADD      R1,R3,#+24
   \       0x3A   0x.... 0x....      BL       vListInsertEnd
   2863          
   2864          	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   \       0x3E                      REQUIRE ?Subroutine2
   \       0x3E                      ;; // Fall through to label ?Subroutine2
   2865          }
   2866          /*-----------------------------------------------------------*/
   2867          
   2868          #if( configUSE_TIMERS == 1 )
   2869          

   \                                 In section .text, align 2, keep-with-next
   2870          	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
   2871          	{
   \                     vTaskPlaceOnEventListRestricted: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x460D             MOV      R5,R1
   \        0x4   0x4614             MOV      R4,R2
   2872          		configASSERT( pxEventList );
   \        0x6   0xB938             CBNZ.N   R0,??vTaskPlaceOnEventListRestricted_0
   \        0x8   0x2020             MOVS     R0,#+32
   \        0xA   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xE   0xF3BF 0x8F4F      DSB      SY
   \       0x12   0xF3BF 0x8F6F      ISB      SY
   \                     ??vTaskPlaceOnEventListRestricted_1: (+1)
   \       0x16   0xE7FE             B.N      ??vTaskPlaceOnEventListRestricted_1
   2873          
   2874          		/* This function should not be called by application code hence the
   2875          		'Restricted' in its name.  It is not part of the public API.  It is
   2876          		designed for use by kernel code, and has special calling requirements -
   2877          		it should be called with the scheduler suspended. */
   2878          
   2879          
   2880          		/* Place the event list item of the TCB in the appropriate event list.
   2881          		In this case it is assume that this is the only task that is going to
   2882          		be waiting on this event list, so the faster vListInsertEnd() function
   2883          		can be used in place of vListInsert. */
   2884          		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   \                     ??vTaskPlaceOnEventListRestricted_0: (+1)
   \       0x18   0x....             LDR.N    R2,??DataTable36
   \       0x1A   0x6E53             LDR      R3,[R2, #+100]
   \       0x1C   0xF103 0x0118      ADD      R1,R3,#+24
   \       0x20   0x.... 0x....      BL       vListInsertEnd
   2885          
   2886          		/* If the task should block indefinitely then set the block time to a
   2887          		value that will be recognised as an indefinite delay inside the
   2888          		prvAddCurrentTaskToDelayedList() function. */
   2889          		if( xWaitIndefinitely != pdFALSE )
   \       0x24   0xB10C             CBZ.N    R4,??vTaskPlaceOnEventListRestricted_2
   2890          		{
   2891          			xTicksToWait = portMAX_DELAY;
   \       0x26   0xF04F 0x35FF      MOV      R5,#-1
   2892          		}
   2893          
   2894          		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
   2895          		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
   \                     ??vTaskPlaceOnEventListRestricted_2: (+1)
   \       0x2A   0x4621             MOV      R1,R4
   \       0x2C   0x4628             MOV      R0,R5
   \       0x2E   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0x32   0x.... 0x....      B.W      prvAddCurrentTaskToDelayedList
   2896          	}
   2897          
   2898          #endif /* configUSE_TIMERS */
   2899          /*-----------------------------------------------------------*/
   2900          

   \                                 In section .text, align 2, keep-with-next
   2901          BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
   2902          {
   \                     xTaskRemoveFromEventList: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   2903          TCB_t *pxUnblockedTCB;
   2904          BaseType_t xReturn;
   2905          
   2906          	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
   2907          	called from a critical section within an ISR. */
   2908          
   2909          	/* The event list is sorted in priority order, so the first in the list can
   2910          	be removed as it is known to be the highest priority.  Remove the TCB from
   2911          	the delayed list, and add it to the ready list.
   2912          
   2913          	If an event is for a queue that is locked then this function will never
   2914          	get called - the lock count on the queue will get modified instead.  This
   2915          	means exclusive access to the event list is guaranteed here.
   2916          
   2917          	This function assumes that a check has already been made to ensure that
   2918          	pxEventList is not empty. */
   2919          	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   \        0x2   0x68C0             LDR      R0,[R0, #+12]
   \        0x4   0x68C4             LDR      R4,[R0, #+12]
   2920          	configASSERT( pxUnblockedTCB );
   \        0x6   0xB93C             CBNZ.N   R4,??xTaskRemoveFromEventList_0
   \        0x8   0x2020             MOVS     R0,#+32
   \        0xA   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xE   0xF3BF 0x8F4F      DSB      SY
   \       0x12   0xF3BF 0x8F6F      ISB      SY
   \                     ??xTaskRemoveFromEventList_1: (+1)
   \       0x16   0xE7FE             B.N      ??xTaskRemoveFromEventList_1
   2921          	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   \                     ??xTaskRemoveFromEventList_0: (+1)
   \       0x18   0xF104 0x0018      ADD      R0,R4,#+24
   \       0x1C   0x.... 0x....      BL       uxListRemove
   2922          
   2923          	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   \       0x20   0x....             LDR.N    R5,??DataTable36
   \       0x22   0x6FE8             LDR      R0,[R5, #+124]
   \       0x24   0xB970             CBNZ.N   R0,??xTaskRemoveFromEventList_2
   2924          	{
   2925          		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
   \       0x26   0x1D20             ADDS     R0,R4,#+4
   \       0x28   0x.... 0x....      BL       uxListRemove
   2926          		prvAddTaskToReadyList( pxUnblockedTCB );
   \       0x2C   0x6AE0             LDR      R0,[R4, #+44]
   \       0x2E   0x6F69             LDR      R1,[R5, #+116]
   \       0x30   0x2201             MOVS     R2,#+1
   \       0x32   0x4082             LSLS     R2,R2,R0
   \       0x34   0x4311             ORRS     R1,R2,R1
   \       0x36   0x6769             STR      R1,[R5, #+116]
   \       0x38   0xEB00 0x0380      ADD      R3,R0,R0, LSL #+2
   \       0x3C   0x1D21             ADDS     R1,R4,#+4
   \       0x3E   0xEB05 0x0083      ADD      R0,R5,R3, LSL #+2
   \       0x42   0xE003             B.N      ??xTaskRemoveFromEventList_3
   2927          	}
   2928          	else
   2929          	{
   2930          		/* The delayed and ready lists cannot be accessed, so hold this task
   2931          		pending until the scheduler is resumed. */
   2932          		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   \                     ??xTaskRemoveFromEventList_2: (+1)
   \       0x44   0xF104 0x0118      ADD      R1,R4,#+24
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable52
   \                     ??xTaskRemoveFromEventList_3: (+1)
   \       0x4C   0x.... 0x....      BL       vListInsertEnd
   2933          	}
   2934          
   2935          	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   \       0x50   0x6E68             LDR      R0,[R5, #+100]
   \       0x52   0x6AC1             LDR      R1,[R0, #+44]
   \       0x54   0x6AE0             LDR      R0,[R4, #+44]
   \       0x56   0x4281             CMP      R1,R0
   \       0x58   0xD200             BCS.N    ??xTaskRemoveFromEventList_4
   2936          	{
   2937          		/* Return true if the task removed from the event list has a higher
   2938          		priority than the calling task.  This allows the calling task to know if
   2939          		it should force a context switch now. */
   2940          		xReturn = pdTRUE;
   \       0x5A   0x....             B.N      ?Subroutine3
   2941          
   2942          		/* Mark that a yield is pending in case the user is not using the
   2943          		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
   2944          		xYieldPending = pdTRUE;
   2945          	}
   2946          	else
   2947          	{
   2948          		xReturn = pdFALSE;
   \                     ??xTaskRemoveFromEventList_4: (+1)
   \       0x5C   0x2000             MOVS     R0,#+0
   2949          	}
   2950          
   2951          	#if( configUSE_TICKLESS_IDLE != 0 )
   2952          	{
   2953          		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
   2954          		might be set to the blocked task's time out time.  If the task is
   2955          		unblocked for a reason other than a timeout xNextTaskUnblockTime is
   2956          		normally left unchanged, because it is automatically reset to a new
   2957          		value when the tick count equals xNextTaskUnblockTime.  However if
   2958          		tickless idling is used it might be more important to enter sleep mode
   2959          		at the earliest possible time - so reset xNextTaskUnblockTime here to
   2960          		ensure it is updated at the earliest possible time. */
   2961          		prvResetNextTaskUnblockTime();
   2962          	}
   2963          	#endif
   2964          
   2965          	return xReturn;
   \       0x5E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2966          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x67A8             STR      R0,[R5, #+120]
   \        0x4   0xBD32             POP      {R1,R4,R5,PC}
   2967          /*-----------------------------------------------------------*/
   2968          

   \                                 In section .text, align 2, keep-with-next
   2969          BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
   2970          {
   \                     xTaskRemoveFromUnorderedEventList: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   2971          TCB_t *pxUnblockedTCB;
   2972          BaseType_t xReturn;
   2973          
   2974          	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
   2975          	the event flags implementation. */
   2976          	configASSERT( uxSchedulerSuspended != pdFALSE );
   \        0x2   0x.... 0x....      LDR.W    R5,??DataTable52_1
   \        0x6   0x6FEA             LDR      R2,[R5, #+124]
   \        0x8   0xB93A             CBNZ.N   R2,??xTaskRemoveFromUnorderedEventList_0
   \        0xA   0x2020             MOVS     R0,#+32
   \        0xC   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x10   0xF3BF 0x8F4F      DSB      SY
   \       0x14   0xF3BF 0x8F6F      ISB      SY
   \                     ??xTaskRemoveFromUnorderedEventList_1: (+1)
   \       0x18   0xE7FE             B.N      ??xTaskRemoveFromUnorderedEventList_1
   2977          
   2978          	/* Store the new item value in the event list. */
   2979          	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
   \                     ??xTaskRemoveFromUnorderedEventList_0: (+1)
   \       0x1A   0xF041 0x4100      ORR      R1,R1,#0x80000000
   \       0x1E   0x6001             STR      R1,[R0, #+0]
   2980          
   2981          	/* Remove the event list form the event flag.  Interrupts do not access
   2982          	event flags. */
   2983          	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
   \       0x20   0x68C4             LDR      R4,[R0, #+12]
   2984          	configASSERT( pxUnblockedTCB );
   \       0x22   0xB93C             CBNZ.N   R4,??xTaskRemoveFromUnorderedEventList_2
   \       0x24   0x2020             MOVS     R0,#+32
   \       0x26   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x2A   0xF3BF 0x8F4F      DSB      SY
   \       0x2E   0xF3BF 0x8F6F      ISB      SY
   \                     ??xTaskRemoveFromUnorderedEventList_3: (+1)
   \       0x32   0xE7FE             B.N      ??xTaskRemoveFromUnorderedEventList_3
   2985          	( void ) uxListRemove( pxEventListItem );
   \                     ??xTaskRemoveFromUnorderedEventList_2: (+1)
   \       0x34   0x.... 0x....      BL       uxListRemove
   2986          
   2987          	/* Remove the task from the delayed list and add it to the ready list.  The
   2988          	scheduler is suspended so interrupts will not be accessing the ready
   2989          	lists. */
   2990          	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
   \       0x38   0x1D20             ADDS     R0,R4,#+4
   \       0x3A   0x.... 0x....      BL       uxListRemove
   2991          	prvAddTaskToReadyList( pxUnblockedTCB );
   \       0x3E   0x6AE0             LDR      R0,[R4, #+44]
   \       0x40   0x6F69             LDR      R1,[R5, #+116]
   \       0x42   0x2201             MOVS     R2,#+1
   \       0x44   0x4082             LSLS     R2,R2,R0
   \       0x46   0x4311             ORRS     R1,R2,R1
   \       0x48   0x6769             STR      R1,[R5, #+116]
   \       0x4A   0xEB00 0x0380      ADD      R3,R0,R0, LSL #+2
   \       0x4E   0x1D21             ADDS     R1,R4,#+4
   \       0x50   0xEB05 0x0083      ADD      R0,R5,R3, LSL #+2
   \       0x54   0x.... 0x....      BL       vListInsertEnd
   2992          
   2993          	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   \       0x58   0x6E68             LDR      R0,[R5, #+100]
   \       0x5A   0x6AC1             LDR      R1,[R0, #+44]
   \       0x5C   0x6AE0             LDR      R0,[R4, #+44]
   \       0x5E   0x4281             CMP      R1,R0
   \       0x60   0xD200             BCS.N    ??xTaskRemoveFromUnorderedEventList_4
   2994          	{
   2995          		/* Return true if the task removed from the event list has
   2996          		a higher priority than the calling task.  This allows
   2997          		the calling task to know if it should force a context
   2998          		switch now. */
   2999          		xReturn = pdTRUE;
   \       0x62   0x....             B.N      ?Subroutine3
   3000          
   3001          		/* Mark that a yield is pending in case the user is not using the
   3002          		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
   3003          		xYieldPending = pdTRUE;
   3004          	}
   3005          	else
   3006          	{
   3007          		xReturn = pdFALSE;
   \                     ??xTaskRemoveFromUnorderedEventList_4: (+1)
   \       0x64   0x2000             MOVS     R0,#+0
   3008          	}
   3009          
   3010          	return xReturn;
   \       0x66   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3011          }
   3012          /*-----------------------------------------------------------*/
   3013          

   \                                 In section .text, align 2, keep-with-next
   3014          void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
   3015          {
   3016          	configASSERT( pxTimeOut );
   \                     vTaskSetTimeOutState: (+1)
   \        0x0   0xB938             CBNZ.N   R0,??vTaskSetTimeOutState_0
   \        0x2   0x2020             MOVS     R0,#+32
   \        0x4   0xF380 0x8811      MSR      BASEPRI,R0
   \        0x8   0xF3BF 0x8F4F      DSB      SY
   \        0xC   0xF3BF 0x8F6F      ISB      SY
   \                     ??vTaskSetTimeOutState_1: (+1)
   \       0x10   0xE7FE             B.N      ??vTaskSetTimeOutState_1
   3017          	pxTimeOut->xOverflowCount = xNumOfOverflows;
   \                     ??vTaskSetTimeOutState_0: (+1)
   \       0x12   0x.... 0x....      LDR.W    R1,??DataTable52
   \       0x16   0x6CCA             LDR      R2,[R1, #+76]
   \       0x18   0x6002             STR      R2,[R0, #+0]
   3018          	pxTimeOut->xTimeOnEntering = xTickCount;
   \       0x1A   0x6C09             LDR      R1,[R1, #+64]
   \       0x1C   0x6041             STR      R1,[R0, #+4]
   3019          }
   \       0x1E   0x4770             BX       LR               ;; return
   3020          /*-----------------------------------------------------------*/
   3021          

   \                                 In section .text, align 2, keep-with-next
   3022          BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
   3023          {
   \                     xTaskCheckForTimeOut: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x460D             MOV      R5,R1
   3024          BaseType_t xReturn;
   3025          
   3026          	configASSERT( pxTimeOut );
   \        0x6   0xD107             BNE.N    ??xTaskCheckForTimeOut_0
   \        0x8   0x2020             MOVS     R0,#+32
   \        0xA   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xE   0xF3BF 0x8F4F      DSB      SY
   \       0x12   0xF3BF 0x8F6F      ISB      SY
   \                     ??xTaskCheckForTimeOut_1: (+1)
   \       0x16   0xE7FE             B.N      ??xTaskCheckForTimeOut_1
   3027          	configASSERT( pxTicksToWait );
   \                     ??xTaskCheckForTimeOut_0: (+1)
   \       0x18   0xB93D             CBNZ.N   R5,??xTaskCheckForTimeOut_2
   \       0x1A   0x2020             MOVS     R0,#+32
   \       0x1C   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x20   0xF3BF 0x8F4F      DSB      SY
   \       0x24   0xF3BF 0x8F6F      ISB      SY
   \                     ??xTaskCheckForTimeOut_3: (+1)
   \       0x28   0xE7FE             B.N      ??xTaskCheckForTimeOut_3
   3028          
   3029          	taskENTER_CRITICAL();
   \                     ??xTaskCheckForTimeOut_2: (+1)
   \       0x2A   0x.... 0x....      BL       vPortEnterCritical
   3030          	{
   3031          		/* Minor optimisation.  The tick count cannot change in this block. */
   3032          		const TickType_t xConstTickCount = xTickCount;
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable52
   \       0x32   0x6C01             LDR      R1,[R0, #+64]
   3033          
   3034          		#if( INCLUDE_xTaskAbortDelay == 1 )
   3035          			if( pxCurrentTCB->ucDelayAborted != pdFALSE )
   3036          			{
   3037          				/* The delay was aborted, which is not the same as a time out,
   3038          				but has the same result. */
   3039          				pxCurrentTCB->ucDelayAborted = pdFALSE;
   3040          				xReturn = pdTRUE;
   3041          			}
   3042          			else
   3043          		#endif
   3044          
   3045          		#if ( INCLUDE_vTaskSuspend == 1 )
   3046          			if( *pxTicksToWait == portMAX_DELAY )
   \       0x34   0x682A             LDR      R2,[R5, #+0]
   \       0x36   0xF112 0x0F01      CMN      R2,#+1
   \       0x3A   0xD00F             BEQ.N    ??xTaskCheckForTimeOut_4
   3047          			{
   3048          				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
   3049          				specified is the maximum block time then the task should block
   3050          				indefinitely, and therefore never time out. */
   3051          				xReturn = pdFALSE;
   3052          			}
   3053          			else
   3054          		#endif
   3055          
   3056          		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
   \       0x3C   0x6863             LDR      R3,[R4, #+4]
   \       0x3E   0x6CC0             LDR      R0,[R0, #+76]
   \       0x40   0x6826             LDR      R6,[R4, #+0]
   \       0x42   0x42B0             CMP      R0,R6
   \       0x44   0xD001             BEQ.N    ??xTaskCheckForTimeOut_5
   \       0x46   0x4299             CMP      R1,R3
   \       0x48   0xD20A             BCS.N    ??xTaskCheckForTimeOut_6
   3057          		{
   3058          			/* The tick count is greater than the time at which
   3059          			vTaskSetTimeout() was called, but has also overflowed since
   3060          			vTaskSetTimeOut() was called.  It must have wrapped all the way
   3061          			around and gone past again. This passed since vTaskSetTimeout()
   3062          			was called. */
   3063          			xReturn = pdTRUE;
   3064          		}
   3065          		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
   \                     ??xTaskCheckForTimeOut_5: (+1)
   \       0x4A   0x1AC8             SUBS     R0,R1,R3
   \       0x4C   0x4290             CMP      R0,R2
   \       0x4E   0xD207             BCS.N    ??xTaskCheckForTimeOut_6
   3066          		{
   3067          			/* Not a genuine timeout. Adjust parameters for time remaining. */
   3068          			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
   \       0x50   0x1A51             SUBS     R1,R2,R1
   \       0x52   0x1859             ADDS     R1,R3,R1
   \       0x54   0x6029             STR      R1,[R5, #+0]
   3069          			vTaskSetTimeOutState( pxTimeOut );
   \       0x56   0x4620             MOV      R0,R4
   \       0x58   0x.... 0x....      BL       vTaskSetTimeOutState
   3070          			xReturn = pdFALSE;
   \                     ??xTaskCheckForTimeOut_4: (+1)
   \       0x5C   0x2400             MOVS     R4,#+0
   \       0x5E   0xE000             B.N      ??xTaskCheckForTimeOut_7
   3071          		}
   3072          		else
   3073          		{
   3074          			xReturn = pdTRUE;
   \                     ??xTaskCheckForTimeOut_6: (+1)
   \       0x60   0x2401             MOVS     R4,#+1
   3075          		}
   3076          	}
   3077          	taskEXIT_CRITICAL();
   \                     ??xTaskCheckForTimeOut_7: (+1)
   \       0x62   0x.... 0x....      BL       vPortExitCritical
   3078          
   3079          	return xReturn;
   \       0x66   0x4620             MOV      R0,R4
   \       0x68   0xBD70             POP      {R4-R6,PC}       ;; return
   3080          }
   3081          /*-----------------------------------------------------------*/
   3082          

   \                                 In section .text, align 2, keep-with-next
   3083          void vTaskMissedYield( void )
   3084          {
   3085          	xYieldPending = pdTRUE;
   \                     vTaskMissedYield: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable52_1
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0x6788             STR      R0,[R1, #+120]
   3086          }
   \        0x8   0x4770             BX       LR               ;; return
   3087          /*-----------------------------------------------------------*/
   3088          
   3089          #if ( configUSE_TRACE_FACILITY == 1 )
   3090          

   \                                 In section .text, align 2, keep-with-next
   3091          	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
   3092          	{
   3093          	UBaseType_t uxReturn;
   3094          	TCB_t *pxTCB;
   3095          
   3096          		if( xTask != NULL )
   \                     uxTaskGetTaskNumber: (+1)
   \        0x0   0xB100             CBZ.N    R0,??uxTaskGetTaskNumber_0
   3097          		{
   3098          			pxTCB = ( TCB_t * ) xTask;
   3099          			uxReturn = pxTCB->uxTaskNumber;
   \        0x2   0x6D00             LDR      R0,[R0, #+80]
   3100          		}
   3101          		else
   3102          		{
   3103          			uxReturn = 0U;
   3104          		}
   3105          
   3106          		return uxReturn;
   \                     ??uxTaskGetTaskNumber_0: (+1)
   \        0x4   0x4770             BX       LR               ;; return
   3107          	}
   3108          
   3109          #endif /* configUSE_TRACE_FACILITY */
   3110          /*-----------------------------------------------------------*/
   3111          
   3112          #if ( configUSE_TRACE_FACILITY == 1 )
   3113          

   \                                 In section .text, align 2, keep-with-next
   3114          	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
   3115          	{
   3116          	TCB_t *pxTCB;
   3117          
   3118          		if( xTask != NULL )
   \                     vTaskSetTaskNumber: (+1)
   \        0x0   0xB100             CBZ.N    R0,??vTaskSetTaskNumber_0
   3119          		{
   3120          			pxTCB = ( TCB_t * ) xTask;
   3121          			pxTCB->uxTaskNumber = uxHandle;
   \        0x2   0x6501             STR      R1,[R0, #+80]
   3122          		}
   3123          	}
   \                     ??vTaskSetTaskNumber_0: (+1)
   \        0x4   0x4770             BX       LR               ;; return
   3124          
   3125          #endif /* configUSE_TRACE_FACILITY */
   3126          
   3127          /*
   3128           * -----------------------------------------------------------
   3129           * The Idle task.
   3130           * ----------------------------------------------------------
   3131           *
   3132           * The portTASK_FUNCTION() macro is used to allow port/compiler specific
   3133           * language extensions.  The equivalent prototype for this function is:
   3134           *
   3135           * void prvIdleTask( void *pvParameters );
   3136           *
   3137           */

   \                                 In section .text, align 4, keep-with-next
   3138          static portTASK_FUNCTION( prvIdleTask, pvParameters )
   3139          {
   \                     prvIdleTask: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   3140          	/* Stop warnings. */
   3141          	( void ) pvParameters;
   \        0x4   0x....             LDR.N    R4,??DataTable37  ;; 0xe000ed04
   \        0x6   0x....             LDR.N    R6,??DataTable36
   \        0x8   0x....             LDR.N    R7,??DataTable36_1
   \        0xA   0xF04F 0x5880      MOV      R8,#+268435456
   \        0xE   0xE01E             B.N      ??prvIdleTask_0
   \                     ??prvIdleTask_1: (+1)
   \       0x10   0x6FF0             LDR      R0,[R6, #+124]
   \       0x12   0x1C40             ADDS     R0,R0,#+1
   \       0x14   0x67F0             STR      R0,[R6, #+124]
   \       0x16   0x6978             LDR      R0,[R7, #+20]
   \       0x18   0x1E45             SUBS     R5,R0,#+1
   \       0x1A   0x41AD             SBCS     R5,R5,R5
   \       0x1C   0x.... 0x....      BL       xTaskResumeAll
   \       0x20   0x0FED             LSRS     R5,R5,#+31
   \       0x22   0xB9A5             CBNZ.N   R5,??prvIdleTask_0
   \       0x24   0x.... 0x....      BL       vPortEnterCritical
   \       0x28   0x6A38             LDR      R0,[R7, #+32]
   \       0x2A   0x68C5             LDR      R5,[R0, #+12]
   \       0x2C   0x1D28             ADDS     R0,R5,#+4
   \       0x2E   0x.... 0x....      BL       uxListRemove
   \       0x32   0x6F30             LDR      R0,[R6, #+112]
   \       0x34   0x1E40             SUBS     R0,R0,#+1
   \       0x36   0x6730             STR      R0,[R6, #+112]
   \       0x38   0x6AB8             LDR      R0,[R7, #+40]
   \       0x3A   0x1E40             SUBS     R0,R0,#+1
   \       0x3C   0x62B8             STR      R0,[R7, #+40]
   \       0x3E   0x.... 0x....      BL       vPortExitCritical
   \       0x42   0x6B28             LDR      R0,[R5, #+48]
   \       0x44   0x.... 0x....      BL       vPortFree
   \       0x48   0x4628             MOV      R0,R5
   \       0x4A   0x.... 0x....      BL       vPortFree
   \                     ??prvIdleTask_0: (+1)
   \       0x4E   0x6AB8             LDR      R0,[R7, #+40]
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD1DD             BNE.N    ??prvIdleTask_1
   3142          
   3143          	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
   3144          	SCHEDULER IS STARTED. **/
   3145          
   3146          	for( ;; )
   3147          	{
   3148          		/* See if any tasks have deleted themselves - if so then the idle task
   3149          		is responsible for freeing the deleted task's TCB and stack. */
   3150          		prvCheckTasksWaitingTermination();
   3151          
   3152          		#if ( configUSE_PREEMPTION == 0 )
   3153          		{
   3154          			/* If we are not using preemption we keep forcing a task switch to
   3155          			see if any other task has become available.  If we are using
   3156          			preemption we don't need to do this as any task becoming available
   3157          			will automatically get the processor anyway. */
   3158          			taskYIELD();
   3159          		}
   3160          		#endif /* configUSE_PREEMPTION */
   3161          
   3162          		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
   3163          		{
   3164          			/* When using preemption tasks of equal priority will be
   3165          			timesliced.  If a task that is sharing the idle priority is ready
   3166          			to run then the idle task should yield before the end of the
   3167          			timeslice.
   3168          
   3169          			A critical region is not required here as we are just reading from
   3170          			the list, and an occasional incorrect value will not matter.  If
   3171          			the ready list at the idle priority contains more than one task
   3172          			then a task other than the idle task is ready to execute. */
   3173          			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
   \       0x54   0x6831             LDR      R1,[R6, #+0]
   \       0x56   0x2901             CMP      R1,#+1
   \       0x58   0xD9F9             BLS.N    ??prvIdleTask_0
   3174          			{
   3175          				taskYIELD();
   \       0x5A   0xF8C4 0x8000      STR      R8,[R4, #+0]
   \       0x5E   0xF3BF 0x8F4F      DSB      SY
   \       0x62   0xF3BF 0x8F6F      ISB      SY
   \       0x66   0xE7F2             B.N      ??prvIdleTask_0
   3176          			}
   3177          			else
   3178          			{
   3179          				mtCOVERAGE_TEST_MARKER();
   3180          			}
   3181          		}
   3182          		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
   3183          
   3184          		#if ( configUSE_IDLE_HOOK == 1 )
   3185          		{
   3186          			extern void vApplicationIdleHook( void );
   3187          
   3188          			/* Call the user defined function from within the idle task.  This
   3189          			allows the application designer to add background functionality
   3190          			without the overhead of a separate task.
   3191          			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
   3192          			CALL A FUNCTION THAT MIGHT BLOCK. */
   3193          			vApplicationIdleHook();
   3194          		}
   3195          		#endif /* configUSE_IDLE_HOOK */
   3196          
   3197          		/* This conditional compilation should use inequality to 0, not equality
   3198          		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
   3199          		user defined low power mode	implementations require
   3200          		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
   3201          		#if ( configUSE_TICKLESS_IDLE != 0 )
   3202          		{
   3203          		TickType_t xExpectedIdleTime;
   3204          
   3205          			/* It is not desirable to suspend then resume the scheduler on
   3206          			each iteration of the idle task.  Therefore, a preliminary
   3207          			test of the expected idle time is performed without the
   3208          			scheduler suspended.  The result here is not necessarily
   3209          			valid. */
   3210          			xExpectedIdleTime = prvGetExpectedIdleTime();
   3211          
   3212          			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
   3213          			{
   3214          				vTaskSuspendAll();
   3215          				{
   3216          					/* Now the scheduler is suspended, the expected idle
   3217          					time can be sampled again, and this time its value can
   3218          					be used. */
   3219          					configASSERT( xNextTaskUnblockTime >= xTickCount );
   3220          					xExpectedIdleTime = prvGetExpectedIdleTime();
   3221          
   3222          					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
   3223          					{
   3224          						traceLOW_POWER_IDLE_BEGIN();
   3225          						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
   3226          						traceLOW_POWER_IDLE_END();
   3227          					}
   3228          					else
   3229          					{
   3230          						mtCOVERAGE_TEST_MARKER();
   3231          					}
   3232          				}
   3233          				( void ) xTaskResumeAll();
   3234          			}
   3235          			else
   3236          			{
   3237          				mtCOVERAGE_TEST_MARKER();
   3238          			}
   3239          		}
   3240          		#endif /* configUSE_TICKLESS_IDLE */
   3241          	}
   3242          }
   3243          /*-----------------------------------------------------------*/
   3244          
   3245          #if( configUSE_TICKLESS_IDLE != 0 )
   3246          
   3247          	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
   3248          	{
   3249          	/* The idle task exists in addition to the application tasks. */
   3250          	const UBaseType_t uxNonApplicationTasks = 1;
   3251          	eSleepModeStatus eReturn = eStandardSleep;
   3252          
   3253          		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
   3254          		{
   3255          			/* A task was made ready while the scheduler was suspended. */
   3256          			eReturn = eAbortSleep;
   3257          		}
   3258          		else if( xYieldPending != pdFALSE )
   3259          		{
   3260          			/* A yield was pended while the scheduler was suspended. */
   3261          			eReturn = eAbortSleep;
   3262          		}
   3263          		else
   3264          		{
   3265          			/* If all the tasks are in the suspended list (which might mean they
   3266          			have an infinite block time rather than actually being suspended)
   3267          			then it is safe to turn all clocks off and just wait for external
   3268          			interrupts. */
   3269          			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
   3270          			{
   3271          				eReturn = eNoTasksWaitingTimeout;
   3272          			}
   3273          			else
   3274          			{
   3275          				mtCOVERAGE_TEST_MARKER();
   3276          			}
   3277          		}
   3278          
   3279          		return eReturn;
   3280          	}
   3281          
   3282          #endif /* configUSE_TICKLESS_IDLE */
   3283          /*-----------------------------------------------------------*/
   3284          
   3285          #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
   3286          

   \                                 In section .text, align 2, keep-with-next
   3287          	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue )
   3288          	{
   3289          	TCB_t *pxTCB;
   3290          
   3291          		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
   \                     vTaskSetThreadLocalStoragePointer: (+1)
   \        0x0   0x2905             CMP      R1,#+5
   \        0x2   0xDA06             BGE.N    ??vTaskSetThreadLocalStoragePointer_0
   3292          		{
   3293          			pxTCB = prvGetTCBFromHandle( xTaskToSet );
   \        0x4   0xB910             CBNZ.N   R0,??vTaskSetThreadLocalStoragePointer_1
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable52_1
   \        0xA   0x6E40             LDR      R0,[R0, #+100]
   3294          			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
   \                     ??vTaskSetThreadLocalStoragePointer_1: (+1)
   \        0xC   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \       0x10   0x65C2             STR      R2,[R0, #+92]
   3295          		}
   3296          	}
   \                     ??vTaskSetThreadLocalStoragePointer_0: (+1)
   \       0x12   0x4770             BX       LR               ;; return
   3297          
   3298          #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
   3299          /*-----------------------------------------------------------*/
   3300          
   3301          #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
   3302          

   \                                 In section .text, align 2, keep-with-next
   3303          	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
   3304          	{
   \                     pvTaskGetThreadLocalStoragePointer: (+1)
   \        0x0   0x4602             MOV      R2,R0
   3305          	void *pvReturn = NULL;
   \        0x2   0x2000             MOVS     R0,#+0
   3306          	TCB_t *pxTCB;
   3307          
   3308          		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
   \        0x4   0x2905             CMP      R1,#+5
   \        0x6   0xDA06             BGE.N    ??pvTaskGetThreadLocalStoragePointer_0
   3309          		{
   3310          			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
   \        0x8   0xB912             CBNZ.N   R2,??pvTaskGetThreadLocalStoragePointer_1
   \        0xA   0x.... 0x....      LDR.W    R0,??DataTable52_1
   \        0xE   0x6E42             LDR      R2,[R0, #+100]
   3311          			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
   \                     ??pvTaskGetThreadLocalStoragePointer_1: (+1)
   \       0x10   0xEB02 0x0081      ADD      R0,R2,R1, LSL #+2
   \       0x14   0x6DC0             LDR      R0,[R0, #+92]
   3312          		}
   3313          		else
   3314          		{
   3315          			pvReturn = NULL;
   3316          		}
   3317          
   3318          		return pvReturn;
   \                     ??pvTaskGetThreadLocalStoragePointer_0: (+1)
   \       0x16   0x4770             BX       LR               ;; return
   3319          	}
   3320          
   3321          #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
   3322          /*-----------------------------------------------------------*/
   3323          
   3324          #if ( portUSING_MPU_WRAPPERS == 1 )
   3325          
   3326          	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
   3327          	{
   3328          	TCB_t *pxTCB;
   3329          
   3330          		/* If null is passed in here then we are modifying the MPU settings of
   3331          		the calling task. */
   3332          		pxTCB = prvGetTCBFromHandle( xTaskToModify );
   3333          
   3334          		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
   3335          	}
   3336          
   3337          #endif /* portUSING_MPU_WRAPPERS */
   3338          /*-----------------------------------------------------------*/
   3339          
   3340          static void prvInitialiseTaskLists( void )
   3341          {
   3342          UBaseType_t uxPriority;
   3343          
   3344          	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   3345          	{
   3346          		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
   3347          	}
   3348          
   3349          	vListInitialise( &xDelayedTaskList1 );
   3350          	vListInitialise( &xDelayedTaskList2 );
   3351          	vListInitialise( &xPendingReadyList );
   3352          
   3353          	#if ( INCLUDE_vTaskDelete == 1 )
   3354          	{
   3355          		vListInitialise( &xTasksWaitingTermination );
   3356          	}
   3357          	#endif /* INCLUDE_vTaskDelete */
   3358          
   3359          	#if ( INCLUDE_vTaskSuspend == 1 )
   3360          	{
   3361          		vListInitialise( &xSuspendedTaskList );
   3362          	}
   3363          	#endif /* INCLUDE_vTaskSuspend */
   3364          
   3365          	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
   3366          	using list2. */
   3367          	pxDelayedTaskList = &xDelayedTaskList1;
   3368          	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   3369          }
   3370          /*-----------------------------------------------------------*/
   3371          
   3372          static void prvCheckTasksWaitingTermination( void )
   3373          {
   3374          
   3375          	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
   3376          
   3377          	#if ( INCLUDE_vTaskDelete == 1 )
   3378          	{
   3379          		BaseType_t xListIsEmpty;
   3380          
   3381          		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
   3382          		too often in the idle task. */
   3383          		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   3384          		{
   3385          			vTaskSuspendAll();
   3386          			{
   3387          				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
   3388          			}
   3389          			( void ) xTaskResumeAll();
   3390          
   3391          			if( xListIsEmpty == pdFALSE )
   3392          			{
   3393          				TCB_t *pxTCB;
   3394          
   3395          				taskENTER_CRITICAL();
   3396          				{
   3397          					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
   3398          					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   3399          					--uxCurrentNumberOfTasks;
   3400          					--uxDeletedTasksWaitingCleanUp;
   3401          				}
   3402          				taskEXIT_CRITICAL();
   3403          
   3404          				prvDeleteTCB( pxTCB );
   3405          			}
   3406          			else
   3407          			{
   3408          				mtCOVERAGE_TEST_MARKER();
   3409          			}
   3410          		}
   3411          	}
   3412          	#endif /* INCLUDE_vTaskDelete */
   3413          }
   3414          /*-----------------------------------------------------------*/
   3415          
   3416          #if( configUSE_TRACE_FACILITY == 1 )
   3417          

   \                                 In section .text, align 2, keep-with-next
   3418          	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
   3419          	{
   \                     vTaskGetInfo: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x460E             MOV      R6,R1
   3420          	TCB_t *pxTCB;
   3421          
   3422          		/* xTask is NULL then get the state of the calling task. */
   3423          		pxTCB = prvGetTCBFromHandle( xTask );
   \        0x8   0xBF06             ITTE     EQ 
   \        0xA   0x.... 0x....      LDREQ.W  R0,??DataTable52_1
   \        0xE   0x6E45             LDREQ    R5,[R0, #+100]
   \       0x10   0x4625             MOVNE    R5,R4
   3424          
   3425          		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
   \       0x12   0x6035             STR      R5,[R6, #+0]
   3426          		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
   \       0x14   0xF105 0x0034      ADD      R0,R5,#+52
   \       0x18   0x6070             STR      R0,[R6, #+4]
   \       0x1A   0x4690             MOV      R8,R2
   3427          		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
   \       0x1C   0x6AE9             LDR      R1,[R5, #+44]
   \       0x1E   0x6131             STR      R1,[R6, #+16]
   \       0x20   0x461F             MOV      R7,R3
   3428          		pxTaskStatus->pxStackBase = pxTCB->pxStack;
   \       0x22   0x6B28             LDR      R0,[R5, #+48]
   \       0x24   0x61F0             STR      R0,[R6, #+28]
   3429          		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
   3430          
   3431          		#if ( INCLUDE_vTaskSuspend == 1 )
   3432          		{
   3433          			/* If the task is in the suspended list then there is a chance it is
   3434          			actually just blocked indefinitely - so really it should be reported as
   3435          			being in the Blocked state. */
   3436          			if( pxTaskStatus->eCurrentState == eSuspended )
   \       0x26   0x7B30             LDRB     R0,[R6, #+12]
   \       0x28   0x6CE9             LDR      R1,[R5, #+76]
   \       0x2A   0x60B1             STR      R1,[R6, #+8]
   \       0x2C   0x2803             CMP      R0,#+3
   \       0x2E   0xD10A             BNE.N    ??vTaskGetInfo_0
   3437          			{
   3438          				vTaskSuspendAll();
   \       0x30   0x.... 0x....      LDR.W    R0,??DataTable52_1
   \       0x34   0x6FC1             LDR      R1,[R0, #+124]
   \       0x36   0x1C49             ADDS     R1,R1,#+1
   \       0x38   0x67C1             STR      R1,[R0, #+124]
   3439          				{
   3440          					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   \       0x3A   0x6AA8             LDR      R0,[R5, #+40]
   \       0x3C   0xB108             CBZ.N    R0,??vTaskGetInfo_1
   3441          					{
   3442          						pxTaskStatus->eCurrentState = eBlocked;
   \       0x3E   0x2102             MOVS     R1,#+2
   \       0x40   0x7331             STRB     R1,[R6, #+12]
   3443          					}
   3444          				}
   3445          				xTaskResumeAll();
   \                     ??vTaskGetInfo_1: (+1)
   \       0x42   0x.... 0x....      BL       xTaskResumeAll
   3446          			}
   3447          		}
   3448          		#endif /* INCLUDE_vTaskSuspend */
   3449          
   3450          		#if ( configUSE_MUTEXES == 1 )
   3451          		{
   3452          			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
   3453          		}
   3454          		#else
   3455          		{
   3456          			pxTaskStatus->uxBasePriority = 0;
   3457          		}
   3458          		#endif
   3459          
   3460          		#if ( configGENERATE_RUN_TIME_STATS == 1 )
   3461          		{
   3462          			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
   3463          		}
   3464          		#else
   3465          		{
   3466          			pxTaskStatus->ulRunTimeCounter = 0;
   \                     ??vTaskGetInfo_0: (+1)
   \       0x46   0x2100             MOVS     R1,#+0
   \       0x48   0x6D68             LDR      R0,[R5, #+84]
   \       0x4A   0x6170             STR      R0,[R6, #+20]
   3467          		}
   3468          		#endif
   3469          
   3470          		/* Obtaining the task state is a little fiddly, so is only done if the value
   3471          		of eState passed into this function is eInvalid - otherwise the state is
   3472          		just set to whatever is passed in. */
   3473          		if( eState != eInvalid )
   \       0x4C   0x2F05             CMP      R7,#+5
   \       0x4E   0x61B1             STR      R1,[R6, #+24]
   \       0x50   0xD103             BNE.N    ??vTaskGetInfo_2
   3474          		{
   3475          			pxTaskStatus->eCurrentState = eState;
   3476          		}
   3477          		else
   3478          		{
   3479          			pxTaskStatus->eCurrentState = eTaskGetState( xTask );
   \       0x52   0x4620             MOV      R0,R4
   \       0x54   0x.... 0x....      BL       eTaskGetState
   \       0x58   0x4607             MOV      R7,R0
   3480          		}
   3481          
   3482          		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
   3483          		parameter is provided to allow it to be skipped. */
   3484          		if( xGetFreeStackSpace != pdFALSE )
   \                     ??vTaskGetInfo_2: (+1)
   \       0x5A   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x5E   0x7337             STRB     R7,[R6, #+12]
   \       0x60   0xD009             BEQ.N    ??vTaskGetInfo_3
   3485          		{
   3486          			#if ( portSTACK_GROWTH > 0 )
   3487          			{
   3488          				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
   3489          			}
   3490          			#else
   3491          			{
   3492          				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
   \       0x62   0x6B28             LDR      R0,[R5, #+48]
   \       0x64   0x2100             MOVS     R1,#+0
   \       0x66   0xE000             B.N      ??vTaskGetInfo_4
   \                     ??vTaskGetInfo_5: (+1)
   \       0x68   0x1C49             ADDS     R1,R1,#+1
   \                     ??vTaskGetInfo_4: (+1)
   \       0x6A   0xF810 0x2B01      LDRB     R2,[R0], #+1
   \       0x6E   0x2AA5             CMP      R2,#+165
   \       0x70   0xD0FA             BEQ.N    ??vTaskGetInfo_5
   3493          			}
   3494          			#endif
   3495          		}
   \       0x72   0x0889             LSRS     R1,R1,#+2
   \       0x74   0xE000             B.N      ??vTaskGetInfo_6
   3496          		else
   3497          		{
   3498          			pxTaskStatus->usStackHighWaterMark = 0;
   \                     ??vTaskGetInfo_3: (+1)
   \       0x76   0x2100             MOVS     R1,#+0
   \                     ??vTaskGetInfo_6: (+1)
   \       0x78   0x8431             STRH     R1,[R6, #+32]
   3499          		}
   3500          	}
   \       0x7A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   3501          
   3502          #endif /* configUSE_TRACE_FACILITY */
   3503          /*-----------------------------------------------------------*/
   3504          
   3505          #if ( configUSE_TRACE_FACILITY == 1 )
   3506          

   \                                 In section .text, align 2, keep-with-next
   3507          	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
   3508          	{
   \                     prvListTasksWithinSingleList: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   3509          	volatile TCB_t *pxNextTCB, *pxFirstTCB;
   3510          	UBaseType_t uxTask = 0;
   3511          
   3512          		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
   \        0x4   0x680B             LDR      R3,[R1, #+0]
   \        0x6   0x2B00             CMP      R3,#+0
   \        0x8   0xF04F 0x0B00      MOV      R11,#+0
   \        0xC   0xD058             BEQ.N    ??prvListTasksWithinSingleList_0
   3513          		{
   3514          			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
   \        0xE   0x684B             LDR      R3,[R1, #+4]
   \       0x10   0x.... 0x....      LDR.W    R5,??DataTable52_1
   \       0x14   0x685B             LDR      R3,[R3, #+4]
   \       0x16   0x604B             STR      R3,[R1, #+4]
   \       0x18   0xF101 0x0408      ADD      R4,R1,#+8
   \       0x1C   0x42A3             CMP      R3,R4
   \       0x1E   0xBF04             ITT      EQ 
   \       0x20   0x685B             LDREQ    R3,[R3, #+4]
   \       0x22   0x604B             STREQ    R3,[R1, #+4]
   \       0x24   0x684B             LDR      R3,[R1, #+4]
   \       0x26   0xF8D3 0x800C      LDR      R8,[R3, #+12]
   \       0x2A   0xF100 0x040C      ADD      R4,R0,#+12
   \       0x2E   0x460E             MOV      R6,R1
   \       0x30   0x4692             MOV      R10,R2
   3515          
   3516          			/* Populate an TaskStatus_t structure within the
   3517          			pxTaskStatusArray array for each task that is referenced from
   3518          			pxList.  See the definition of TaskStatus_t in task.h for the
   3519          			meaning of each TaskStatus_t structure member. */
   3520          			do
   3521          			{
   3522          				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
   \                     ??prvListTasksWithinSingleList_1: (+1)
   \       0x32   0x6870             LDR      R0,[R6, #+4]
   \       0x34   0x6840             LDR      R0,[R0, #+4]
   \       0x36   0x6070             STR      R0,[R6, #+4]
   \       0x38   0xF106 0x0108      ADD      R1,R6,#+8
   \       0x3C   0x4288             CMP      R0,R1
   \       0x3E   0xBF04             ITT      EQ 
   \       0x40   0x6840             LDREQ    R0,[R0, #+4]
   \       0x42   0x6070             STREQ    R0,[R6, #+4]
   \       0x44   0x6870             LDR      R0,[R6, #+4]
   \       0x46   0xF8D0 0x900C      LDR      R9,[R0, #+12]
   3523          				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
   \       0x4A   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x4E   0xBF0C             ITE      EQ 
   \       0x50   0x6E6F             LDREQ    R7,[R5, #+100]
   \       0x52   0x464F             MOVNE    R7,R9
   \       0x54   0xF107 0x0034      ADD      R0,R7,#+52
   \       0x58   0xF844 0x7C0C      STR      R7,[R4, #-12]
   \       0x5C   0xF844 0x0C08      STR      R0,[R4, #-8]
   \       0x60   0x6AF9             LDR      R1,[R7, #+44]
   \       0x62   0x6061             STR      R1,[R4, #+4]
   \       0x64   0x6B38             LDR      R0,[R7, #+48]
   \       0x66   0x6120             STR      R0,[R4, #+16]
   \       0x68   0x6CF9             LDR      R1,[R7, #+76]
   \       0x6A   0xF844 0x1C04      STR      R1,[R4, #-4]
   \       0x6E   0x7820             LDRB     R0,[R4, #+0]
   \       0x70   0x2803             CMP      R0,#+3
   \       0x72   0xD108             BNE.N    ??prvListTasksWithinSingleList_2
   \       0x74   0x6FE8             LDR      R0,[R5, #+124]
   \       0x76   0x1C40             ADDS     R0,R0,#+1
   \       0x78   0x67E8             STR      R0,[R5, #+124]
   \       0x7A   0x6AB8             LDR      R0,[R7, #+40]
   \       0x7C   0xB108             CBZ.N    R0,??prvListTasksWithinSingleList_3
   \       0x7E   0x2102             MOVS     R1,#+2
   \       0x80   0x7021             STRB     R1,[R4, #+0]
   \                     ??prvListTasksWithinSingleList_3: (+1)
   \       0x82   0x.... 0x....      BL       xTaskResumeAll
   \                     ??prvListTasksWithinSingleList_2: (+1)
   \       0x86   0x2100             MOVS     R1,#+0
   \       0x88   0x6D78             LDR      R0,[R7, #+84]
   \       0x8A   0x60A0             STR      R0,[R4, #+8]
   \       0x8C   0x60E1             STR      R1,[R4, #+12]
   \       0x8E   0xF1BA 0x0F05      CMP      R10,#+5
   \       0x92   0xBF18             IT       NE 
   \       0x94   0xF884 0xA000      STRBNE   R10,[R4, #+0]
   \       0x98   0xD103             BNE.N    ??prvListTasksWithinSingleList_4
   \       0x9A   0x4648             MOV      R0,R9
   \       0x9C   0x.... 0x....      BL       eTaskGetState
   \       0xA0   0x7020             STRB     R0,[R4, #+0]
   \                     ??prvListTasksWithinSingleList_4: (+1)
   \       0xA2   0x2100             MOVS     R1,#+0
   \       0xA4   0x6B38             LDR      R0,[R7, #+48]
   \       0xA6   0xE000             B.N      ??prvListTasksWithinSingleList_5
   \                     ??prvListTasksWithinSingleList_6: (+1)
   \       0xA8   0x1C49             ADDS     R1,R1,#+1
   \                     ??prvListTasksWithinSingleList_5: (+1)
   \       0xAA   0xF810 0x2B01      LDRB     R2,[R0], #+1
   \       0xAE   0x2AA5             CMP      R2,#+165
   \       0xB0   0xD0FA             BEQ.N    ??prvListTasksWithinSingleList_6
   \       0xB2   0x0889             LSRS     R1,R1,#+2
   \       0xB4   0x82A1             STRH     R1,[R4, #+20]
   3524          				uxTask++;
   3525          			} while( pxNextTCB != pxFirstTCB );
   \       0xB6   0x3424             ADDS     R4,R4,#+36
   \       0xB8   0x45C1             CMP      R9,R8
   \       0xBA   0xF10B 0x0B01      ADD      R11,R11,#+1
   \       0xBE   0xD1B8             BNE.N    ??prvListTasksWithinSingleList_1
   3526          		}
   3527          		else
   3528          		{
   3529          			mtCOVERAGE_TEST_MARKER();
   3530          		}
   3531          
   3532          		return uxTask;
   \                     ??prvListTasksWithinSingleList_0: (+1)
   \       0xC0   0x4658             MOV      R0,R11
   \       0xC2   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   3533          	}
   3534          
   3535          #endif /* configUSE_TRACE_FACILITY */
   3536          /*-----------------------------------------------------------*/
   3537          
   3538          #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
   3539          
   3540          	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
   3541          	{
   3542          	uint32_t ulCount = 0U;
   3543          
   3544          		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
   3545          		{
   3546          			pucStackByte -= portSTACK_GROWTH;
   3547          			ulCount++;
   3548          		}
   3549          
   3550          		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
   3551          
   3552          		return ( uint16_t ) ulCount;
   3553          	}
   3554          
   3555          #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
   3556          /*-----------------------------------------------------------*/
   3557          
   3558          #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
   3559          
   3560          	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
   3561          	{
   3562          	TCB_t *pxTCB;
   3563          	uint8_t *pucEndOfStack;
   3564          	UBaseType_t uxReturn;
   3565          
   3566          		pxTCB = prvGetTCBFromHandle( xTask );
   3567          
   3568          		#if portSTACK_GROWTH < 0
   3569          		{
   3570          			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
   3571          		}
   3572          		#else
   3573          		{
   3574          			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
   3575          		}
   3576          		#endif
   3577          
   3578          		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
   3579          
   3580          		return uxReturn;
   3581          	}
   3582          
   3583          #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
   3584          /*-----------------------------------------------------------*/
   3585          
   3586          #if ( INCLUDE_vTaskDelete == 1 )
   3587          
   3588          	static void prvDeleteTCB( TCB_t *pxTCB )
   3589          	{
   3590          		/* This call is required specifically for the TriCore port.  It must be
   3591          		above the vPortFree() calls.  The call is also used by ports/demos that
   3592          		want to allocate and clean RAM statically. */
   3593          		portCLEAN_UP_TCB( pxTCB );
   3594          
   3595          		/* Free up the memory allocated by the scheduler for the task.  It is up
   3596          		to the task to free any memory allocated at the application level. */
   3597          		#if ( configUSE_NEWLIB_REENTRANT == 1 )
   3598          		{
   3599          			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
   3600          		}
   3601          		#endif /* configUSE_NEWLIB_REENTRANT */
   3602          
   3603          		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
   3604          		{
   3605          			/* The task can only have been allocated dynamically - free both
   3606          			the stack and TCB. */
   3607          			vPortFree( pxTCB->pxStack );
   3608          			vPortFree( pxTCB );
   3609          		}
   3610          		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE == 1 )
   3611          		{
   3612          			/* The task could have been allocated statically or dynamically, so
   3613          			check what was statically allocated before trying to free the
   3614          			memory. */
   3615          			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
   3616          			{
   3617          				/* Both the stack and TCB were allocated dynamically, so both
   3618          				must be freed. */
   3619          				vPortFree( pxTCB->pxStack );
   3620          				vPortFree( pxTCB );
   3621          			}
   3622          			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
   3623          			{
   3624          				/* Only the stack was statically allocated, so the TCB is the
   3625          				only memory that must be freed. */
   3626          				vPortFree( pxTCB );
   3627          			}
   3628          			else
   3629          			{
   3630          				/* Neither the stack nor the TCB were allocated dynamically, so
   3631          				nothing needs to be freed. */
   3632          				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
   3633          				mtCOVERAGE_TEST_MARKER();
   3634          			}
   3635          		}
   3636          		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
   3637          	}
   3638          
   3639          #endif /* INCLUDE_vTaskDelete */
   3640          /*-----------------------------------------------------------*/
   3641          

   \                                 In section .text, align 2, keep-with-next
   3642          static void prvResetNextTaskUnblockTime( void )
   3643          {
   3644          TCB_t *pxTCB;
   3645          
   3646          	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   \                     prvResetNextTaskUnblockTime: (+1)
   \        0x0   0x.... 0x....      LDR.W    R2,??DataTable52_1
   \        0x4   0x.... 0x....      LDR.W    R1,??DataTable52
   \        0x8   0x6E93             LDR      R3,[R2, #+104]
   \        0xA   0x6818             LDR      R0,[R3, #+0]
   \        0xC   0xB910             CBNZ.N   R0,??prvResetNextTaskUnblockTime_0
   3647          	{
   3648          		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
   3649          		the maximum possible value so it is	extremely unlikely that the
   3650          		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
   3651          		there is an item in the delayed list. */
   3652          		xNextTaskUnblockTime = portMAX_DELAY;
   \        0xE   0xF04F 0x32FF      MOV      R2,#-1
   \       0x12   0xE003             B.N      ??prvResetNextTaskUnblockTime_1
   3653          	}
   3654          	else
   3655          	{
   3656          		/* The new current delayed list is not empty, get the value of
   3657          		the item at the head of the delayed list.  This is the time at
   3658          		which the task at the head of the delayed list should be removed
   3659          		from the Blocked state. */
   3660          		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   3661          		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
   \                     ??prvResetNextTaskUnblockTime_0: (+1)
   \       0x14   0x6E90             LDR      R0,[R2, #+104]
   \       0x16   0x68C2             LDR      R2,[R0, #+12]
   \       0x18   0x68D0             LDR      R0,[R2, #+12]
   \       0x1A   0x6842             LDR      R2,[R0, #+4]
   \                     ??prvResetNextTaskUnblockTime_1: (+1)
   \       0x1C   0x654A             STR      R2,[R1, #+84]
   3662          	}
   3663          }
   \       0x1E   0x4770             BX       LR               ;; return
   3664          /*-----------------------------------------------------------*/
   3665          
   3666          #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
   3667          

   \                                 In section .text, align 2, keep-with-next
   3668          	TaskHandle_t xTaskGetCurrentTaskHandle( void )
   3669          	{
   3670          	TaskHandle_t xReturn;
   3671          
   3672          		/* A critical section is not required as this is not called from
   3673          		an interrupt and the current TCB will always be the same for any
   3674          		individual execution thread. */
   3675          		xReturn = pxCurrentTCB;
   3676          
   3677          		return xReturn;
   \                     xTaskGetCurrentTaskHandle: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable52_1
   \        0x4   0x6E40             LDR      R0,[R0, #+100]
   \        0x6   0x4770             BX       LR               ;; return
   3678          	}
   3679          
   3680          #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
   3681          /*-----------------------------------------------------------*/
   3682          
   3683          #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
   3684          

   \                                 In section .text, align 2, keep-with-next
   3685          	BaseType_t xTaskGetSchedulerState( void )
   3686          	{
   3687          	BaseType_t xReturn;
   3688          
   3689          		if( xSchedulerRunning == pdFALSE )
   \                     xTaskGetSchedulerState: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable52
   \        0x4   0x6C48             LDR      R0,[R1, #+68]
   \        0x6   0xB908             CBNZ.N   R0,??xTaskGetSchedulerState_0
   3690          		{
   3691          			xReturn = taskSCHEDULER_NOT_STARTED;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0x4770             BX       LR
   3692          		}
   3693          		else
   3694          		{
   3695          			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   \                     ??xTaskGetSchedulerState_0: (+1)
   \        0xC   0x.... 0x....      LDR.W    R1,??DataTable52_1
   \       0x10   0x6FC8             LDR      R0,[R1, #+124]
   \       0x12   0xB908             CBNZ.N   R0,??xTaskGetSchedulerState_1
   3696          			{
   3697          				xReturn = taskSCHEDULER_RUNNING;
   \       0x14   0x2002             MOVS     R0,#+2
   \       0x16   0x4770             BX       LR
   3698          			}
   3699          			else
   3700          			{
   3701          				xReturn = taskSCHEDULER_SUSPENDED;
   \                     ??xTaskGetSchedulerState_1: (+1)
   \       0x18   0x2000             MOVS     R0,#+0
   3702          			}
   3703          		}
   3704          
   3705          		return xReturn;
   \       0x1A   0x4770             BX       LR               ;; return
   3706          	}
   3707          
   3708          #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
   3709          /*-----------------------------------------------------------*/
   3710          
   3711          #if ( configUSE_MUTEXES == 1 )
   3712          

   \                                 In section .text, align 2, keep-with-next
   3713          	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
   3714          	{
   \                     vTaskPriorityInherit: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3715          	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
   3716          
   3717          		/* If the mutex was given back by an interrupt while the queue was
   3718          		locked then the mutex holder might now be NULL. */
   3719          		if( pxMutexHolder != NULL )
   \        0x4   0xD03A             BEQ.N    ??vTaskPriorityInherit_0
   3720          		{
   3721          			/* If the holder of the mutex has a priority below the priority of
   3722          			the task attempting to obtain the mutex then it will temporarily
   3723          			inherit the priority of the task attempting to obtain the mutex. */
   3724          			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
   \        0x6   0x.... 0x....      LDR.W    R5,??DataTable52_1
   \        0xA   0x6AE0             LDR      R0,[R4, #+44]
   \        0xC   0x6E69             LDR      R1,[R5, #+100]
   \        0xE   0x6ACA             LDR      R2,[R1, #+44]
   \       0x10   0x4290             CMP      R0,R2
   \       0x12   0xD233             BCS.N    ??vTaskPriorityInherit_0
   3725          			{
   3726          				/* Adjust the mutex holder state to account for its new
   3727          				priority.  Only reset the event list item value if the value is
   3728          				not	being used for anything else. */
   3729          				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   \       0x14   0x69A0             LDR      R0,[R4, #+24]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD404             BMI.N    ??vTaskPriorityInherit_1
   3730          				{
   3731          					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   \       0x1A   0x6E68             LDR      R0,[R5, #+100]
   \       0x1C   0x6AC1             LDR      R1,[R0, #+44]
   \       0x1E   0xF1C1 0x0105      RSB      R1,R1,#+5
   \       0x22   0x61A1             STR      R1,[R4, #+24]
   3732          				}
   3733          				else
   3734          				{
   3735          					mtCOVERAGE_TEST_MARKER();
   3736          				}
   3737          
   3738          				/* If the task being modified is in the ready state it will need
   3739          				to be moved into a new list. */
   3740          				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
   \                     ??vTaskPriorityInherit_1: (+1)
   \       0x24   0x6AE1             LDR      R1,[R4, #+44]
   \       0x26   0x6960             LDR      R0,[R4, #+20]
   \       0x28   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \       0x2C   0xEB05 0x0282      ADD      R2,R5,R2, LSL #+2
   \       0x30   0x4290             CMP      R0,R2
   \       0x32   0xD120             BNE.N    ??vTaskPriorityInherit_2
   3741          				{
   3742          					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   \       0x34   0x1D20             ADDS     R0,R4,#+4
   \       0x36   0x.... 0x....      BL       uxListRemove
   \       0x3A   0xB958             CBNZ.N   R0,??vTaskPriorityInherit_3
   3743          					{
   3744          						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   \       0x3C   0x6AE1             LDR      R1,[R4, #+44]
   \       0x3E   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \       0x42   0x0092             LSLS     R2,R2,#+2
   \       0x44   0x58A8             LDR      R0,[R5, R2]
   \       0x46   0xB928             CBNZ.N   R0,??vTaskPriorityInherit_3
   \       0x48   0x6F69             LDR      R1,[R5, #+116]
   \       0x4A   0x6AE0             LDR      R0,[R4, #+44]
   \       0x4C   0x2201             MOVS     R2,#+1
   \       0x4E   0x4082             LSLS     R2,R2,R0
   \       0x50   0x4391             BICS     R1,R1,R2
   \       0x52   0x6769             STR      R1,[R5, #+116]
   3745          					}
   3746          					else
   3747          					{
   3748          						mtCOVERAGE_TEST_MARKER();
   3749          					}
   3750          
   3751          					/* Inherit the priority before being moved into the new list. */
   3752          					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   3753          					prvAddTaskToReadyList( pxTCB );
   \                     ??vTaskPriorityInherit_3: (+1)
   \       0x54   0x2201             MOVS     R2,#+1
   \       0x56   0x6E68             LDR      R0,[R5, #+100]
   \       0x58   0x6AC0             LDR      R0,[R0, #+44]
   \       0x5A   0x62E0             STR      R0,[R4, #+44]
   \       0x5C   0x4082             LSLS     R2,R2,R0
   \       0x5E   0x6F69             LDR      R1,[R5, #+116]
   \       0x60   0x4311             ORRS     R1,R2,R1
   \       0x62   0x6769             STR      R1,[R5, #+116]
   \       0x64   0xEB00 0x0380      ADD      R3,R0,R0, LSL #+2
   \       0x68   0x1D21             ADDS     R1,R4,#+4
   \       0x6A   0xEB05 0x0083      ADD      R0,R5,R3, LSL #+2
   \       0x6E   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0x72   0x.... 0x....      B.W      vListInsertEnd
   3754          				}
   3755          				else
   3756          				{
   3757          					/* Just inherit the priority. */
   3758          					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   \                     ??vTaskPriorityInherit_2: (+1)
   \       0x76   0x6E68             LDR      R0,[R5, #+100]
   \       0x78   0x6AC1             LDR      R1,[R0, #+44]
   \       0x7A   0x62E1             STR      R1,[R4, #+44]
   3759          				}
   3760          
   3761          				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
   3762          			}
   3763          			else
   3764          			{
   3765          				mtCOVERAGE_TEST_MARKER();
   3766          			}
   3767          		}
   3768          		else
   3769          		{
   3770          			mtCOVERAGE_TEST_MARKER();
   3771          		}
   3772          	}
   \                     ??vTaskPriorityInherit_0: (+1)
   \       0x7C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   3773          
   3774          #endif /* configUSE_MUTEXES */
   3775          /*-----------------------------------------------------------*/
   3776          
   3777          #if ( configUSE_MUTEXES == 1 )
   3778          

   \                                 In section .text, align 2, keep-with-next
   3779          	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
   3780          	{
   \                     xTaskPriorityDisinherit: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   3781          	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
   3782          	BaseType_t xReturn = pdFALSE;
   \        0x4   0x2100             MOVS     R1,#+0
   3783          
   3784          		if( pxMutexHolder != NULL )
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD040             BEQ.N    ??xTaskPriorityDisinherit_0
   3785          		{
   3786          			/* A task can only have an inherited priority if it holds the mutex.
   3787          			If the mutex is held by a task then it cannot be given from an
   3788          			interrupt, and if a mutex is given by the holding task then it must
   3789          			be the running state task. */
   3790          			configASSERT( pxTCB == pxCurrentTCB );
   \        0xA   0x.... 0x....      LDR.W    R5,??DataTable52_1
   \        0xE   0x6E68             LDR      R0,[R5, #+100]
   \       0x10   0x4284             CMP      R4,R0
   \       0x12   0xD007             BEQ.N    ??xTaskPriorityDisinherit_1
   \       0x14   0x2120             MOVS     R1,#+32
   \       0x16   0xF381 0x8811      MSR      BASEPRI,R1
   \       0x1A   0xF3BF 0x8F4F      DSB      SY
   \       0x1E   0xF3BF 0x8F6F      ISB      SY
   \                     ??xTaskPriorityDisinherit_2: (+1)
   \       0x22   0xE7FE             B.N      ??xTaskPriorityDisinherit_2
   3791          
   3792          			configASSERT( pxTCB->uxMutexesHeld );
   \                     ??xTaskPriorityDisinherit_1: (+1)
   \       0x24   0x6DA0             LDR      R0,[R4, #+88]
   \       0x26   0xB938             CBNZ.N   R0,??xTaskPriorityDisinherit_3
   \       0x28   0x2020             MOVS     R0,#+32
   \       0x2A   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x2E   0xF3BF 0x8F4F      DSB      SY
   \       0x32   0xF3BF 0x8F6F      ISB      SY
   \                     ??xTaskPriorityDisinherit_4: (+1)
   \       0x36   0xE7FE             B.N      ??xTaskPriorityDisinherit_4
   3793          			( pxTCB->uxMutexesHeld )--;
   3794          
   3795          			/* Has the holder of the mutex inherited the priority of another
   3796          			task? */
   3797          			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   \                     ??xTaskPriorityDisinherit_3: (+1)
   \       0x38   0x6AE2             LDR      R2,[R4, #+44]
   \       0x3A   0x6D63             LDR      R3,[R4, #+84]
   \       0x3C   0x1E40             SUBS     R0,R0,#+1
   \       0x3E   0x429A             CMP      R2,R3
   \       0x40   0x65A0             STR      R0,[R4, #+88]
   \       0x42   0xD023             BEQ.N    ??xTaskPriorityDisinherit_0
   3798          			{
   3799          				/* Only disinherit if no other mutexes are held. */
   3800          				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
   \       0x44   0xBB10             CBNZ.N   R0,??xTaskPriorityDisinherit_0
   3801          				{
   3802          					/* A task can only have an inherited priority if it holds
   3803          					the mutex.  If the mutex is held by a task then it cannot be
   3804          					given from an interrupt, and if a mutex is given by the
   3805          					holding	task then it must be the running state task.  Remove
   3806          					the	holding task from the ready	list. */
   3807          					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   \       0x46   0x1D20             ADDS     R0,R4,#+4
   \       0x48   0x.... 0x....      BL       uxListRemove
   \       0x4C   0xB958             CBNZ.N   R0,??xTaskPriorityDisinherit_5
   3808          					{
   3809          						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   \       0x4E   0x6AE1             LDR      R1,[R4, #+44]
   \       0x50   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \       0x54   0x0092             LSLS     R2,R2,#+2
   \       0x56   0x58A8             LDR      R0,[R5, R2]
   \       0x58   0xB928             CBNZ.N   R0,??xTaskPriorityDisinherit_5
   \       0x5A   0x6F69             LDR      R1,[R5, #+116]
   \       0x5C   0x6AE0             LDR      R0,[R4, #+44]
   \       0x5E   0x2201             MOVS     R2,#+1
   \       0x60   0x4082             LSLS     R2,R2,R0
   \       0x62   0x4391             BICS     R1,R1,R2
   \       0x64   0x6769             STR      R1,[R5, #+116]
   3810          					}
   3811          					else
   3812          					{
   3813          						mtCOVERAGE_TEST_MARKER();
   3814          					}
   3815          
   3816          					/* Disinherit the priority before adding the task into the
   3817          					new	ready list. */
   3818          					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
   3819          					pxTCB->uxPriority = pxTCB->uxBasePriority;
   3820          
   3821          					/* Reset the event list item value.  It cannot be in use for
   3822          					any other purpose if this task is running, and it must be
   3823          					running to give back the mutex. */
   3824          					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   3825          					prvAddTaskToReadyList( pxTCB );
   \                     ??xTaskPriorityDisinherit_5: (+1)
   \       0x66   0x2201             MOVS     R2,#+1
   \       0x68   0x6D60             LDR      R0,[R4, #+84]
   \       0x6A   0x62E0             STR      R0,[R4, #+44]
   \       0x6C   0xF1C0 0x0005      RSB      R0,R0,#+5
   \       0x70   0x61A0             STR      R0,[R4, #+24]
   \       0x72   0x6AE0             LDR      R0,[R4, #+44]
   \       0x74   0x6F69             LDR      R1,[R5, #+116]
   \       0x76   0x4082             LSLS     R2,R2,R0
   \       0x78   0x4311             ORRS     R1,R2,R1
   \       0x7A   0x6769             STR      R1,[R5, #+116]
   \       0x7C   0xEB00 0x0380      ADD      R3,R0,R0, LSL #+2
   \       0x80   0x1D21             ADDS     R1,R4,#+4
   \       0x82   0xEB05 0x0083      ADD      R0,R5,R3, LSL #+2
   \       0x86   0x.... 0x....      BL       vListInsertEnd
   3826          
   3827          					/* Return true to indicate that a context switch is required.
   3828          					This is only actually required in the corner case whereby
   3829          					multiple mutexes were held and the mutexes were given back
   3830          					in an order different to that in which they were taken.
   3831          					If a context switch did not occur when the first mutex was
   3832          					returned, even if a task was waiting on it, then a context
   3833          					switch should occur when the last mutex is returned whether
   3834          					a task is waiting on it or not. */
   3835          					xReturn = pdTRUE;
   \       0x8A   0x2101             MOVS     R1,#+1
   3836          				}
   3837          				else
   3838          				{
   3839          					mtCOVERAGE_TEST_MARKER();
   3840          				}
   3841          			}
   3842          			else
   3843          			{
   3844          				mtCOVERAGE_TEST_MARKER();
   3845          			}
   3846          		}
   3847          		else
   3848          		{
   3849          			mtCOVERAGE_TEST_MARKER();
   3850          		}
   3851          
   3852          		return xReturn;
   \                     ??xTaskPriorityDisinherit_0: (+1)
   \       0x8C   0x4608             MOV      R0,R1
   \       0x8E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3853          	}
   3854          
   3855          #endif /* configUSE_MUTEXES */
   3856          /*-----------------------------------------------------------*/
   3857          
   3858          #if ( portCRITICAL_NESTING_IN_TCB == 1 )
   3859          
   3860          	void vTaskEnterCritical( void )
   3861          	{
   3862          		portDISABLE_INTERRUPTS();
   3863          
   3864          		if( xSchedulerRunning != pdFALSE )
   3865          		{
   3866          			( pxCurrentTCB->uxCriticalNesting )++;
   3867          
   3868          			/* This is not the interrupt safe version of the enter critical
   3869          			function so	assert() if it is being called from an interrupt
   3870          			context.  Only API functions that end in "FromISR" can be used in an
   3871          			interrupt.  Only assert if the critical nesting count is 1 to
   3872          			protect against recursive calls if the assert function also uses a
   3873          			critical section. */
   3874          			if( pxCurrentTCB->uxCriticalNesting == 1 )
   3875          			{
   3876          				portASSERT_IF_IN_ISR();
   3877          			}
   3878          		}
   3879          		else
   3880          		{
   3881          			mtCOVERAGE_TEST_MARKER();
   3882          		}
   3883          	}
   3884          
   3885          #endif /* portCRITICAL_NESTING_IN_TCB */
   3886          /*-----------------------------------------------------------*/
   3887          
   3888          #if ( portCRITICAL_NESTING_IN_TCB == 1 )
   3889          
   3890          	void vTaskExitCritical( void )
   3891          	{
   3892          		if( xSchedulerRunning != pdFALSE )
   3893          		{
   3894          			if( pxCurrentTCB->uxCriticalNesting > 0U )
   3895          			{
   3896          				( pxCurrentTCB->uxCriticalNesting )--;
   3897          
   3898          				if( pxCurrentTCB->uxCriticalNesting == 0U )
   3899          				{
   3900          					portENABLE_INTERRUPTS();
   3901          				}
   3902          				else
   3903          				{
   3904          					mtCOVERAGE_TEST_MARKER();
   3905          				}
   3906          			}
   3907          			else
   3908          			{
   3909          				mtCOVERAGE_TEST_MARKER();
   3910          			}
   3911          		}
   3912          		else
   3913          		{
   3914          			mtCOVERAGE_TEST_MARKER();
   3915          		}
   3916          	}
   3917          
   3918          #endif /* portCRITICAL_NESTING_IN_TCB */
   3919          /*-----------------------------------------------------------*/
   3920          
   3921          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
   3922          
   3923          	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
   3924          	{
   3925          	size_t x;
   3926          
   3927          		/* Start by copying the entire string. */
   3928          		strcpy( pcBuffer, pcTaskName );
   3929          
   3930          		/* Pad the end of the string with spaces to ensure columns line up when
   3931          		printed out. */
   3932          		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
   3933          		{
   3934          			pcBuffer[ x ] = ' ';
   3935          		}
   3936          
   3937          		/* Terminate. */
   3938          		pcBuffer[ x ] = 0x00;
   3939          
   3940          		/* Return the new end of string. */
   3941          		return &( pcBuffer[ x ] );
   3942          	}
   3943          
   3944          #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
   3945          /*-----------------------------------------------------------*/
   3946          
   3947          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
   3948          
   3949          	void vTaskList( char * pcWriteBuffer )
   3950          	{
   3951          	TaskStatus_t *pxTaskStatusArray;
   3952          	volatile UBaseType_t uxArraySize, x;
   3953          	char cStatus;
   3954          
   3955          		/*
   3956          		 * PLEASE NOTE:
   3957          		 *
   3958          		 * This function is provided for convenience only, and is used by many
   3959          		 * of the demo applications.  Do not consider it to be part of the
   3960          		 * scheduler.
   3961          		 *
   3962          		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
   3963          		 * uxTaskGetSystemState() output into a human readable table that
   3964          		 * displays task names, states and stack usage.
   3965          		 *
   3966          		 * vTaskList() has a dependency on the sprintf() C library function that
   3967          		 * might bloat the code size, use a lot of stack, and provide different
   3968          		 * results on different platforms.  An alternative, tiny, third party,
   3969          		 * and limited functionality implementation of sprintf() is provided in
   3970          		 * many of the FreeRTOS/Demo sub-directories in a file called
   3971          		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
   3972          		 * snprintf() implementation!).
   3973          		 *
   3974          		 * It is recommended that production systems call uxTaskGetSystemState()
   3975          		 * directly to get access to raw stats data, rather than indirectly
   3976          		 * through a call to vTaskList().
   3977          		 */
   3978          
   3979          
   3980          		/* Make sure the write buffer does not contain a string. */
   3981          		*pcWriteBuffer = 0x00;
   3982          
   3983          		/* Take a snapshot of the number of tasks in case it changes while this
   3984          		function is executing. */
   3985          		uxArraySize = uxCurrentNumberOfTasks;
   3986          
   3987          		/* Allocate an array index for each task.  NOTE!  if
   3988          		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
   3989          		equate to NULL. */
   3990          		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
   3991          
   3992          		if( pxTaskStatusArray != NULL )
   3993          		{
   3994          			/* Generate the (binary) data. */
   3995          			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
   3996          
   3997          			/* Create a human readable table from the binary data. */
   3998          			for( x = 0; x < uxArraySize; x++ )
   3999          			{
   4000          				switch( pxTaskStatusArray[ x ].eCurrentState )
   4001          				{
   4002          					case eReady:		cStatus = tskREADY_CHAR;
   4003          										break;
   4004          
   4005          					case eBlocked:		cStatus = tskBLOCKED_CHAR;
   4006          										break;
   4007          
   4008          					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
   4009          										break;
   4010          
   4011          					case eDeleted:		cStatus = tskDELETED_CHAR;
   4012          										break;
   4013          
   4014          					default:			/* Should not get here, but it is included
   4015          										to prevent static checking errors. */
   4016          										cStatus = 0x00;
   4017          										break;
   4018          				}
   4019          
   4020          				/* Write the task name to the string, padding with spaces so it
   4021          				can be printed in tabular form more easily. */
   4022          				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
   4023          
   4024          				/* Write the rest of the string. */
   4025          				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
   4026          				pcWriteBuffer += strlen( pcWriteBuffer );
   4027          			}
   4028          
   4029          			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
   4030          			is 0 then vPortFree() will be #defined to nothing. */
   4031          			vPortFree( pxTaskStatusArray );
   4032          		}
   4033          		else
   4034          		{
   4035          			mtCOVERAGE_TEST_MARKER();
   4036          		}
   4037          	}
   4038          
   4039          #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
   4040          /*----------------------------------------------------------*/
   4041          
   4042          #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
   4043          
   4044          	void vTaskGetRunTimeStats( char *pcWriteBuffer )
   4045          	{
   4046          	TaskStatus_t *pxTaskStatusArray;
   4047          	volatile UBaseType_t uxArraySize, x;
   4048          	uint32_t ulTotalTime, ulStatsAsPercentage;
   4049          
   4050          		#if( configUSE_TRACE_FACILITY != 1 )
   4051          		{
   4052          			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTimeStats().
   4053          		}
   4054          		#endif
   4055          
   4056          		/*
   4057          		 * PLEASE NOTE:
   4058          		 *
   4059          		 * This function is provided for convenience only, and is used by many
   4060          		 * of the demo applications.  Do not consider it to be part of the
   4061          		 * scheduler.
   4062          		 *
   4063          		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
   4064          		 * of the uxTaskGetSystemState() output into a human readable table that
   4065          		 * displays the amount of time each task has spent in the Running state
   4066          		 * in both absolute and percentage terms.
   4067          		 *
   4068          		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
   4069          		 * function that might bloat the code size, use a lot of stack, and
   4070          		 * provide different results on different platforms.  An alternative,
   4071          		 * tiny, third party, and limited functionality implementation of
   4072          		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
   4073          		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
   4074          		 * a full snprintf() implementation!).
   4075          		 *
   4076          		 * It is recommended that production systems call uxTaskGetSystemState()
   4077          		 * directly to get access to raw stats data, rather than indirectly
   4078          		 * through a call to vTaskGetRunTimeStats().
   4079          		 */
   4080          
   4081          		/* Make sure the write buffer does not contain a string. */
   4082          		*pcWriteBuffer = 0x00;
   4083          
   4084          		/* Take a snapshot of the number of tasks in case it changes while this
   4085          		function is executing. */
   4086          		uxArraySize = uxCurrentNumberOfTasks;
   4087          
   4088          		/* Allocate an array index for each task.  NOTE!  If
   4089          		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
   4090          		equate to NULL. */
   4091          		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
   4092          
   4093          		if( pxTaskStatusArray != NULL )
   4094          		{
   4095          			/* Generate the (binary) data. */
   4096          			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
   4097          
   4098          			/* For percentage calculations. */
   4099          			ulTotalTime /= 100UL;
   4100          
   4101          			/* Avoid divide by zero errors. */
   4102          			if( ulTotalTime > 0 )
   4103          			{
   4104          				/* Create a human readable table from the binary data. */
   4105          				for( x = 0; x < uxArraySize; x++ )
   4106          				{
   4107          					/* What percentage of the total run time has the task used?
   4108          					This will always be rounded down to the nearest integer.
   4109          					ulTotalRunTimeDiv100 has already been divided by 100. */
   4110          					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
   4111          
   4112          					/* Write the task name to the string, padding with
   4113          					spaces so it can be printed in tabular form more
   4114          					easily. */
   4115          					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
   4116          
   4117          					if( ulStatsAsPercentage > 0UL )
   4118          					{
   4119          						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
   4120          						{
   4121          							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
   4122          						}
   4123          						#else
   4124          						{
   4125          							/* sizeof( int ) == sizeof( long ) so a smaller
   4126          							printf() library can be used. */
   4127          							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
   4128          						}
   4129          						#endif
   4130          					}
   4131          					else
   4132          					{
   4133          						/* If the percentage is zero here then the task has
   4134          						consumed less than 1% of the total run time. */
   4135          						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
   4136          						{
   4137          							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
   4138          						}
   4139          						#else
   4140          						{
   4141          							/* sizeof( int ) == sizeof( long ) so a smaller
   4142          							printf() library can be used. */
   4143          							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter );
   4144          						}
   4145          						#endif
   4146          					}
   4147          
   4148          					pcWriteBuffer += strlen( pcWriteBuffer );
   4149          				}
   4150          			}
   4151          			else
   4152          			{
   4153          				mtCOVERAGE_TEST_MARKER();
   4154          			}
   4155          
   4156          			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
   4157          			is 0 then vPortFree() will be #defined to nothing. */
   4158          			vPortFree( pxTaskStatusArray );
   4159          		}
   4160          		else
   4161          		{
   4162          			mtCOVERAGE_TEST_MARKER();
   4163          		}
   4164          	}
   4165          
   4166          #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
   4167          /*-----------------------------------------------------------*/
   4168          

   \                                 In section .text, align 2, keep-with-next
   4169          TickType_t uxTaskResetEventItemValue( void )
   4170          {
   4171          TickType_t uxReturn;
   4172          
   4173          	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
   \                     uxTaskResetEventItemValue: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable52_1
   \        0x4   0x6E48             LDR      R0,[R1, #+100]
   \        0x6   0x6980             LDR      R0,[R0, #+24]
   4174          
   4175          	/* Reset the event list item to its normal value - so it can be used with
   4176          	queues and semaphores. */
   4177          	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   \        0x8   0x6E4A             LDR      R2,[R1, #+100]
   \        0xA   0x6E49             LDR      R1,[R1, #+100]
   \        0xC   0x6ACB             LDR      R3,[R1, #+44]
   \        0xE   0xF1C3 0x0305      RSB      R3,R3,#+5
   \       0x12   0x6193             STR      R3,[R2, #+24]
   4178          
   4179          	return uxReturn;
   \       0x14   0x4770             BX       LR               ;; return
   4180          }
   4181          /*-----------------------------------------------------------*/
   4182          
   4183          #if ( configUSE_MUTEXES == 1 )
   4184          

   \                                 In section .text, align 2, keep-with-next
   4185          	void *pvTaskIncrementMutexHeldCount( void )
   4186          	{
   4187          		/* If xSemaphoreCreateMutex() is called before any tasks have been created
   4188          		then pxCurrentTCB will be NULL. */
   4189          		if( pxCurrentTCB != NULL )
   \                     pvTaskIncrementMutexHeldCount: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable52_1
   \        0x4   0x6E48             LDR      R0,[R1, #+100]
   \        0x6   0xB118             CBZ.N    R0,??pvTaskIncrementMutexHeldCount_0
   4190          		{
   4191          			( pxCurrentTCB->uxMutexesHeld )++;
   \        0x8   0x6E48             LDR      R0,[R1, #+100]
   \        0xA   0x6D82             LDR      R2,[R0, #+88]
   \        0xC   0x1C52             ADDS     R2,R2,#+1
   \        0xE   0x6582             STR      R2,[R0, #+88]
   4192          		}
   4193          
   4194          		return pxCurrentTCB;
   \                     ??pvTaskIncrementMutexHeldCount_0: (+1)
   \       0x10   0x6E48             LDR      R0,[R1, #+100]
   \       0x12   0x4770             BX       LR               ;; return
   4195          	}
   4196          
   4197          #endif /* configUSE_MUTEXES */
   4198          /*-----------------------------------------------------------*/
   4199          
   4200          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4201          

   \                                 In section .text, align 2, keep-with-next
   4202          	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
   4203          	{
   \                     ulTaskNotifyTake: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   4204          	uint32_t ulReturn;
   4205          
   4206          		taskENTER_CRITICAL();
   \        0x6   0x.... 0x....      BL       vPortEnterCritical
   4207          		{
   4208          			/* Only block if the notification count is not already non-zero. */
   4209          			if( pxCurrentTCB->ulNotifiedValue == 0UL )
   \        0xA   0x.... 0x....      LDR.W    R6,??DataTable52_1
   \        0xE   0x6E70             LDR      R0,[R6, #+100]
   \       0x10   0x6F00             LDR      R0,[R0, #+112]
   \       0x12   0xB980             CBNZ.N   R0,??ulTaskNotifyTake_0
   4210          			{
   4211          				/* Mark this task as waiting for a notification. */
   4212          				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
   \       0x14   0x6E70             LDR      R0,[R6, #+100]
   \       0x16   0x2101             MOVS     R1,#+1
   \       0x18   0xF880 0x1074      STRB     R1,[R0, #+116]
   4213          
   4214          				if( xTicksToWait > ( TickType_t ) 0 )
   \       0x1C   0xB15D             CBZ.N    R5,??ulTaskNotifyTake_0
   4215          				{
   4216          					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   \       0x1E   0x4628             MOV      R0,R5
   \       0x20   0x.... 0x....      BL       prvAddCurrentTaskToDelayedList
   4217          					traceTASK_NOTIFY_TAKE_BLOCK();
   4218          
   4219          					/* All ports are written to allow a yield in a critical
   4220          					section (some will yield immediately, others wait until the
   4221          					critical section exits) - but it is not something that
   4222          					application code should ever do. */
   4223          					portYIELD_WITHIN_API();
   \       0x24   0x.... 0x....      LDR.W    R1,??DataTable52_2  ;; 0xe000ed04
   \       0x28   0xF04F 0x5080      MOV      R0,#+268435456
   \       0x2C   0x6008             STR      R0,[R1, #+0]
   \       0x2E   0xF3BF 0x8F4F      DSB      SY
   \       0x32   0xF3BF 0x8F6F      ISB      SY
   4224          				}
   4225          				else
   4226          				{
   4227          					mtCOVERAGE_TEST_MARKER();
   4228          				}
   4229          			}
   4230          			else
   4231          			{
   4232          				mtCOVERAGE_TEST_MARKER();
   4233          			}
   4234          		}
   4235          		taskEXIT_CRITICAL();
   \                     ??ulTaskNotifyTake_0: (+1)
   \       0x36   0x.... 0x....      BL       vPortExitCritical
   4236          
   4237          		taskENTER_CRITICAL();
   \       0x3A   0x.... 0x....      BL       vPortEnterCritical
   4238          		{
   4239          			traceTASK_NOTIFY_TAKE();
   4240          			ulReturn = pxCurrentTCB->ulNotifiedValue;
   \       0x3E   0x6E70             LDR      R0,[R6, #+100]
   \       0x40   0x6F05             LDR      R5,[R0, #+112]
   4241          
   4242          			if( ulReturn != 0UL )
   \       0x42   0xB12D             CBZ.N    R5,??ulTaskNotifyTake_1
   4243          			{
   4244          				if( xClearCountOnExit != pdFALSE )
   4245          				{
   4246          					pxCurrentTCB->ulNotifiedValue = 0UL;
   4247          				}
   4248          				else
   4249          				{
   4250          					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
   \       0x44   0x6E71             LDR      R1,[R6, #+100]
   \       0x46   0x2C00             CMP      R4,#+0
   \       0x48   0xBF14             ITE      NE 
   \       0x4A   0x2000             MOVNE    R0,#+0
   \       0x4C   0x1E68             SUBEQ    R0,R5,#+1
   \       0x4E   0x6708             STR      R0,[R1, #+112]
   4251          				}
   4252          			}
   4253          			else
   4254          			{
   4255          				mtCOVERAGE_TEST_MARKER();
   4256          			}
   4257          
   4258          			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   \                     ??ulTaskNotifyTake_1: (+1)
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0x6E71             LDR      R1,[R6, #+100]
   \       0x54   0xF881 0x0074      STRB     R0,[R1, #+116]
   4259          		}
   4260          		taskEXIT_CRITICAL();
   \       0x58   0x.... 0x....      BL       vPortExitCritical
   4261          
   4262          		return ulReturn;
   \       0x5C   0x4628             MOV      R0,R5
   \       0x5E   0xBD70             POP      {R4-R6,PC}       ;; return
   4263          	}
   4264          
   4265          #endif /* configUSE_TASK_NOTIFICATIONS */
   4266          /*-----------------------------------------------------------*/
   4267          
   4268          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4269          

   \                                 In section .text, align 2, keep-with-next
   4270          	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
   4271          	{
   \                     xTaskNotifyWait: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x460F             MOV      R7,R1
   \        0x8   0x4614             MOV      R4,R2
   \        0xA   0x461D             MOV      R5,R3
   4272          	BaseType_t xReturn;
   4273          
   4274          		taskENTER_CRITICAL();
   \        0xC   0x.... 0x....      BL       vPortEnterCritical
   4275          		{
   4276          			/* Only block if a notification is not already pending. */
   4277          			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
   \       0x10   0x....             LDR.N    R6,??DataTable52_1
   \       0x12   0x6E70             LDR      R0,[R6, #+100]
   \       0x14   0xF890 0x0074      LDRB     R0,[R0, #+116]
   \       0x18   0x2802             CMP      R0,#+2
   \       0x1A   0xD015             BEQ.N    ??xTaskNotifyWait_0
   4278          			{
   4279          				/* Clear bits in the task's notification value as bits may get
   4280          				set	by the notifying task or interrupt.  This can be used to
   4281          				clear the value to zero. */
   4282          				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
   \       0x1C   0x6E70             LDR      R0,[R6, #+100]
   \       0x1E   0x6F01             LDR      R1,[R0, #+112]
   \       0x20   0xEA21 0x0108      BIC      R1,R1,R8
   \       0x24   0x6701             STR      R1,[R0, #+112]
   4283          
   4284          				/* Mark this task as waiting for a notification. */
   4285          				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0x6E71             LDR      R1,[R6, #+100]
   \       0x2A   0xF881 0x0074      STRB     R0,[R1, #+116]
   4286          
   4287          				if( xTicksToWait > ( TickType_t ) 0 )
   \       0x2E   0xB15D             CBZ.N    R5,??xTaskNotifyWait_0
   4288          				{
   4289          					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   \       0x30   0x2101             MOVS     R1,#+1
   \       0x32   0x4628             MOV      R0,R5
   \       0x34   0x.... 0x....      BL       prvAddCurrentTaskToDelayedList
   4290          					traceTASK_NOTIFY_WAIT_BLOCK();
   4291          
   4292          					/* All ports are written to allow a yield in a critical
   4293          					section (some will yield immediately, others wait until the
   4294          					critical section exits) - but it is not something that
   4295          					application code should ever do. */
   4296          					portYIELD_WITHIN_API();
   \       0x38   0x....             LDR.N    R1,??DataTable52_2  ;; 0xe000ed04
   \       0x3A   0xF04F 0x5080      MOV      R0,#+268435456
   \       0x3E   0x6008             STR      R0,[R1, #+0]
   \       0x40   0xF3BF 0x8F4F      DSB      SY
   \       0x44   0xF3BF 0x8F6F      ISB      SY
   4297          				}
   4298          				else
   4299          				{
   4300          					mtCOVERAGE_TEST_MARKER();
   4301          				}
   4302          			}
   4303          			else
   4304          			{
   4305          				mtCOVERAGE_TEST_MARKER();
   4306          			}
   4307          		}
   4308          		taskEXIT_CRITICAL();
   \                     ??xTaskNotifyWait_0: (+1)
   \       0x48   0x.... 0x....      BL       vPortExitCritical
   4309          
   4310          		taskENTER_CRITICAL();
   \       0x4C   0x.... 0x....      BL       vPortEnterCritical
   4311          		{
   4312          			traceTASK_NOTIFY_WAIT();
   4313          
   4314          			if( pulNotificationValue != NULL )
   \       0x50   0xB114             CBZ.N    R4,??xTaskNotifyWait_1
   4315          			{
   4316          				/* Output the current notification value, which may or may not
   4317          				have changed. */
   4318          				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
   \       0x52   0x6E70             LDR      R0,[R6, #+100]
   \       0x54   0x6F00             LDR      R0,[R0, #+112]
   \       0x56   0x6020             STR      R0,[R4, #+0]
   4319          			}
   4320          
   4321          			/* If ucNotifyValue is set then either the task never entered the
   4322          			blocked state (because a notification was already pending) or the
   4323          			task unblocked because of a notification.  Otherwise the task
   4324          			unblocked because of a timeout. */
   4325          			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
   \                     ??xTaskNotifyWait_1: (+1)
   \       0x58   0x6E70             LDR      R0,[R6, #+100]
   \       0x5A   0xF890 0x0074      LDRB     R0,[R0, #+116]
   \       0x5E   0x2801             CMP      R0,#+1
   \       0x60   0xBF08             IT       EQ 
   \       0x62   0x2400             MOVEQ    R4,#+0
   4326          			{
   4327          				/* A notification was not received. */
   4328          				xReturn = pdFALSE;
   \       0x64   0xD005             BEQ.N    ??xTaskNotifyWait_2
   4329          			}
   4330          			else
   4331          			{
   4332          				/* A notification was already pending or a notification was
   4333          				received while the task was waiting. */
   4334          				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
   \       0x66   0x6E70             LDR      R0,[R6, #+100]
   \       0x68   0x6F01             LDR      R1,[R0, #+112]
   \       0x6A   0xEA21 0x0707      BIC      R7,R1,R7
   \       0x6E   0x6707             STR      R7,[R0, #+112]
   4335          				xReturn = pdTRUE;
   \       0x70   0x2401             MOVS     R4,#+1
   4336          			}
   4337          
   4338          			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   \                     ??xTaskNotifyWait_2: (+1)
   \       0x72   0x6E71             LDR      R1,[R6, #+100]
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0xF881 0x0074      STRB     R0,[R1, #+116]
   4339          		}
   4340          		taskEXIT_CRITICAL();
   \       0x7A   0x.... 0x....      BL       vPortExitCritical
   4341          
   4342          		return xReturn;
   \       0x7E   0x4620             MOV      R0,R4
   \       0x80   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   4343          	}
   4344          
   4345          #endif /* configUSE_TASK_NOTIFICATIONS */
   4346          /*-----------------------------------------------------------*/
   4347          
   4348          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4349          

   \                                 In section .text, align 4, keep-with-next
   4350          	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
   4351          	{
   \                     xTaskGenericNotify: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460F             MOV      R7,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x461D             MOV      R5,R3
   4352          	TCB_t * pxTCB;
   4353          	BaseType_t xReturn = pdPASS;
   \        0xC   0x2601             MOVS     R6,#+1
   4354          	uint8_t ucOriginalNotifyState;
   4355          
   4356          		configASSERT( xTaskToNotify );
   \        0xE   0xB93C             CBNZ.N   R4,??xTaskGenericNotify_1
   \       0x10   0x2020             MOVS     R0,#+32
   \       0x12   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x16   0xF3BF 0x8F4F      DSB      SY
   \       0x1A   0xF3BF 0x8F6F      ISB      SY
   \                     ??xTaskGenericNotify_2: (+1)
   \       0x1E   0xE7FE             B.N      ??xTaskGenericNotify_2
   4357          		pxTCB = ( TCB_t * ) xTaskToNotify;
   4358          
   4359          		taskENTER_CRITICAL();
   \                     ??xTaskGenericNotify_1: (+1)
   \       0x20   0x.... 0x....      BL       vPortEnterCritical
   4360          		{
   4361          			if( pulPreviousNotificationValue != NULL )
   \       0x24   0xB10D             CBZ.N    R5,??xTaskGenericNotify_3
   4362          			{
   4363          				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
   \       0x26   0x6F20             LDR      R0,[R4, #+112]
   \       0x28   0x6028             STR      R0,[R5, #+0]
   4364          			}
   4365          
   4366          			ucOriginalNotifyState = pxTCB->ucNotifyState;
   4367          
   4368          			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
   \                     ??xTaskGenericNotify_3: (+1)
   \       0x2A   0x2102             MOVS     R1,#+2
   \       0x2C   0xF894 0x0074      LDRB     R0,[R4, #+116]
   \       0x30   0xF884 0x1074      STRB     R1,[R4, #+116]
   4369          
   4370          			switch( eAction )
   \       0x34   0xF1A8 0x0101      SUB      R1,R8,#+1
   \       0x38   0x2903             CMP      R1,#+3
   \       0x3A   0xD80F             BHI.N    ??xTaskGenericNotify_4
   \       0x3C   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??xTaskGenericNotify_0:
   \       0x40   0x02 0x05          DC8      0x2,0x5,0xD,0x9
   \              0x0D 0x09    
   4371          			{
   4372          				case eSetBits	:
   4373          					pxTCB->ulNotifiedValue |= ulValue;
   \                     ??xTaskGenericNotify_5: (+1)
   \       0x44   0x6F21             LDR      R1,[R4, #+112]
   \       0x46   0x430F             ORRS     R7,R7,R1
   \       0x48   0xE007             B.N      ??xTaskGenericNotify_6
   4374          					break;
   4375          
   4376          				case eIncrement	:
   4377          					( pxTCB->ulNotifiedValue )++;
   \                     ??xTaskGenericNotify_7: (+1)
   \       0x4A   0x6F21             LDR      R1,[R4, #+112]
   \       0x4C   0x1C49             ADDS     R1,R1,#+1
   \       0x4E   0x6721             STR      R1,[R4, #+112]
   4378          					break;
   \       0x50   0xE004             B.N      ??xTaskGenericNotify_4
   4379          
   4380          				case eSetValueWithOverwrite	:
   4381          					pxTCB->ulNotifiedValue = ulValue;
   4382          					break;
   4383          
   4384          				case eSetValueWithoutOverwrite :
   4385          					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
   \                     ??xTaskGenericNotify_8: (+1)
   \       0x52   0x2802             CMP      R0,#+2
   \       0x54   0xBF08             IT       EQ 
   \       0x56   0x2600             MOVEQ    R6,#+0
   \       0x58   0xD02A             BEQ.N    ??xTaskGenericNotify_9
   4386          					{
   4387          						pxTCB->ulNotifiedValue = ulValue;
   \                     ??xTaskGenericNotify_6: (+1)
   \       0x5A   0x6727             STR      R7,[R4, #+112]
   4388          					}
   4389          					else
   4390          					{
   4391          						/* The value could not be written to the task. */
   4392          						xReturn = pdFAIL;
   4393          					}
   4394          					break;
   4395          
   4396          				case eNoAction:
   4397          					/* The task is being notified without its notify value being
   4398          					updated. */
   4399          					break;
   4400          			}
   4401          
   4402          			traceTASK_NOTIFY();
   4403          
   4404          			/* If the task is in the blocked state specifically to wait for a
   4405          			notification then unblock it now. */
   4406          			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
   \                     ??xTaskGenericNotify_4: (+1)
   \       0x5C   0x2801             CMP      R0,#+1
   \       0x5E   0xD127             BNE.N    ??xTaskGenericNotify_9
   4407          			{
   4408          				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   \       0x60   0x1D20             ADDS     R0,R4,#+4
   \       0x62   0x.... 0x....      BL       uxListRemove
   4409          				prvAddTaskToReadyList( pxTCB );
   \       0x66   0x6AE0             LDR      R0,[R4, #+44]
   \       0x68   0x....             LDR.N    R5,??DataTable52_1
   \       0x6A   0x6F69             LDR      R1,[R5, #+116]
   \       0x6C   0xFA06 0xF200      LSL      R2,R6,R0
   \       0x70   0x4311             ORRS     R1,R2,R1
   \       0x72   0x6769             STR      R1,[R5, #+116]
   \       0x74   0xEB00 0x0380      ADD      R3,R0,R0, LSL #+2
   \       0x78   0x1D21             ADDS     R1,R4,#+4
   \       0x7A   0xEB05 0x0083      ADD      R0,R5,R3, LSL #+2
   \       0x7E   0x.... 0x....      BL       vListInsertEnd
   4410          
   4411          				/* The task should not have been on an event list. */
   4412          				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   \       0x82   0x6AA0             LDR      R0,[R4, #+40]
   \       0x84   0xB138             CBZ.N    R0,??xTaskGenericNotify_10
   \       0x86   0x2120             MOVS     R1,#+32
   \       0x88   0xF381 0x8811      MSR      BASEPRI,R1
   \       0x8C   0xF3BF 0x8F4F      DSB      SY
   \       0x90   0xF3BF 0x8F6F      ISB      SY
   \                     ??xTaskGenericNotify_11: (+1)
   \       0x94   0xE7FE             B.N      ??xTaskGenericNotify_11
   4413          
   4414          				#if( configUSE_TICKLESS_IDLE != 0 )
   4415          				{
   4416          					/* If a task is blocked waiting for a notification then
   4417          					xNextTaskUnblockTime might be set to the blocked task's time
   4418          					out time.  If the task is unblocked for a reason other than
   4419          					a timeout xNextTaskUnblockTime is normally left unchanged,
   4420          					because it will automatically get reset to a new value when
   4421          					the tick count equals xNextTaskUnblockTime.  However if
   4422          					tickless idling is used it might be more important to enter
   4423          					sleep mode at the earliest possible time - so reset
   4424          					xNextTaskUnblockTime here to ensure it is updated at the
   4425          					earliest possible time. */
   4426          					prvResetNextTaskUnblockTime();
   4427          				}
   4428          				#endif
   4429          
   4430          				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   \                     ??xTaskGenericNotify_10: (+1)
   \       0x96   0x6E68             LDR      R0,[R5, #+100]
   \       0x98   0x6AC1             LDR      R1,[R0, #+44]
   \       0x9A   0x6AE0             LDR      R0,[R4, #+44]
   \       0x9C   0x4281             CMP      R1,R0
   \       0x9E   0xD207             BCS.N    ??xTaskGenericNotify_9
   4431          				{
   4432          					/* The notified task has a priority above the currently
   4433          					executing task so a yield is required. */
   4434          					taskYIELD_IF_USING_PREEMPTION();
   \       0xA0   0x....             LDR.N    R2,??DataTable52_2  ;; 0xe000ed04
   \       0xA2   0xF04F 0x5180      MOV      R1,#+268435456
   \       0xA6   0x6011             STR      R1,[R2, #+0]
   \       0xA8   0xF3BF 0x8F4F      DSB      SY
   \       0xAC   0xF3BF 0x8F6F      ISB      SY
   4435          				}
   4436          				else
   4437          				{
   4438          					mtCOVERAGE_TEST_MARKER();
   4439          				}
   4440          			}
   4441          			else
   4442          			{
   4443          				mtCOVERAGE_TEST_MARKER();
   4444          			}
   4445          		}
   4446          		taskEXIT_CRITICAL();
   \                     ??xTaskGenericNotify_9: (+1)
   \       0xB0   0x.... 0x....      BL       vPortExitCritical
   4447          
   4448          		return xReturn;
   \       0xB4   0x4630             MOV      R0,R6
   \       0xB6   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   4449          	}
   4450          
   4451          #endif /* configUSE_TASK_NOTIFICATIONS */
   4452          /*-----------------------------------------------------------*/
   4453          
   4454          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4455          

   \                                 In section .text, align 4, keep-with-next
   4456          	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
   4457          	{
   \                     xTaskGenericNotifyFromISR: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460F             MOV      R7,R1
   \        0x8   0x4692             MOV      R10,R2
   \        0xA   0x461D             MOV      R5,R3
   4458          	TCB_t * pxTCB;
   4459          	uint8_t ucOriginalNotifyState;
   4460          	BaseType_t xReturn = pdPASS;
   \        0xC   0x2601             MOVS     R6,#+1
   4461          	UBaseType_t uxSavedInterruptStatus;
   4462          
   4463          		configASSERT( xTaskToNotify );
   \        0xE   0xF04F 0x0820      MOV      R8,#+32
   \       0x12   0xB934             CBNZ.N   R4,??xTaskGenericNotifyFromISR_1
   \       0x14   0xF388 0x8811      MSR      BASEPRI,R8
   \       0x18   0xF3BF 0x8F4F      DSB      SY
   \       0x1C   0xF3BF 0x8F6F      ISB      SY
   \                     ??xTaskGenericNotifyFromISR_2: (+1)
   \       0x20   0xE7FE             B.N      ??xTaskGenericNotifyFromISR_2
   4464          
   4465          		/* RTOS ports that support interrupt nesting have the concept of a
   4466          		maximum	system call (or maximum API call) interrupt priority.
   4467          		Interrupts that are	above the maximum system call priority are keep
   4468          		permanently enabled, even when the RTOS kernel is in a critical section,
   4469          		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   4470          		is defined in FreeRTOSConfig.h then
   4471          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   4472          		failure if a FreeRTOS API function is called from an interrupt that has
   4473          		been assigned a priority above the configured maximum system call
   4474          		priority.  Only FreeRTOS functions that end in FromISR can be called
   4475          		from interrupts	that have been assigned a priority at or (logically)
   4476          		below the maximum system call interrupt priority.  FreeRTOS maintains a
   4477          		separate interrupt safe API to ensure interrupt entry is as fast and as
   4478          		simple as possible.  More information (albeit Cortex-M specific) is
   4479          		provided on the following link:
   4480          		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   4481          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   \                     ??xTaskGenericNotifyFromISR_1: (+1)
   \       0x22   0x.... 0x....      BL       vPortValidateInterruptPriority
   4482          
   4483          		pxTCB = ( TCB_t * ) xTaskToNotify;
   4484          
   4485          		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \       0x26   0xF3EF 0x8911      MRS      R9,BASEPRI
   \       0x2A   0xF388 0x8811      MSR      BASEPRI,R8
   \       0x2E   0xF3BF 0x8F4F      DSB      SY
   \       0x32   0xF3BF 0x8F6F      ISB      SY
   4486          		{
   4487          			if( pulPreviousNotificationValue != NULL )
   \       0x36   0xB10D             CBZ.N    R5,??xTaskGenericNotifyFromISR_3
   4488          			{
   4489          				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
   \       0x38   0x6F20             LDR      R0,[R4, #+112]
   \       0x3A   0x6028             STR      R0,[R5, #+0]
   4490          			}
   4491          
   4492          			ucOriginalNotifyState = pxTCB->ucNotifyState;
   4493          			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
   \                     ??xTaskGenericNotifyFromISR_3: (+1)
   \       0x3C   0x2102             MOVS     R1,#+2
   \       0x3E   0xF894 0x0074      LDRB     R0,[R4, #+116]
   \       0x42   0xF884 0x1074      STRB     R1,[R4, #+116]
   4494          
   4495          			switch( eAction )
   \       0x46   0xF1AA 0x0101      SUB      R1,R10,#+1
   \       0x4A   0x2903             CMP      R1,#+3
   \       0x4C   0xD80F             BHI.N    ??xTaskGenericNotifyFromISR_4
   \       0x4E   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??xTaskGenericNotifyFromISR_0:
   \       0x52   0x02 0x05          DC8      0x2,0x5,0xD,0x9
   \              0x0D 0x09    
   4496          			{
   4497          				case eSetBits	:
   4498          					pxTCB->ulNotifiedValue |= ulValue;
   \                     ??xTaskGenericNotifyFromISR_5: (+1)
   \       0x56   0x6F21             LDR      R1,[R4, #+112]
   \       0x58   0x430F             ORRS     R7,R7,R1
   \       0x5A   0xE007             B.N      ??xTaskGenericNotifyFromISR_6
   4499          					break;
   4500          
   4501          				case eIncrement	:
   4502          					( pxTCB->ulNotifiedValue )++;
   \                     ??xTaskGenericNotifyFromISR_7: (+1)
   \       0x5C   0x6F21             LDR      R1,[R4, #+112]
   \       0x5E   0x1C49             ADDS     R1,R1,#+1
   \       0x60   0x6721             STR      R1,[R4, #+112]
   4503          					break;
   \       0x62   0xE004             B.N      ??xTaskGenericNotifyFromISR_4
   4504          
   4505          				case eSetValueWithOverwrite	:
   4506          					pxTCB->ulNotifiedValue = ulValue;
   4507          					break;
   4508          
   4509          				case eSetValueWithoutOverwrite :
   4510          					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
   \                     ??xTaskGenericNotifyFromISR_8: (+1)
   \       0x64   0x2802             CMP      R0,#+2
   \       0x66   0xBF08             IT       EQ 
   \       0x68   0x2600             MOVEQ    R6,#+0
   \       0x6A   0xD02C             BEQ.N    ??xTaskGenericNotifyFromISR_9
   4511          					{
   4512          						pxTCB->ulNotifiedValue = ulValue;
   \                     ??xTaskGenericNotifyFromISR_6: (+1)
   \       0x6C   0x6727             STR      R7,[R4, #+112]
   4513          					}
   4514          					else
   4515          					{
   4516          						/* The value could not be written to the task. */
   4517          						xReturn = pdFAIL;
   4518          					}
   4519          					break;
   4520          
   4521          				case eNoAction :
   4522          					/* The task is being notified without its notify value being
   4523          					updated. */
   4524          					break;
   4525          			}
   4526          
   4527          			traceTASK_NOTIFY_FROM_ISR();
   4528          
   4529          			/* If the task is in the blocked state specifically to wait for a
   4530          			notification then unblock it now. */
   4531          			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
   \                     ??xTaskGenericNotifyFromISR_4: (+1)
   \       0x6E   0x2801             CMP      R0,#+1
   \       0x70   0xD129             BNE.N    ??xTaskGenericNotifyFromISR_9
   4532          			{
   4533          				/* The task should not have been on an event list. */
   4534          				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   \       0x72   0x6AA0             LDR      R0,[R4, #+40]
   \       0x74   0xB130             CBZ.N    R0,??xTaskGenericNotifyFromISR_10
   \       0x76   0xF388 0x8811      MSR      BASEPRI,R8
   \       0x7A   0xF3BF 0x8F4F      DSB      SY
   \       0x7E   0xF3BF 0x8F6F      ISB      SY
   \                     ??xTaskGenericNotifyFromISR_11: (+1)
   \       0x82   0xE7FE             B.N      ??xTaskGenericNotifyFromISR_11
   4535          
   4536          				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   \                     ??xTaskGenericNotifyFromISR_10: (+1)
   \       0x84   0x....             LDR.N    R5,??DataTable52_1
   \       0x86   0x6FE8             LDR      R0,[R5, #+124]
   \       0x88   0xB970             CBNZ.N   R0,??xTaskGenericNotifyFromISR_12
   4537          				{
   4538          					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   \       0x8A   0x1D20             ADDS     R0,R4,#+4
   \       0x8C   0x.... 0x....      BL       uxListRemove
   4539          					prvAddTaskToReadyList( pxTCB );
   \       0x90   0x6AE0             LDR      R0,[R4, #+44]
   \       0x92   0x6F69             LDR      R1,[R5, #+116]
   \       0x94   0xFA06 0xF200      LSL      R2,R6,R0
   \       0x98   0x4311             ORRS     R1,R2,R1
   \       0x9A   0x6769             STR      R1,[R5, #+116]
   \       0x9C   0xEB00 0x0380      ADD      R3,R0,R0, LSL #+2
   \       0xA0   0x1D21             ADDS     R1,R4,#+4
   \       0xA2   0xEB05 0x0083      ADD      R0,R5,R3, LSL #+2
   \       0xA6   0xE002             B.N      ??xTaskGenericNotifyFromISR_13
   4540          				}
   4541          				else
   4542          				{
   4543          					/* The delayed and ready lists cannot be accessed, so hold
   4544          					this task pending until the scheduler is resumed. */
   4545          					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   \                     ??xTaskGenericNotifyFromISR_12: (+1)
   \       0xA8   0xF104 0x0118      ADD      R1,R4,#+24
   \       0xAC   0x....             LDR.N    R0,??DataTable52
   \                     ??xTaskGenericNotifyFromISR_13: (+1)
   \       0xAE   0x.... 0x....      BL       vListInsertEnd
   4546          				}
   4547          
   4548          				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   \       0xB2   0x6E68             LDR      R0,[R5, #+100]
   \       0xB4   0x6AC1             LDR      R1,[R0, #+44]
   \       0xB6   0x6AE0             LDR      R0,[R4, #+44]
   \       0xB8   0x4281             CMP      R1,R0
   \       0xBA   0xD204             BCS.N    ??xTaskGenericNotifyFromISR_9
   \       0xBC   0x9808             LDR      R0,[SP, #+32]
   4549          				{
   4550          					/* The notified task has a priority above the currently
   4551          					executing task so a yield is required. */
   4552          					if( pxHigherPriorityTaskWoken != NULL )
   \       0xBE   0x2800             CMP      R0,#+0
   \       0xC0   0xBF14             ITE      NE 
   \       0xC2   0x6006             STRNE    R6,[R0, #+0]
   \       0xC4   0x67AE             STREQ    R6,[R5, #+120]
   4553          					{
   4554          						*pxHigherPriorityTaskWoken = pdTRUE;
   4555          					}
   4556          					else
   4557          					{
   4558          						/* Mark that a yield is pending in case the user is not
   4559          						using the "xHigherPriorityTaskWoken" parameter to an ISR
   4560          						safe FreeRTOS function. */
   4561          						xYieldPending = pdTRUE;
   4562          					}
   4563          				}
   4564          				else
   4565          				{
   4566          					mtCOVERAGE_TEST_MARKER();
   4567          				}
   4568          			}
   4569          		}
   4570          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xTaskGenericNotifyFromISR_9: (+1)
   \       0xC6   0xF389 0x8811      MSR      BASEPRI,R9
   4571          
   4572          		return xReturn;
   \       0xCA   0x4630             MOV      R0,R6
   \       0xCC   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   4573          	}
   4574          
   4575          #endif /* configUSE_TASK_NOTIFICATIONS */
   4576          /*-----------------------------------------------------------*/
   4577          
   4578          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4579          

   \                                 In section .text, align 2, keep-with-next
   4580          	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
   4581          	{
   \                     vTaskNotifyGiveFromISR: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   4582          	TCB_t * pxTCB;
   4583          	uint8_t ucOriginalNotifyState;
   4584          	UBaseType_t uxSavedInterruptStatus;
   4585          
   4586          		configASSERT( xTaskToNotify );
   \        0x6   0x2720             MOVS     R7,#+32
   \        0x8   0xB934             CBNZ.N   R4,??vTaskNotifyGiveFromISR_0
   \        0xA   0xF387 0x8811      MSR      BASEPRI,R7
   \        0xE   0xF3BF 0x8F4F      DSB      SY
   \       0x12   0xF3BF 0x8F6F      ISB      SY
   \                     ??vTaskNotifyGiveFromISR_1: (+1)
   \       0x16   0xE7FE             B.N      ??vTaskNotifyGiveFromISR_1
   4587          
   4588          		/* RTOS ports that support interrupt nesting have the concept of a
   4589          		maximum	system call (or maximum API call) interrupt priority.
   4590          		Interrupts that are	above the maximum system call priority are keep
   4591          		permanently enabled, even when the RTOS kernel is in a critical section,
   4592          		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   4593          		is defined in FreeRTOSConfig.h then
   4594          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   4595          		failure if a FreeRTOS API function is called from an interrupt that has
   4596          		been assigned a priority above the configured maximum system call
   4597          		priority.  Only FreeRTOS functions that end in FromISR can be called
   4598          		from interrupts	that have been assigned a priority at or (logically)
   4599          		below the maximum system call interrupt priority.  FreeRTOS maintains a
   4600          		separate interrupt safe API to ensure interrupt entry is as fast and as
   4601          		simple as possible.  More information (albeit Cortex-M specific) is
   4602          		provided on the following link:
   4603          		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   4604          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   \                     ??vTaskNotifyGiveFromISR_0: (+1)
   \       0x18   0x.... 0x....      BL       vPortValidateInterruptPriority
   4605          
   4606          		pxTCB = ( TCB_t * ) xTaskToNotify;
   4607          
   4608          		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \       0x1C   0xF3EF 0x8611      MRS      R6,BASEPRI
   \       0x20   0xF387 0x8811      MSR      BASEPRI,R7
   \       0x24   0xF3BF 0x8F4F      DSB      SY
   \       0x28   0xF3BF 0x8F6F      ISB      SY
   4609          		{
   4610          			ucOriginalNotifyState = pxTCB->ucNotifyState;
   \       0x2C   0xF894 0x0074      LDRB     R0,[R4, #+116]
   4611          			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
   \       0x30   0x2102             MOVS     R1,#+2
   \       0x32   0xF884 0x1074      STRB     R1,[R4, #+116]
   4612          
   4613          			/* 'Giving' is equivalent to incrementing a count in a counting
   4614          			semaphore. */
   4615          			( pxTCB->ulNotifiedValue )++;
   \       0x36   0x6F22             LDR      R2,[R4, #+112]
   \       0x38   0x1C52             ADDS     R2,R2,#+1
   4616          
   4617          			traceTASK_NOTIFY_GIVE_FROM_ISR();
   4618          
   4619          			/* If the task is in the blocked state specifically to wait for a
   4620          			notification then unblock it now. */
   4621          			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
   \       0x3A   0x2801             CMP      R0,#+1
   \       0x3C   0x6722             STR      R2,[R4, #+112]
   \       0x3E   0xD12A             BNE.N    ??vTaskNotifyGiveFromISR_2
   4622          			{
   4623          				/* The task should not have been on an event list. */
   4624          				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   \       0x40   0x6AA0             LDR      R0,[R4, #+40]
   \       0x42   0xB130             CBZ.N    R0,??vTaskNotifyGiveFromISR_3
   \       0x44   0xF387 0x8811      MSR      BASEPRI,R7
   \       0x48   0xF3BF 0x8F4F      DSB      SY
   \       0x4C   0xF3BF 0x8F6F      ISB      SY
   \                     ??vTaskNotifyGiveFromISR_4: (+1)
   \       0x50   0xE7FE             B.N      ??vTaskNotifyGiveFromISR_4
   4625          
   4626          				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   \                     ??vTaskNotifyGiveFromISR_3: (+1)
   \       0x52   0x....             LDR.N    R7,??DataTable52_1
   \       0x54   0x6FF8             LDR      R0,[R7, #+124]
   \       0x56   0xB970             CBNZ.N   R0,??vTaskNotifyGiveFromISR_5
   4627          				{
   4628          					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   \       0x58   0x1D20             ADDS     R0,R4,#+4
   \       0x5A   0x.... 0x....      BL       uxListRemove
   4629          					prvAddTaskToReadyList( pxTCB );
   \       0x5E   0x6AE0             LDR      R0,[R4, #+44]
   \       0x60   0x6F79             LDR      R1,[R7, #+116]
   \       0x62   0x2201             MOVS     R2,#+1
   \       0x64   0x4082             LSLS     R2,R2,R0
   \       0x66   0x4311             ORRS     R1,R2,R1
   \       0x68   0x6779             STR      R1,[R7, #+116]
   \       0x6A   0xEB00 0x0380      ADD      R3,R0,R0, LSL #+2
   \       0x6E   0x1D21             ADDS     R1,R4,#+4
   \       0x70   0xEB07 0x0083      ADD      R0,R7,R3, LSL #+2
   \       0x74   0xE002             B.N      ??vTaskNotifyGiveFromISR_6
   4630          				}
   4631          				else
   4632          				{
   4633          					/* The delayed and ready lists cannot be accessed, so hold
   4634          					this task pending until the scheduler is resumed. */
   4635          					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   \                     ??vTaskNotifyGiveFromISR_5: (+1)
   \       0x76   0xF104 0x0118      ADD      R1,R4,#+24
   \       0x7A   0x....             LDR.N    R0,??DataTable52
   \                     ??vTaskNotifyGiveFromISR_6: (+1)
   \       0x7C   0x.... 0x....      BL       vListInsertEnd
   4636          				}
   4637          
   4638          				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   \       0x80   0x6E78             LDR      R0,[R7, #+100]
   \       0x82   0x6AC1             LDR      R1,[R0, #+44]
   \       0x84   0x6AE0             LDR      R0,[R4, #+44]
   \       0x86   0x4281             CMP      R1,R0
   \       0x88   0xD205             BCS.N    ??vTaskNotifyGiveFromISR_2
   4639          				{
   4640          					/* The notified task has a priority above the currently
   4641          					executing task so a yield is required. */
   4642          					if( pxHigherPriorityTaskWoken != NULL )
   \       0x8A   0x2D00             CMP      R5,#+0
   \       0x8C   0xBF19             ITTEE    NE 
   \       0x8E   0x2001             MOVNE    R0,#+1
   \       0x90   0x6028             STRNE    R0,[R5, #+0]
   \       0x92   0x2101             MOVEQ    R1,#+1
   \       0x94   0x67B9             STREQ    R1,[R7, #+120]
   4643          					{
   4644          						*pxHigherPriorityTaskWoken = pdTRUE;
   4645          					}
   4646          					else
   4647          					{
   4648          						/* Mark that a yield is pending in case the user is not
   4649          						using the "xHigherPriorityTaskWoken" parameter in an ISR
   4650          						safe FreeRTOS function. */
   4651          						xYieldPending = pdTRUE;
   4652          					}
   4653          				}
   4654          				else
   4655          				{
   4656          					mtCOVERAGE_TEST_MARKER();
   4657          				}
   4658          			}
   4659          		}
   4660          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??vTaskNotifyGiveFromISR_2: (+1)
   \       0x96   0xF386 0x8811      MSR      BASEPRI,R6
   4661          	}
   \       0x9A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   4662          
   4663          #endif /* configUSE_TASK_NOTIFICATIONS */
   4664          
   4665          /*-----------------------------------------------------------*/
   4666          
   4667          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4668          

   \                                 In section .text, align 2, keep-with-next
   4669          	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
   4670          	{
   \                     xTaskNotifyStateClear: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   4671          	TCB_t *pxTCB;
   4672          	BaseType_t xReturn;
   4673          
   4674          		/* If null is passed in here then it is the calling task that is having
   4675          		its notification state cleared. */
   4676          		pxTCB = prvGetTCBFromHandle( xTask );
   \        0x4   0xBF04             ITT      EQ 
   \        0x6   0x....             LDREQ.N  R0,??DataTable52_1
   \        0x8   0x6E44             LDREQ    R4,[R0, #+100]
   4677          
   4678          		taskENTER_CRITICAL();
   \        0xA   0x.... 0x....      BL       vPortEnterCritical
   4679          		{
   4680          			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
   \        0xE   0xF894 0x0074      LDRB     R0,[R4, #+116]
   \       0x12   0x2802             CMP      R0,#+2
   \       0x14   0xBF03             ITTTE    EQ 
   \       0x16   0x2100             MOVEQ    R1,#+0
   \       0x18   0xF884 0x1074      STRBEQ   R1,[R4, #+116]
   \       0x1C   0x2401             MOVEQ    R4,#+1
   \       0x1E   0x2400             MOVNE    R4,#+0
   4681          			{
   4682          				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   4683          				xReturn = pdPASS;
   4684          			}
   4685          			else
   4686          			{
   4687          				xReturn = pdFAIL;
   4688          			}
   4689          		}
   4690          		taskEXIT_CRITICAL();
   \       0x20                      REQUIRE ?Subroutine1
   \       0x20                      ;; // Fall through to label ?Subroutine1
   4691          
   4692          		return xReturn;
   4693          	}
   4694          
   4695          #endif /* configUSE_TASK_NOTIFICATIONS */
   4696          /*-----------------------------------------------------------*/
   4697          
   4698          

   \                                 In section .text, align 2, keep-with-next
   4699          static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
   4700          {
   \                     prvAddCurrentTaskToDelayedList: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   4701          TickType_t xTimeToWake;
   4702          const TickType_t xConstTickCount = xTickCount;
   \        0x4   0x....             LDR.N    R7,??DataTable52
   4703          
   4704          	#if( INCLUDE_xTaskAbortDelay == 1 )
   4705          	{
   4706          		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
   4707          		reset to pdFALSE so it can be detected as having been set to pdTRUE
   4708          		when the task leaves the Blocked state. */
   4709          		pxCurrentTCB->ucDelayAborted = pdFALSE;
   4710          	}
   4711          	#endif
   4712          
   4713          	/* Remove the task from the ready list before adding it to the blocked list
   4714          	as the same list item is used for both lists. */
   4715          	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   \        0x6   0x....             LDR.N    R5,??DataTable52_1
   \        0x8   0xF8D7 0x8040      LDR      R8,[R7, #+64]
   \        0xC   0x460C             MOV      R4,R1
   \        0xE   0x6E69             LDR      R1,[R5, #+100]
   \       0x10   0x4606             MOV      R6,R0
   \       0x12   0x1D08             ADDS     R0,R1,#+4
   \       0x14   0x.... 0x....      BL       uxListRemove
   \       0x18   0xB930             CBNZ.N   R0,??prvAddCurrentTaskToDelayedList_0
   4716          	{
   4717          		/* The current task must be in a ready list, so there is no need to
   4718          		check, and the port reset macro can be called directly. */
   4719          		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   \       0x1A   0x6E68             LDR      R0,[R5, #+100]
   \       0x1C   0x6F69             LDR      R1,[R5, #+116]
   \       0x1E   0x6AC0             LDR      R0,[R0, #+44]
   \       0x20   0x2201             MOVS     R2,#+1
   \       0x22   0x4082             LSLS     R2,R2,R0
   \       0x24   0x4391             BICS     R1,R1,R2
   \       0x26   0x6769             STR      R1,[R5, #+116]
   4720          	}
   4721          	else
   4722          	{
   4723          		mtCOVERAGE_TEST_MARKER();
   4724          	}
   4725          
   4726          	#if ( INCLUDE_vTaskSuspend == 1 )
   4727          	{
   4728          		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
   \                     ??prvAddCurrentTaskToDelayedList_0: (+1)
   \       0x28   0xF116 0x0F01      CMN      R6,#+1
   \       0x2C   0xD108             BNE.N    ??prvAddCurrentTaskToDelayedList_1
   \       0x2E   0xB13C             CBZ.N    R4,??prvAddCurrentTaskToDelayedList_1
   4729          		{
   4730          			/* Add the task to the suspended task list instead of a delayed task
   4731          			list to ensure it is not woken by a timing event.  It will block
   4732          			indefinitely. */
   4733          			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
   \       0x30   0x6E68             LDR      R0,[R5, #+100]
   \       0x32   0x1D01             ADDS     R1,R0,#+4
   \       0x34   0xF107 0x002C      ADD      R0,R7,#+44
   \       0x38   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0x3C   0x.... 0x....      B.W      vListInsertEnd
   4734          		}
   4735          		else
   4736          		{
   4737          			/* Calculate the time at which the task should be woken if the event
   4738          			does not occur.  This may overflow but this doesn't matter, the
   4739          			kernel will manage it correctly. */
   4740          			xTimeToWake = xConstTickCount + xTicksToWait;
   4741          
   4742          			/* The list item will be inserted in wake time order. */
   4743          			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
   \                     ??prvAddCurrentTaskToDelayedList_1: (+1)
   \       0x40   0x6E68             LDR      R0,[R5, #+100]
   \       0x42   0x4446             ADD      R6,R6,R8
   \       0x44   0x6046             STR      R6,[R0, #+4]
   4744          
   4745          			if( xTimeToWake < xConstTickCount )
   \       0x46   0x4546             CMP      R6,R8
   \       0x48   0x6E68             LDR      R0,[R5, #+100]
   \       0x4A   0xD205             BCS.N    ??prvAddCurrentTaskToDelayedList_2
   4746          			{
   4747          				/* Wake time has overflowed.  Place this item in the overflow
   4748          				list. */
   4749          				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   \       0x4C   0x1D01             ADDS     R1,R0,#+4
   \       0x4E   0x6EE8             LDR      R0,[R5, #+108]
   \       0x50   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0x54   0x.... 0x....      B.W      vListInsert
   4750          			}
   4751          			else
   4752          			{
   4753          				/* The wake time has not overflowed, so the current block list
   4754          				is used. */
   4755          				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   \                     ??prvAddCurrentTaskToDelayedList_2: (+1)
   \       0x58   0x1D01             ADDS     R1,R0,#+4
   \       0x5A   0x6EA8             LDR      R0,[R5, #+104]
   \       0x5C   0x.... 0x....      BL       vListInsert
   4756          
   4757          				/* If the task entering the blocked state was placed at the
   4758          				head of the list of blocked tasks then xNextTaskUnblockTime
   4759          				needs to be updated too. */
   4760          				if( xTimeToWake < xNextTaskUnblockTime )
   \       0x60   0x6D78             LDR      R0,[R7, #+84]
   \       0x62   0x4286             CMP      R6,R0
   \       0x64   0xBF38             IT       CC 
   \       0x66   0x657E             STRCC    R6,[R7, #+84]
   4761          				{
   4762          					xNextTaskUnblockTime = xTimeToWake;
   4763          				}
   4764          				else
   4765          				{
   4766          					mtCOVERAGE_TEST_MARKER();
   4767          				}
   4768          			}
   4769          		}
   4770          	}
   4771          	#else /* INCLUDE_vTaskSuspend */
   4772          	{
   4773          		/* Calculate the time at which the task should be woken if the event
   4774          		does not occur.  This may overflow but this doesn't matter, the kernel
   4775          		will manage it correctly. */
   4776          		xTimeToWake = xConstTickCount + xTicksToWait;
   4777          
   4778          		/* The list item will be inserted in wake time order. */
   4779          		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
   4780          
   4781          		if( xTimeToWake < xConstTickCount )
   4782          		{
   4783          			/* Wake time has overflowed.  Place this item in the overflow list. */
   4784          			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   4785          		}
   4786          		else
   4787          		{
   4788          			/* The wake time has not overflowed, so the current block list is used. */
   4789          			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   4790          
   4791          			/* If the task entering the blocked state was placed at the head of the
   4792          			list of blocked tasks then xNextTaskUnblockTime needs to be updated
   4793          			too. */
   4794          			if( xTimeToWake < xNextTaskUnblockTime )
   4795          			{
   4796          				xNextTaskUnblockTime = xTimeToWake;
   4797          			}
   4798          			else
   4799          			{
   4800          				mtCOVERAGE_TEST_MARKER();
   4801          			}
   4802          		}
   4803          
   4804          		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
   4805          		( void ) xCanBlockIndefinitely;
   4806          	}
   4807          	#endif /* INCLUDE_vTaskSuspend */
   4808          }
   \       0x68   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   4809          
   4810          
   4811          #ifdef FREERTOS_MODULE_TEST
   4812          	#include "tasks_test_access_functions.h"
   4813          #endif
   4814          
   4815          #if (configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H == 1)
   4816          	#include "freertos_tasks_c_additions.h"

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute uint8_t const FreeRTOSDebugConfig[16]
   \                     FreeRTOSDebugConfig:
   \        0x0   0x01 0x01          DC8 1, 1, 9, 0, 0, 4, 0, 4, 24, 48, 52, 76, 80, 20, 5, 0
   \              0x09 0x00    
   \              0x00 0x04    
   \              0x00 0x04    
   \              0x18 0x30    
   \              0x34 0x4C    
   \              0x50 0x14    
   \              0x05 0x00    
   \       0x10                      REQUIRE FreeRTOSDebugConfig

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \        0x0   0x49 0x44          DC8 "IDLE"
   \              0x4C 0x45    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36:
   \        0x0   0x....'....        DC32     pxReadyTasksLists

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36_1:
   \        0x0   0x....'....        DC32     xPendingReadyList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37:
   \        0x0   0xE000'ED04        DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52:
   \        0x0   0x....'....        DC32     xPendingReadyList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52_1:
   \        0x0   0x....'....        DC32     pxReadyTasksLists

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52_2:
   \        0x0   0xE000'ED04        DC32     0xe000ed04
   4817          
   4818          	#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
   4819          	static void freertos_tasks_c_additions_init( void )
   4820          	{
   4821          		FREERTOS_TASKS_C_ADDITIONS_INIT();
   4822          	}
   4823          	#endif
   4824          #endif
   4825          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   eTaskGetState
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
       0   pcTaskGetName
      24   prvAddCurrentTaskToDelayedList
        24   -> uxListRemove
         0   -> vListInsert
        24   -> vListInsert
         0   -> vListInsertEnd
      24   prvAddNewTaskToReadyList
        24   -> vListInitialise
        24   -> vListInsertEnd
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
      24   prvIdleTask
        24   -> uxListRemove
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
        24   -> vPortFree
        24   -> xTaskResumeAll
      32   prvInitialiseNewTask
        32   -> __aeabi_memset4
        32   -> pxPortInitialiseStack
        32   -> vListInitialiseItem
      40   prvListTasksWithinSingleList
        40   -> eTaskGetState
        40   -> xTaskResumeAll
       0   prvResetNextTaskUnblockTime
       0   prvTaskIsTaskSuspended
       0   pvTaskGetThreadLocalStoragePointer
       0   pvTaskIncrementMutexHeldCount
      16   ulTaskNotifyTake
        16   -> prvAddCurrentTaskToDelayedList
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
       0   uxTaskGetNumberOfTasks
      48   uxTaskGetSystemState
        48   -> prvListTasksWithinSingleList
        48   -> xTaskResumeAll
       0   uxTaskGetTaskNumber
       8   uxTaskPriorityGet
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
       8   uxTaskPriorityGetFromISR
         8   -> vPortValidateInterruptPriority
       0   uxTaskResetEventItemValue
       8   vTaskDelay
         8   -> prvAddCurrentTaskToDelayedList
         8   -> xTaskResumeAll
       8   vTaskDelayUntil
         8   -> prvAddCurrentTaskToDelayedList
         8   -> xTaskResumeAll
      16   vTaskDelete
        16   -> prvResetNextTaskUnblockTime
        16   -> uxListRemove
        16   -> vListInsertEnd
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vPortFree
       0   vTaskEndScheduler
         0   -> vPortEndScheduler
      24   vTaskGetInfo
        24   -> eTaskGetState
        24   -> xTaskResumeAll
       0   vTaskMissedYield
      24   vTaskNotifyGiveFromISR
        24   -> uxListRemove
        24   -> vListInsertEnd
        24   -> vPortValidateInterruptPriority
       8   vTaskPlaceOnEventList
         0   -> prvAddCurrentTaskToDelayedList
         8   -> vListInsert
      16   vTaskPlaceOnEventListRestricted
         0   -> prvAddCurrentTaskToDelayedList
        16   -> vListInsertEnd
       8   vTaskPlaceOnUnorderedEventList
         0   -> prvAddCurrentTaskToDelayedList
         8   -> vListInsertEnd
      16   vTaskPriorityInherit
        16   -> uxListRemove
         0   -> vListInsertEnd
      24   vTaskPrioritySet
        24   -> uxListRemove
        24   -> vListInsertEnd
        24   -> vPortEnterCritical
         0   -> vPortExitCritical
      16   vTaskResume
        16   -> prvTaskIsTaskSuspended
        16   -> uxListRemove
        16   -> vListInsertEnd
        16   -> vPortEnterCritical
         0   -> vPortExitCritical
       0   vTaskSetTaskNumber
       0   vTaskSetThreadLocalStoragePointer
       0   vTaskSetTimeOutState
      24   vTaskStartScheduler
         0   -> xPortStartScheduler
        24   -> xTaskCreate
        24   -> xTimerCreateTimerTask
      16   vTaskSuspend
        16   -> prvResetNextTaskUnblockTime
        16   -> uxListRemove
        16   -> vListInsertEnd
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
         0   -> vTaskSwitchContext
       0   vTaskSuspendAll
       0   vTaskSwitchContext
      16   xTaskCheckForTimeOut
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vTaskSetTimeOutState
      48   xTaskCreate
        48   -> prvAddNewTaskToReadyList
        48   -> prvInitialiseNewTask
        48   -> pvPortMalloc
        48   -> vPortFree
      24   xTaskGenericNotify
        24   -> uxListRemove
        24   -> vListInsertEnd
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
      32   xTaskGenericNotifyFromISR
        32   -> uxListRemove
        32   -> vListInsertEnd
        32   -> vPortValidateInterruptPriority
       0   xTaskGetCurrentTaskHandle
       0   xTaskGetSchedulerState
       0   xTaskGetTickCount
       8   xTaskGetTickCountFromISR
         8   -> vPortValidateInterruptPriority
      24   xTaskIncrementTick
        24   -> prvResetNextTaskUnblockTime
        24   -> uxListRemove
        24   -> vListInsertEnd
       8   xTaskNotifyStateClear
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
      24   xTaskNotifyWait
        24   -> prvAddCurrentTaskToDelayedList
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
      16   xTaskPriorityDisinherit
        16   -> uxListRemove
        16   -> vListInsertEnd
      16   xTaskRemoveFromEventList
        16   -> uxListRemove
        16   -> vListInsertEnd
      16   xTaskRemoveFromUnorderedEventList
        16   -> uxListRemove
        16   -> vListInsertEnd
      24   xTaskResumeAll
        24   -> prvResetNextTaskUnblockTime
        24   -> uxListRemove
        24   -> vListInsertEnd
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
        24   -> xTaskIncrementTick
      24   xTaskResumeFromISR
        24   -> prvTaskIsTaskSuspended
        24   -> uxListRemove
        24   -> vListInsertEnd
        24   -> vPortValidateInterruptPriority


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable36
       4  ??DataTable36_1
       4  ??DataTable37
       4  ??DataTable52
       4  ??DataTable52_1
       4  ??DataTable52_2
       6  ?Subroutine0
       8  ?Subroutine1
      12  ?Subroutine2
       6  ?Subroutine3
       8  ?_0
      16  FreeRTOSDebugConfig
     100  eTaskGetState
      30  pcTaskGetName
     108  prvAddCurrentTaskToDelayedList
     222  prvAddNewTaskToReadyList
     104  prvIdleTask
     178  prvInitialiseNewTask
     198  prvListTasksWithinSingleList
      32  prvResetNextTaskUnblockTime
      48  prvTaskIsTaskSuspended
      24  pvTaskGetThreadLocalStoragePointer
      20  pvTaskIncrementMutexHeldCount
     168  pxReadyTasksLists
          pxCurrentTCB
          pxDelayedTaskList
          pxOverflowDelayedTaskList
          uxCurrentNumberOfTasks
          uxTopReadyPriority
          xYieldPending
          uxSchedulerSuspended
          xDelayedTaskList1
          xDelayedTaskList2
      96  ulTaskNotifyTake
       8  uxTaskGetNumberOfTasks
     332  uxTaskGetSystemState
       6  uxTaskGetTaskNumber
      22  uxTaskPriorityGet
      42  uxTaskPriorityGetFromISR
      22  uxTaskResetEventItemValue
      66  vTaskDelay
     136  vTaskDelayUntil
     172  vTaskDelete
      26  vTaskEndScheduler
     126  vTaskGetInfo
      10  vTaskMissedYield
     156  vTaskNotifyGiveFromISR
      36  vTaskPlaceOnEventList
      54  vTaskPlaceOnEventListRestricted
      62  vTaskPlaceOnUnorderedEventList
     126  vTaskPriorityInherit
     182  vTaskPrioritySet
     114  vTaskResume
       6  vTaskSetTaskNumber
      20  vTaskSetThreadLocalStoragePointer
      32  vTaskSetTimeOutState
     108  vTaskStartScheduler
     168  vTaskSuspend
      12  vTaskSuspendAll
      78  vTaskSwitchContext
      92  xPendingReadyList
          xTasksWaitingTermination
          uxDeletedTasksWaitingCleanUp
          xSuspendedTaskList
          xTickCount
          xSchedulerRunning
          uxPendedTicks
          xNumOfOverflows
          uxTaskNumber
          xNextTaskUnblockTime
          xIdleTaskHandle
     106  xTaskCheckForTimeOut
      82  xTaskCreate
     186  xTaskGenericNotify
     208  xTaskGenericNotifyFromISR
       8  xTaskGetCurrentTaskHandle
      28  xTaskGetSchedulerState
       8  xTaskGetTickCount
      14  xTaskGetTickCountFromISR
     184  xTaskIncrementTick
      32  xTaskNotifyStateClear
     132  xTaskNotifyWait
     144  xTaskPriorityDisinherit
      96  xTaskRemoveFromEventList
     104  xTaskRemoveFromUnorderedEventList
     180  xTaskResumeAll
     122  xTaskResumeFromISR

 
   260 bytes in section .bss
    16 bytes in section .rodata
 4 980 bytes in section .text
 
 4 980 bytes of CODE  memory
    16 bytes of CONST memory
   260 bytes of DATA  memory

Errors: none
Warnings: none
