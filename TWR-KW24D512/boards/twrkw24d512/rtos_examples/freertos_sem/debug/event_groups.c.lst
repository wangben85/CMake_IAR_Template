###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         03/Mar/2020  16:31:37
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\event_groups.c
#    Command line =  
#        C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\event_groups.c
#        "-IC:\Program Files (x86)\IAR Systems\Embedded Workbench 8.1\arm\inc"
#        -I..\..\..\..\..\CMSIS\Include -I..\..\..\..\..\devices -I..\..\..
#        -I..\..\..\..\..\devices\MKW24D5\drivers
#        -I..\..\..\..\..\devices\MKW24D5\utilities
#        -I..\..\..\..\..\devices\MKW24D5 -I..\..\iar -I..\.. -I..\
#        -I..\..\..\..\..\rtos\freertos_9.0.0\Source\portable\IAR\ARM_CM3
#        -I..\..\..\..\..\rtos\freertos_9.0.0\Source\include
#        -DCPU_MKW24D512VHA5 -DIAR -DFSL_RTOS_FREE_RTOS -DPRINTF_FLOAT_ENABLE=0
#        -DSCANF_FLOAT_ENABLE=0 -DPRINTF_ADVANCED_ENABLE=0
#        -DSCANF_ADVANCED_ENABLE=0 -DTWR_KW24D512 -DTOWER --diag_suppress
#        Pa082,Pa050,Pe167,Pa182 --endian=little --cpu=Cortex-M4 --fpu=None
#        --no_path_in_file_macros --silent -lC . -e --dlib_config "C:/Program
#        Files (x86)/IAR Systems/Embedded Workbench
#        8.1/arm/inc/c/DLib_Config_Normal.h" -Om --debug --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --dependencies=ns
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\event_groups.c.obj.d
#        -o
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\event_groups.c.obj
#    Locale       =  C
#    List file    =  .\event_groups.c.lst
#    Object file  =  
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\event_groups.c.obj
#
###############################################################################

C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\event_groups.c
      1          /*
      2              FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
      3              All rights reserved
      4          
      5              VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              This file is part of the FreeRTOS distribution.
      8          
      9              FreeRTOS is free software; you can redistribute it and/or modify it under
     10              the terms of the GNU General Public License (version 2) as published by the
     11              Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
     12          
     13              ***************************************************************************
     14              >>!   NOTE: The modification to the GPL is included to allow you to     !<<
     15              >>!   distribute a combined work that includes FreeRTOS without being   !<<
     16              >>!   obliged to provide the source code for proprietary components     !<<
     17              >>!   outside of the FreeRTOS kernel.                                   !<<
     18              ***************************************************************************
     19          
     20              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
     21              WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     22              FOR A PARTICULAR PURPOSE.  Full license text is available on the following
     23              link: http://www.freertos.org/a00114.html
     24          
     25              ***************************************************************************
     26               *                                                                       *
     27               *    FreeRTOS provides completely free yet professionally developed,    *
     28               *    robust, strictly quality controlled, supported, and cross          *
     29               *    platform software that is more than just the market leader, it     *
     30               *    is the industry's de facto standard.                               *
     31               *                                                                       *
     32               *    Help yourself get started quickly while simultaneously helping     *
     33               *    to support the FreeRTOS project by purchasing a FreeRTOS           *
     34               *    tutorial book, reference manual, or both:                          *
     35               *    http://www.FreeRTOS.org/Documentation                              *
     36               *                                                                       *
     37              ***************************************************************************
     38          
     39              http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
     40              the FAQ page "My application does not run, what could be wrong?".  Have you
     41              defined configASSERT()?
     42          
     43              http://www.FreeRTOS.org/support - In return for receiving this top quality
     44              embedded software for free we request you assist our global community by
     45              participating in the support forum.
     46          
     47              http://www.FreeRTOS.org/training - Investing in training allows your team to
     48              be as productive as possible as early as possible.  Now you can receive
     49              FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
     50              Ltd, and the world's leading authority on the world's leading RTOS.
     51          
     52              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     53              including FreeRTOS+Trace - an indispensable productivity tool, a DOS
     54              compatible FAT file system, and our tiny thread aware UDP/IP stack.
     55          
     56              http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
     57              Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
     58          
     59              http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
     60              Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
     61              licenses offer ticketed support, indemnification and commercial middleware.
     62          
     63              http://www.SafeRTOS.com - High Integrity Systems also provide a safety
     64              engineered and independently SIL3 certified version for use in safety and
     65              mission critical applications that require provable dependability.
     66          
     67              1 tab == 4 spaces!
     68          */
     69          
     70          /* Standard includes. */
     71          #include <stdlib.h>
     72          
     73          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     74          all the API functions to use the MPU wrappers.  That should only be done when
     75          task.h is included from an application file. */
     76          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     77          
     78          /* FreeRTOS includes. */
     79          #include "FreeRTOS.h"
     80          #include "task.h"
     81          #include "timers.h"
     82          #include "event_groups.h"
     83          
     84          /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
     85          MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
     86          header files above, but not in this file, in order to generate the correct
     87          privileged Vs unprivileged linkage and placement. */
     88          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
     89          
     90          /* The following bit fields convey control information in a task's event list
     91          item value.  It is important they don't clash with the
     92          taskEVENT_LIST_ITEM_VALUE_IN_USE definition. */
     93          #if configUSE_16_BIT_TICKS == 1
     94          	#define eventCLEAR_EVENTS_ON_EXIT_BIT	0x0100U
     95          	#define eventUNBLOCKED_DUE_TO_BIT_SET	0x0200U
     96          	#define eventWAIT_FOR_ALL_BITS			0x0400U
     97          	#define eventEVENT_BITS_CONTROL_BYTES	0xff00U
     98          #else
     99          	#define eventCLEAR_EVENTS_ON_EXIT_BIT	0x01000000UL
    100          	#define eventUNBLOCKED_DUE_TO_BIT_SET	0x02000000UL
    101          	#define eventWAIT_FOR_ALL_BITS			0x04000000UL
    102          	#define eventEVENT_BITS_CONTROL_BYTES	0xff000000UL
    103          #endif
    104          
    105          typedef struct xEventGroupDefinition
    106          {
    107          	EventBits_t uxEventBits;
    108          	List_t xTasksWaitingForBits;		/*< List of tasks waiting for a bit to be set. */
    109          
    110          	#if( configUSE_TRACE_FACILITY == 1 )
    111          		UBaseType_t uxEventGroupNumber;
    112          	#endif
    113          
    114          	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
    115          		uint8_t ucStaticallyAllocated; /*< Set to pdTRUE if the event group is statically allocated to ensure no attempt is made to free the memory. */
    116          	#endif
    117          } EventGroup_t;
    118          
    119          /*-----------------------------------------------------------*/
    120          
    121          /*
    122           * Test the bits set in uxCurrentEventBits to see if the wait condition is met.
    123           * The wait condition is defined by xWaitForAllBits.  If xWaitForAllBits is
    124           * pdTRUE then the wait condition is met if all the bits set in uxBitsToWaitFor
    125           * are also set in uxCurrentEventBits.  If xWaitForAllBits is pdFALSE then the
    126           * wait condition is met if any of the bits set in uxBitsToWait for are also set
    127           * in uxCurrentEventBits.
    128           */
    129          static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits ) PRIVILEGED_FUNCTION;
    130          
    131          /*-----------------------------------------------------------*/
    132          
    133          #if( configSUPPORT_STATIC_ALLOCATION == 1 )
    134          
    135          	EventGroupHandle_t xEventGroupCreateStatic( StaticEventGroup_t *pxEventGroupBuffer )
    136          	{
    137          	EventGroup_t *pxEventBits;
    138          
    139          		/* A StaticEventGroup_t object must be provided. */
    140          		configASSERT( pxEventGroupBuffer );
    141          
    142          		/* The user has provided a statically allocated event group - use it. */
    143          		pxEventBits = ( EventGroup_t * ) pxEventGroupBuffer; /*lint !e740 EventGroup_t and StaticEventGroup_t are guaranteed to have the same size and alignment requirement - checked by configASSERT(). */
    144          
    145          		if( pxEventBits != NULL )
    146          		{
    147          			pxEventBits->uxEventBits = 0;
    148          			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    149          
    150          			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    151          			{
    152          				/* Both static and dynamic allocation can be used, so note that
    153          				this event group was created statically in case the event group
    154          				is later deleted. */
    155          				pxEventBits->ucStaticallyAllocated = pdTRUE;
    156          			}
    157          			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    158          
    159          			traceEVENT_GROUP_CREATE( pxEventBits );
    160          		}
    161          		else
    162          		{
    163          			traceEVENT_GROUP_CREATE_FAILED();
    164          		}
    165          
    166          		return ( EventGroupHandle_t ) pxEventBits;
    167          	}
    168          
    169          #endif /* configSUPPORT_STATIC_ALLOCATION */
    170          /*-----------------------------------------------------------*/
    171          
    172          #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    173          

   \                                 In section .text, align 2, keep-with-next
    174          	EventGroupHandle_t xEventGroupCreate( void )
    175          	{
   \                     xEventGroupCreate: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    176          	EventGroup_t *pxEventBits;
    177          
    178          		/* Allocate the event group. */
    179          		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
   \        0x2   0x201C             MOVS     R0,#+28
   \        0x4   0x.... 0x....      BL       pvPortMalloc
   \        0x8   0x0004             MOVS     R4,R0
    180          
    181          		if( pxEventBits != NULL )
   \        0xA   0xD004             BEQ.N    ??xEventGroupCreate_0
    182          		{
    183          			pxEventBits->uxEventBits = 0;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x6020             STR      R0,[R4, #+0]
    184          			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
   \       0x10   0x1D20             ADDS     R0,R4,#+4
   \       0x12   0x.... 0x....      BL       vListInitialise
    185          
    186          			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
    187          			{
    188          				/* Both static and dynamic allocation can be used, so note this
    189          				event group was allocated statically in case the event group is
    190          				later deleted. */
    191          				pxEventBits->ucStaticallyAllocated = pdFALSE;
    192          			}
    193          			#endif /* configSUPPORT_STATIC_ALLOCATION */
    194          
    195          			traceEVENT_GROUP_CREATE( pxEventBits );
    196          		}
    197          		else
    198          		{
    199          			traceEVENT_GROUP_CREATE_FAILED();
    200          		}
    201          
    202          		return ( EventGroupHandle_t ) pxEventBits;
   \                     ??xEventGroupCreate_0: (+1)
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0xBD10             POP      {R4,PC}          ;; return
    203          	}
    204          
    205          #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    206          /*-----------------------------------------------------------*/
    207          

   \                                 In section .text, align 2, keep-with-next
    208          EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
    209          {
   \                     xEventGroupSync: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460F             MOV      R7,R1
   \        0x8   0x4615             MOV      R5,R2
   \        0xA   0x461C             MOV      R4,R3
    210          EventBits_t uxOriginalBitValue, uxReturn;
    211          EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    212          BaseType_t xAlreadyYielded;
    213          BaseType_t xTimeoutOccurred = pdFALSE;
    214          
    215          	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
   \        0xC   0xF015 0x4F7F      TST      R5,#0xFF000000
   \       0x10   0xD007             BEQ.N    ??xEventGroupSync_0
   \       0x12   0x2020             MOVS     R0,#+32
   \       0x14   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x18   0xF3BF 0x8F4F      DSB      SY
   \       0x1C   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupSync_1: (+1)
   \       0x20   0xE7FE             B.N      ??xEventGroupSync_1
    216          	configASSERT( uxBitsToWaitFor != 0 );
   \                     ??xEventGroupSync_0: (+1)
   \       0x22   0x2D00             CMP      R5,#+0
   \       0x24   0xD107             BNE.N    ??xEventGroupSync_2
   \       0x26   0x2020             MOVS     R0,#+32
   \       0x28   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x2C   0xF3BF 0x8F4F      DSB      SY
   \       0x30   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupSync_3: (+1)
   \       0x34   0xE7FE             B.N      ??xEventGroupSync_3
    217          	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
    218          	{
    219          		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   \                     ??xEventGroupSync_2: (+1)
   \       0x36   0x.... 0x....      BL       xTaskGetSchedulerState
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD104             BNE.N    ??xEventGroupSync_4
   \       0x3E   0x4620             MOV      R0,R4
   \       0x40   0x1E40             SUBS     R0,R0,#+1
   \       0x42   0x4180             SBCS     R0,R0,R0
   \       0x44   0x0FC0             LSRS     R0,R0,#+31
   \       0x46   0xE000             B.N      ??xEventGroupSync_5
   \                     ??xEventGroupSync_4: (+1)
   \       0x48   0x2001             MOVS     R0,#+1
   \                     ??xEventGroupSync_5: (+1)
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD107             BNE.N    ??xEventGroupSync_6
   \       0x4E   0x2020             MOVS     R0,#+32
   \       0x50   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x54   0xF3BF 0x8F4F      DSB      SY
   \       0x58   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupSync_7: (+1)
   \       0x5C   0xE7FE             B.N      ??xEventGroupSync_7
    220          	}
    221          	#endif
    222          
    223          	vTaskSuspendAll();
   \                     ??xEventGroupSync_6: (+1)
   \       0x5E   0x.... 0x....      BL       vTaskSuspendAll
    224          	{
    225          		uxOriginalBitValue = pxEventBits->uxEventBits;
   \       0x62   0xF8D6 0x8000      LDR      R8,[R6, #+0]
    226          
    227          		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
   \       0x66   0x4639             MOV      R1,R7
   \       0x68   0x4630             MOV      R0,R6
   \       0x6A   0x.... 0x....      BL       xEventGroupSetBits
    228          
    229          		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
   \       0x6E   0xEA47 0x0008      ORR      R0,R7,R8
   \       0x72   0x4028             ANDS     R0,R5,R0
   \       0x74   0x42A8             CMP      R0,R5
   \       0x76   0xD106             BNE.N    ??xEventGroupSync_8
    230          		{
    231          			/* All the rendezvous bits are now set - no need to block. */
    232          			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
   \       0x78   0xEA47 0x0708      ORR      R7,R7,R8
    233          
    234          			/* Rendezvous always clear the bits.  They will have been cleared
    235          			already unless this is the only task in the rendezvous. */
    236          			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
   \       0x7C   0x6830             LDR      R0,[R6, #+0]
   \       0x7E   0x43A8             BICS     R0,R0,R5
   \       0x80   0x6030             STR      R0,[R6, #+0]
    237          
    238          			xTicksToWait = 0;
   \       0x82   0x2400             MOVS     R4,#+0
   \       0x84   0xE00A             B.N      ??xEventGroupSync_9
    239          		}
    240          		else
    241          		{
    242          			if( xTicksToWait != ( TickType_t ) 0 )
   \                     ??xEventGroupSync_8: (+1)
   \       0x86   0x2C00             CMP      R4,#+0
   \       0x88   0xD007             BEQ.N    ??xEventGroupSync_10
    243          			{
    244          				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );
    245          
    246          				/* Store the bits that the calling task is waiting for in the
    247          				task's event list item so the kernel knows when a match is
    248          				found.  Then enter the blocked state. */
    249          				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
   \       0x8A   0x4622             MOV      R2,R4
   \       0x8C   0xF045 0x61A0      ORR      R1,R5,#0x5000000
   \       0x90   0x1D30             ADDS     R0,R6,#+4
   \       0x92   0x.... 0x....      BL       vTaskPlaceOnUnorderedEventList
    250          
    251          				/* This assignment is obsolete as uxReturn will get set after
    252          				the task unblocks, but some compilers mistakenly generate a
    253          				warning about uxReturn being returned without being set if the
    254          				assignment is omitted. */
    255          				uxReturn = 0;
   \       0x96   0x2700             MOVS     R7,#+0
   \       0x98   0xE000             B.N      ??xEventGroupSync_9
    256          			}
    257          			else
    258          			{
    259          				/* The rendezvous bits were not set, but no block time was
    260          				specified - just return the current event bit value. */
    261          				uxReturn = pxEventBits->uxEventBits;
   \                     ??xEventGroupSync_10: (+1)
   \       0x9A   0x6837             LDR      R7,[R6, #+0]
    262          			}
    263          		}
    264          	}
    265          	xAlreadyYielded = xTaskResumeAll();
   \                     ??xEventGroupSync_9: (+1)
   \       0x9C   0x.... 0x....      BL       xTaskResumeAll
    266          
    267          	if( xTicksToWait != ( TickType_t ) 0 )
   \       0xA0   0x2C00             CMP      R4,#+0
   \       0xA2   0xD01D             BEQ.N    ??xEventGroupSync_11
    268          	{
    269          		if( xAlreadyYielded == pdFALSE )
   \       0xA4   0x2800             CMP      R0,#+0
   \       0xA6   0xD107             BNE.N    ??xEventGroupSync_12
    270          		{
    271          			portYIELD_WITHIN_API();
   \       0xA8   0xF04F 0x5080      MOV      R0,#+268435456
   \       0xAC   0x....             LDR.N    R1,??DataTable3  ;; 0xe000ed04
   \       0xAE   0x6008             STR      R0,[R1, #+0]
   \       0xB0   0xF3BF 0x8F4F      DSB      SY
   \       0xB4   0xF3BF 0x8F6F      ISB      SY
    272          		}
    273          		else
    274          		{
    275          			mtCOVERAGE_TEST_MARKER();
    276          		}
    277          
    278          		/* The task blocked to wait for its required bits to be set - at this
    279          		point either the required bits were set or the block time expired.  If
    280          		the required bits were set they will have been stored in the task's
    281          		event list item, and they should now be retrieved then cleared. */
    282          		uxReturn = uxTaskResetEventItemValue();
   \                     ??xEventGroupSync_12: (+1)
   \       0xB8   0x.... 0x....      BL       uxTaskResetEventItemValue
   \       0xBC   0x4607             MOV      R7,R0
    283          
    284          		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
   \       0xBE   0x01B8             LSLS     R0,R7,#+6
   \       0xC0   0xD40C             BMI.N    ??xEventGroupSync_13
    285          		{
    286          			/* The task timed out, just return the current event bit value. */
    287          			taskENTER_CRITICAL();
   \       0xC2   0x.... 0x....      BL       vPortEnterCritical
    288          			{
    289          				uxReturn = pxEventBits->uxEventBits;
   \       0xC6   0x6837             LDR      R7,[R6, #+0]
    290          
    291          				/* Although the task got here because it timed out before the
    292          				bits it was waiting for were set, it is possible that since it
    293          				unblocked another task has set the bits.  If this is the case
    294          				then it needs to clear the bits before exiting. */
    295          				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
   \       0xC8   0xEA05 0x0007      AND      R0,R5,R7
   \       0xCC   0x42A8             CMP      R0,R5
   \       0xCE   0xD103             BNE.N    ??xEventGroupSync_14
    296          				{
    297          					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
   \       0xD0   0x4638             MOV      R0,R7
   \       0xD2   0xEA20 0x0505      BIC      R5,R0,R5
   \       0xD6   0x6035             STR      R5,[R6, #+0]
    298          				}
    299          				else
    300          				{
    301          					mtCOVERAGE_TEST_MARKER();
    302          				}
    303          			}
    304          			taskEXIT_CRITICAL();
   \                     ??xEventGroupSync_14: (+1)
   \       0xD8   0x.... 0x....      BL       vPortExitCritical
    305          
    306          			xTimeoutOccurred = pdTRUE;
    307          		}
    308          		else
    309          		{
    310          			/* The task unblocked because the bits were set. */
    311          		}
    312          
    313          		/* Control bits might be set as the task had blocked should not be
    314          		returned. */
    315          		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
   \                     ??xEventGroupSync_13: (+1)
   \       0xDC   0xF027 0x477F      BIC      R7,R7,#0xFF000000
    316          	}
    317          
    318          	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );
    319          
    320          	return uxReturn;
   \                     ??xEventGroupSync_11: (+1)
   \       0xE0   0x4638             MOV      R0,R7
   \       0xE2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    321          }
    322          /*-----------------------------------------------------------*/
    323          

   \                                 In section .text, align 2, keep-with-next
    324          EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
    325          {
   \                     xEventGroupWaitBits: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x4614             MOV      R4,R2
   \        0x8   0x4698             MOV      R8,R3
    326          EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    327          EventBits_t uxReturn, uxControlBits = 0;
   \        0xA   0xF04F 0x0900      MOV      R9,#+0
    328          BaseType_t xWaitConditionMet, xAlreadyYielded;
    329          BaseType_t xTimeoutOccurred = pdFALSE;
    330          
    331          	/* Check the user is not attempting to wait on the bits used by the kernel
    332          	itself, and that at least one bit is being requested. */
    333          	configASSERT( xEventGroup );
   \        0xE   0x2F00             CMP      R7,#+0
   \       0x10   0xD107             BNE.N    ??xEventGroupWaitBits_0
   \       0x12   0x2020             MOVS     R0,#+32
   \       0x14   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x18   0xF3BF 0x8F4F      DSB      SY
   \       0x1C   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupWaitBits_1: (+1)
   \       0x20   0xE7FE             B.N      ??xEventGroupWaitBits_1
   \                     ??xEventGroupWaitBits_0: (+1)
   \       0x22   0x460E             MOV      R6,R1
    334          	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
   \       0x24   0xF016 0x4F7F      TST      R6,#0xFF000000
   \       0x28   0xD007             BEQ.N    ??xEventGroupWaitBits_2
   \       0x2A   0x2020             MOVS     R0,#+32
   \       0x2C   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x30   0xF3BF 0x8F4F      DSB      SY
   \       0x34   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupWaitBits_3: (+1)
   \       0x38   0xE7FE             B.N      ??xEventGroupWaitBits_3
    335          	configASSERT( uxBitsToWaitFor != 0 );
   \                     ??xEventGroupWaitBits_2: (+1)
   \       0x3A   0x2E00             CMP      R6,#+0
   \       0x3C   0xD107             BNE.N    ??xEventGroupWaitBits_4
   \       0x3E   0x2020             MOVS     R0,#+32
   \       0x40   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x44   0xF3BF 0x8F4F      DSB      SY
   \       0x48   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupWaitBits_5: (+1)
   \       0x4C   0xE7FE             B.N      ??xEventGroupWaitBits_5
   \                     ??xEventGroupWaitBits_4: (+1)
   \       0x4E   0x9D08             LDR      R5,[SP, #+32]
    336          	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
    337          	{
    338          		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   \       0x50   0x.... 0x....      BL       xTaskGetSchedulerState
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD104             BNE.N    ??xEventGroupWaitBits_6
   \       0x58   0x4628             MOV      R0,R5
   \       0x5A   0x1E40             SUBS     R0,R0,#+1
   \       0x5C   0x4180             SBCS     R0,R0,R0
   \       0x5E   0x0FC0             LSRS     R0,R0,#+31
   \       0x60   0xE000             B.N      ??xEventGroupWaitBits_7
   \                     ??xEventGroupWaitBits_6: (+1)
   \       0x62   0x2001             MOVS     R0,#+1
   \                     ??xEventGroupWaitBits_7: (+1)
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD107             BNE.N    ??xEventGroupWaitBits_8
   \       0x68   0x2020             MOVS     R0,#+32
   \       0x6A   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x6E   0xF3BF 0x8F4F      DSB      SY
   \       0x72   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupWaitBits_9: (+1)
   \       0x76   0xE7FE             B.N      ??xEventGroupWaitBits_9
    339          	}
    340          	#endif
    341          
    342          	vTaskSuspendAll();
   \                     ??xEventGroupWaitBits_8: (+1)
   \       0x78   0x.... 0x....      BL       vTaskSuspendAll
    343          	{
    344          		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
   \       0x7C   0xF8D7 0xA000      LDR      R10,[R7, #+0]
    345          
    346          		/* Check to see if the wait condition is already met or not. */
    347          		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    348          
    349          		if( xWaitConditionMet != pdFALSE )
   \       0x80   0x4642             MOV      R2,R8
   \       0x82   0x4631             MOV      R1,R6
   \       0x84   0x4650             MOV      R0,R10
   \       0x86   0x.... 0x....      BL       prvTestWaitCondition
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD006             BEQ.N    ??xEventGroupWaitBits_10
    350          		{
    351          			/* The wait condition has already been met so there is no need to
    352          			block. */
    353          			uxReturn = uxCurrentEventBits;
    354          			xTicksToWait = ( TickType_t ) 0;
   \       0x8E   0x464D             MOV      R5,R9
    355          
    356          			/* Clear the wait bits if requested to do so. */
    357          			if( xClearOnExit != pdFALSE )
   \       0x90   0x2C00             CMP      R4,#+0
   \       0x92   0xD017             BEQ.N    ??xEventGroupWaitBits_11
    358          			{
    359          				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
   \       0x94   0x6838             LDR      R0,[R7, #+0]
   \       0x96   0x43B0             BICS     R0,R0,R6
   \       0x98   0x6038             STR      R0,[R7, #+0]
   \       0x9A   0xE013             B.N      ??xEventGroupWaitBits_11
    360          			}
    361          			else
    362          			{
    363          				mtCOVERAGE_TEST_MARKER();
    364          			}
    365          		}
    366          		else if( xTicksToWait == ( TickType_t ) 0 )
   \                     ??xEventGroupWaitBits_10: (+1)
   \       0x9C   0x2D00             CMP      R5,#+0
   \       0x9E   0xD011             BEQ.N    ??xEventGroupWaitBits_11
    367          		{
    368          			/* The wait condition has not been met, but no block time was
    369          			specified, so just return the current value. */
    370          			uxReturn = uxCurrentEventBits;
    371          		}
    372          		else
    373          		{
    374          			/* The task is going to block to wait for its required bits to be
    375          			set.  uxControlBits are used to remember the specified behaviour of
    376          			this call to xEventGroupWaitBits() - for use when the event bits
    377          			unblock the task. */
    378          			if( xClearOnExit != pdFALSE )
   \       0xA0   0x2C00             CMP      R4,#+0
   \       0xA2   0xD001             BEQ.N    ??xEventGroupWaitBits_12
    379          			{
    380          				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
   \       0xA4   0xF04F 0x7980      MOV      R9,#+16777216
    381          			}
    382          			else
    383          			{
    384          				mtCOVERAGE_TEST_MARKER();
    385          			}
    386          
    387          			if( xWaitForAllBits != pdFALSE )
   \                     ??xEventGroupWaitBits_12: (+1)
   \       0xA8   0xF1B8 0x0F00      CMP      R8,#+0
   \       0xAC   0xD001             BEQ.N    ??xEventGroupWaitBits_13
    388          			{
    389          				uxControlBits |= eventWAIT_FOR_ALL_BITS;
   \       0xAE   0xF049 0x6980      ORR      R9,R9,#0x4000000
    390          			}
    391          			else
    392          			{
    393          				mtCOVERAGE_TEST_MARKER();
    394          			}
    395          
    396          			/* Store the bits that the calling task is waiting for in the
    397          			task's event list item so the kernel knows when a match is
    398          			found.  Then enter the blocked state. */
    399          			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
   \                     ??xEventGroupWaitBits_13: (+1)
   \       0xB2   0x462A             MOV      R2,R5
   \       0xB4   0xEA49 0x0906      ORR      R9,R9,R6
   \       0xB8   0x4649             MOV      R1,R9
   \       0xBA   0x1D38             ADDS     R0,R7,#+4
   \       0xBC   0x.... 0x....      BL       vTaskPlaceOnUnorderedEventList
    400          
    401          			/* This is obsolete as it will get set after the task unblocks, but
    402          			some compilers mistakenly generate a warning about the variable
    403          			being returned without being set if it is not done. */
    404          			uxReturn = 0;
   \       0xC0   0xF04F 0x0A00      MOV      R10,#+0
    405          
    406          			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
    407          		}
    408          	}
    409          	xAlreadyYielded = xTaskResumeAll();
   \                     ??xEventGroupWaitBits_11: (+1)
   \       0xC4   0x.... 0x....      BL       xTaskResumeAll
    410          
    411          	if( xTicksToWait != ( TickType_t ) 0 )
   \       0xC8   0x2D00             CMP      R5,#+0
   \       0xCA   0xD024             BEQ.N    ??xEventGroupWaitBits_14
    412          	{
    413          		if( xAlreadyYielded == pdFALSE )
   \       0xCC   0x2800             CMP      R0,#+0
   \       0xCE   0xD107             BNE.N    ??xEventGroupWaitBits_15
    414          		{
    415          			portYIELD_WITHIN_API();
   \       0xD0   0xF04F 0x5080      MOV      R0,#+268435456
   \       0xD4   0x....             LDR.N    R1,??DataTable3  ;; 0xe000ed04
   \       0xD6   0x6008             STR      R0,[R1, #+0]
   \       0xD8   0xF3BF 0x8F4F      DSB      SY
   \       0xDC   0xF3BF 0x8F6F      ISB      SY
    416          		}
    417          		else
    418          		{
    419          			mtCOVERAGE_TEST_MARKER();
    420          		}
    421          
    422          		/* The task blocked to wait for its required bits to be set - at this
    423          		point either the required bits were set or the block time expired.  If
    424          		the required bits were set they will have been stored in the task's
    425          		event list item, and they should now be retrieved then cleared. */
    426          		uxReturn = uxTaskResetEventItemValue();
   \                     ??xEventGroupWaitBits_15: (+1)
   \       0xE0   0x.... 0x....      BL       uxTaskResetEventItemValue
   \       0xE4   0x4682             MOV      R10,R0
    427          
    428          		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
   \       0xE6   0xEA5F 0x108A      LSLS     R0,R10,#+6
   \       0xEA   0xD412             BMI.N    ??xEventGroupWaitBits_16
    429          		{
    430          			taskENTER_CRITICAL();
   \       0xEC   0x.... 0x....      BL       vPortEnterCritical
    431          			{
    432          				/* The task timed out, just return the current event bit value. */
    433          				uxReturn = pxEventBits->uxEventBits;
   \       0xF0   0xF8D7 0xA000      LDR      R10,[R7, #+0]
    434          
    435          				/* It is possible that the event bits were updated between this
    436          				task leaving the Blocked state and running again. */
    437          				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
   \       0xF4   0x4642             MOV      R2,R8
   \       0xF6   0x4631             MOV      R1,R6
   \       0xF8   0x4650             MOV      R0,R10
   \       0xFA   0x.... 0x....      BL       prvTestWaitCondition
   \       0xFE   0x2800             CMP      R0,#+0
   \      0x100   0xD005             BEQ.N    ??xEventGroupWaitBits_17
    438          				{
    439          					if( xClearOnExit != pdFALSE )
   \      0x102   0x2C00             CMP      R4,#+0
   \      0x104   0xD003             BEQ.N    ??xEventGroupWaitBits_17
    440          					{
    441          						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
   \      0x106   0x6838             LDR      R0,[R7, #+0]
   \      0x108   0xEA20 0x0606      BIC      R6,R0,R6
   \      0x10C   0x603E             STR      R6,[R7, #+0]
    442          					}
    443          					else
    444          					{
    445          						mtCOVERAGE_TEST_MARKER();
    446          					}
    447          				}
    448          				else
    449          				{
    450          					mtCOVERAGE_TEST_MARKER();
    451          				}
    452          			}
    453          			taskEXIT_CRITICAL();
   \                     ??xEventGroupWaitBits_17: (+1)
   \      0x10E   0x.... 0x....      BL       vPortExitCritical
    454          
    455          			/* Prevent compiler warnings when trace macros are not used. */
    456          			xTimeoutOccurred = pdFALSE;
    457          		}
    458          		else
    459          		{
    460          			/* The task unblocked because the bits were set. */
    461          		}
    462          
    463          		/* The task blocked so control bits may have been set. */
    464          		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
   \                     ??xEventGroupWaitBits_16: (+1)
   \      0x112   0xF02A 0x4A7F      BIC      R10,R10,#0xFF000000
    465          	}
    466          	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );
    467          
    468          	return uxReturn;
   \                     ??xEventGroupWaitBits_14: (+1)
   \      0x116   0x4650             MOV      R0,R10
   \      0x118   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    469          }
    470          /*-----------------------------------------------------------*/
    471          

   \                                 In section .text, align 2, keep-with-next
    472          EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
    473          {
   \                     xEventGroupClearBits: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    474          EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    475          EventBits_t uxReturn;
    476          
    477          	/* Check the user is not attempting to clear the bits used by the kernel
    478          	itself. */
    479          	configASSERT( xEventGroup );
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD107             BNE.N    ??xEventGroupClearBits_0
   \        0xA   0x2020             MOVS     R0,#+32
   \        0xC   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x10   0xF3BF 0x8F4F      DSB      SY
   \       0x14   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupClearBits_1: (+1)
   \       0x18   0xE7FE             B.N      ??xEventGroupClearBits_1
    480          	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
   \                     ??xEventGroupClearBits_0: (+1)
   \       0x1A   0xF015 0x4F7F      TST      R5,#0xFF000000
   \       0x1E   0xD007             BEQ.N    ??xEventGroupClearBits_2
   \       0x20   0x2020             MOVS     R0,#+32
   \       0x22   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x26   0xF3BF 0x8F4F      DSB      SY
   \       0x2A   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupClearBits_3: (+1)
   \       0x2E   0xE7FE             B.N      ??xEventGroupClearBits_3
    481          
    482          	taskENTER_CRITICAL();
   \                     ??xEventGroupClearBits_2: (+1)
   \       0x30   0x.... 0x....      BL       vPortEnterCritical
    483          	{
    484          		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );
    485          
    486          		/* The value returned is the event group value prior to the bits being
    487          		cleared. */
    488          		uxReturn = pxEventBits->uxEventBits;
   \       0x34   0x6826             LDR      R6,[R4, #+0]
    489          
    490          		/* Clear the bits. */
    491          		pxEventBits->uxEventBits &= ~uxBitsToClear;
   \       0x36   0x4630             MOV      R0,R6
   \       0x38   0xEA20 0x0505      BIC      R5,R0,R5
   \       0x3C   0x6025             STR      R5,[R4, #+0]
    492          	}
    493          	taskEXIT_CRITICAL();
   \       0x3E   0x.... 0x....      BL       vPortExitCritical
    494          
    495          	return uxReturn;
   \       0x42   0x4630             MOV      R0,R6
   \       0x44   0xBD70             POP      {R4-R6,PC}       ;; return
    496          }
    497          /*-----------------------------------------------------------*/
    498          
    499          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )
    500          

   \                                 In section .text, align 2, keep-with-next
    501          	BaseType_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
    502          	{
   \                     xEventGroupClearBitsFromISR: (+1)
   \        0x0   0x460A             MOV      R2,R1
    503          		BaseType_t xReturn;
    504          
    505          		traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear );
    506          		xReturn = xTimerPendFunctionCallFromISR( vEventGroupClearBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToClear, NULL );
    507          
    508          		return xReturn;
   \        0x2   0x2300             MOVS     R3,#+0
   \        0x4   0x4601             MOV      R1,R0
   \        0x6   0x.... 0x....      ADR.W    R0,vEventGroupClearBitsCallback
   \        0xA   0x.... 0x....      B.W      xTimerPendFunctionCallFromISR
    509          	}
    510          
    511          #endif
    512          /*-----------------------------------------------------------*/
    513          

   \                                 In section .text, align 2, keep-with-next
    514          EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
    515          {
    516          UBaseType_t uxSavedInterruptStatus;
    517          EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    518          EventBits_t uxReturn;
    519          
    520          	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \                     xEventGroupGetBitsFromISR: (+1)
   \        0x0   0xF3EF 0x8111      MRS      R1,BASEPRI
   \        0x4   0x2220             MOVS     R2,#+32
   \        0x6   0xF382 0x8811      MSR      BASEPRI,R2
   \        0xA   0xF3BF 0x8F4F      DSB      SY
   \        0xE   0xF3BF 0x8F6F      ISB      SY
    521          	{
    522          		uxReturn = pxEventBits->uxEventBits;
   \       0x12   0x6800             LDR      R0,[R0, #+0]
    523          	}
    524          	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \       0x14   0xF381 0x8811      MSR      BASEPRI,R1
    525          
    526          	return uxReturn;
   \       0x18   0x4770             BX       LR               ;; return
    527          }
    528          /*-----------------------------------------------------------*/
    529          

   \                                 In section .text, align 2, keep-with-next
    530          EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
    531          {
   \                     xEventGroupSetBits: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
    532          ListItem_t *pxListItem, *pxNext;
    533          ListItem_t const *pxListEnd;
    534          List_t *pxList;
    535          EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
   \        0x8   0x2600             MOVS     R6,#+0
    536          EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    537          BaseType_t xMatchFound = pdFALSE;
    538          
    539          	/* Check the user is not attempting to set the bits used by the kernel
    540          	itself. */
    541          	configASSERT( xEventGroup );
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD107             BNE.N    ??xEventGroupSetBits_0
   \        0xE   0x2020             MOVS     R0,#+32
   \       0x10   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x14   0xF3BF 0x8F4F      DSB      SY
   \       0x18   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupSetBits_1: (+1)
   \       0x1C   0xE7FE             B.N      ??xEventGroupSetBits_1
    542          	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
   \                     ??xEventGroupSetBits_0: (+1)
   \       0x1E   0xF015 0x4F7F      TST      R5,#0xFF000000
   \       0x22   0xD007             BEQ.N    ??xEventGroupSetBits_2
   \       0x24   0x2020             MOVS     R0,#+32
   \       0x26   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x2A   0xF3BF 0x8F4F      DSB      SY
   \       0x2E   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupSetBits_3: (+1)
   \       0x32   0xE7FE             B.N      ??xEventGroupSetBits_3
    543          
    544          	pxList = &( pxEventBits->xTasksWaitingForBits );
   \                     ??xEventGroupSetBits_2: (+1)
   \       0x34   0xF104 0x0804      ADD      R8,R4,#+4
    545          	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   \       0x38   0xF108 0x0708      ADD      R7,R8,#+8
    546          	vTaskSuspendAll();
   \       0x3C   0x.... 0x....      BL       vTaskSuspendAll
    547          	{
    548          		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );
    549          
    550          		pxListItem = listGET_HEAD_ENTRY( pxList );
   \       0x40   0xF8D8 0x200C      LDR      R2,[R8, #+12]
    551          
    552          		/* Set the bits. */
    553          		pxEventBits->uxEventBits |= uxBitsToSet;
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x4305             ORRS     R5,R5,R0
   \       0x48   0x6025             STR      R5,[R4, #+0]
    554          
    555          		/* See if the new bit value should unblock any tasks. */
    556          		while( pxListItem != pxListEnd )
   \                     ??xEventGroupSetBits_4: (+1)
   \       0x4A   0x42BA             CMP      R2,R7
   \       0x4C   0xD022             BEQ.N    ??xEventGroupSetBits_5
    557          		{
    558          			pxNext = listGET_NEXT( pxListItem );
   \       0x4E   0x6855             LDR      R5,[R2, #+4]
    559          			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
   \       0x50   0x6811             LDR      R1,[R2, #+0]
    560          			xMatchFound = pdFALSE;
   \       0x52   0x2000             MOVS     R0,#+0
    561          
    562          			/* Split the bits waited for from the control bits. */
    563          			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
   \       0x54   0xF001 0x437F      AND      R3,R1,#0xFF000000
    564          			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
   \       0x58   0xF021 0x417F      BIC      R1,R1,#0xFF000000
    565          
    566          			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
   \       0x5C   0xEA5F 0x1C43      LSLS     R12,R3,#+5
   \       0x60   0xF8D4 0xC000      LDR      R12,[R4, #+0]
   \       0x64   0xD505             BPL.N    ??xEventGroupSetBits_6
    567          			{
    568          				/* Just looking for single bit being set. */
    569          				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    570          				{
    571          					xMatchFound = pdTRUE;
    572          				}
    573          				else
    574          				{
    575          					mtCOVERAGE_TEST_MARKER();
    576          				}
    577          			}
    578          			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
   \       0x66   0xEA0C 0x0C01      AND      R12,R12,R1
   \       0x6A   0x458C             CMP      R12,R1
   \       0x6C   0xD105             BNE.N    ??xEventGroupSetBits_7
    579          			{
    580          				/* All bits are set. */
    581          				xMatchFound = pdTRUE;
   \       0x6E   0x2001             MOVS     R0,#+1
   \       0x70   0xE003             B.N      ??xEventGroupSetBits_7
    582          			}
   \                     ??xEventGroupSetBits_6: (+1)
   \       0x72   0xEA11 0x0F0C      TST      R1,R12
   \       0x76   0xD000             BEQ.N    ??xEventGroupSetBits_7
   \       0x78   0x2001             MOVS     R0,#+1
    583          			else
    584          			{
    585          				/* Need all bits to be set, but not all the bits were set. */
    586          			}
    587          
    588          			if( xMatchFound != pdFALSE )
   \                     ??xEventGroupSetBits_7: (+1)
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD008             BEQ.N    ??xEventGroupSetBits_8
    589          			{
    590          				/* The bits match.  Should the bits be cleared on exit? */
    591          				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
   \       0x7E   0x01D8             LSLS     R0,R3,#+7
   \       0x80   0xD500             BPL.N    ??xEventGroupSetBits_9
    592          				{
    593          					uxBitsToClear |= uxBitsWaitedFor;
   \       0x82   0x430E             ORRS     R6,R1,R6
    594          				}
    595          				else
    596          				{
    597          					mtCOVERAGE_TEST_MARKER();
    598          				}
    599          
    600          				/* Store the actual event flag value in the task's event list
    601          				item before removing the task from the event list.  The
    602          				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
    603          				that is was unblocked due to its required bits matching, rather
    604          				than because it timed out. */
    605          				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
   \                     ??xEventGroupSetBits_9: (+1)
   \       0x84   0x6821             LDR      R1,[R4, #+0]
   \       0x86   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \       0x8A   0x4610             MOV      R0,R2
   \       0x8C   0x.... 0x....      BL       xTaskRemoveFromUnorderedEventList
    606          			}
    607          
    608          			/* Move onto the next list item.  Note pxListItem->pxNext is not
    609          			used here as the list item may have been removed from the event list
    610          			and inserted into the ready/pending reading list. */
    611          			pxListItem = pxNext;
   \                     ??xEventGroupSetBits_8: (+1)
   \       0x90   0x462A             MOV      R2,R5
   \       0x92   0xE7DA             B.N      ??xEventGroupSetBits_4
    612          		}
    613          
    614          		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
    615          		bit was set in the control word. */
    616          		pxEventBits->uxEventBits &= ~uxBitsToClear;
   \                     ??xEventGroupSetBits_5: (+1)
   \       0x94   0x6820             LDR      R0,[R4, #+0]
   \       0x96   0xEA20 0x0606      BIC      R6,R0,R6
   \       0x9A   0x6026             STR      R6,[R4, #+0]
    617          	}
    618          	( void ) xTaskResumeAll();
   \       0x9C   0x.... 0x....      BL       xTaskResumeAll
    619          
    620          	return pxEventBits->uxEventBits;
   \       0xA0   0x6820             LDR      R0,[R4, #+0]
   \       0xA2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    621          }
    622          /*-----------------------------------------------------------*/
    623          

   \                                 In section .text, align 2, keep-with-next
    624          void vEventGroupDelete( EventGroupHandle_t xEventGroup )
    625          {
   \                     vEventGroupDelete: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
    626          EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    627          const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
   \        0x4   0x1D25             ADDS     R5,R4,#+4
    628          
    629          	vTaskSuspendAll();
   \        0x6   0x.... 0x....      BL       vTaskSuspendAll
   \        0xA   0xE003             B.N      ??vEventGroupDelete_0
    630          	{
    631          		traceEVENT_GROUP_DELETE( xEventGroup );
    632          
    633          		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    634          		{
    635          			/* Unblock the task, returning 0 as the event list is being deleted
    636          			and	cannot therefore have any bits set. */
    637          			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
    638          			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
   \                     ??vEventGroupDelete_1: (+1)
   \        0xC   0xF04F 0x7100      MOV      R1,#+33554432
   \       0x10   0x.... 0x....      BL       xTaskRemoveFromUnorderedEventList
   \                     ??vEventGroupDelete_0: (+1)
   \       0x14   0x6828             LDR      R0,[R5, #+0]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD00C             BEQ.N    ??vEventGroupDelete_2
   \       0x1A   0x68E8             LDR      R0,[R5, #+12]
   \       0x1C   0xF105 0x0108      ADD      R1,R5,#+8
   \       0x20   0x4288             CMP      R0,R1
   \       0x22   0xD1F3             BNE.N    ??vEventGroupDelete_1
   \       0x24   0x2020             MOVS     R0,#+32
   \       0x26   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x2A   0xF3BF 0x8F4F      DSB      SY
   \       0x2E   0xF3BF 0x8F6F      ISB      SY
   \                     ??vEventGroupDelete_3: (+1)
   \       0x32   0xE7FE             B.N      ??vEventGroupDelete_3
    639          		}
    640          
    641          		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    642          		{
    643          			/* The event group can only have been allocated dynamically - free
    644          			it again. */
    645          			vPortFree( pxEventBits );
   \                     ??vEventGroupDelete_2: (+1)
   \       0x34   0x4620             MOV      R0,R4
   \       0x36   0x.... 0x....      BL       vPortFree
    646          		}
    647          		#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
    648          		{
    649          			/* The event group could have been allocated statically or
    650          			dynamically, so check before attempting to free the memory. */
    651          			if( pxEventBits->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
    652          			{
    653          				vPortFree( pxEventBits );
    654          			}
    655          			else
    656          			{
    657          				mtCOVERAGE_TEST_MARKER();
    658          			}
    659          		}
    660          		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    661          	}
    662          	( void ) xTaskResumeAll();
   \       0x3A   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \       0x3E   0x.... 0x....      B.W      xTaskResumeAll
    663          }
    664          /*-----------------------------------------------------------*/
    665          
    666          /* For internal use only - execute a 'set bits' command that was pended from
    667          an interrupt. */

   \                                 In section .text, align 2, keep-with-next
    668          void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
    669          {
    670          	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
   \                     vEventGroupSetBitsCallback: (+1)
   \        0x0   0x....             B.N      xEventGroupSetBits
    671          }
    672          /*-----------------------------------------------------------*/
    673          
    674          /* For internal use only - execute a 'clear bits' command that was pended from
    675          an interrupt. */

   \                                 In section .text, align 4, keep-with-next
    676          void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
    677          {
    678          	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
   \                     vEventGroupClearBitsCallback: (+1)
   \        0x0   0x....             B.N      xEventGroupClearBits
    679          }
    680          /*-----------------------------------------------------------*/
    681          

   \                                 In section .text, align 2, keep-with-next
    682          static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
    683          {
   \                     prvTestWaitCondition: (+1)
   \        0x0   0x4603             MOV      R3,R0
    684          BaseType_t xWaitConditionMet = pdFALSE;
   \        0x2   0x2000             MOVS     R0,#+0
    685          
    686          	if( xWaitForAllBits == pdFALSE )
   \        0x4   0x2A00             CMP      R2,#+0
   \        0x6   0xD103             BNE.N    ??prvTestWaitCondition_0
    687          	{
    688          		/* Task only has to wait for one bit within uxBitsToWaitFor to be
    689          		set.  Is one already set? */
    690          		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
   \        0x8   0x420B             TST      R3,R1
   \        0xA   0xD005             BEQ.N    ??prvTestWaitCondition_1
    691          		{
    692          			xWaitConditionMet = pdTRUE;
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0x4770             BX       LR
    693          		}
    694          		else
    695          		{
    696          			mtCOVERAGE_TEST_MARKER();
    697          		}
    698          	}
    699          	else
    700          	{
    701          		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
    702          		Are they set already? */
    703          		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
   \                     ??prvTestWaitCondition_0: (+1)
   \       0x10   0x400B             ANDS     R3,R1,R3
   \       0x12   0x428B             CMP      R3,R1
   \       0x14   0xD100             BNE.N    ??prvTestWaitCondition_1
    704          		{
    705          			xWaitConditionMet = pdTRUE;
   \       0x16   0x2001             MOVS     R0,#+1
    706          		}
    707          		else
    708          		{
    709          			mtCOVERAGE_TEST_MARKER();
    710          		}
    711          	}
    712          
    713          	return xWaitConditionMet;
   \                     ??prvTestWaitCondition_1: (+1)
   \       0x18   0x4770             BX       LR               ;; return
    714          }
    715          /*-----------------------------------------------------------*/
    716          
    717          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )
    718          

   \                                 In section .text, align 2, keep-with-next
    719          	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken )
    720          	{
   \                     xEventGroupSetBitsFromISR: (+1)
   \        0x0   0x4613             MOV      R3,R2
    721          	BaseType_t xReturn;
    722          
    723          		traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet );
    724          		xReturn = xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken );
    725          
    726          		return xReturn;
   \        0x2   0x460A             MOV      R2,R1
   \        0x4   0x4601             MOV      R1,R0
   \        0x6   0x....             LDR.N    R0,??DataTable3_1
   \        0x8   0x.... 0x....      B.W      xTimerPendFunctionCallFromISR
    727          	}
    728          
    729          #endif
    730          /*-----------------------------------------------------------*/
    731          
    732          #if (configUSE_TRACE_FACILITY == 1)
    733          

   \                                 In section .text, align 2, keep-with-next
    734          	UBaseType_t uxEventGroupGetNumber( void* xEventGroup )
    735          	{
    736          	UBaseType_t xReturn;
    737          	EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    738          
    739          		if( xEventGroup == NULL )
   \                     uxEventGroupGetNumber: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD101             BNE.N    ??uxEventGroupGetNumber_0
    740          		{
    741          			xReturn = 0;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x4770             BX       LR
    742          		}
    743          		else
    744          		{
    745          			xReturn = pxEventBits->uxEventGroupNumber;
   \                     ??uxEventGroupGetNumber_0: (+1)
   \        0x8   0x6980             LDR      R0,[R0, #+24]
    746          		}
    747          
    748          		return xReturn;
   \        0xA   0x4770             BX       LR               ;; return
    749          	}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0xE000'ED04        DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0x....'....        DC32     vEventGroupSetBitsCallback
    750          
    751          #endif
    752          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   prvTestWaitCondition
       0   uxEventGroupGetNumber
       0   vEventGroupClearBitsCallback
         0   -> xEventGroupClearBits
      16   vEventGroupDelete
        16   -> vPortFree
        16   -> vTaskSuspendAll
        16   -> xTaskRemoveFromUnorderedEventList
         0   -> xTaskResumeAll
       0   vEventGroupSetBitsCallback
         0   -> xEventGroupSetBits
      16   xEventGroupClearBits
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
       0   xEventGroupClearBitsFromISR
         0   -> xTimerPendFunctionCallFromISR
       8   xEventGroupCreate
         8   -> pvPortMalloc
         8   -> vListInitialise
       0   xEventGroupGetBitsFromISR
      24   xEventGroupSetBits
        24   -> vTaskSuspendAll
        24   -> xTaskRemoveFromUnorderedEventList
        24   -> xTaskResumeAll
       0   xEventGroupSetBitsFromISR
         0   -> xTimerPendFunctionCallFromISR
      24   xEventGroupSync
        24   -> uxTaskResetEventItemValue
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
        24   -> vTaskPlaceOnUnorderedEventList
        24   -> vTaskSuspendAll
        24   -> xEventGroupSetBits
        24   -> xTaskGetSchedulerState
        24   -> xTaskResumeAll
      32   xEventGroupWaitBits
        32   -> prvTestWaitCondition
        32   -> uxTaskResetEventItemValue
        32   -> vPortEnterCritical
        32   -> vPortExitCritical
        32   -> vTaskPlaceOnUnorderedEventList
        32   -> vTaskSuspendAll
        32   -> xTaskGetSchedulerState
        32   -> xTaskResumeAll


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
      26  prvTestWaitCondition
      12  uxEventGroupGetNumber
       2  vEventGroupClearBitsCallback
      66  vEventGroupDelete
       2  vEventGroupSetBitsCallback
      70  xEventGroupClearBits
      14  xEventGroupClearBitsFromISR
      26  xEventGroupCreate
      26  xEventGroupGetBitsFromISR
     166  xEventGroupSetBits
      12  xEventGroupSetBitsFromISR
     230  xEventGroupSync
     284  xEventGroupWaitBits

 
 944 bytes in section .text
 
 944 bytes of CODE memory

Errors: none
Warnings: none
