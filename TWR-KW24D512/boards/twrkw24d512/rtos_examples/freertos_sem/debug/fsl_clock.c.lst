###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         03/Mar/2020  16:31:37
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_clock.c
#    Command line =  
#        C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_clock.c
#        "-IC:\Program Files (x86)\IAR Systems\Embedded Workbench 8.1\arm\inc"
#        -I..\..\..\..\..\CMSIS\Include -I..\..\..\..\..\devices -I..\..\..
#        -I..\..\..\..\..\devices\MKW24D5\drivers
#        -I..\..\..\..\..\devices\MKW24D5\utilities
#        -I..\..\..\..\..\devices\MKW24D5 -I..\..\iar -I..\.. -I..\
#        -I..\..\..\..\..\rtos\freertos_9.0.0\Source\portable\IAR\ARM_CM3
#        -I..\..\..\..\..\rtos\freertos_9.0.0\Source\include
#        -DCPU_MKW24D512VHA5 -DIAR -DFSL_RTOS_FREE_RTOS -DPRINTF_FLOAT_ENABLE=0
#        -DSCANF_FLOAT_ENABLE=0 -DPRINTF_ADVANCED_ENABLE=0
#        -DSCANF_ADVANCED_ENABLE=0 -DTWR_KW24D512 -DTOWER --diag_suppress
#        Pa082,Pa050,Pe167,Pa182 --endian=little --cpu=Cortex-M4 --fpu=None
#        --no_path_in_file_macros --silent -lC . -e --dlib_config "C:/Program
#        Files (x86)/IAR Systems/Embedded Workbench
#        8.1/arm/inc/c/DLib_Config_Normal.h" -Om --debug --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --dependencies=ns
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_clock.c.obj.d
#        -o
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_clock.c.obj
#    Locale       =  C
#    List file    =  .\fsl_clock.c.lst
#    Object file  =  
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_clock.c.obj
#
###############################################################################

C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_clock.c
      1          /*
      2           * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3           * Copyright (c) 2016 - 2017 , NXP
      4           * All rights reserved.
      5           *
      6           * Redistribution and use in source and binary forms, with or without modification,
      7           * are permitted provided that the following conditions are met:
      8           *
      9           * o Redistributions of source code must retain the above copyright notice, this list
     10           *   of conditions and the following disclaimer.
     11           *
     12           * o Redistributions in binary form must reproduce the above copyright notice, this
     13           *   list of conditions and the following disclaimer in the documentation and/or
     14           *   other materials provided with the distribution.
     15           *
     16           * o Neither the name of copyright holder nor the names of its
     17           *   contributors may be used to endorse or promote products derived from this
     18           *   software without specific prior written permission.
     19           *
     20           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     21           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     22           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     23           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     24           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     25           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     26           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     27           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     28           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     29           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     30           */
     31          
     32          #include "fsl_clock.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_EnableClock(clock_ip_name_t)
   \                     CLOCK_EnableClock: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable42  ;; 0x40047000
   \        0x4   0xEB01 0x4110      ADD      R1,R1,R0, LSR #+16
   \        0x8   0x680A             LDR      R2,[R1, #+0]
   \        0xA   0x2301             MOVS     R3,#+1
   \        0xC   0xFA03 0xF000      LSL      R0,R3,R0
   \       0x10   0x4310             ORRS     R0,R0,R2
   \       0x12   0x6008             STR      R0,[R1, #+0]
   \       0x14   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_DisableClock(clock_ip_name_t)
   \                     CLOCK_DisableClock: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable42  ;; 0x40047000
   \        0x4   0xEB01 0x4110      ADD      R1,R1,R0, LSR #+16
   \        0x8   0x680A             LDR      R2,[R1, #+0]
   \        0xA   0x2301             MOVS     R3,#+1
   \        0xC   0xFA03 0xF000      LSL      R0,R3,R0
   \       0x10   0xEA22 0x0000      BIC      R0,R2,R0
   \       0x14   0x6008             STR      R0,[R1, #+0]
   \       0x16   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_SetEr32kClock(uint32_t)
   \                     CLOCK_SetEr32kClock: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable42  ;; 0x40047000
   \        0x4   0x680A             LDR      R2,[R1, #+0]
   \        0x6   0xF422 0x2240      BIC      R2,R2,#0xC0000
   \        0xA   0x0480             LSLS     R0,R0,#+18
   \        0xC   0xF400 0x2040      AND      R0,R0,#0xC0000
   \       0x10   0x4310             ORRS     R0,R0,R2
   \       0x12   0x6008             STR      R0,[R1, #+0]
   \       0x14   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_SetPllFllSelClock(uint32_t)
   \                     CLOCK_SetPllFllSelClock: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable43  ;; 0x40048004
   \        0x4   0x680A             LDR      R2,[R1, #+0]
   \        0x6   0xF422 0x3280      BIC      R2,R2,#0x10000
   \        0xA   0x0400             LSLS     R0,R0,#+16
   \        0xC   0xF400 0x3080      AND      R0,R0,#0x10000
   \       0x10   0x4310             ORRS     R0,R0,R2
   \       0x12   0x6008             STR      R0,[R1, #+0]
   \       0x14   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void OSC_SetExtRefClkConfig(OSC_Type *, oscer_config_t const *)
   \                     OSC_SetExtRefClkConfig: (+1)
   \        0x0   0x7802             LDRB     R2,[R0, #+0]
   \        0x2   0xF002 0x025F      AND      R2,R2,#0x5F
   \        0x6   0x7809             LDRB     R1,[R1, #+0]
   \        0x8   0x430A             ORRS     R2,R1,R2
   \        0xA   0x7002             STRB     R2,[R0, #+0]
   \        0xC   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void OSC_SetCapLoad(OSC_Type *, uint8_t)
   \                     OSC_SetCapLoad: (+1)
   \        0x0   0x7802             LDRB     R2,[R0, #+0]
   \        0x2   0xF002 0x02F0      AND      R2,R2,#0xF0
   \        0x6   0x4311             ORRS     R1,R1,R2
   \        0x8   0x7001             STRB     R1,[R0, #+0]
   \        0xA   0x4770             BX       LR               ;; return
     33          
     34          /*******************************************************************************
     35           * Definitions
     36           ******************************************************************************/
     37          
     38          /* Macro definition remap workaround. */
     39          #if (defined(MCG_C2_EREFS_MASK) && !(defined(MCG_C2_EREFS0_MASK)))
     40          #define MCG_C2_EREFS0_MASK MCG_C2_EREFS_MASK
     41          #endif
     42          #if (defined(MCG_C2_HGO_MASK) && !(defined(MCG_C2_HGO0_MASK)))
     43          #define MCG_C2_HGO0_MASK MCG_C2_HGO_MASK
     44          #endif
     45          #if (defined(MCG_C2_RANGE_MASK) && !(defined(MCG_C2_RANGE0_MASK)))
     46          #define MCG_C2_RANGE0_MASK MCG_C2_RANGE_MASK
     47          #endif
     48          #if (defined(MCG_C6_CME_MASK) && !(defined(MCG_C6_CME0_MASK)))
     49          #define MCG_C6_CME0_MASK MCG_C6_CME_MASK
     50          #endif
     51          
     52          /* PLL fixed multiplier when there is not PRDIV and VDIV. */
     53          #define PLL_FIXED_MULT (375U)
     54          /* Max frequency of the reference clock used for internal clock trim. */
     55          #define TRIM_REF_CLK_MIN (8000000U)
     56          /* Min frequency of the reference clock used for internal clock trim. */
     57          #define TRIM_REF_CLK_MAX (16000000U)
     58          /* Max trim value of fast internal reference clock. */
     59          #define TRIM_FIRC_MAX (5000000U)
     60          /* Min trim value of fast internal reference clock. */
     61          #define TRIM_FIRC_MIN (3000000U)
     62          /* Max trim value of fast internal reference clock. */
     63          #define TRIM_SIRC_MAX (39063U)
     64          /* Min trim value of fast internal reference clock. */
     65          #define TRIM_SIRC_MIN (31250U)
     66          
     67          #define MCG_S_IRCST_VAL ((MCG->S & MCG_S_IRCST_MASK) >> MCG_S_IRCST_SHIFT)
     68          #define MCG_S_CLKST_VAL ((MCG->S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT)
     69          #define MCG_S_IREFST_VAL ((MCG->S & MCG_S_IREFST_MASK) >> MCG_S_IREFST_SHIFT)
     70          #define MCG_S_PLLST_VAL ((MCG->S & MCG_S_PLLST_MASK) >> MCG_S_PLLST_SHIFT)
     71          #define MCG_C1_FRDIV_VAL ((MCG->C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT)
     72          #define MCG_C2_LP_VAL ((MCG->C2 & MCG_C2_LP_MASK) >> MCG_C2_LP_SHIFT)
     73          #define MCG_C2_RANGE_VAL ((MCG->C2 & MCG_C2_RANGE_MASK) >> MCG_C2_RANGE_SHIFT)
     74          #define MCG_SC_FCRDIV_VAL ((MCG->SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)
     75          #define MCG_S2_PLLCST_VAL ((MCG->S2 & MCG_S2_PLLCST_MASK) >> MCG_S2_PLLCST_SHIFT)
     76          #define MCG_C7_OSCSEL_VAL ((MCG->C7 & MCG_C7_OSCSEL_MASK) >> MCG_C7_OSCSEL_SHIFT)
     77          #define MCG_C4_DMX32_VAL ((MCG->C4 & MCG_C4_DMX32_MASK) >> MCG_C4_DMX32_SHIFT)
     78          #define MCG_C4_DRST_DRS_VAL ((MCG->C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT)
     79          #define MCG_C7_PLL32KREFSEL_VAL ((MCG->C7 & MCG_C7_PLL32KREFSEL_MASK) >> MCG_C7_PLL32KREFSEL_SHIFT)
     80          #define MCG_C5_PLLREFSEL0_VAL ((MCG->C5 & MCG_C5_PLLREFSEL0_MASK) >> MCG_C5_PLLREFSEL0_SHIFT)
     81          #define MCG_C11_PLLREFSEL1_VAL ((MCG->C11 & MCG_C11_PLLREFSEL1_MASK) >> MCG_C11_PLLREFSEL1_SHIFT)
     82          #define MCG_C11_PRDIV1_VAL ((MCG->C11 & MCG_C11_PRDIV1_MASK) >> MCG_C11_PRDIV1_SHIFT)
     83          #define MCG_C12_VDIV1_VAL ((MCG->C12 & MCG_C12_VDIV1_MASK) >> MCG_C12_VDIV1_SHIFT)
     84          #define MCG_C5_PRDIV0_VAL ((MCG->C5 & MCG_C5_PRDIV0_MASK) >> MCG_C5_PRDIV0_SHIFT)
     85          #define MCG_C6_VDIV0_VAL ((MCG->C6 & MCG_C6_VDIV0_MASK) >> MCG_C6_VDIV0_SHIFT)
     86          
     87          #define OSC_MODE_MASK (MCG_C2_EREFS0_MASK | MCG_C2_HGO0_MASK | MCG_C2_RANGE0_MASK)
     88          
     89          #define SIM_CLKDIV1_OUTDIV1_VAL ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV1_MASK) >> SIM_CLKDIV1_OUTDIV1_SHIFT)
     90          #define SIM_CLKDIV1_OUTDIV2_VAL ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV2_MASK) >> SIM_CLKDIV1_OUTDIV2_SHIFT)
     91          #define SIM_CLKDIV1_OUTDIV4_VAL ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV4_MASK) >> SIM_CLKDIV1_OUTDIV4_SHIFT)
     92          #define SIM_SOPT1_OSC32KSEL_VAL ((SIM->SOPT1 & SIM_SOPT1_OSC32KSEL_MASK) >> SIM_SOPT1_OSC32KSEL_SHIFT)
     93          #define SIM_SOPT2_PLLFLLSEL_VAL ((SIM->SOPT2 & SIM_SOPT2_PLLFLLSEL_MASK) >> SIM_SOPT2_PLLFLLSEL_SHIFT)
     94          
     95          /* MCG_S_CLKST definition. */
     96          enum _mcg_clkout_stat
     97          {
     98              kMCG_ClkOutStatFll, /* FLL.            */
     99              kMCG_ClkOutStatInt, /* Internal clock. */
    100              kMCG_ClkOutStatExt, /* External clock. */
    101              kMCG_ClkOutStatPll  /* PLL.            */
    102          };
    103          
    104          /* MCG_S_PLLST definition. */
    105          enum _mcg_pllst
    106          {
    107              kMCG_PllstFll, /* FLL is used. */
    108              kMCG_PllstPll  /* PLL is used. */
    109          };
    110          
    111          /*******************************************************************************
    112           * Variables
    113           ******************************************************************************/
    114          
    115          /* Slow internal reference clock frequency. */

   \                                 In section .data, align 4
    116          static uint32_t s_slowIrcFreq = 32768U;
   \                     s_slowIrcFreq:
   \        0x0   0x0000'8000        DC32 32768
    117          /* Fast internal reference clock frequency. */

   \                                 In section .data, align 4
    118          static uint32_t s_fastIrcFreq = 4000000U;
   \                     s_fastIrcFreq:
   \        0x0   0x003D'0900        DC32 4000000
    119          
    120          /* External XTAL0 (OSC0) clock frequency. */

   \                                 In section .bss, align 4
    121          uint32_t g_xtal0Freq;
   \                     g_xtal0Freq:
   \        0x0                      DS8 4
    122          /* External XTAL32K clock frequency. */

   \                                 In section .bss, align 4
    123          uint32_t g_xtal32Freq;
   \                     g_xtal32Freq:
   \        0x0                      DS8 4
    124          
    125          /*******************************************************************************
    126           * Prototypes
    127           ******************************************************************************/
    128          
    129          /*!
    130           * @brief Get the MCG external reference clock frequency.
    131           *
    132           * Get the current MCG external reference clock frequency in Hz. It is
    133           * the frequency select by MCG_C7[OSCSEL]. This is an internal function.
    134           *
    135           * @return MCG external reference clock frequency in Hz.
    136           */
    137          static uint32_t CLOCK_GetMcgExtClkFreq(void);
    138          
    139          /*!
    140           * @brief Get the MCG FLL external reference clock frequency.
    141           *
    142           * Get the current MCG FLL external reference clock frequency in Hz. It is
    143           * the frequency after by MCG_C1[FRDIV]. This is an internal function.
    144           *
    145           * @return MCG FLL external reference clock frequency in Hz.
    146           */
    147          static uint32_t CLOCK_GetFllExtRefClkFreq(void);
    148          
    149          /*!
    150           * @brief Get the MCG FLL reference clock frequency.
    151           *
    152           * Get the current MCG FLL reference clock frequency in Hz. It is
    153           * the frequency select by MCG_C1[IREFS]. This is an internal function.
    154           *
    155           * @return MCG FLL reference clock frequency in Hz.
    156           */
    157          static uint32_t CLOCK_GetFllRefClkFreq(void);
    158          
    159          /*!
    160           * @brief Get the frequency of clock selected by MCG_C2[IRCS].
    161           *
    162           * This clock's two output:
    163           *  1. MCGOUTCLK when MCG_S[CLKST]=0.
    164           *  2. MCGIRCLK when MCG_C1[IRCLKEN]=1.
    165           *
    166           * @return The frequency in Hz.
    167           */
    168          static uint32_t CLOCK_GetInternalRefClkSelectFreq(void);
    169          
    170          /*!
    171           * @brief Get the MCG PLL/PLL0 reference clock frequency.
    172           *
    173           * Get the current MCG PLL/PLL0 reference clock frequency in Hz.
    174           * This is an internal function.
    175           *
    176           * @return MCG PLL/PLL0 reference clock frequency in Hz.
    177           */
    178          static uint32_t CLOCK_GetPll0RefFreq(void);
    179          
    180          /*!
    181           * @brief Calculate the RANGE value base on crystal frequency.
    182           *
    183           * To setup external crystal oscillator, must set the register bits RANGE
    184           * base on the crystal frequency. This function returns the RANGE base on the
    185           * input frequency. This is an internal function.
    186           *
    187           * @param freq Crystal frequency in Hz.
    188           * @return The RANGE value.
    189           */
    190          static uint8_t CLOCK_GetOscRangeFromFreq(uint32_t freq);
    191          
    192          /*******************************************************************************
    193           * Code
    194           ******************************************************************************/
    195          
    196          #ifndef MCG_USER_CONFIG_FLL_STABLE_DELAY_EN
    197          /*!
    198           * @brief Delay function to wait FLL stable.
    199           *
    200           * Delay function to wait FLL stable in FEI mode or FEE mode, should wait at least
    201           * 1ms. Every time changes FLL setting, should wait this time for FLL stable.
    202           */

   \                                 In section .text, align 2, keep-with-next
    203          void CLOCK_FllStableDelay(void)
    204          {
   \                     CLOCK_FllStableDelay: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
    205              /*
    206                 Should wait at least 1ms. Because in these modes, the core clock is 100MHz
    207                 at most, so this function could obtain the 1ms delay.
    208               */
    209              volatile uint32_t i = 30000U;
   \        0x2   0xF247 0x5030      MOVW     R0,#+30000
   \        0x6   0x9000             STR      R0,[SP, #+0]
   \        0x8   0xE000             B.N      ??CLOCK_FllStableDelay_0
    210              while (i--)
    211              {
    212                  __NOP();
   \                     ??CLOCK_FllStableDelay_1: (+1)
   \        0xA   0xBF00             Nop      
    213              }
   \                     ??CLOCK_FllStableDelay_0: (+1)
   \        0xC   0x9800             LDR      R0,[SP, #+0]
   \        0xE   0x1E41             SUBS     R1,R0,#+1
   \       0x10   0x9100             STR      R1,[SP, #+0]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD1F9             BNE.N    ??CLOCK_FllStableDelay_1
    214          }
   \       0x16   0xB001             ADD      SP,SP,#+4
   \       0x18   0x4770             BX       LR               ;; return
    215          #else  /* With MCG_USER_CONFIG_FLL_STABLE_DELAY_EN defined. */
    216          /* Once user defines the MCG_USER_CONFIG_FLL_STABLE_DELAY_EN to use their own delay function, he has to
    217           * create his own CLOCK_FllStableDelay() function in application code. Since the clock functions in this
    218           * file would call the CLOCK_FllStableDelay() regardness how it is defined.
    219           */
    220          extern void CLOCK_FllStableDelay(void);
    221          #endif /* MCG_USER_CONFIG_FLL_STABLE_DELAY_EN */
    222          

   \                                 In section .text, align 2, keep-with-next
    223          static uint32_t CLOCK_GetMcgExtClkFreq(void)
    224          {
   \                     CLOCK_GetMcgExtClkFreq: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    225              uint32_t freq;
    226          
    227              switch (MCG_C7_OSCSEL_VAL)
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable38  ;; 0x4006400c
   \        0x6   0x7800             LDRB     R0,[R0, #+0]
   \        0x8   0xF010 0x0001      ANDS     R0,R0,#0x1
   \        0xC   0xD002             BEQ.N    ??CLOCK_GetMcgExtClkFreq_0
   \        0xE   0x2801             CMP      R0,#+1
   \       0x10   0xD010             BEQ.N    ??CLOCK_GetMcgExtClkFreq_1
   \       0x12   0xE01F             B.N      ??CLOCK_GetMcgExtClkFreq_2
    228              {
    229                  case 0U:
    230                      /* Please call CLOCK_SetXtal0Freq base on board setting before using OSC0 clock. */
    231                      assert(g_xtal0Freq);
   \                     ??CLOCK_GetMcgExtClkFreq_0: (+1)
   \       0x14   0x.... 0x....      LDR.W    R4,??DataTable38_1
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD108             BNE.N    ??CLOCK_GetMcgExtClkFreq_3
   \       0x1E   0x22E7             MOVS     R2,#+231
   \       0x20   0x.... 0x....      LDR.W    R1,??DataTable38_2
   \       0x24   0x.... 0x....      LDR.W    R0,??DataTable38_3
   \       0x28   0x.... 0x....      BL       __aeabi_assert
   \       0x2C   0x.... 0x....      BL       __iar_EmptyStepPoint
    232                      freq = g_xtal0Freq;
   \                     ??CLOCK_GetMcgExtClkFreq_3: (+1)
   \       0x30   0x6820             LDR      R0,[R4, #+0]
    233                      break;
   \       0x32   0xBD10             POP      {R4,PC}
    234                  case 1U:
    235                      /* Please call CLOCK_SetXtal32Freq base on board setting before using XTAL32K/RTC_CLKIN clock. */
    236                      assert(g_xtal32Freq);
   \                     ??CLOCK_GetMcgExtClkFreq_1: (+1)
   \       0x34   0x.... 0x....      LDR.W    R4,??DataTable38_4
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD108             BNE.N    ??CLOCK_GetMcgExtClkFreq_4
   \       0x3E   0x22EC             MOVS     R2,#+236
   \       0x40   0x.... 0x....      LDR.W    R1,??DataTable38_2
   \       0x44   0x.... 0x....      LDR.W    R0,??DataTable45
   \       0x48   0x.... 0x....      BL       __aeabi_assert
   \       0x4C   0x.... 0x....      BL       __iar_EmptyStepPoint
    237                      freq = g_xtal32Freq;
   \                     ??CLOCK_GetMcgExtClkFreq_4: (+1)
   \       0x50   0x6820             LDR      R0,[R4, #+0]
    238                      break;
   \       0x52   0xBD10             POP      {R4,PC}
    239                  default:
    240                      freq = 0U;
   \                     ??CLOCK_GetMcgExtClkFreq_2: (+1)
   \       0x54   0x2000             MOVS     R0,#+0
    241                      break;
    242              }
    243          
    244              return freq;
   \       0x56   0xBD10             POP      {R4,PC}          ;; return
    245          }
    246          

   \                                 In section .text, align 2, keep-with-next
    247          static uint32_t CLOCK_GetFllExtRefClkFreq(void)
    248          {
   \                     CLOCK_GetFllExtRefClkFreq: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    249              /* FllExtRef = McgExtRef / FllExtRefDiv */
    250              uint8_t frdiv;
    251              uint8_t range;
    252              uint8_t oscsel;
    253          
    254              uint32_t freq = CLOCK_GetMcgExtClkFreq();
   \        0x2   0x.... 0x....      BL       CLOCK_GetMcgExtClkFreq
    255          
    256              if (!freq)
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD025             BEQ.N    ??CLOCK_GetFllExtRefClkFreq_0
    257              {
    258                  return freq;
    259              }
    260          
    261              frdiv = MCG_C1_FRDIV_VAL;
   \        0xA   0x.... 0x....      LDR.W    R1,??DataTable38_5  ;; 0x40064000
   \        0xE   0x7809             LDRB     R1,[R1, #+0]
   \       0x10   0xF3C1 0x01C2      UBFX     R1,R1,#+3,#+3
    262              freq >>= frdiv;
   \       0x14   0x40C8             LSRS     R0,R0,R1
    263          
    264              range = MCG_C2_RANGE_VAL;
   \       0x16   0x.... 0x....      LDR.W    R2,??DataTable38_6  ;; 0x40064001
   \       0x1A   0x7812             LDRB     R2,[R2, #+0]
   \       0x1C   0xF3C2 0x1301      UBFX     R3,R2,#+4,#+2
    265              oscsel = MCG_C7_OSCSEL_VAL;
   \       0x20   0x.... 0x....      LDR.W    R2,??DataTable38  ;; 0x4006400c
   \       0x24   0x7812             LDRB     R2,[R2, #+0]
   \       0x26   0xF002 0x0201      AND      R2,R2,#0x1
    266          
    267              /*
    268                 When should use divider 32, 64, 128, 256, 512, 1024, 1280, 1536.
    269                 1. MCG_C7[OSCSEL] selects IRC48M.
    270                 2. MCG_C7[OSCSEL] selects OSC0 and MCG_C2[RANGE] is not 0.
    271              */
    272              if (((0U != range) && (kMCG_OscselOsc == oscsel)))
   \       0x2A   0x2B00             CMP      R3,#+0
   \       0x2C   0xD013             BEQ.N    ??CLOCK_GetFllExtRefClkFreq_0
   \       0x2E   0x2A00             CMP      R2,#+0
   \       0x30   0xD111             BNE.N    ??CLOCK_GetFllExtRefClkFreq_0
    273              {
    274                  switch (frdiv)
   \       0x32   0x2905             CMP      R1,#+5
   \       0x34   0xD904             BLS.N    ??CLOCK_GetFllExtRefClkFreq_1
   \       0x36   0x1F89             SUBS     R1,R1,#+6
   \       0x38   0xD004             BEQ.N    ??CLOCK_GetFllExtRefClkFreq_2
   \       0x3A   0x1E49             SUBS     R1,R1,#+1
   \       0x3C   0xD006             BEQ.N    ??CLOCK_GetFllExtRefClkFreq_3
   \       0x3E   0xE009             B.N      ??CLOCK_GetFllExtRefClkFreq_4
    275                  {
    276                      case 0:
    277                      case 1:
    278                      case 2:
    279                      case 3:
    280                      case 4:
    281                      case 5:
    282                          freq >>= 5u;
   \                     ??CLOCK_GetFllExtRefClkFreq_1: (+1)
   \       0x40   0x0940             LSRS     R0,R0,#+5
    283                          break;
   \       0x42   0xBD02             POP      {R1,PC}
    284                      case 6:
    285                          /* 64*20=1280 */
    286                          freq /= 20u;
   \                     ??CLOCK_GetFllExtRefClkFreq_2: (+1)
   \       0x44   0x2114             MOVS     R1,#+20
   \       0x46   0xFBB0 0xF0F1      UDIV     R0,R0,R1
    287                          break;
   \       0x4A   0xBD02             POP      {R1,PC}
    288                      case 7:
    289                          /* 128*12=1536 */
    290                          freq /= 12u;
   \                     ??CLOCK_GetFllExtRefClkFreq_3: (+1)
   \       0x4C   0x210C             MOVS     R1,#+12
   \       0x4E   0xFBB0 0xF0F1      UDIV     R0,R0,R1
    291                          break;
   \       0x52   0xBD02             POP      {R1,PC}
    292                      default:
    293                          freq = 0u;
   \                     ??CLOCK_GetFllExtRefClkFreq_4: (+1)
   \       0x54   0x2000             MOVS     R0,#+0
    294                          break;
    295                  }
    296              }
    297          
    298              return freq;
   \                     ??CLOCK_GetFllExtRefClkFreq_0: (+1)
   \       0x56   0xBD02             POP      {R1,PC}          ;; return
    299          }
    300          

   \                                 In section .text, align 2, keep-with-next
    301          static uint32_t CLOCK_GetInternalRefClkSelectFreq(void)
    302          {
    303              if (kMCG_IrcSlow == MCG_S_IRCST_VAL)
   \                     CLOCK_GetInternalRefClkSelectFreq: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable40  ;; 0x40064006
   \        0x4   0x7800             LDRB     R0,[R0, #+0]
   \        0x6   0x07C0             LSLS     R0,R0,#+31
   \        0x8   0xD403             BMI.N    ??CLOCK_GetInternalRefClkSelectFreq_0
    304              {
    305                  /* Slow internal reference clock selected*/
    306                  return s_slowIrcFreq;
   \        0xA   0x.... 0x....      LDR.W    R0,??DataTable41
   \        0xE   0x6800             LDR      R0,[R0, #+0]
   \       0x10   0x4770             BX       LR
    307              }
    308              else
    309              {
    310                  /* Fast internal reference clock selected*/
    311                  return s_fastIrcFreq >> MCG_SC_FCRDIV_VAL;
   \                     ??CLOCK_GetInternalRefClkSelectFreq_0: (+1)
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable41_1
   \       0x16   0x6800             LDR      R0,[R0, #+0]
   \       0x18   0x.... 0x....      LDR.W    R1,??DataTable47  ;; 0x40064008
   \       0x1C   0x7809             LDRB     R1,[R1, #+0]
   \       0x1E   0xF3C1 0x0142      UBFX     R1,R1,#+1,#+3
   \       0x22   0x40C8             LSRS     R0,R0,R1
   \       0x24   0x4770             BX       LR               ;; return
    312              }
    313          }
    314          

   \                                 In section .text, align 2, keep-with-next
    315          static uint32_t CLOCK_GetFllRefClkFreq(void)
    316          {
    317              /* If use external reference clock. */
    318              if (kMCG_FllSrcExternal == MCG_S_IREFST_VAL)
   \                     CLOCK_GetFllRefClkFreq: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable40  ;; 0x40064006
   \        0x4   0x7800             LDRB     R0,[R0, #+0]
   \        0x6   0xF3C0 0x1000      UBFX     R0,R0,#+4,#+1
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD100             BNE.N    ??CLOCK_GetFllRefClkFreq_0
    319              {
    320                  return CLOCK_GetFllExtRefClkFreq();
   \        0xE   0x....             B.N      CLOCK_GetFllExtRefClkFreq
    321              }
    322              /* If use internal reference clock. */
    323              else
    324              {
    325                  return s_slowIrcFreq;
   \                     ??CLOCK_GetFllRefClkFreq_0: (+1)
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable41
   \       0x14   0x6800             LDR      R0,[R0, #+0]
   \       0x16   0x4770             BX       LR               ;; return
    326              }
    327          }
    328          

   \                                 In section .text, align 2, keep-with-next
    329          static uint32_t CLOCK_GetPll0RefFreq(void)
    330          {
    331              /* MCG external reference clock. */
    332              return CLOCK_GetMcgExtClkFreq();
   \                     CLOCK_GetPll0RefFreq: (+1)
   \        0x0   0x....             B.N      CLOCK_GetMcgExtClkFreq
    333          }
    334          

   \                                 In section .text, align 2, keep-with-next
    335          static uint8_t CLOCK_GetOscRangeFromFreq(uint32_t freq)
    336          {
    337              uint8_t range;
    338          
    339              if (freq <= 39063U)
   \                     CLOCK_GetOscRangeFromFreq: (+1)
   \        0x0   0xF649 0x0198      MOVW     R1,#+39064
   \        0x4   0x4288             CMP      R0,R1
   \        0x6   0xD201             BCS.N    ??CLOCK_GetOscRangeFromFreq_0
    340              {
    341                  range = 0U;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x4770             BX       LR
    342              }
    343              else if (freq <= 8000000U)
   \                     ??CLOCK_GetOscRangeFromFreq_0: (+1)
   \        0xC   0x.... 0x....      LDR.W    R1,??DataTable48  ;; 0x7a1201
   \       0x10   0x4288             CMP      R0,R1
   \       0x12   0xD201             BCS.N    ??CLOCK_GetOscRangeFromFreq_1
    344              {
    345                  range = 1U;
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0x4770             BX       LR
    346              }
    347              else
    348              {
    349                  range = 2U;
   \                     ??CLOCK_GetOscRangeFromFreq_1: (+1)
   \       0x18   0x2002             MOVS     R0,#+2
    350              }
    351          
    352              return range;
   \       0x1A   0x4770             BX       LR               ;; return
    353          }
    354          

   \                                 In section .text, align 2, keep-with-next
    355          uint32_t CLOCK_GetOsc0ErClkFreq(void)
    356          {
   \                     CLOCK_GetOsc0ErClkFreq: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    357              if (OSC0->CR & OSC_CR_ERCLKEN_MASK)
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable41_2  ;; 0x40065000
   \        0x6   0x7800             LDRB     R0,[R0, #+0]
   \        0x8   0x0600             LSLS     R0,R0,#+24
   \        0xA   0xD510             BPL.N    ??CLOCK_GetOsc0ErClkFreq_0
    358              {
    359                  /* Please call CLOCK_SetXtal0Freq base on board setting before using OSC0 clock. */
    360                  assert(g_xtal0Freq);
   \        0xC   0x.... 0x....      LDR.W    R4,??DataTable38_1
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD109             BNE.N    ??CLOCK_GetOsc0ErClkFreq_1
   \       0x16   0xF44F 0x72B4      MOV      R2,#+360
   \       0x1A   0x.... 0x....      LDR.W    R1,??DataTable38_2
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable38_3
   \       0x22   0x.... 0x....      BL       __aeabi_assert
   \       0x26   0x.... 0x....      BL       __iar_EmptyStepPoint
    361                  return g_xtal0Freq;
   \                     ??CLOCK_GetOsc0ErClkFreq_1: (+1)
   \       0x2A   0x6820             LDR      R0,[R4, #+0]
   \       0x2C   0xBD10             POP      {R4,PC}
    362              }
    363              else
    364              {
    365                  return 0U;
   \                     ??CLOCK_GetOsc0ErClkFreq_0: (+1)
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xBD10             POP      {R4,PC}          ;; return
    366              }
    367          }
    368          

   \                                 In section .text, align 2, keep-with-next
    369          uint32_t CLOCK_GetEr32kClkFreq(void)
    370          {
   \                     CLOCK_GetEr32kClkFreq: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    371              uint32_t freq;
    372          
    373              switch (SIM_SOPT1_OSC32KSEL_VAL)
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable42  ;; 0x40047000
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0x0C80             LSRS     R0,R0,#+18
   \        0xA   0xF010 0x0003      ANDS     R0,R0,#0x3
   \        0xE   0xD004             BEQ.N    ??CLOCK_GetEr32kClkFreq_0
   \       0x10   0x2802             CMP      R0,#+2
   \       0x12   0xD00C             BEQ.N    ??CLOCK_GetEr32kClkFreq_1
   \       0x14   0x2803             CMP      R0,#+3
   \       0x16   0xD01B             BEQ.N    ??CLOCK_GetEr32kClkFreq_2
   \       0x18   0xE01D             B.N      ??CLOCK_GetEr32kClkFreq_3
    374              {
    375                  case 0U: /* OSC 32k clock  */
    376                      freq = (CLOCK_GetOsc0ErClkFreq() == 32768U) ? 32768U : 0U;
   \                     ??CLOCK_GetEr32kClkFreq_0: (+1)
   \       0x1A   0x.... 0x....      BL       CLOCK_GetOsc0ErClkFreq
   \       0x1E   0xF5B0 0x4F00      CMP      R0,#+32768
   \       0x22   0xD102             BNE.N    ??CLOCK_GetEr32kClkFreq_4
   \       0x24   0xF44F 0x4000      MOV      R0,#+32768
   \       0x28   0xBD10             POP      {R4,PC}
   \                     ??CLOCK_GetEr32kClkFreq_4: (+1)
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0xBD10             POP      {R4,PC}
    377                      break;
    378                  case 2U: /* RTC 32k clock  */
    379                      /* Please call CLOCK_SetXtal32Freq base on board setting before using XTAL32K/RTC_CLKIN clock. */
    380                      assert(g_xtal32Freq);
   \                     ??CLOCK_GetEr32kClkFreq_1: (+1)
   \       0x2E   0x.... 0x....      LDR.W    R4,??DataTable38_4
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD109             BNE.N    ??CLOCK_GetEr32kClkFreq_5
   \       0x38   0xF44F 0x72BE      MOV      R2,#+380
   \       0x3C   0x.... 0x....      LDR.W    R1,??DataTable38_2
   \       0x40   0x.... 0x....      LDR.W    R0,??DataTable45
   \       0x44   0x.... 0x....      BL       __aeabi_assert
   \       0x48   0x.... 0x....      BL       __iar_EmptyStepPoint
    381                      freq = g_xtal32Freq;
   \                     ??CLOCK_GetEr32kClkFreq_5: (+1)
   \       0x4C   0x6820             LDR      R0,[R4, #+0]
    382                      break;
   \       0x4E   0xBD10             POP      {R4,PC}
    383                  case 3U: /* LPO clock      */
    384                      freq = LPO_CLK_FREQ;
   \                     ??CLOCK_GetEr32kClkFreq_2: (+1)
   \       0x50   0xF44F 0x707A      MOV      R0,#+1000
    385                      break;
   \       0x54   0xBD10             POP      {R4,PC}
    386                  default:
    387                      freq = 0U;
   \                     ??CLOCK_GetEr32kClkFreq_3: (+1)
   \       0x56   0x2000             MOVS     R0,#+0
    388                      break;
    389              }
    390              return freq;
   \       0x58   0xBD10             POP      {R4,PC}          ;; return
    391          }
    392          

   \                                 In section .text, align 2, keep-with-next
    393          uint32_t CLOCK_GetPllFllSelClkFreq(void)
    394          {
    395              uint32_t freq;
    396          
    397              switch (SIM_SOPT2_PLLFLLSEL_VAL)
   \                     CLOCK_GetPllFllSelClkFreq: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable43  ;; 0x40048004
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x0C00             LSRS     R0,R0,#+16
   \        0x8   0xF010 0x0001      ANDS     R0,R0,#0x1
   \        0xC   0xD002             BEQ.N    ??CLOCK_GetPllFllSelClkFreq_0
   \        0xE   0x2801             CMP      R0,#+1
   \       0x10   0xD001             BEQ.N    ??CLOCK_GetPllFllSelClkFreq_1
   \       0x12   0xE001             B.N      ??CLOCK_GetPllFllSelClkFreq_2
    398              {
    399                  case 0U: /* FLL. */
    400                      freq = CLOCK_GetFllFreq();
   \                     ??CLOCK_GetPllFllSelClkFreq_0: (+1)
   \       0x14   0x....             B.N      CLOCK_GetFllFreq
    401                      break;
    402                  case 1U: /* PLL. */
    403                      freq = CLOCK_GetPll0Freq();
   \                     ??CLOCK_GetPllFllSelClkFreq_1: (+1)
   \       0x16   0x....             B.N      CLOCK_GetPll0Freq
    404                      break;
    405                  default:
    406                      freq = 0U;
   \                     ??CLOCK_GetPllFllSelClkFreq_2: (+1)
   \       0x18   0x2000             MOVS     R0,#+0
    407                      break;
    408              }
    409          
    410              return freq;
   \       0x1A   0x4770             BX       LR               ;; return
    411          }
    412          

   \                                 In section .text, align 2, keep-with-next
    413          uint32_t CLOCK_GetPlatClkFreq(void)
    414          {
   \                     CLOCK_GetPlatClkFreq: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    415              return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1);
   \        0x2   0x.... 0x....      BL       CLOCK_GetOutClkFreq
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable48_1  ;; 0x40048044
   \        0xA   0x6809             LDR      R1,[R1, #+0]
   \        0xC   0x0F09             LSRS     R1,R1,#+28
   \        0xE   0x1C49             ADDS     R1,R1,#+1
   \       0x10   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0x14   0xBD02             POP      {R1,PC}          ;; return
    416          }
    417          

   \                                 In section .text, align 2, keep-with-next
    418          uint32_t CLOCK_GetFlashClkFreq(void)
    419          {
   \                     CLOCK_GetFlashClkFreq: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    420              return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV4_VAL + 1);
   \        0x2   0x.... 0x....      BL       CLOCK_GetOutClkFreq
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable48_1  ;; 0x40048044
   \        0xA   0x6809             LDR      R1,[R1, #+0]
   \        0xC   0xF3C1 0x4103      UBFX     R1,R1,#+16,#+4
   \       0x10   0x1C49             ADDS     R1,R1,#+1
   \       0x12   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0x16   0xBD02             POP      {R1,PC}          ;; return
    421          }
    422          

   \                                 In section .text, align 2, keep-with-next
    423          uint32_t CLOCK_GetBusClkFreq(void)
    424          {
   \                     CLOCK_GetBusClkFreq: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    425              return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV2_VAL + 1);
   \        0x2   0x.... 0x....      BL       CLOCK_GetOutClkFreq
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable48_1  ;; 0x40048044
   \        0xA   0x6809             LDR      R1,[R1, #+0]
   \        0xC   0xF3C1 0x6103      UBFX     R1,R1,#+24,#+4
   \       0x10   0x1C49             ADDS     R1,R1,#+1
   \       0x12   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0x16   0xBD02             POP      {R1,PC}          ;; return
    426          }
    427          

   \                                 In section .text, align 2, keep-with-next
    428          uint32_t CLOCK_GetCoreSysClkFreq(void)
    429          {
   \                     CLOCK_GetCoreSysClkFreq: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    430              return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1);
   \        0x2   0x.... 0x....      BL       CLOCK_GetOutClkFreq
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable48_1  ;; 0x40048044
   \        0xA   0x6809             LDR      R1,[R1, #+0]
   \        0xC   0x0F09             LSRS     R1,R1,#+28
   \        0xE   0x1C49             ADDS     R1,R1,#+1
   \       0x10   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0x14   0xBD02             POP      {R1,PC}          ;; return
    431          }
    432          

   \                                 In section .text, align 4, keep-with-next
    433          uint32_t CLOCK_GetFreq(clock_name_t clockName)
    434          {
   \                     CLOCK_GetFreq: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    435              uint32_t freq;
    436          
    437              switch (clockName)
   \        0x2   0x280E             CMP      R0,#+14
   \        0x4   0xD841             BHI.N    ??CLOCK_GetFreq_1
   \        0x6   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??CLOCK_GetFreq_0:
   \        0xA   0x08 0x08          DC8      0x8,0x8,0x12,0x1D
   \              0x12 0x1D    
   \        0xE   0x28 0x2B          DC8      0x28,0x2B,0x3D,0x2E
   \              0x3D 0x2E    
   \       0x12   0x31 0x34          DC8      0x31,0x34,0x37,0x40
   \              0x37 0x40    
   \       0x16   0x40 0x40          DC8      0x40,0x40,0x3A,0x0
   \              0x3A 0x00    
    438              {
    439                  case kCLOCK_CoreSysClk:
    440                  case kCLOCK_PlatClk:
    441                      freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1);
   \                     ??CLOCK_GetFreq_2: (+1)
   \       0x1A   0x.... 0x....      BL       CLOCK_GetOutClkFreq
   \       0x1E   0x.... 0x....      LDR.W    R1,??DataTable48_1  ;; 0x40048044
   \       0x22   0x6809             LDR      R1,[R1, #+0]
   \       0x24   0x0F09             LSRS     R1,R1,#+28
   \       0x26   0x1C49             ADDS     R1,R1,#+1
   \       0x28   0xFBB0 0xF0F1      UDIV     R0,R0,R1
    442                      break;
   \       0x2C   0xBD02             POP      {R1,PC}
    443                  case kCLOCK_BusClk:
    444                      freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV2_VAL + 1);
   \                     ??CLOCK_GetFreq_3: (+1)
   \       0x2E   0x.... 0x....      BL       CLOCK_GetOutClkFreq
   \       0x32   0x.... 0x....      LDR.W    R1,??DataTable48_1  ;; 0x40048044
   \       0x36   0x6809             LDR      R1,[R1, #+0]
   \       0x38   0xF3C1 0x6103      UBFX     R1,R1,#+24,#+4
   \       0x3C   0x1C49             ADDS     R1,R1,#+1
   \       0x3E   0xFBB0 0xF0F1      UDIV     R0,R0,R1
    445                      break;
   \       0x42   0xBD02             POP      {R1,PC}
    446                  case kCLOCK_FlashClk:
    447                      freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV4_VAL + 1);
   \                     ??CLOCK_GetFreq_4: (+1)
   \       0x44   0x.... 0x....      BL       CLOCK_GetOutClkFreq
   \       0x48   0x.... 0x....      LDR.W    R1,??DataTable48_1  ;; 0x40048044
   \       0x4C   0x6809             LDR      R1,[R1, #+0]
   \       0x4E   0xF3C1 0x4103      UBFX     R1,R1,#+16,#+4
   \       0x52   0x1C49             ADDS     R1,R1,#+1
   \       0x54   0xFBB0 0xF0F1      UDIV     R0,R0,R1
    448                      break;
   \       0x58   0xBD02             POP      {R1,PC}
    449                  case kCLOCK_PllFllSelClk:
    450                      freq = CLOCK_GetPllFllSelClkFreq();
   \                     ??CLOCK_GetFreq_5: (+1)
   \       0x5A   0xE8BD 0x4001      POP      {R0,LR}
   \       0x5E   0x....             B.N      CLOCK_GetPllFllSelClkFreq
    451                      break;
    452                  case kCLOCK_Er32kClk:
    453                      freq = CLOCK_GetEr32kClkFreq();
   \                     ??CLOCK_GetFreq_6: (+1)
   \       0x60   0xE8BD 0x4001      POP      {R0,LR}
   \       0x64   0x....             B.N      CLOCK_GetEr32kClkFreq
    454                      break;
    455                  case kCLOCK_McgFixedFreqClk:
    456                      freq = CLOCK_GetFixedFreqClkFreq();
   \                     ??CLOCK_GetFreq_7: (+1)
   \       0x66   0xE8BD 0x4001      POP      {R0,LR}
   \       0x6A   0x....             B.N      CLOCK_GetFixedFreqClkFreq
    457                      break;
    458                  case kCLOCK_McgInternalRefClk:
    459                      freq = CLOCK_GetInternalRefClkFreq();
   \                     ??CLOCK_GetFreq_8: (+1)
   \       0x6C   0xE8BD 0x4001      POP      {R0,LR}
   \       0x70   0x....             B.N      CLOCK_GetInternalRefClkFreq
    460                      break;
    461                  case kCLOCK_McgFllClk:
    462                      freq = CLOCK_GetFllFreq();
   \                     ??CLOCK_GetFreq_9: (+1)
   \       0x72   0xE8BD 0x4001      POP      {R0,LR}
   \       0x76   0x....             B.N      CLOCK_GetFllFreq
    463                      break;
    464                  case kCLOCK_McgPll0Clk:
    465                      freq = CLOCK_GetPll0Freq();
   \                     ??CLOCK_GetFreq_10: (+1)
   \       0x78   0xE8BD 0x4001      POP      {R0,LR}
   \       0x7C   0x....             B.N      CLOCK_GetPll0Freq
    466                      break;
    467                  case kCLOCK_LpoClk:
    468                      freq = LPO_CLK_FREQ;
   \                     ??CLOCK_GetFreq_11: (+1)
   \       0x7E   0xF44F 0x707A      MOV      R0,#+1000
    469                      break;
   \       0x82   0xBD02             POP      {R1,PC}
    470                  case kCLOCK_Osc0ErClk:
    471                      freq = CLOCK_GetOsc0ErClkFreq();
   \                     ??CLOCK_GetFreq_12: (+1)
   \       0x84   0xE8BD 0x4001      POP      {R0,LR}
   \       0x88   0x....             B.N      CLOCK_GetOsc0ErClkFreq
    472                      break;
    473                  default:
    474                      freq = 0U;
   \                     ??CLOCK_GetFreq_1: (+1)
   \       0x8A   0x2000             MOVS     R0,#+0
    475                      break;
    476              }
    477          
    478              return freq;
   \       0x8C   0xBD02             POP      {R1,PC}          ;; return
    479          }
    480          

   \                                 In section .text, align 2, keep-with-next
    481          void CLOCK_SetSimConfig(sim_clock_config_t const *config)
    482          {
   \                     CLOCK_SetSimConfig: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    483              SIM->CLKDIV1 = config->clkdiv1;
   \        0x4   0x6860             LDR      R0,[R4, #+4]
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable48_1  ;; 0x40048044
   \        0xA   0x6008             STR      R0,[R1, #+0]
    484              CLOCK_SetPllFllSelClock(config->pllFllSel);
   \        0xC   0x7820             LDRB     R0,[R4, #+0]
   \        0xE   0x.... 0x....      BL       CLOCK_SetPllFllSelClock
    485              CLOCK_SetEr32kClock(config->er32kSrc);
   \       0x12   0x7860             LDRB     R0,[R4, #+1]
   \       0x14   0xE8BD 0x4010      POP      {R4,LR}
   \       0x18   0x....             B.N      CLOCK_SetEr32kClock
    486          }
    487          

   \                                 In section .text, align 2, keep-with-next
    488          bool CLOCK_EnableUsbfs0Clock(clock_usb_src_t src, uint32_t freq)
    489          {
   \                     CLOCK_EnableUsbfs0Clock: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460F             MOV      R7,R1
    490              bool ret = true;
   \        0x6   0x2501             MOVS     R5,#+1
    491          
    492              CLOCK_DisableClock(kCLOCK_Usbfs0);
   \        0x8   0x.... 0x....      LDR.W    R6,??DataTable47_1  ;; 0x10340012
   \        0xC   0x4630             MOV      R0,R6
   \        0xE   0x.... 0x....      BL       CLOCK_DisableClock
    493          
    494              if (kCLOCK_UsbSrcExt == src)
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD106             BNE.N    ??CLOCK_EnableUsbfs0Clock_0
    495              {
    496                  SIM->SOPT2 &= ~SIM_SOPT2_USBSRC_MASK;
   \       0x16   0x.... 0x....      LDR.W    R0,??DataTable43  ;; 0x40048004
   \       0x1A   0x6801             LDR      R1,[R0, #+0]
   \       0x1C   0xF421 0x2180      BIC      R1,R1,#0x40000
   \       0x20   0x6001             STR      R1,[R0, #+0]
   \       0x22   0xE02B             B.N      ??CLOCK_EnableUsbfs0Clock_1
    497              }
    498              else
    499              {
    500                  switch (freq)
   \                     ??CLOCK_EnableUsbfs0Clock_0: (+1)
   \       0x24   0x.... 0x....      LDR.W    R0,??DataTable47_2  ;; 0x2dc6c00
   \       0x28   0x4287             CMP      R7,R0
   \       0x2A   0xD01A             BEQ.N    ??CLOCK_EnableUsbfs0Clock_2
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable47_3  ;; 0x44aa200
   \       0x30   0x4287             CMP      R7,R0
   \       0x32   0xD011             BEQ.N    ??CLOCK_EnableUsbfs0Clock_3
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable48_2  ;; 0x5b8d800
   \       0x38   0x4287             CMP      R7,R0
   \       0x3A   0xD008             BEQ.N    ??CLOCK_EnableUsbfs0Clock_4
   \       0x3C   0x.... 0x....      LDR.W    R0,??DataTable48_3  ;; 0x7270e00
   \       0x40   0x4287             CMP      R7,R0
   \       0x42   0xD113             BNE.N    ??CLOCK_EnableUsbfs0Clock_5
    501                  {
    502                      case 120000000U:
    503                          SIM->CLKDIV2 = SIM_CLKDIV2_USBDIV(4) | SIM_CLKDIV2_USBFRAC(1);
   \       0x44   0x2009             MOVS     R0,#+9
   \       0x46   0x.... 0x....      LDR.W    R1,??DataTable48_4  ;; 0x40048048
   \       0x4A   0x6008             STR      R0,[R1, #+0]
    504                          break;
   \       0x4C   0xE00F             B.N      ??CLOCK_EnableUsbfs0Clock_6
    505                      case 96000000U:
    506                          SIM->CLKDIV2 = SIM_CLKDIV2_USBDIV(1) | SIM_CLKDIV2_USBFRAC(0);
   \                     ??CLOCK_EnableUsbfs0Clock_4: (+1)
   \       0x4E   0x2002             MOVS     R0,#+2
   \       0x50   0x.... 0x....      LDR.W    R1,??DataTable48_4  ;; 0x40048048
   \       0x54   0x6008             STR      R0,[R1, #+0]
    507                          break;
   \       0x56   0xE00A             B.N      ??CLOCK_EnableUsbfs0Clock_6
    508                      case 72000000U:
    509                          SIM->CLKDIV2 = SIM_CLKDIV2_USBDIV(2) | SIM_CLKDIV2_USBFRAC(1);
   \                     ??CLOCK_EnableUsbfs0Clock_3: (+1)
   \       0x58   0x2005             MOVS     R0,#+5
   \       0x5A   0x.... 0x....      LDR.W    R1,??DataTable48_4  ;; 0x40048048
   \       0x5E   0x6008             STR      R0,[R1, #+0]
    510                          break;
   \       0x60   0xE005             B.N      ??CLOCK_EnableUsbfs0Clock_6
    511                      case 48000000U:
    512                          SIM->CLKDIV2 = SIM_CLKDIV2_USBDIV(0) | SIM_CLKDIV2_USBFRAC(0);
   \                     ??CLOCK_EnableUsbfs0Clock_2: (+1)
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0x.... 0x....      LDR.W    R1,??DataTable48_4  ;; 0x40048048
   \       0x68   0x6008             STR      R0,[R1, #+0]
    513                          break;
   \       0x6A   0xE000             B.N      ??CLOCK_EnableUsbfs0Clock_6
    514                      default:
    515                          ret = false;
   \                     ??CLOCK_EnableUsbfs0Clock_5: (+1)
   \       0x6C   0x2500             MOVS     R5,#+0
    516                          break;
    517                  }
    518          
    519                  SIM->SOPT2 = ((SIM->SOPT2 & ~(SIM_SOPT2_PLLFLLSEL_MASK | SIM_SOPT2_USBSRC_MASK)) | (uint32_t)src);
   \                     ??CLOCK_EnableUsbfs0Clock_6: (+1)
   \       0x6E   0x.... 0x....      LDR.W    R0,??DataTable43  ;; 0x40048004
   \       0x72   0x6801             LDR      R1,[R0, #+0]
   \       0x74   0xF421 0x21A0      BIC      R1,R1,#0x50000
   \       0x78   0x430C             ORRS     R4,R4,R1
   \       0x7A   0x6004             STR      R4,[R0, #+0]
    520              }
    521          
    522              CLOCK_EnableClock(kCLOCK_Usbfs0);
   \                     ??CLOCK_EnableUsbfs0Clock_1: (+1)
   \       0x7C   0x4630             MOV      R0,R6
   \       0x7E   0x.... 0x....      BL       CLOCK_EnableClock
    523          
    524              return ret;
   \       0x82   0x4628             MOV      R0,R5
   \       0x84   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    525          }
    526          

   \                                 In section .text, align 4, keep-with-next
    527          uint32_t CLOCK_GetOutClkFreq(void)
    528          {
    529              uint32_t mcgoutclk;
    530              uint32_t clkst = MCG_S_CLKST_VAL;
   \                     CLOCK_GetOutClkFreq: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable49  ;; 0x40064006
   \        0x4   0x7800             LDRB     R0,[R0, #+0]
   \        0x6   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
    531          
    532              switch (clkst)
   \        0xA   0x2803             CMP      R0,#+3
   \        0xC   0xD807             BHI.N    ??CLOCK_GetOutClkFreq_1
   \        0xE   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??CLOCK_GetOutClkFreq_0:
   \       0x12   0x03 0x04          DC8      0x3,0x4,0x5,0x2
   \              0x05 0x02    
    533              {
    534                  case kMCG_ClkOutStatPll:
    535                      mcgoutclk = CLOCK_GetPll0Freq();
   \                     ??CLOCK_GetOutClkFreq_2: (+1)
   \       0x16   0x....             B.N      CLOCK_GetPll0Freq
    536                      break;
    537                  case kMCG_ClkOutStatFll:
    538                      mcgoutclk = CLOCK_GetFllFreq();
   \                     ??CLOCK_GetOutClkFreq_3: (+1)
   \       0x18   0x....             B.N      CLOCK_GetFllFreq
    539                      break;
    540                  case kMCG_ClkOutStatInt:
    541                      mcgoutclk = CLOCK_GetInternalRefClkSelectFreq();
   \                     ??CLOCK_GetOutClkFreq_4: (+1)
   \       0x1A   0x....             B.N      CLOCK_GetInternalRefClkSelectFreq
    542                      break;
    543                  case kMCG_ClkOutStatExt:
    544                      mcgoutclk = CLOCK_GetMcgExtClkFreq();
   \                     ??CLOCK_GetOutClkFreq_5: (+1)
   \       0x1C   0x....             B.N      CLOCK_GetMcgExtClkFreq
    545                      break;
    546                  default:
    547                      mcgoutclk = 0U;
   \                     ??CLOCK_GetOutClkFreq_1: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
    548                      break;
    549              }
    550              return mcgoutclk;
   \       0x20   0x4770             BX       LR               ;; return
    551          }
    552          

   \                                 In section .text, align 2, keep-with-next
    553          uint32_t CLOCK_GetFllFreq(void)
    554          {
   \                     CLOCK_GetFllFreq: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    555              static const uint16_t fllFactorTable[4][2] = {{640, 732}, {1280, 1464}, {1920, 2197}, {2560, 2929}};
    556          
    557              uint8_t drs, dmx32;
    558              uint32_t freq;
    559          
    560              /* If FLL is not enabled currently, then return 0U. */
    561              if ((MCG->C2 & MCG_C2_LP_MASK) || (MCG->S & MCG_S_PLLST_MASK))
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable38_6  ;; 0x40064001
   \        0x6   0x7800             LDRB     R0,[R0, #+0]
   \        0x8   0x0780             LSLS     R0,R0,#+30
   \        0xA   0xD404             BMI.N    ??CLOCK_GetFllFreq_0
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable40  ;; 0x40064006
   \       0x10   0x7800             LDRB     R0,[R0, #+0]
   \       0x12   0x0680             LSLS     R0,R0,#+26
   \       0x14   0xD501             BPL.N    ??CLOCK_GetFllFreq_1
    562              {
    563                  return 0U;
   \                     ??CLOCK_GetFllFreq_0: (+1)
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xBD02             POP      {R1,PC}
    564              }
    565          
    566              /* Get FLL reference clock frequency. */
    567              freq = CLOCK_GetFllRefClkFreq();
   \                     ??CLOCK_GetFllFreq_1: (+1)
   \       0x1A   0x.... 0x....      BL       CLOCK_GetFllRefClkFreq
    568              if (!freq)
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD101             BNE.N    ??CLOCK_GetFllFreq_2
    569              {
    570                  return freq;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0xBD02             POP      {R1,PC}
    571              }
    572          
    573              drs = MCG_C4_DRST_DRS_VAL;
   \                     ??CLOCK_GetFllFreq_2: (+1)
   \       0x26   0x.... 0x....      LDR.W    R1,??DataTable48_5  ;; 0x40064003
   \       0x2A   0x780A             LDRB     R2,[R1, #+0]
   \       0x2C   0xF3C2 0x1241      UBFX     R2,R2,#+5,#+2
    574              dmx32 = MCG_C4_DMX32_VAL;
   \       0x30   0x7809             LDRB     R1,[R1, #+0]
   \       0x32   0x09C9             LSRS     R1,R1,#+7
    575          
    576              return freq * fllFactorTable[drs][dmx32];
   \       0x34   0x.... 0x....      LDR.W    R3,??DataTable49_1
   \       0x38   0xEB03 0x0282      ADD      R2,R3,R2, LSL #+2
   \       0x3C   0xF832 0x1011      LDRH     R1,[R2, R1, LSL #+1]
   \       0x40   0x4348             MULS     R0,R1,R0
   \       0x42   0xBD02             POP      {R1,PC}          ;; return
    577          }

   \                                 In section .rodata, align 4
   \                     `CLOCK_GetFllFreq::fllFactorTable`:
   \        0x0   0x0280 0x02DC      DC16 640, 732, 1280, 1464, 1920, 2197, 2560, 2929
   \               0x0500 0x05B
   \              8 0x0780 0x08
   \              95 0x0A00 0x0
   \              B71          
    578          

   \                                 In section .text, align 2, keep-with-next
    579          uint32_t CLOCK_GetInternalRefClkFreq(void)
    580          {
    581              /* If MCGIRCLK is gated. */
    582              if (!(MCG->C1 & MCG_C1_IRCLKEN_MASK))
   \                     CLOCK_GetInternalRefClkFreq: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable49_2  ;; 0x40064000
   \        0x4   0x7800             LDRB     R0,[R0, #+0]
   \        0x6   0x0780             LSLS     R0,R0,#+30
   \        0x8   0xD401             BMI.N    ??CLOCK_GetInternalRefClkFreq_0
    583              {
    584                  return 0U;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x4770             BX       LR
    585              }
    586          
    587              return CLOCK_GetInternalRefClkSelectFreq();
   \                     ??CLOCK_GetInternalRefClkFreq_0: (+1)
   \        0xE   0x....             B.N      CLOCK_GetInternalRefClkSelectFreq
    588          }
    589          

   \                                 In section .text, align 2, keep-with-next
    590          uint32_t CLOCK_GetFixedFreqClkFreq(void)
    591          {
   \                     CLOCK_GetFixedFreqClkFreq: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    592              uint32_t freq = CLOCK_GetFllRefClkFreq();
   \        0x2   0x.... 0x....      BL       CLOCK_GetFllRefClkFreq
   \        0x6   0x0004             MOVS     R4,R0
    593          
    594              /* MCGFFCLK must be no more than MCGOUTCLK/8. */
    595              if ((freq) && (freq <= (CLOCK_GetOutClkFreq() / 8U)))
   \        0x8   0xD006             BEQ.N    ??CLOCK_GetFixedFreqClkFreq_0
   \        0xA   0x.... 0x....      BL       CLOCK_GetOutClkFreq
   \        0xE   0x08C0             LSRS     R0,R0,#+3
   \       0x10   0x42A0             CMP      R0,R4
   \       0x12   0xD301             BCC.N    ??CLOCK_GetFixedFreqClkFreq_0
    596              {
    597                  return freq;
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0xBD10             POP      {R4,PC}
    598              }
    599              else
    600              {
    601                  return 0U;
   \                     ??CLOCK_GetFixedFreqClkFreq_0: (+1)
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xBD10             POP      {R4,PC}          ;; return
    602              }
    603          }
    604          

   \                                 In section .text, align 2, keep-with-next
    605          uint32_t CLOCK_GetPll0Freq(void)
    606          {
   \                     CLOCK_GetPll0Freq: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    607              uint32_t mcgpll0clk;
    608          
    609              /* If PLL0 is not enabled, return 0. */
    610              if (!(MCG->S & MCG_S_LOCK0_MASK))
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable40  ;; 0x40064006
   \        0x6   0x7800             LDRB     R0,[R0, #+0]
   \        0x8   0x0640             LSLS     R0,R0,#+25
   \        0xA   0xD401             BMI.N    ??CLOCK_GetPll0Freq_0
    611              {
    612                  return 0U;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0xBD10             POP      {R4,PC}
    613              }
    614          
    615              mcgpll0clk = CLOCK_GetPll0RefFreq();
   \                     ??CLOCK_GetPll0Freq_0: (+1)
   \       0x10   0x.... 0x....      BL       CLOCK_GetPll0RefFreq
   \       0x14   0x0004             MOVS     R4,R0
    616          
    617              /*
    618               * Please call CLOCK_SetXtal0Freq base on board setting before using OSC0 clock.
    619               * Please call CLOCK_SetXtal1Freq base on board setting before using OSC1 clock.
    620               */
    621              assert(mcgpll0clk);
   \       0x16   0xD109             BNE.N    ??CLOCK_GetPll0Freq_1
   \       0x18   0xF240 0x226D      MOVW     R2,#+621
   \       0x1C   0x.... 0x....      LDR.W    R1,??DataTable38_2
   \       0x20   0x.... 0x....      LDR.W    R0,??DataTable48_6
   \       0x24   0x.... 0x....      BL       __aeabi_assert
   \       0x28   0x.... 0x....      BL       __iar_EmptyStepPoint
    622          
    623              mcgpll0clk /= (FSL_FEATURE_MCG_PLL_PRDIV_BASE + MCG_C5_PRDIV0_VAL);
   \                     ??CLOCK_GetPll0Freq_1: (+1)
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable48_7  ;; 0x40064004
   \       0x30   0x7800             LDRB     R0,[R0, #+0]
   \       0x32   0xF000 0x001F      AND      R0,R0,#0x1F
   \       0x36   0x1C40             ADDS     R0,R0,#+1
   \       0x38   0xFBB4 0xF0F0      UDIV     R0,R4,R0
    624              mcgpll0clk *= (FSL_FEATURE_MCG_PLL_VDIV_BASE + MCG_C6_VDIV0_VAL);
   \       0x3C   0x.... 0x....      LDR.W    R1,??DataTable49_3  ;; 0x40064005
   \       0x40   0x7809             LDRB     R1,[R1, #+0]
   \       0x42   0xF001 0x011F      AND      R1,R1,#0x1F
   \       0x46   0x3118             ADDS     R1,R1,#+24
   \       0x48   0x4348             MULS     R0,R1,R0
    625          
    626              return mcgpll0clk;
   \       0x4A   0xBD10             POP      {R4,PC}          ;; return
    627          }
    628          

   \                                 In section .text, align 2, keep-with-next
    629          status_t CLOCK_SetExternalRefClkConfig(mcg_oscsel_t oscsel)
    630          {
    631              bool needDelay;
    632              uint32_t i;
    633          
    634          #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
    635              /* If change MCG_C7[OSCSEL] and external reference clock is system clock source, return error. */
    636              if ((MCG_C7_OSCSEL_VAL != oscsel) && (!(MCG->S & MCG_S_IREFST_MASK)))
    637              {
    638                  return kStatus_MCG_SourceUsed;
    639              }
    640          #endif /* MCG_CONFIG_CHECK_PARAM */
    641          
    642              if (MCG_C7_OSCSEL_VAL != oscsel)
   \                     CLOCK_SetExternalRefClkConfig: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable49_4  ;; 0x4006400c
   \        0x4   0x780A             LDRB     R2,[R1, #+0]
   \        0x6   0xF002 0x0201      AND      R2,R2,#0x1
   \        0xA   0x4603             MOV      R3,R0
   \        0xC   0x429A             CMP      R2,R3
   \        0xE   0xD001             BEQ.N    ??CLOCK_SetExternalRefClkConfig_0
    643              {
    644                  /* If change OSCSEL, need to delay, ERR009878. */
    645                  needDelay = true;
   \       0x10   0x2201             MOVS     R2,#+1
   \       0x12   0xE000             B.N      ??CLOCK_SetExternalRefClkConfig_1
    646              }
    647              else
    648              {
    649                  needDelay = false;
   \                     ??CLOCK_SetExternalRefClkConfig_0: (+1)
   \       0x14   0x2200             MOVS     R2,#+0
    650              }
    651          
    652              MCG->C7 = (MCG->C7 & ~MCG_C7_OSCSEL_MASK) | MCG_C7_OSCSEL(oscsel);
   \                     ??CLOCK_SetExternalRefClkConfig_1: (+1)
   \       0x16   0x780B             LDRB     R3,[R1, #+0]
   \       0x18   0xF003 0x03FE      AND      R3,R3,#0xFE
   \       0x1C   0xF000 0x0001      AND      R0,R0,#0x1
   \       0x20   0x4318             ORRS     R0,R0,R3
   \       0x22   0x7008             STRB     R0,[R1, #+0]
    653              if (needDelay)
   \       0x24   0x2A00             CMP      R2,#+0
   \       0x26   0xD007             BEQ.N    ??CLOCK_SetExternalRefClkConfig_2
    654              {
    655                  /* ERR009878 Delay at least 50 micro-seconds for external clock change valid. */
    656                  i = 1500U;
   \       0x28   0xF240 0x51DC      MOVW     R1,#+1500
   \       0x2C   0xE000             B.N      ??CLOCK_SetExternalRefClkConfig_3
    657                  while (i--)
    658                  {
    659                      __NOP();
   \                     ??CLOCK_SetExternalRefClkConfig_4: (+1)
   \       0x2E   0xBF00             Nop      
    660                  }
   \                     ??CLOCK_SetExternalRefClkConfig_3: (+1)
   \       0x30   0x4608             MOV      R0,R1
   \       0x32   0x1E41             SUBS     R1,R0,#+1
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD1FA             BNE.N    ??CLOCK_SetExternalRefClkConfig_4
    661              }
    662          
    663              return kStatus_Success;
   \                     ??CLOCK_SetExternalRefClkConfig_2: (+1)
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0x4770             BX       LR               ;; return
    664          }
    665          

   \                                 In section .text, align 2, keep-with-next
    666          status_t CLOCK_SetInternalRefClkConfig(uint8_t enableMode, mcg_irc_mode_t ircs, uint8_t fcrdiv)
    667          {
   \                     CLOCK_SetInternalRefClkConfig: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
    668              uint32_t mcgOutClkState = MCG_S_CLKST_VAL;
   \        0x2   0x.... 0x....      LDR.W    R3,??DataTable40  ;; 0x40064006
   \        0x6   0x781C             LDRB     R4,[R3, #+0]
   \        0x8   0xF3C4 0x0481      UBFX     R4,R4,#+2,#+2
    669              mcg_irc_mode_t curIrcs = (mcg_irc_mode_t)MCG_S_IRCST_VAL;
   \        0xC   0x781E             LDRB     R6,[R3, #+0]
   \        0xE   0xF006 0x0601      AND      R6,R6,#0x1
    670              uint8_t curFcrdiv = MCG_SC_FCRDIV_VAL;
   \       0x12   0x.... 0x....      LDR.W    R5,??DataTable47  ;; 0x40064008
   \       0x16   0x782F             LDRB     R7,[R5, #+0]
   \       0x18   0xF3C7 0x0742      UBFX     R7,R7,#+1,#+3
    671          
    672          #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
    673              /* If MCGIRCLK is used as system clock source. */
    674              if (kMCG_ClkOutStatInt == mcgOutClkState)
    675              {
    676                  /* If need to change MCGIRCLK source or driver, return error. */
    677                  if (((kMCG_IrcFast == curIrcs) && (fcrdiv != curFcrdiv)) || (ircs != curIrcs))
    678                  {
    679                      return kStatus_MCG_SourceUsed;
    680                  }
    681              }
    682          #endif
    683          
    684              /* If need to update the FCRDIV. */
    685              if (fcrdiv != curFcrdiv)
   \       0x1C   0x4694             MOV      R12,R2
   \       0x1E   0x45BC             CMP      R12,R7
   \       0x20   0xD019             BEQ.N    ??CLOCK_SetInternalRefClkConfig_0
    686              {
    687                  /* If fast IRC is in use currently, change to slow IRC. */
    688                  if ((kMCG_IrcFast == curIrcs) && ((mcgOutClkState == kMCG_ClkOutStatInt) || (MCG->C1 & MCG_C1_IRCLKEN_MASK)))
   \       0x22   0x2E01             CMP      R6,#+1
   \       0x24   0xD10F             BNE.N    ??CLOCK_SetInternalRefClkConfig_1
   \       0x26   0x2C01             CMP      R4,#+1
   \       0x28   0xD004             BEQ.N    ??CLOCK_SetInternalRefClkConfig_2
   \       0x2A   0x.... 0x....      LDR.W    R6,??DataTable49_2  ;; 0x40064000
   \       0x2E   0x7836             LDRB     R6,[R6, #+0]
   \       0x30   0x07B6             LSLS     R6,R6,#+30
   \       0x32   0xD508             BPL.N    ??CLOCK_SetInternalRefClkConfig_1
    689                  {
    690                      MCG->C2 = ((MCG->C2 & ~MCG_C2_IRCS_MASK) | (MCG_C2_IRCS(kMCG_IrcSlow)));
   \                     ??CLOCK_SetInternalRefClkConfig_2: (+1)
   \       0x34   0x.... 0x....      LDR.W    R6,??DataTable38_6  ;; 0x40064001
   \       0x38   0x7837             LDRB     R7,[R6, #+0]
   \       0x3A   0xF007 0x07FE      AND      R7,R7,#0xFE
   \       0x3E   0x7037             STRB     R7,[R6, #+0]
    691                      while (MCG_S_IRCST_VAL != kMCG_IrcSlow)
   \                     ??CLOCK_SetInternalRefClkConfig_3: (+1)
   \       0x40   0x781E             LDRB     R6,[R3, #+0]
   \       0x42   0x07F6             LSLS     R6,R6,#+31
   \       0x44   0xD4FC             BMI.N    ??CLOCK_SetInternalRefClkConfig_3
    692                      {
    693                      }
    694                  }
    695                  /* Update FCRDIV. */
    696                  MCG->SC = (MCG->SC & ~(MCG_SC_FCRDIV_MASK | MCG_SC_ATMF_MASK | MCG_SC_LOCS0_MASK)) | MCG_SC_FCRDIV(fcrdiv);
   \                     ??CLOCK_SetInternalRefClkConfig_1: (+1)
   \       0x46   0x782E             LDRB     R6,[R5, #+0]
   \       0x48   0xF006 0x06D0      AND      R6,R6,#0xD0
   \       0x4C   0x0052             LSLS     R2,R2,#+1
   \       0x4E   0xF002 0x020E      AND      R2,R2,#0xE
   \       0x52   0x4332             ORRS     R2,R2,R6
   \       0x54   0x702A             STRB     R2,[R5, #+0]
    697              }
    698          
    699              /* Set internal reference clock selection. */
    700              MCG->C2 = (MCG->C2 & ~MCG_C2_IRCS_MASK) | (MCG_C2_IRCS(ircs));
   \                     ??CLOCK_SetInternalRefClkConfig_0: (+1)
   \       0x56   0x.... 0x....      LDR.W    R5,??DataTable38_6  ;; 0x40064001
   \       0x5A   0x782E             LDRB     R6,[R5, #+0]
   \       0x5C   0xF006 0x06FE      AND      R6,R6,#0xFE
   \       0x60   0xF001 0x0201      AND      R2,R1,#0x1
   \       0x64   0x4316             ORRS     R6,R2,R6
   \       0x66   0x702E             STRB     R6,[R5, #+0]
    701              MCG->C1 = (MCG->C1 & ~(MCG_C1_IRCLKEN_MASK | MCG_C1_IREFSTEN_MASK)) | (uint8_t)enableMode;
   \       0x68   0x.... 0x....      LDR.W    R2,??DataTable49_2  ;; 0x40064000
   \       0x6C   0x7815             LDRB     R5,[R2, #+0]
   \       0x6E   0xF005 0x05FC      AND      R5,R5,#0xFC
   \       0x72   0x4305             ORRS     R5,R0,R5
   \       0x74   0x7015             STRB     R5,[R2, #+0]
    702          
    703              /* If MCGIRCLK is used, need to wait for MCG_S_IRCST. */
    704              if ((mcgOutClkState == kMCG_ClkOutStatInt) || (enableMode & kMCG_IrclkEnable))
   \       0x76   0x2C01             CMP      R4,#+1
   \       0x78   0xD001             BEQ.N    ??CLOCK_SetInternalRefClkConfig_4
   \       0x7A   0x0780             LSLS     R0,R0,#+30
   \       0x7C   0xD505             BPL.N    ??CLOCK_SetInternalRefClkConfig_5
    705              {
    706                  while (MCG_S_IRCST_VAL != ircs)
   \                     ??CLOCK_SetInternalRefClkConfig_4: (+1)
   \       0x7E   0x7818             LDRB     R0,[R3, #+0]
   \       0x80   0xF000 0x0001      AND      R0,R0,#0x1
   \       0x84   0x460A             MOV      R2,R1
   \       0x86   0x4290             CMP      R0,R2
   \       0x88   0xD1F9             BNE.N    ??CLOCK_SetInternalRefClkConfig_4
    707                  {
    708                  }
    709              }
    710          
    711              return kStatus_Success;
   \                     ??CLOCK_SetInternalRefClkConfig_5: (+1)
   \       0x8A   0x2000             MOVS     R0,#+0
   \       0x8C   0xBCF0             POP      {R4-R7}
   \       0x8E   0x4770             BX       LR               ;; return
    712          }
    713          

   \                                 In section .text, align 2, keep-with-next
    714          uint32_t CLOCK_CalcPllDiv(uint32_t refFreq, uint32_t desireFreq, uint8_t *prdiv, uint8_t *vdiv)
    715          {
   \                     CLOCK_CalcPllDiv: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x461F             MOV      R7,R3
    716              uint8_t ret_prdiv;           /* PRDIV to return. */
    717              uint8_t ret_vdiv;            /* VDIV to return.  */
    718              uint8_t prdiv_min;           /* Min PRDIV value to make reference clock in allowed range. */
    719              uint8_t prdiv_max;           /* Max PRDIV value to make reference clock in allowed range. */
    720              uint8_t prdiv_cur;           /* PRDIV value for iteration.    */
    721              uint8_t vdiv_cur;            /* VDIV value for iteration.     */
    722              uint32_t ret_freq = 0U;      /* PLL output fequency to return. */
    723              uint32_t diff = 0xFFFFFFFFU; /* Difference between desireFreq and return frequency. */
   \        0x6   0xF04F 0x36FF      MOV      R6,#-1
    724              uint32_t ref_div;            /* Reference frequency after PRDIV. */
    725          
    726              /*
    727                 Steps:
    728                 1. Get allowed prdiv with such rules:
    729                    1). refFreq / prdiv >= FSL_FEATURE_MCG_PLL_REF_MIN.
    730                    2). refFreq / prdiv <= FSL_FEATURE_MCG_PLL_REF_MAX.
    731                 2. For each allowed prdiv, there are two candidate vdiv values:
    732                    1). (desireFreq / (refFreq / prdiv)).
    733                    2). (desireFreq / (refFreq / prdiv)) + 1.
    734                    If could get the precise desired frequency, return current prdiv and
    735                    vdiv directly. Otherwise choose the one which is closer to desired
    736                    frequency.
    737               */
    738          
    739              /* Reference frequency is out of range. */
    740              if ((refFreq < FSL_FEATURE_MCG_PLL_REF_MIN) ||
    741                  (refFreq > (FSL_FEATURE_MCG_PLL_REF_MAX * (FSL_FEATURE_MCG_PLL_PRDIV_MAX + FSL_FEATURE_MCG_PLL_PRDIV_BASE))))
   \        0xA   0x.... 0x....      LDR.W    R3,??DataTable49_5  ;; 0xffe17b80
   \        0xE   0x181B             ADDS     R3,R3,R0
   \       0x10   0x.... 0x....      LDR.W    R4,??DataTable49_6  ;; 0x5d75c81
   \       0x14   0x42A3             CMP      R3,R4
   \       0x16   0xD301             BCC.N    ??CLOCK_CalcPllDiv_0
    742              {
    743                  return 0U;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xE048             B.N      ??CLOCK_CalcPllDiv_1
    744              }
    745          
    746              /* refFreq/PRDIV must in a range. First get the allowed PRDIV range. */
    747              prdiv_max = refFreq / FSL_FEATURE_MCG_PLL_REF_MIN;
    748              prdiv_min = (refFreq + FSL_FEATURE_MCG_PLL_REF_MAX - 1U) / FSL_FEATURE_MCG_PLL_REF_MAX;
   \                     ??CLOCK_CalcPllDiv_0: (+1)
   \       0x1C   0x.... 0x....      LDR.W    R3,??DataTable49_7  ;; 0x3d08ff
   \       0x20   0x181B             ADDS     R3,R3,R0
   \       0x22   0x.... 0x....      LDR.W    R4,??DataTable49_8  ;; 0x3d0900
   \       0x26   0xFBB3 0xF5F4      UDIV     R5,R3,R4
   \       0x2A   0xB2ED             UXTB     R5,R5
    749          
    750              /* PRDIV traversal. */
    751              for (prdiv_cur = prdiv_max; prdiv_cur >= prdiv_min; prdiv_cur--)
   \       0x2C   0x.... 0x....      LDR.W    R3,??DataTable49_9  ;; 0x1e8480
   \       0x30   0xFBB0 0xF4F3      UDIV     R4,R0,R3
   \       0x34   0x460B             MOV      R3,R1
   \       0x36   0x4694             MOV      R12,R2
   \       0x38   0x4602             MOV      R2,R0
   \       0x3A   0x4670             MOV      R0,LR
   \       0x3C   0xE017             B.N      ??CLOCK_CalcPllDiv_2
    752              {
    753                  /* Reference frequency after PRDIV. */
    754                  ref_div = refFreq / prdiv_cur;
    755          
    756                  vdiv_cur = desireFreq / ref_div;
    757          
    758                  if ((vdiv_cur < FSL_FEATURE_MCG_PLL_VDIV_BASE - 1U) || (vdiv_cur > FSL_FEATURE_MCG_PLL_VDIV_BASE + 31U))
    759                  {
    760                      /* No VDIV is available with this PRDIV. */
    761                      continue;
    762                  }
    763          
    764                  ret_freq = vdiv_cur * ref_div;
    765          
    766                  if (vdiv_cur >= FSL_FEATURE_MCG_PLL_VDIV_BASE)
    767                  {
    768                      if (ret_freq == desireFreq) /* If desire frequency is got. */
    769                      {
    770                          *prdiv = prdiv_cur - FSL_FEATURE_MCG_PLL_PRDIV_BASE;
    771                          *vdiv = vdiv_cur - FSL_FEATURE_MCG_PLL_VDIV_BASE;
    772                          return ret_freq;
    773                      }
    774                      /* New PRDIV/VDIV is closer. */
    775                      if (diff > desireFreq - ret_freq)
   \                     ??CLOCK_CalcPllDiv_3: (+1)
   \       0x3E   0xEBA3 0x0A01      SUB      R10,R3,R1
   \       0x42   0x45B2             CMP      R10,R6
   \       0x44   0xD202             BCS.N    ??CLOCK_CalcPllDiv_4
    776                      {
    777                          diff = desireFreq - ret_freq;
   \       0x46   0x1A5E             SUBS     R6,R3,R1
    778                          ret_prdiv = prdiv_cur;
   \       0x48   0x46A0             MOV      R8,R4
    779                          ret_vdiv = vdiv_cur;
   \       0x4A   0x4670             MOV      R0,LR
    780                      }
    781                  }
    782                  vdiv_cur++;
   \                     ??CLOCK_CalcPllDiv_4: (+1)
   \       0x4C   0xF10E 0x0E01      ADD      LR,LR,#+1
   \       0x50   0xFA5F 0xFE8E      UXTB     LR,LR
    783                  if (vdiv_cur <= (FSL_FEATURE_MCG_PLL_VDIV_BASE + 31U))
   \       0x54   0xF1BE 0x0F38      CMP      LR,#+56
   \       0x58   0xD208             BCS.N    ??CLOCK_CalcPllDiv_5
    784                  {
    785                      ret_freq += ref_div;
   \       0x5A   0x4449             ADD      R1,R9,R1
    786                      /* New PRDIV/VDIV is closer. */
    787                      if (diff > ret_freq - desireFreq)
   \       0x5C   0xEBA1 0x0903      SUB      R9,R1,R3
   \       0x60   0x45B1             CMP      R9,R6
   \       0x62   0xD203             BCS.N    ??CLOCK_CalcPllDiv_5
    788                      {
    789                          diff = ret_freq - desireFreq;
   \       0x64   0x460E             MOV      R6,R1
   \       0x66   0x1AF6             SUBS     R6,R6,R3
    790                          ret_prdiv = prdiv_cur;
   \       0x68   0x46A0             MOV      R8,R4
    791                          ret_vdiv = vdiv_cur;
   \       0x6A   0x4670             MOV      R0,LR
    792                      }
    793                  }
   \                     ??CLOCK_CalcPllDiv_5: (+1)
   \       0x6C   0x1E64             SUBS     R4,R4,#+1
   \                     ??CLOCK_CalcPllDiv_2: (+1)
   \       0x6E   0x4621             MOV      R1,R4
   \       0x70   0xB2C9             UXTB     R1,R1
   \       0x72   0x42A9             CMP      R1,R5
   \       0x74   0xDB1D             BLT.N    ??CLOCK_CalcPllDiv_6
   \       0x76   0x4621             MOV      R1,R4
   \       0x78   0xB2C9             UXTB     R1,R1
   \       0x7A   0xFBB2 0xF9F1      UDIV     R9,R2,R1
   \       0x7E   0xFBB3 0xFEF9      UDIV     LR,R3,R9
   \       0x82   0xFA5F 0xFE8E      UXTB     LR,LR
   \       0x86   0xF1AE 0x0117      SUB      R1,LR,#+23
   \       0x8A   0x2921             CMP      R1,#+33
   \       0x8C   0xD2EE             BCS.N    ??CLOCK_CalcPllDiv_5
   \       0x8E   0xFB09 0xF10E      MUL      R1,R9,LR
   \       0x92   0xF1BE 0x0F18      CMP      LR,#+24
   \       0x96   0xDBD9             BLT.N    ??CLOCK_CalcPllDiv_4
   \       0x98   0x4299             CMP      R1,R3
   \       0x9A   0xD1D0             BNE.N    ??CLOCK_CalcPllDiv_3
   \       0x9C   0x1E60             SUBS     R0,R4,#+1
   \       0x9E   0xF88C 0x0000      STRB     R0,[R12, #+0]
   \       0xA2   0xF1AE 0x0018      SUB      R0,LR,#+24
   \       0xA6   0x7038             STRB     R0,[R7, #+0]
   \       0xA8   0x4608             MOV      R0,R1
   \       0xAA   0xE000             B.N      ??CLOCK_CalcPllDiv_1
    794              }
    795          
    796              if (0xFFFFFFFFU != diff)
    797              {
    798                  /* PRDIV/VDIV found. */
    799                  *prdiv = ret_prdiv - FSL_FEATURE_MCG_PLL_PRDIV_BASE;
    800                  *vdiv = ret_vdiv - FSL_FEATURE_MCG_PLL_VDIV_BASE;
    801                  ret_freq = (refFreq / ret_prdiv) * ret_vdiv;
    802                  return ret_freq;
    803              }
    804              else
    805              {
    806                  /* No proper PRDIV/VDIV found. */
    807                  return 0U;
   \                     ??CLOCK_CalcPllDiv_7: (+1)
   \       0xAC   0x2000             MOVS     R0,#+0
   \                     ??CLOCK_CalcPllDiv_1: (+1)
   \       0xAE   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    808              }
   \                     ??CLOCK_CalcPllDiv_6: (+1)
   \       0xB2   0xF116 0x0F01      CMN      R6,#+1
   \       0xB6   0xD0F9             BEQ.N    ??CLOCK_CalcPllDiv_7
   \       0xB8   0xF1A8 0x0101      SUB      R1,R8,#+1
   \       0xBC   0xF88C 0x1000      STRB     R1,[R12, #+0]
   \       0xC0   0xF1A0 0x0118      SUB      R1,R0,#+24
   \       0xC4   0x7039             STRB     R1,[R7, #+0]
   \       0xC6   0xFA5F 0xF888      UXTB     R8,R8
   \       0xCA   0xFBB2 0xF1F8      UDIV     R1,R2,R8
   \       0xCE   0xB2C0             UXTB     R0,R0
   \       0xD0   0x4348             MULS     R0,R0,R1
   \       0xD2   0xE7EC             B.N      ??CLOCK_CalcPllDiv_1
    809          }
    810          

   \                                 In section .text, align 2, keep-with-next
    811          void CLOCK_EnablePll0(mcg_pll_config_t const *config)
    812          {
   \                     CLOCK_EnablePll0: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    813              assert(config);
   \        0x4   0xD109             BNE.N    ??CLOCK_EnablePll0_0
   \        0x6   0xF240 0x322D      MOVW     R2,#+813
   \        0xA   0x.... 0x....      LDR.W    R1,??DataTable38_2
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable49_10
   \       0x12   0x.... 0x....      BL       __aeabi_assert
   \       0x16   0x.... 0x....      BL       __iar_EmptyStepPoint
    814          
    815              uint8_t mcg_c5 = 0U;
    816          
    817              mcg_c5 |= MCG_C5_PRDIV0(config->prdiv);
    818              MCG->C5 = mcg_c5; /* Disable the PLL first. */
   \                     ??CLOCK_EnablePll0_0: (+1)
   \       0x1A   0x.... 0x....      LDR.W    R0,??DataTable48_7  ;; 0x40064004
   \       0x1E   0x7861             LDRB     R1,[R4, #+1]
   \       0x20   0xF001 0x011F      AND      R1,R1,#0x1F
   \       0x24   0x7001             STRB     R1,[R0, #+0]
    819          
    820              MCG->C6 = (MCG->C6 & ~MCG_C6_VDIV0_MASK) | MCG_C6_VDIV0(config->vdiv);
   \       0x26   0x.... 0x....      LDR.W    R1,??DataTable49_3  ;; 0x40064005
   \       0x2A   0x780A             LDRB     R2,[R1, #+0]
   \       0x2C   0xF002 0x02E0      AND      R2,R2,#0xE0
   \       0x30   0x78A3             LDRB     R3,[R4, #+2]
   \       0x32   0xF003 0x031F      AND      R3,R3,#0x1F
   \       0x36   0x431A             ORRS     R2,R3,R2
   \       0x38   0x700A             STRB     R2,[R1, #+0]
    821          
    822              /* Set enable mode. */
    823              MCG->C5 |= ((uint32_t)kMCG_PllEnableIndependent | (uint32_t)config->enableMode);
   \       0x3A   0x7801             LDRB     R1,[R0, #+0]
   \       0x3C   0x7822             LDRB     R2,[R4, #+0]
   \       0x3E   0xF042 0x0240      ORR      R2,R2,#0x40
   \       0x42   0x4311             ORRS     R1,R2,R1
   \       0x44   0x7001             STRB     R1,[R0, #+0]
    824          
    825              /* Wait for PLL lock. */
    826              while (!(MCG->S & MCG_S_LOCK0_MASK))
   \                     ??CLOCK_EnablePll0_1: (+1)
   \       0x46   0x.... 0x....      LDR.W    R0,??DataTable49  ;; 0x40064006
   \       0x4A   0x7800             LDRB     R0,[R0, #+0]
   \       0x4C   0x0640             LSLS     R0,R0,#+25
   \       0x4E   0xD5FA             BPL.N    ??CLOCK_EnablePll0_1
    827              {
    828              }
    829          }
   \       0x50   0xBD10             POP      {R4,PC}          ;; return
    830          

   \                                 In section .text, align 2, keep-with-next
    831          void CLOCK_SetOsc0MonitorMode(mcg_monitor_mode_t mode)
    832          {
    833              /* Clear the previous flag, MCG_SC[LOCS0]. */
    834              MCG->SC &= ~MCG_SC_ATMF_MASK;
   \                     CLOCK_SetOsc0MonitorMode: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable47  ;; 0x40064008
   \        0x4   0x780A             LDRB     R2,[R1, #+0]
   \        0x6   0xF002 0x02DF      AND      R2,R2,#0xDF
   \        0xA   0x700A             STRB     R2,[R1, #+0]
    835          
    836              if (kMCG_MonitorNone == mode)
   \        0xC   0x0001             MOVS     R1,R0
   \        0xE   0xD106             BNE.N    ??CLOCK_SetOsc0MonitorMode_0
    837              {
    838                  MCG->C6 &= ~MCG_C6_CME0_MASK;
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable49_3  ;; 0x40064005
   \       0x14   0x7801             LDRB     R1,[R0, #+0]
   \       0x16   0xF001 0x01DF      AND      R1,R1,#0xDF
   \       0x1A   0x7001             STRB     R1,[R0, #+0]
   \       0x1C   0x4770             BX       LR
    839              }
    840              else
    841              {
    842                  if (kMCG_MonitorInt == mode)
   \                     ??CLOCK_SetOsc0MonitorMode_0: (+1)
   \       0x1E   0x2801             CMP      R0,#+1
   \       0x20   0x.... 0x....      LDR.W    R0,??DataTable38_6  ;; 0x40064001
   \       0x24   0x7801             LDRB     R1,[R0, #+0]
   \       0x26   0xD103             BNE.N    ??CLOCK_SetOsc0MonitorMode_1
    843                  {
    844                      MCG->C2 &= ~MCG_C2_LOCRE0_MASK;
   \       0x28   0xF001 0x017F      AND      R1,R1,#0x7F
   \       0x2C   0x7001             STRB     R1,[R0, #+0]
   \       0x2E   0xE002             B.N      ??CLOCK_SetOsc0MonitorMode_2
    845                  }
    846                  else
    847                  {
    848                      MCG->C2 |= MCG_C2_LOCRE0_MASK;
   \                     ??CLOCK_SetOsc0MonitorMode_1: (+1)
   \       0x30   0xF041 0x0180      ORR      R1,R1,#0x80
   \       0x34   0x7001             STRB     R1,[R0, #+0]
    849                  }
    850                  MCG->C6 |= MCG_C6_CME0_MASK;
   \                     ??CLOCK_SetOsc0MonitorMode_2: (+1)
   \       0x36   0x.... 0x....      LDR.W    R0,??DataTable49_3  ;; 0x40064005
   \       0x3A   0x7801             LDRB     R1,[R0, #+0]
   \       0x3C   0xF041 0x0120      ORR      R1,R1,#0x20
   \       0x40   0x7001             STRB     R1,[R0, #+0]
    851              }
    852          }
   \       0x42   0x4770             BX       LR               ;; return
    853          

   \                                 In section .text, align 2, keep-with-next
    854          void CLOCK_SetRtcOscMonitorMode(mcg_monitor_mode_t mode)
    855          {
    856              uint8_t mcg_c8 = MCG->C8;
   \                     CLOCK_SetRtcOscMonitorMode: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable49_11  ;; 0x4006400d
   \        0x4   0x780A             LDRB     R2,[R1, #+0]
    857          
    858              mcg_c8 &= ~(MCG_C8_CME1_MASK | MCG_C8_LOCRE1_MASK);
   \        0x6   0xF022 0x02A0      BIC      R2,R2,#0xA0
    859          
    860              if (kMCG_MonitorNone != mode)
   \        0xA   0x0003             MOVS     R3,R0
   \        0xC   0xD005             BEQ.N    ??CLOCK_SetRtcOscMonitorMode_0
    861              {
    862                  if (kMCG_MonitorReset == mode)
   \        0xE   0x2802             CMP      R0,#+2
   \       0x10   0xD101             BNE.N    ??CLOCK_SetRtcOscMonitorMode_1
    863                  {
    864                      mcg_c8 |= MCG_C8_LOCRE1_MASK;
   \       0x12   0xF042 0x0280      ORR      R2,R2,#0x80
    865                  }
    866                  mcg_c8 |= MCG_C8_CME1_MASK;
   \                     ??CLOCK_SetRtcOscMonitorMode_1: (+1)
   \       0x16   0xF042 0x0220      ORR      R2,R2,#0x20
    867              }
    868              MCG->C8 = mcg_c8;
   \                     ??CLOCK_SetRtcOscMonitorMode_0: (+1)
   \       0x1A   0x700A             STRB     R2,[R1, #+0]
    869          }
   \       0x1C   0x4770             BX       LR               ;; return
    870          

   \                                 In section .text, align 2, keep-with-next
    871          void CLOCK_SetPll0MonitorMode(mcg_monitor_mode_t mode)
    872          {
    873              uint8_t mcg_c8;
    874          
    875              /* Clear previous flag. */
    876              MCG->S = MCG_S_LOLS0_MASK;
   \                     CLOCK_SetPll0MonitorMode: (+1)
   \        0x0   0x2180             MOVS     R1,#+128
   \        0x2   0x.... 0x....      LDR.W    R2,??DataTable40  ;; 0x40064006
   \        0x6   0x7011             STRB     R1,[R2, #+0]
    877          
    878              if (kMCG_MonitorNone == mode)
   \        0x8   0x0001             MOVS     R1,R0
   \        0xA   0xD106             BNE.N    ??CLOCK_SetPll0MonitorMode_0
    879              {
    880                  MCG->C6 &= ~MCG_C6_LOLIE0_MASK;
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable49_3  ;; 0x40064005
   \       0x10   0x7801             LDRB     R1,[R0, #+0]
   \       0x12   0xF001 0x017F      AND      R1,R1,#0x7F
   \       0x16   0x7001             STRB     R1,[R0, #+0]
   \       0x18   0x4770             BX       LR
    881              }
    882              else
    883              {
    884                  mcg_c8 = MCG->C8;
   \                     ??CLOCK_SetPll0MonitorMode_0: (+1)
   \       0x1A   0x.... 0x....      LDR.W    R1,??DataTable49_11  ;; 0x4006400d
   \       0x1E   0x780A             LDRB     R2,[R1, #+0]
    885          
    886                  mcg_c8 &= ~MCG_C8_LOCS1_MASK;
   \       0x20   0x0852             LSRS     R2,R2,#+1
   \       0x22   0x0052             LSLS     R2,R2,#+1
    887          
    888                  if (kMCG_MonitorInt == mode)
   \       0x24   0x2801             CMP      R0,#+1
   \       0x26   0xD102             BNE.N    ??CLOCK_SetPll0MonitorMode_1
    889                  {
    890                      mcg_c8 &= ~MCG_C8_LOLRE_MASK;
   \       0x28   0xF022 0x0240      BIC      R2,R2,#0x40
   \       0x2C   0xE001             B.N      ??CLOCK_SetPll0MonitorMode_2
    891                  }
    892                  else
    893                  {
    894                      mcg_c8 |= MCG_C8_LOLRE_MASK;
   \                     ??CLOCK_SetPll0MonitorMode_1: (+1)
   \       0x2E   0xF042 0x0240      ORR      R2,R2,#0x40
    895                  }
    896                  MCG->C8 = mcg_c8;
   \                     ??CLOCK_SetPll0MonitorMode_2: (+1)
   \       0x32   0x700A             STRB     R2,[R1, #+0]
    897                  MCG->C6 |= MCG_C6_LOLIE0_MASK;
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable49_3  ;; 0x40064005
   \       0x38   0x7801             LDRB     R1,[R0, #+0]
   \       0x3A   0xF041 0x0180      ORR      R1,R1,#0x80
   \       0x3E   0x7001             STRB     R1,[R0, #+0]
    898              }
    899          }
   \       0x40   0x4770             BX       LR               ;; return
    900          

   \                                 In section .text, align 2, keep-with-next
    901          uint32_t CLOCK_GetStatusFlags(void)
    902          {
    903              uint32_t ret = 0U;
   \                     CLOCK_GetStatusFlags: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
    904              uint8_t mcg_s = MCG->S;
   \        0x2   0x.... 0x....      LDR.W    R1,??DataTable40  ;; 0x40064006
   \        0x6   0x7809             LDRB     R1,[R1, #+0]
    905          
    906              if (MCG->SC & MCG_SC_LOCS0_MASK)
   \        0x8   0x.... 0x....      LDR.W    R2,??DataTable47  ;; 0x40064008
   \        0xC   0x7812             LDRB     R2,[R2, #+0]
   \        0xE   0x07D2             LSLS     R2,R2,#+31
   \       0x10   0xD500             BPL.N    ??CLOCK_GetStatusFlags_0
    907              {
    908                  ret |= kMCG_Osc0LostFlag;
   \       0x12   0x2001             MOVS     R0,#+1
    909              }
    910              if (mcg_s & MCG_S_OSCINIT0_MASK)
   \                     ??CLOCK_GetStatusFlags_0: (+1)
   \       0x14   0x078A             LSLS     R2,R1,#+30
   \       0x16   0xD501             BPL.N    ??CLOCK_GetStatusFlags_1
    911              {
    912                  ret |= kMCG_Osc0InitFlag;
   \       0x18   0xF040 0x0002      ORR      R0,R0,#0x2
    913              }
    914              if (MCG->C8 & MCG_C8_LOCS1_MASK)
   \                     ??CLOCK_GetStatusFlags_1: (+1)
   \       0x1C   0x.... 0x....      LDR.W    R2,??DataTable49_11  ;; 0x4006400d
   \       0x20   0x7812             LDRB     R2,[R2, #+0]
   \       0x22   0x07D2             LSLS     R2,R2,#+31
   \       0x24   0xD501             BPL.N    ??CLOCK_GetStatusFlags_2
    915              {
    916                  ret |= kMCG_RtcOscLostFlag;
   \       0x26   0xF040 0x0010      ORR      R0,R0,#0x10
    917              }
    918              if (mcg_s & MCG_S_LOLS0_MASK)
   \                     ??CLOCK_GetStatusFlags_2: (+1)
   \       0x2A   0x060A             LSLS     R2,R1,#+24
   \       0x2C   0xD501             BPL.N    ??CLOCK_GetStatusFlags_3
    919              {
    920                  ret |= kMCG_Pll0LostFlag;
   \       0x2E   0xF040 0x0020      ORR      R0,R0,#0x20
    921              }
    922              if (mcg_s & MCG_S_LOCK0_MASK)
   \                     ??CLOCK_GetStatusFlags_3: (+1)
   \       0x32   0x0649             LSLS     R1,R1,#+25
   \       0x34   0xD501             BPL.N    ??CLOCK_GetStatusFlags_4
    923              {
    924                  ret |= kMCG_Pll0LockFlag;
   \       0x36   0xF040 0x0040      ORR      R0,R0,#0x40
    925              }
    926              return ret;
   \                     ??CLOCK_GetStatusFlags_4: (+1)
   \       0x3A   0x4770             BX       LR               ;; return
    927          }
    928          

   \                                 In section .text, align 2, keep-with-next
    929          void CLOCK_ClearStatusFlags(uint32_t mask)
    930          {
    931              uint8_t reg;
    932          
    933              if (mask & kMCG_Osc0LostFlag)
   \                     CLOCK_ClearStatusFlags: (+1)
   \        0x0   0x07C1             LSLS     R1,R0,#+31
   \        0x2   0xD505             BPL.N    ??CLOCK_ClearStatusFlags_0
    934              {
    935                  MCG->SC &= ~MCG_SC_ATMF_MASK;
   \        0x4   0x.... 0x....      LDR.W    R1,??DataTable47  ;; 0x40064008
   \        0x8   0x780A             LDRB     R2,[R1, #+0]
   \        0xA   0xF002 0x02DF      AND      R2,R2,#0xDF
   \        0xE   0x700A             STRB     R2,[R1, #+0]
    936              }
    937              if (mask & kMCG_RtcOscLostFlag)
   \                     ??CLOCK_ClearStatusFlags_0: (+1)
   \       0x10   0x06C1             LSLS     R1,R0,#+27
   \       0x12   0xD503             BPL.N    ??CLOCK_ClearStatusFlags_1
    938              {
    939                  reg = MCG->C8;
   \       0x14   0x.... 0x....      LDR.W    R1,??DataTable49_11  ;; 0x4006400d
   \       0x18   0x780A             LDRB     R2,[R1, #+0]
    940                  MCG->C8 = reg;
   \       0x1A   0x700A             STRB     R2,[R1, #+0]
    941              }
    942              if (mask & kMCG_Pll0LostFlag)
   \                     ??CLOCK_ClearStatusFlags_1: (+1)
   \       0x1C   0x0680             LSLS     R0,R0,#+26
   \       0x1E   0xD503             BPL.N    ??CLOCK_ClearStatusFlags_2
    943              {
    944                  MCG->S = MCG_S_LOLS0_MASK;
   \       0x20   0x2080             MOVS     R0,#+128
   \       0x22   0x.... 0x....      LDR.W    R1,??DataTable49  ;; 0x40064006
   \       0x26   0x7008             STRB     R0,[R1, #+0]
    945              }
    946          }
   \                     ??CLOCK_ClearStatusFlags_2: (+1)
   \       0x28   0x4770             BX       LR               ;; return
    947          

   \                                 In section .text, align 2, keep-with-next
    948          void CLOCK_InitOsc0(osc_config_t const *config)
    949          {
   \                     CLOCK_InitOsc0: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
    950              uint8_t range = CLOCK_GetOscRangeFromFreq(config->freq);
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x.... 0x....      BL       CLOCK_GetOscRangeFromFreq
   \        0xA   0x4606             MOV      R6,R0
    951          
    952              OSC_SetCapLoad(OSC0, config->capLoad);
   \        0xC   0x.... 0x....      LDR.W    R5,??DataTable41_2  ;; 0x40065000
   \       0x10   0x7921             LDRB     R1,[R4, #+4]
   \       0x12   0x4628             MOV      R0,R5
   \       0x14   0x.... 0x....      BL       OSC_SetCapLoad
    953              OSC_SetExtRefClkConfig(OSC0, &config->oscerConfig);
   \       0x18   0x1DA1             ADDS     R1,R4,#+6
   \       0x1A   0x4628             MOV      R0,R5
   \       0x1C   0x.... 0x....      BL       OSC_SetExtRefClkConfig
    954          
    955              MCG->C2 = ((MCG->C2 & ~OSC_MODE_MASK) | MCG_C2_RANGE(range) | (uint8_t)config->workMode);
   \       0x20   0x....             LDR.N    R1,??DataTable38_6  ;; 0x40064001
   \       0x22   0x7808             LDRB     R0,[R1, #+0]
   \       0x24   0xF000 0x00C3      AND      R0,R0,#0xC3
   \       0x28   0x0136             LSLS     R6,R6,#+4
   \       0x2A   0xF006 0x0630      AND      R6,R6,#0x30
   \       0x2E   0x4306             ORRS     R6,R6,R0
   \       0x30   0x7960             LDRB     R0,[R4, #+5]
   \       0x32   0x4306             ORRS     R6,R0,R6
   \       0x34   0x700E             STRB     R6,[R1, #+0]
    956          
    957              if ((kOSC_ModeExt != config->workMode) && (OSC0->CR & OSC_CR_ERCLKEN_MASK))
   \       0x36   0x7960             LDRB     R0,[R4, #+5]
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD007             BEQ.N    ??CLOCK_InitOsc0_0
   \       0x3C   0x7828             LDRB     R0,[R5, #+0]
   \       0x3E   0x0600             LSLS     R0,R0,#+24
   \       0x40   0xD504             BPL.N    ??CLOCK_InitOsc0_0
    958              {
    959                  /* Wait for stable. */
    960                  while (!(MCG->S & MCG_S_OSCINIT0_MASK))
   \                     ??CLOCK_InitOsc0_1: (+1)
   \       0x42   0x.... 0x....      LDR.W    R0,??DataTable49  ;; 0x40064006
   \       0x46   0x7800             LDRB     R0,[R0, #+0]
   \       0x48   0x0780             LSLS     R0,R0,#+30
   \       0x4A   0xD5FA             BPL.N    ??CLOCK_InitOsc0_1
    961                  {
    962                  }
    963              }
    964          }
   \                     ??CLOCK_InitOsc0_0: (+1)
   \       0x4C   0xBD70             POP      {R4-R6,PC}       ;; return
    965          

   \                                 In section .text, align 2, keep-with-next
    966          void CLOCK_DeinitOsc0(void)
    967          {
    968              OSC0->CR = 0U;
   \                     CLOCK_DeinitOsc0: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x.... 0x....      LDR.W    R1,??DataTable41_2  ;; 0x40065000
   \        0x6   0x7008             STRB     R0,[R1, #+0]
    969              MCG->C2 &= ~OSC_MODE_MASK;
   \        0x8   0x.... 0x....      LDR.W    R0,??DataTable49_12  ;; 0x40064001
   \        0xC   0x7801             LDRB     R1,[R0, #+0]
   \        0xE   0xF001 0x01C3      AND      R1,R1,#0xC3
   \       0x12   0x7001             STRB     R1,[R0, #+0]
    970          }
   \       0x14   0x4770             BX       LR               ;; return
    971          

   \                                 In section .text, align 2, keep-with-next
    972          status_t CLOCK_TrimInternalRefClk(uint32_t extFreq, uint32_t desireFreq, uint32_t *actualFreq, mcg_atm_select_t atms)
    973          {
   \                     CLOCK_TrimInternalRefClk: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
    974              uint32_t multi; /* extFreq / desireFreq */
    975              uint32_t actv;  /* Auto trim value. */
    976              uint8_t mcg_sc;
    977          
    978              static const uint32_t trimRange[2][2] = {
    979                  /*     Min           Max      */
    980                  {TRIM_SIRC_MIN, TRIM_SIRC_MAX}, /* Slow IRC. */
    981                  {TRIM_FIRC_MIN, TRIM_FIRC_MAX}  /* Fast IRC. */
    982              };
    983          
    984              if ((extFreq > TRIM_REF_CLK_MAX) || (extFreq < TRIM_REF_CLK_MIN))
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable49_13  ;; 0xff85ee00
   \        0x6   0x1824             ADDS     R4,R4,R0
   \        0x8   0x.... 0x....      LDR.W    R5,??DataTable48  ;; 0x7a1201
   \        0xC   0x42AC             CMP      R4,R5
   \        0xE   0xD302             BCC.N    ??CLOCK_TrimInternalRefClk_0
    985              {
    986                  return kStatus_MCG_AtmBusClockInvalid;
   \       0x10   0xF240 0x70D2      MOVW     R0,#+2002
   \       0x14   0xE047             B.N      ??CLOCK_TrimInternalRefClk_1
    987              }
    988          
    989              /* Check desired frequency range. */
    990              if ((desireFreq < trimRange[atms][0]) || (desireFreq > trimRange[atms][1]))
   \                     ??CLOCK_TrimInternalRefClk_0: (+1)
   \       0x16   0x.... 0x....      LDR.W    R4,??DataTable49_14
   \       0x1A   0x461D             MOV      R5,R3
   \       0x1C   0xF854 0x5035      LDR      R5,[R4, R5, LSL #+3]
   \       0x20   0x42A9             CMP      R1,R5
   \       0x22   0xD305             BCC.N    ??CLOCK_TrimInternalRefClk_2
   \       0x24   0x461D             MOV      R5,R3
   \       0x26   0xEB04 0x04C5      ADD      R4,R4,R5, LSL #+3
   \       0x2A   0x6864             LDR      R4,[R4, #+4]
   \       0x2C   0x428C             CMP      R4,R1
   \       0x2E   0xD202             BCS.N    ??CLOCK_TrimInternalRefClk_3
    991              {
    992                  return kStatus_MCG_AtmDesiredFreqInvalid;
   \                     ??CLOCK_TrimInternalRefClk_2: (+1)
   \       0x30   0xF240 0x70D3      MOVW     R0,#+2003
   \       0x34   0xE037             B.N      ??CLOCK_TrimInternalRefClk_1
    993              }
    994          
    995              /*
    996                 Make sure internal reference clock is not used to generate bus clock.
    997                 Here only need to check (MCG_S_IREFST == 1).
    998               */
    999              if (MCG_S_IREFST(kMCG_FllSrcInternal) == (MCG->S & MCG_S_IREFST_MASK))
   \                     ??CLOCK_TrimInternalRefClk_3: (+1)
   \       0x36   0x....             LDR.N    R4,??DataTable40  ;; 0x40064006
   \       0x38   0x7824             LDRB     R4,[R4, #+0]
   \       0x3A   0x06E4             LSLS     R4,R4,#+27
   \       0x3C   0xD502             BPL.N    ??CLOCK_TrimInternalRefClk_4
   1000              {
   1001                  return kStatus_MCG_AtmIrcUsed;
   \       0x3E   0xF240 0x70D4      MOVW     R0,#+2004
   \       0x42   0xE030             B.N      ??CLOCK_TrimInternalRefClk_1
   1002              }
   1003          
   1004              multi = extFreq / desireFreq;
   \                     ??CLOCK_TrimInternalRefClk_4: (+1)
   \       0x44   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   1005              actv = multi * 21U;
   \       0x48   0x2415             MOVS     R4,#+21
   \       0x4A   0x434C             MULS     R4,R4,R1
   1006          
   1007              if (kMCG_AtmSel4m == atms)
   \       0x4C   0x2D01             CMP      R5,#+1
   \       0x4E   0xD100             BNE.N    ??CLOCK_TrimInternalRefClk_5
   1008              {
   1009                  actv *= 128U;
   \       0x50   0x01E4             LSLS     R4,R4,#+7
   1010              }
   1011          
   1012              /* Now begin to start trim. */
   1013              MCG->ATCVL = (uint8_t)actv;
   \                     ??CLOCK_TrimInternalRefClk_5: (+1)
   \       0x52   0x.... 0x....      LDR.W    R5,??DataTable49_15  ;; 0x4006400b
   \       0x56   0x702C             STRB     R4,[R5, #+0]
   1014              MCG->ATCVH = (uint8_t)(actv >> 8U);
   \       0x58   0x0A24             LSRS     R4,R4,#+8
   \       0x5A   0x.... 0x....      LDR.W    R5,??DataTable49_16  ;; 0x4006400a
   \       0x5E   0x702C             STRB     R4,[R5, #+0]
   1015          
   1016              mcg_sc = MCG->SC;
   \       0x60   0x.... 0x....      LDR.W    R4,??DataTable47  ;; 0x40064008
   \       0x64   0x7825             LDRB     R5,[R4, #+0]
   1017              mcg_sc &= ~(MCG_SC_ATMS_MASK | MCG_SC_LOCS0_MASK);
   1018              mcg_sc |= (MCG_SC_ATMF_MASK | MCG_SC_ATMS(atms));
   \       0x66   0xF005 0x05BE      AND      R5,R5,#0xBE
   \       0x6A   0x019E             LSLS     R6,R3,#+6
   \       0x6C   0xF006 0x0640      AND      R6,R6,#0x40
   \       0x70   0x4335             ORRS     R5,R6,R5
   \       0x72   0xF045 0x0520      ORR      R5,R5,#0x20
   1019              MCG->SC = (mcg_sc | MCG_SC_ATME_MASK);
   \       0x76   0xF045 0x0680      ORR      R6,R5,#0x80
   \       0x7A   0x7026             STRB     R6,[R4, #+0]
   1020          
   1021              /* Wait for finished. */
   1022              while (MCG->SC & MCG_SC_ATME_MASK)
   \                     ??CLOCK_TrimInternalRefClk_6: (+1)
   \       0x7C   0x7826             LDRB     R6,[R4, #+0]
   \       0x7E   0x0636             LSLS     R6,R6,#+24
   \       0x80   0xD4FC             BMI.N    ??CLOCK_TrimInternalRefClk_6
   1023              {
   1024              }
   1025          
   1026              /* Error occurs? */
   1027              if (MCG->SC & MCG_SC_ATMF_MASK)
   \       0x82   0x7826             LDRB     R6,[R4, #+0]
   \       0x84   0x06B6             LSLS     R6,R6,#+26
   \       0x86   0xD503             BPL.N    ??CLOCK_TrimInternalRefClk_7
   1028              {
   1029                  /* Clear the failed flag. */
   1030                  MCG->SC = mcg_sc;
   \       0x88   0x7025             STRB     R5,[R4, #+0]
   1031                  return kStatus_MCG_AtmHardwareFail;
   \       0x8A   0xF240 0x70D5      MOVW     R0,#+2005
   \       0x8E   0xE00A             B.N      ??CLOCK_TrimInternalRefClk_1
   1032              }
   1033          
   1034              *actualFreq = extFreq / multi;
   \                     ??CLOCK_TrimInternalRefClk_7: (+1)
   \       0x90   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0x94   0x6010             STR      R0,[R2, #+0]
   1035          
   1036              if (kMCG_AtmSel4m == atms)
   \       0x96   0x2B01             CMP      R3,#+1
   \       0x98   0xD102             BNE.N    ??CLOCK_TrimInternalRefClk_8
   1037              {
   1038                  s_fastIrcFreq = *actualFreq;
   \       0x9A   0x....             LDR.N    R1,??DataTable41_1
   \       0x9C   0x6008             STR      R0,[R1, #+0]
   \       0x9E   0xE001             B.N      ??CLOCK_TrimInternalRefClk_9
   1039              }
   1040              else
   1041              {
   1042                  s_slowIrcFreq = *actualFreq;
   \                     ??CLOCK_TrimInternalRefClk_8: (+1)
   \       0xA0   0x....             LDR.N    R1,??DataTable41
   \       0xA2   0x6008             STR      R0,[R1, #+0]
   1043              }
   1044          
   1045              return kStatus_Success;
   \                     ??CLOCK_TrimInternalRefClk_9: (+1)
   \       0xA4   0x2000             MOVS     R0,#+0
   \                     ??CLOCK_TrimInternalRefClk_1: (+1)
   \       0xA6   0xBC70             POP      {R4-R6}
   \       0xA8   0x4770             BX       LR               ;; return
   1046          }

   \                                 In section .rodata, align 4
   \                     `CLOCK_TrimInternalRefClk::trimRange`:
   \        0x0   0x0000'7A12        DC32 31250, 39063, 3000000, 5000000
   \              0x0000'9897  
   \              0x002D'C6C0  
   \              0x004C'4B40  
   1047          

   \                                 In section .text, align 4, keep-with-next
   1048          mcg_mode_t CLOCK_GetMode(void)
   1049          {
   \                     CLOCK_GetMode: (+1)
   \        0x0   0xB410             PUSH     {R4}
   1050              mcg_mode_t mode = kMCG_ModeError;
   \        0x2   0x2008             MOVS     R0,#+8
   1051              uint32_t clkst = MCG_S_CLKST_VAL;
   \        0x4   0x....             LDR.N    R3,??DataTable40  ;; 0x40064006
   \        0x6   0x7819             LDRB     R1,[R3, #+0]
   \        0x8   0xF3C1 0x0481      UBFX     R4,R1,#+2,#+2
   1052              uint32_t irefst = MCG_S_IREFST_VAL;
   \        0xC   0x7819             LDRB     R1,[R3, #+0]
   \        0xE   0xF3C1 0x1200      UBFX     R2,R1,#+4,#+1
   1053              uint32_t lp = MCG_C2_LP_VAL;
   \       0x12   0x.... 0x....      LDR.W    R1,??DataTable49_12  ;; 0x40064001
   \       0x16   0x7809             LDRB     R1,[R1, #+0]
   \       0x18   0xF3C1 0x0140      UBFX     R1,R1,#+1,#+1
   1054              uint32_t pllst = MCG_S_PLLST_VAL;
   \       0x1C   0x781B             LDRB     R3,[R3, #+0]
   \       0x1E   0xF3C3 0x1340      UBFX     R3,R3,#+5,#+1
   1055          
   1056              /*------------------------------------------------------------------
   1057                                     Mode and Registers
   1058              ____________________________________________________________________
   1059          
   1060                Mode   |   CLKST    |   IREFST   |   PLLST   |      LP
   1061              ____________________________________________________________________
   1062          
   1063                FEI    |  00(FLL)   |   1(INT)   |   0(FLL)  |      X
   1064              ____________________________________________________________________
   1065          
   1066                FEE    |  00(FLL)   |   0(EXT)   |   0(FLL)  |      X
   1067              ____________________________________________________________________
   1068          
   1069                FBE    |  10(EXT)   |   0(EXT)   |   0(FLL)  |   0(NORMAL)
   1070              ____________________________________________________________________
   1071          
   1072                FBI    |  01(INT)   |   1(INT)   |   0(FLL)  |   0(NORMAL)
   1073              ____________________________________________________________________
   1074          
   1075                BLPI   |  01(INT)   |   1(INT)   |   0(FLL)  |   1(LOW POWER)
   1076              ____________________________________________________________________
   1077          
   1078                BLPE   |  10(EXT)   |   0(EXT)   |     X     |   1(LOW POWER)
   1079              ____________________________________________________________________
   1080          
   1081                PEE    |  11(PLL)   |   0(EXT)   |   1(PLL)  |      X
   1082              ____________________________________________________________________
   1083          
   1084                PBE    |  10(EXT)   |   0(EXT)   |   1(PLL)  |   O(NORMAL)
   1085              ____________________________________________________________________
   1086          
   1087                PBI    |  01(INT)   |   1(INT)   |   1(PLL)  |   0(NORMAL)
   1088              ____________________________________________________________________
   1089          
   1090                PEI    |  11(PLL)   |   1(INT)   |   1(PLL)  |      X
   1091              ____________________________________________________________________
   1092          
   1093              ----------------------------------------------------------------------*/
   1094          
   1095              switch (clkst)
   \       0x22   0x2C03             CMP      R4,#+3
   \       0x24   0xD81A             BHI.N    ??CLOCK_GetMode_1
   \       0x26   0xE8DF 0xF004      TBB      [PC, R4]
   \                     ??CLOCK_GetMode_0:
   \       0x2A   0x02 0x08          DC8      0x2,0x8,0xE,0x18
   \              0x0E 0x18    
   1096              {
   1097                  case kMCG_ClkOutStatFll:
   1098                      if (kMCG_FllSrcExternal == irefst)
   \                     ??CLOCK_GetMode_2: (+1)
   \       0x2E   0x2A00             CMP      R2,#+0
   \       0x30   0xD101             BNE.N    ??CLOCK_GetMode_3
   1099                      {
   1100                          mode = kMCG_ModeFEE;
   \       0x32   0x2003             MOVS     R0,#+3
   \       0x34   0xE012             B.N      ??CLOCK_GetMode_1
   1101                      }
   1102                      else
   1103                      {
   1104                          mode = kMCG_ModeFEI;
   \                     ??CLOCK_GetMode_3: (+1)
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xE010             B.N      ??CLOCK_GetMode_1
   1105                      }
   1106                      break;
   1107                  case kMCG_ClkOutStatInt:
   1108                      if (lp)
   \                     ??CLOCK_GetMode_4: (+1)
   \       0x3A   0x2900             CMP      R1,#+0
   \       0x3C   0xD001             BEQ.N    ??CLOCK_GetMode_5
   1109                      {
   1110                          mode = kMCG_ModeBLPI;
   \       0x3E   0x2002             MOVS     R0,#+2
   \       0x40   0xE00C             B.N      ??CLOCK_GetMode_1
   1111                      }
   1112                      else
   1113                      {
   1114                          {
   1115                              mode = kMCG_ModeFBI;
   \                     ??CLOCK_GetMode_5: (+1)
   \       0x42   0x2001             MOVS     R0,#+1
   \       0x44   0xE00A             B.N      ??CLOCK_GetMode_1
   1116                          }
   1117                      }
   1118                      break;
   1119                  case kMCG_ClkOutStatExt:
   1120                      if (lp)
   \                     ??CLOCK_GetMode_6: (+1)
   \       0x46   0x2900             CMP      R1,#+0
   \       0x48   0xD001             BEQ.N    ??CLOCK_GetMode_7
   1121                      {
   1122                          mode = kMCG_ModeBLPE;
   \       0x4A   0x2005             MOVS     R0,#+5
   \       0x4C   0xE006             B.N      ??CLOCK_GetMode_1
   1123                      }
   1124                      else
   1125                      {
   1126                          if (kMCG_PllstPll == pllst)
   \                     ??CLOCK_GetMode_7: (+1)
   \       0x4E   0x2B01             CMP      R3,#+1
   \       0x50   0xD101             BNE.N    ??CLOCK_GetMode_8
   1127                          {
   1128                              mode = kMCG_ModePBE;
   \       0x52   0x2006             MOVS     R0,#+6
   \       0x54   0xE002             B.N      ??CLOCK_GetMode_1
   1129                          }
   1130                          else
   1131                          {
   1132                              mode = kMCG_ModeFBE;
   \                     ??CLOCK_GetMode_8: (+1)
   \       0x56   0x2004             MOVS     R0,#+4
   \       0x58   0xE000             B.N      ??CLOCK_GetMode_1
   1133                          }
   1134                      }
   1135                      break;
   1136                  case kMCG_ClkOutStatPll:
   1137                  {
   1138                      mode = kMCG_ModePEE;
   \                     ??CLOCK_GetMode_9: (+1)
   \       0x5A   0x2007             MOVS     R0,#+7
   1139                  }
   1140                  break;
   1141                  default:
   1142                      break;
   1143              }
   1144          
   1145              return mode;
   \                     ??CLOCK_GetMode_1: (+1)
   \       0x5C   0xBC10             POP      {R4}
   \       0x5E   0x4770             BX       LR               ;; return
   1146          }
   1147          

   \                                 In section .text, align 2, keep-with-next
   1148          status_t CLOCK_SetFeiMode(mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(void))
   1149          {
   \                     CLOCK_SetFeiMode: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4603             MOV      R3,R0
   1150              uint8_t mcg_c4;
   1151              bool change_drs = false;
   \        0x4   0x2500             MOVS     R5,#+0
   1152          
   1153          #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
   1154              mcg_mode_t mode = CLOCK_GetMode();
   1155              if (!((kMCG_ModeFEI == mode) || (kMCG_ModeFBI == mode) || (kMCG_ModeFBE == mode) || (kMCG_ModeFEE == mode)))
   1156              {
   1157                  return kStatus_MCG_ModeUnreachable;
   1158              }
   1159          #endif
   1160              mcg_c4 = MCG->C4;
   \        0x6   0x.... 0x....      LDR.W    R6,??DataTable48_5  ;; 0x40064003
   \        0xA   0x7837             LDRB     R7,[R6, #+0]
   1161          
   1162              /*
   1163                 Errata: ERR007993
   1164                 Workaround: Invert MCG_C4[DMX32] or change MCG_C4[DRST_DRS] before
   1165                 reference clock source changes, then reset to previous value after
   1166                 reference clock changes.
   1167               */
   1168              if (kMCG_FllSrcExternal == MCG_S_IREFST_VAL)
   \        0xC   0x....             LDR.N    R4,??DataTable40  ;; 0x40064006
   \        0xE   0x7820             LDRB     R0,[R4, #+0]
   \       0x10   0xF3C0 0x1000      UBFX     R0,R0,#+4,#+1
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD104             BNE.N    ??CLOCK_SetFeiMode_0
   1169              {
   1170                  change_drs = true;
   \       0x18   0x2501             MOVS     R5,#+1
   1171                  /* Change the LSB of DRST_DRS. */
   1172                  MCG->C4 ^= (1U << MCG_C4_DRST_DRS_SHIFT);
   \       0x1A   0x7830             LDRB     R0,[R6, #+0]
   \       0x1C   0xF080 0x0020      EOR      R0,R0,#0x20
   \       0x20   0x7030             STRB     R0,[R6, #+0]
   1173              }
   1174          
   1175              /* Set CLKS and IREFS. */
   1176              MCG->C1 =
   1177                  ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK))) | (MCG_C1_CLKS(kMCG_ClkOutSrcOut)        /* CLKS = 0 */
   1178                                                                           | MCG_C1_IREFS(kMCG_FllSrcInternal)); /* IREFS = 1 */
   \                     ??CLOCK_SetFeiMode_0: (+1)
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable49_2  ;; 0x40064000
   \       0x26   0xF890 0xC000      LDRB     R12,[R0, #+0]
   \       0x2A   0xF00C 0x0C3B      AND      R12,R12,#0x3B
   \       0x2E   0xF04C 0x0C04      ORR      R12,R12,#0x4
   \       0x32   0xF880 0xC000      STRB     R12,[R0, #+0]
   1179          
   1180              /* Wait and check status. */
   1181              while (kMCG_FllSrcInternal != MCG_S_IREFST_VAL)
   \                     ??CLOCK_SetFeiMode_1: (+1)
   \       0x36   0x7820             LDRB     R0,[R4, #+0]
   \       0x38   0xF3C0 0x1000      UBFX     R0,R0,#+4,#+1
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD0FA             BEQ.N    ??CLOCK_SetFeiMode_1
   1182              {
   1183              }
   1184          
   1185              /* Errata: ERR007993 */
   1186              if (change_drs)
   \       0x40   0x2D00             CMP      R5,#+0
   \       0x42   0xD000             BEQ.N    ??CLOCK_SetFeiMode_2
   1187              {
   1188                  MCG->C4 = mcg_c4;
   \       0x44   0x7037             STRB     R7,[R6, #+0]
   1189              }
   1190          
   1191              /* In FEI mode, the MCG_C4[DMX32] is set to 0U. */
   1192              MCG->C4 = (mcg_c4 & ~(MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) | (MCG_C4_DMX32(dmx32) | MCG_C4_DRST_DRS(drs));
   \                     ??CLOCK_SetFeiMode_2: (+1)
   \       0x46   0xF007 0x071F      AND      R7,R7,#0x1F
   \       0x4A   0xEA47 0x17C3      ORR      R7,R7,R3, LSL #+7
   \       0x4E   0x0149             LSLS     R1,R1,#+5
   \       0x50   0xF001 0x0160      AND      R1,R1,#0x60
   \       0x54   0x4339             ORRS     R1,R1,R7
   \       0x56   0x7031             STRB     R1,[R6, #+0]
   1193          
   1194              /* Check MCG_S[CLKST] */
   1195              while (kMCG_ClkOutStatFll != MCG_S_CLKST_VAL)
   \                     ??CLOCK_SetFeiMode_3: (+1)
   \       0x58   0x7820             LDRB     R0,[R4, #+0]
   \       0x5A   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD1FA             BNE.N    ??CLOCK_SetFeiMode_3
   1196              {
   1197              }
   1198          
   1199              /* Wait for FLL stable time. */
   1200              if (fllStableDelay)
   \       0x62   0x0010             MOVS     R0,R2
   \       0x64   0xD000             BEQ.N    ??CLOCK_SetFeiMode_4
   1201              {
   1202                  fllStableDelay();
   \       0x66   0x4790             BLX      R2
   1203              }
   1204          
   1205              return kStatus_Success;
   \                     ??CLOCK_SetFeiMode_4: (+1)
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1206          }
   1207          

   \                                 In section .text, align 2, keep-with-next
   1208          status_t CLOCK_SetFeeMode(uint8_t frdiv, mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(void))
   1209          {
   \                     CLOCK_SetFeeMode: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   1210              uint8_t mcg_c4;
   1211              bool change_drs = false;
   \        0x2   0xF04F 0x0C00      MOV      R12,#+0
   1212          
   1213          #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
   1214              mcg_mode_t mode = CLOCK_GetMode();
   1215              if (!((kMCG_ModeFEE == mode) || (kMCG_ModeFBI == mode) || (kMCG_ModeFBE == mode) || (kMCG_ModeFEI == mode)))
   1216              {
   1217                  return kStatus_MCG_ModeUnreachable;
   1218              }
   1219          #endif
   1220              mcg_c4 = MCG->C4;
   \        0x6   0x.... 0x....      LDR.W    R6,??DataTable48_5  ;; 0x40064003
   \        0xA   0x7837             LDRB     R7,[R6, #+0]
   1221          
   1222              /*
   1223                 Errata: ERR007993
   1224                 Workaround: Invert MCG_C4[DMX32] or change MCG_C4[DRST_DRS] before
   1225                 reference clock source changes, then reset to previous value after
   1226                 reference clock changes.
   1227               */
   1228              if (kMCG_FllSrcInternal == MCG_S_IREFST_VAL)
   \        0xC   0x....             LDR.N    R5,??DataTable40  ;; 0x40064006
   \        0xE   0x782C             LDRB     R4,[R5, #+0]
   \       0x10   0xF3C4 0x1400      UBFX     R4,R4,#+4,#+1
   \       0x14   0x2C00             CMP      R4,#+0
   \       0x16   0xD005             BEQ.N    ??CLOCK_SetFeeMode_0
   1229              {
   1230                  change_drs = true;
   \       0x18   0xF04F 0x0C01      MOV      R12,#+1
   1231                  /* Change the LSB of DRST_DRS. */
   1232                  MCG->C4 ^= (1U << MCG_C4_DRST_DRS_SHIFT);
   \       0x1C   0x7834             LDRB     R4,[R6, #+0]
   \       0x1E   0xF084 0x0420      EOR      R4,R4,#0x20
   \       0x22   0x7034             STRB     R4,[R6, #+0]
   1233              }
   1234          
   1235              /* Set CLKS and IREFS. */
   1236              MCG->C1 = ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK)) |
   1237                         (MCG_C1_CLKS(kMCG_ClkOutSrcOut)         /* CLKS = 0 */
   1238                          | MCG_C1_FRDIV(frdiv)                  /* FRDIV */
   1239                          | MCG_C1_IREFS(kMCG_FllSrcExternal))); /* IREFS = 0 */
   \                     ??CLOCK_SetFeeMode_0: (+1)
   \       0x24   0x....             LDR.N    R4,??DataTable38_5  ;; 0x40064000
   \       0x26   0xF894 0xE000      LDRB     LR,[R4, #+0]
   \       0x2A   0xF00E 0x0E03      AND      LR,LR,#0x3
   \       0x2E   0x00C0             LSLS     R0,R0,#+3
   \       0x30   0xF000 0x0038      AND      R0,R0,#0x38
   \       0x34   0xEA40 0x000E      ORR      R0,R0,LR
   \       0x38   0x7020             STRB     R0,[R4, #+0]
   1240          
   1241              /* If use external crystal as clock source, wait for it stable. */
   1242              if (MCG_C7_OSCSEL(kMCG_OscselOsc) == (MCG->C7 & MCG_C7_OSCSEL_MASK))
   \       0x3A   0x....             LDR.N    R0,??DataTable38  ;; 0x4006400c
   \       0x3C   0x7800             LDRB     R0,[R0, #+0]
   \       0x3E   0x07C0             LSLS     R0,R0,#+31
   \       0x40   0xD407             BMI.N    ??CLOCK_SetFeeMode_1
   1243              {
   1244                  if (MCG->C2 & MCG_C2_EREFS_MASK)
   \       0x42   0x.... 0x....      LDR.W    R0,??DataTable49_12  ;; 0x40064001
   \       0x46   0x7800             LDRB     R0,[R0, #+0]
   \       0x48   0x0740             LSLS     R0,R0,#+29
   \       0x4A   0xD502             BPL.N    ??CLOCK_SetFeeMode_1
   1245                  {
   1246                      while (!(MCG->S & MCG_S_OSCINIT0_MASK))
   \                     ??CLOCK_SetFeeMode_2: (+1)
   \       0x4C   0x7828             LDRB     R0,[R5, #+0]
   \       0x4E   0x0780             LSLS     R0,R0,#+30
   \       0x50   0xD5FC             BPL.N    ??CLOCK_SetFeeMode_2
   1247                      {
   1248                      }
   1249                  }
   1250              }
   1251          
   1252              /* Wait and check status. */
   1253              while (kMCG_FllSrcExternal != MCG_S_IREFST_VAL)
   \                     ??CLOCK_SetFeeMode_1: (+1)
   \       0x52   0x7828             LDRB     R0,[R5, #+0]
   \       0x54   0xF3C0 0x1000      UBFX     R0,R0,#+4,#+1
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD1FA             BNE.N    ??CLOCK_SetFeeMode_1
   1254              {
   1255              }
   1256          
   1257              /* Errata: ERR007993 */
   1258              if (change_drs)
   \       0x5C   0xF1BC 0x0F00      CMP      R12,#+0
   \       0x60   0xD000             BEQ.N    ??CLOCK_SetFeeMode_3
   1259              {
   1260                  MCG->C4 = mcg_c4;
   \       0x62   0x7037             STRB     R7,[R6, #+0]
   1261              }
   1262          
   1263              /* Set DRS and DMX32. */
   1264              mcg_c4 = ((mcg_c4 & ~(MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) | (MCG_C4_DMX32(dmx32) | MCG_C4_DRST_DRS(drs)));
   \                     ??CLOCK_SetFeeMode_3: (+1)
   \       0x64   0xF007 0x071F      AND      R7,R7,#0x1F
   \       0x68   0xEA47 0x17C1      ORR      R7,R7,R1, LSL #+7
   \       0x6C   0x0152             LSLS     R2,R2,#+5
   \       0x6E   0xF002 0x0260      AND      R2,R2,#0x60
   \       0x72   0x433A             ORRS     R2,R2,R7
   \       0x74   0xB2D2             UXTB     R2,R2
   1265              MCG->C4 = mcg_c4;
   \       0x76   0x7032             STRB     R2,[R6, #+0]
   1266          
   1267              /* Wait for DRST_DRS update. */
   1268              while (MCG->C4 != mcg_c4)
   \                     ??CLOCK_SetFeeMode_4: (+1)
   \       0x78   0x7830             LDRB     R0,[R6, #+0]
   \       0x7A   0x4290             CMP      R0,R2
   \       0x7C   0xD1FC             BNE.N    ??CLOCK_SetFeeMode_4
   1269              {
   1270              }
   1271          
   1272              /* Check MCG_S[CLKST] */
   1273              while (kMCG_ClkOutStatFll != MCG_S_CLKST_VAL)
   \                     ??CLOCK_SetFeeMode_5: (+1)
   \       0x7E   0x7828             LDRB     R0,[R5, #+0]
   \       0x80   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0xD1FA             BNE.N    ??CLOCK_SetFeeMode_5
   1274              {
   1275              }
   1276          
   1277              /* Wait for FLL stable time. */
   1278              if (fllStableDelay)
   \       0x88   0x0018             MOVS     R0,R3
   \       0x8A   0xD000             BEQ.N    ??CLOCK_SetFeeMode_6
   1279              {
   1280                  fllStableDelay();
   \       0x8C   0x4798             BLX      R3
   1281              }
   1282          
   1283              return kStatus_Success;
   \                     ??CLOCK_SetFeeMode_6: (+1)
   \       0x8E   0x2000             MOVS     R0,#+0
   \       0x90   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1284          }
   1285          

   \                                 In section .text, align 2, keep-with-next
   1286          status_t CLOCK_SetFbiMode(mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(void))
   1287          {
   \                     CLOCK_SetFbiMode: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4603             MOV      R3,R0
   1288              uint8_t mcg_c4;
   1289              bool change_drs = false;
   \        0x4   0x2600             MOVS     R6,#+0
   1290          
   1291          #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
   1292              mcg_mode_t mode = CLOCK_GetMode();
   1293          
   1294              if (!((kMCG_ModeFEE == mode) || (kMCG_ModeFBI == mode) || (kMCG_ModeFBE == mode) || (kMCG_ModeFEI == mode) ||
   1295                    (kMCG_ModeBLPI == mode)))
   1296          
   1297              {
   1298                  return kStatus_MCG_ModeUnreachable;
   1299              }
   1300          #endif
   1301          
   1302              mcg_c4 = MCG->C4;
   \        0x6   0x.... 0x....      LDR.W    R4,??DataTable48_5  ;; 0x40064003
   \        0xA   0x7825             LDRB     R5,[R4, #+0]
   1303          
   1304              MCG->C2 &= ~MCG_C2_LP_MASK; /* Disable lowpower. */
   \        0xC   0x....             LDR.N    R0,??DataTable38_6  ;; 0x40064001
   \        0xE   0x7807             LDRB     R7,[R0, #+0]
   \       0x10   0xF007 0x07FD      AND      R7,R7,#0xFD
   \       0x14   0x7007             STRB     R7,[R0, #+0]
   1305          
   1306              /*
   1307                 Errata: ERR007993
   1308                 Workaround: Invert MCG_C4[DMX32] or change MCG_C4[DRST_DRS] before
   1309                 reference clock source changes, then reset to previous value after
   1310                 reference clock changes.
   1311               */
   1312              if (kMCG_FllSrcExternal == MCG_S_IREFST_VAL)
   \       0x16   0x....             LDR.N    R7,??DataTable40  ;; 0x40064006
   \       0x18   0x7838             LDRB     R0,[R7, #+0]
   \       0x1A   0xF3C0 0x1000      UBFX     R0,R0,#+4,#+1
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD104             BNE.N    ??CLOCK_SetFbiMode_0
   1313              {
   1314                  change_drs = true;
   \       0x22   0x2601             MOVS     R6,#+1
   1315                  /* Change the LSB of DRST_DRS. */
   1316                  MCG->C4 ^= (1U << MCG_C4_DRST_DRS_SHIFT);
   \       0x24   0x7820             LDRB     R0,[R4, #+0]
   \       0x26   0xF080 0x0020      EOR      R0,R0,#0x20
   \       0x2A   0x7020             STRB     R0,[R4, #+0]
   1317              }
   1318          
   1319              /* Set CLKS and IREFS. */
   1320              MCG->C1 =
   1321                  ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK)) | (MCG_C1_CLKS(kMCG_ClkOutSrcInternal)    /* CLKS = 1 */
   1322                                                                          | MCG_C1_IREFS(kMCG_FllSrcInternal))); /* IREFS = 1 */
   \                     ??CLOCK_SetFbiMode_0: (+1)
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable49_2  ;; 0x40064000
   \       0x30   0xF890 0xC000      LDRB     R12,[R0, #+0]
   \       0x34   0xF00C 0x0C3B      AND      R12,R12,#0x3B
   \       0x38   0xF04C 0x0C44      ORR      R12,R12,#0x44
   \       0x3C   0xF880 0xC000      STRB     R12,[R0, #+0]
   1323          
   1324              /* Wait and check status. */
   1325              while (kMCG_FllSrcInternal != MCG_S_IREFST_VAL)
   \                     ??CLOCK_SetFbiMode_1: (+1)
   \       0x40   0x7838             LDRB     R0,[R7, #+0]
   \       0x42   0xF3C0 0x1000      UBFX     R0,R0,#+4,#+1
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD0FA             BEQ.N    ??CLOCK_SetFbiMode_1
   1326              {
   1327              }
   1328          
   1329              /* Errata: ERR007993 */
   1330              if (change_drs)
   \       0x4A   0x2E00             CMP      R6,#+0
   \       0x4C   0xD000             BEQ.N    ??CLOCK_SetFbiMode_2
   1331              {
   1332                  MCG->C4 = mcg_c4;
   \       0x4E   0x7025             STRB     R5,[R4, #+0]
   1333              }
   1334          
   1335              while (kMCG_ClkOutStatInt != MCG_S_CLKST_VAL)
   \                     ??CLOCK_SetFbiMode_2: (+1)
   \       0x50   0x7838             LDRB     R0,[R7, #+0]
   \       0x52   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \       0x56   0x2801             CMP      R0,#+1
   \       0x58   0xD1FA             BNE.N    ??CLOCK_SetFbiMode_2
   1336              {
   1337              }
   1338          
   1339              MCG->C4 = (mcg_c4 & ~(MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) | (MCG_C4_DMX32(dmx32) | MCG_C4_DRST_DRS(drs));
   \       0x5A   0xF005 0x051F      AND      R5,R5,#0x1F
   \       0x5E   0xEA45 0x15C3      ORR      R5,R5,R3, LSL #+7
   \       0x62   0x0149             LSLS     R1,R1,#+5
   \       0x64   0xF001 0x0160      AND      R1,R1,#0x60
   \       0x68   0x4329             ORRS     R1,R1,R5
   \       0x6A   0x7021             STRB     R1,[R4, #+0]
   1340          
   1341              /* Wait for FLL stable time. */
   1342              if (fllStableDelay)
   \       0x6C   0x0010             MOVS     R0,R2
   \       0x6E   0xD000             BEQ.N    ??CLOCK_SetFbiMode_3
   1343              {
   1344                  fllStableDelay();
   \       0x70   0x4790             BLX      R2
   1345              }
   1346          
   1347              return kStatus_Success;
   \                     ??CLOCK_SetFbiMode_3: (+1)
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1348          }
   1349          

   \                                 In section .text, align 2, keep-with-next
   1350          status_t CLOCK_SetFbeMode(uint8_t frdiv, mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(void))
   1351          {
   \                     CLOCK_SetFbeMode: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   1352              uint8_t mcg_c4;
   1353              bool change_drs = false;
   \        0x2   0x2200             MOVS     R2,#+0
   1354          
   1355          #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
   1356              mcg_mode_t mode = CLOCK_GetMode();
   1357              if (!((kMCG_ModeFEE == mode) || (kMCG_ModeFBI == mode) || (kMCG_ModeFBE == mode) || (kMCG_ModeFEI == mode) ||
   1358                    (kMCG_ModePBE == mode) || (kMCG_ModeBLPE == mode)))
   1359              {
   1360                  return kStatus_MCG_ModeUnreachable;
   1361              }
   1362          #endif
   1363          
   1364              /* Change to FLL mode. */
   1365              MCG->C6 &= ~MCG_C6_PLLS_MASK;
   \        0x4   0x.... 0x....      LDR.W    R1,??DataTable49_3  ;; 0x40064005
   \        0x8   0x780C             LDRB     R4,[R1, #+0]
   \        0xA   0xF004 0x04BF      AND      R4,R4,#0xBF
   \        0xE   0x700C             STRB     R4,[R1, #+0]
   \       0x10   0x....             LDR.N    R4,??DataTable40  ;; 0x40064006
   1366              while (MCG->S & MCG_S_PLLST_MASK)
   \                     ??CLOCK_SetFbeMode_0: (+1)
   \       0x12   0x7821             LDRB     R1,[R4, #+0]
   \       0x14   0x0689             LSLS     R1,R1,#+26
   \       0x16   0xD4FC             BMI.N    ??CLOCK_SetFbeMode_0
   1367              {
   1368              }
   1369          
   1370              /* Set LP bit to enable the FLL */
   1371              MCG->C2 &= ~MCG_C2_LP_MASK;
   \       0x18   0x.... 0x....      LDR.W    R5,??DataTable49_12  ;; 0x40064001
   \       0x1C   0x7829             LDRB     R1,[R5, #+0]
   \       0x1E   0xF001 0x01FD      AND      R1,R1,#0xFD
   \       0x22   0x7029             STRB     R1,[R5, #+0]
   1372          
   1373              mcg_c4 = MCG->C4;
   \       0x24   0x....             LDR.N    R6,??DataTable48_5  ;; 0x40064003
   \       0x26   0x7837             LDRB     R7,[R6, #+0]
   1374          
   1375              /*
   1376                 Errata: ERR007993
   1377                 Workaround: Invert MCG_C4[DMX32] or change MCG_C4[DRST_DRS] before
   1378                 reference clock source changes, then reset to previous value after
   1379                 reference clock changes.
   1380               */
   1381              if (kMCG_FllSrcInternal == MCG_S_IREFST_VAL)
   \       0x28   0x7821             LDRB     R1,[R4, #+0]
   \       0x2A   0xF3C1 0x1100      UBFX     R1,R1,#+4,#+1
   \       0x2E   0x2900             CMP      R1,#+0
   \       0x30   0xD004             BEQ.N    ??CLOCK_SetFbeMode_1
   1382              {
   1383                  change_drs = true;
   \       0x32   0x2201             MOVS     R2,#+1
   1384                  /* Change the LSB of DRST_DRS. */
   1385                  MCG->C4 ^= (1U << MCG_C4_DRST_DRS_SHIFT);
   \       0x34   0x7831             LDRB     R1,[R6, #+0]
   \       0x36   0xF081 0x0120      EOR      R1,R1,#0x20
   \       0x3A   0x7031             STRB     R1,[R6, #+0]
   1386              }
   1387          
   1388              /* Set CLKS and IREFS. */
   1389              MCG->C1 = ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK)) |
   1390                         (MCG_C1_CLKS(kMCG_ClkOutSrcExternal)    /* CLKS = 2 */
   1391                          | MCG_C1_FRDIV(frdiv)                  /* FRDIV = frdiv */
   1392                          | MCG_C1_IREFS(kMCG_FllSrcExternal))); /* IREFS = 0 */
   \                     ??CLOCK_SetFbeMode_1: (+1)
   \       0x3C   0x.... 0x....      LDR.W    R1,??DataTable49_2  ;; 0x40064000
   \       0x40   0xF891 0xC000      LDRB     R12,[R1, #+0]
   \       0x44   0xF00C 0x0C03      AND      R12,R12,#0x3
   \       0x48   0x00C0             LSLS     R0,R0,#+3
   \       0x4A   0xF000 0x0038      AND      R0,R0,#0x38
   \       0x4E   0xEA40 0x000C      ORR      R0,R0,R12
   \       0x52   0xF040 0x0080      ORR      R0,R0,#0x80
   \       0x56   0x7008             STRB     R0,[R1, #+0]
   1393          
   1394              /* If use external crystal as clock source, wait for it stable. */
   1395              if (MCG_C7_OSCSEL(kMCG_OscselOsc) == (MCG->C7 & MCG_C7_OSCSEL_MASK))
   \       0x58   0x.... 0x....      LDR.W    R0,??DataTable49_4  ;; 0x4006400c
   \       0x5C   0x7800             LDRB     R0,[R0, #+0]
   \       0x5E   0x07C0             LSLS     R0,R0,#+31
   \       0x60   0xD405             BMI.N    ??CLOCK_SetFbeMode_2
   1396              {
   1397                  if (MCG->C2 & MCG_C2_EREFS_MASK)
   \       0x62   0x7828             LDRB     R0,[R5, #+0]
   \       0x64   0x0740             LSLS     R0,R0,#+29
   \       0x66   0xD502             BPL.N    ??CLOCK_SetFbeMode_2
   1398                  {
   1399                      while (!(MCG->S & MCG_S_OSCINIT0_MASK))
   \                     ??CLOCK_SetFbeMode_3: (+1)
   \       0x68   0x7820             LDRB     R0,[R4, #+0]
   \       0x6A   0x0780             LSLS     R0,R0,#+30
   \       0x6C   0xD5FC             BPL.N    ??CLOCK_SetFbeMode_3
   1400                      {
   1401                      }
   1402                  }
   1403              }
   1404          
   1405              /* Wait for Reference clock Status bit to clear */
   1406              while (kMCG_FllSrcExternal != MCG_S_IREFST_VAL)
   \                     ??CLOCK_SetFbeMode_2: (+1)
   \       0x6E   0x7820             LDRB     R0,[R4, #+0]
   \       0x70   0xF3C0 0x1000      UBFX     R0,R0,#+4,#+1
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD1FA             BNE.N    ??CLOCK_SetFbeMode_2
   1407              {
   1408              }
   1409          
   1410              /* Errata: ERR007993 */
   1411              if (change_drs)
   \       0x78   0x2A00             CMP      R2,#+0
   \       0x7A   0xD000             BEQ.N    ??CLOCK_SetFbeMode_4
   1412              {
   1413                  MCG->C4 = mcg_c4;
   \       0x7C   0x7037             STRB     R7,[R6, #+0]
   1414              }
   1415          
   1416              /* Set DRST_DRS and DMX32. */
   1417              mcg_c4 = ((mcg_c4 & ~(MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) | (MCG_C4_DMX32(dmx32) | MCG_C4_DRST_DRS(drs)));
   1418          
   1419              /* Wait for clock status bits to show clock source is ext ref clk */
   1420              while (kMCG_ClkOutStatExt != MCG_S_CLKST_VAL)
   \                     ??CLOCK_SetFbeMode_4: (+1)
   \       0x7E   0x7820             LDRB     R0,[R4, #+0]
   \       0x80   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \       0x84   0x2802             CMP      R0,#+2
   \       0x86   0xD1FA             BNE.N    ??CLOCK_SetFbeMode_4
   1421              {
   1422              }
   1423          
   1424              /* Wait for fll stable time. */
   1425              if (fllStableDelay)
   \       0x88   0x0018             MOVS     R0,R3
   \       0x8A   0xD000             BEQ.N    ??CLOCK_SetFbeMode_5
   1426              {
   1427                  fllStableDelay();
   \       0x8C   0x4798             BLX      R3
   1428              }
   1429          
   1430              return kStatus_Success;
   \                     ??CLOCK_SetFbeMode_5: (+1)
   \       0x8E   0x2000             MOVS     R0,#+0
   \       0x90   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1431          }
   1432          

   \                                 In section .text, align 2, keep-with-next
   1433          status_t CLOCK_SetBlpiMode(void)
   1434          {
   1435          #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
   1436              if (MCG_S_CLKST_VAL != kMCG_ClkOutStatInt)
   1437              {
   1438                  return kStatus_MCG_ModeUnreachable;
   1439              }
   1440          #endif /* MCG_CONFIG_CHECK_PARAM */
   1441          
   1442              /* Set LP. */
   1443              MCG->C2 |= MCG_C2_LP_MASK;
   \                     CLOCK_SetBlpiMode: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable49_12  ;; 0x40064001
   \        0x4   0x7801             LDRB     R1,[R0, #+0]
   \        0x6   0xF041 0x0102      ORR      R1,R1,#0x2
   \        0xA   0x7001             STRB     R1,[R0, #+0]
   1444          
   1445              return kStatus_Success;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x4770             BX       LR               ;; return
   1446          }
   1447          

   \                                 In section .text, align 2, keep-with-next
   1448          status_t CLOCK_SetBlpeMode(void)
   1449          {
   1450          #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
   1451              if (MCG_S_CLKST_VAL != kMCG_ClkOutStatExt)
   1452              {
   1453                  return kStatus_MCG_ModeUnreachable;
   1454              }
   1455          #endif
   1456          
   1457              /* Set LP bit to enter BLPE mode. */
   1458              MCG->C2 |= MCG_C2_LP_MASK;
   \                     CLOCK_SetBlpeMode: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable49_12  ;; 0x40064001
   \        0x4   0x7801             LDRB     R1,[R0, #+0]
   \        0x6   0xF041 0x0102      ORR      R1,R1,#0x2
   \        0xA   0x7001             STRB     R1,[R0, #+0]
   1459          
   1460              return kStatus_Success;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x4770             BX       LR               ;; return
   1461          }
   1462          

   \                                 In section .text, align 2, keep-with-next
   1463          status_t CLOCK_SetPbeMode(mcg_pll_clk_select_t pllcs, mcg_pll_config_t const *config)
   1464          {
   \                     CLOCK_SetPbeMode: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x000C             MOVS     R4,R1
   1465              assert(config);
   \        0x4   0xD109             BNE.N    ??CLOCK_SetPbeMode_0
   \        0x6   0xF240 0x52B9      MOVW     R2,#+1465
   \        0xA   0x.... 0x....      LDR.W    R1,??DataTable49_17
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable49_10
   \       0x12   0x.... 0x....      BL       __aeabi_assert
   \       0x16   0x.... 0x....      BL       __iar_EmptyStepPoint
   1466          
   1467              /*
   1468                 This function is designed to change MCG to PBE mode from PEE/BLPE/FBE,
   1469                 but with this workflow, the source mode could be all modes except PEI/PBI.
   1470               */
   1471              MCG->C2 &= ~MCG_C2_LP_MASK; /* Disable lowpower. */
   \                     ??CLOCK_SetPbeMode_0: (+1)
   \       0x1A   0x.... 0x....      LDR.W    R0,??DataTable49_12  ;; 0x40064001
   \       0x1E   0x7801             LDRB     R1,[R0, #+0]
   \       0x20   0xF001 0x01FD      AND      R1,R1,#0xFD
   \       0x24   0x7001             STRB     R1,[R0, #+0]
   1472          
   1473              /* Change to use external clock first. */
   1474              MCG->C1 = ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK)) | MCG_C1_CLKS(kMCG_ClkOutSrcExternal));
   \       0x26   0x....             LDR.N    R0,??DataTable49_2  ;; 0x40064000
   \       0x28   0x7801             LDRB     R1,[R0, #+0]
   \       0x2A   0xF001 0x013B      AND      R1,R1,#0x3B
   \       0x2E   0xF041 0x0180      ORR      R1,R1,#0x80
   \       0x32   0x7001             STRB     R1,[R0, #+0]
   \       0x34   0x....             LDR.N    R5,??DataTable49  ;; 0x40064006
   1475          
   1476              /* Wait for CLKST clock status bits to show clock source is ext ref clk */
   1477              while ((MCG->S & (MCG_S_IREFST_MASK | MCG_S_CLKST_MASK)) !=
   1478                     (MCG_S_IREFST(kMCG_FllSrcExternal) | MCG_S_CLKST(kMCG_ClkOutStatExt)))
   \                     ??CLOCK_SetPbeMode_1: (+1)
   \       0x36   0x7828             LDRB     R0,[R5, #+0]
   \       0x38   0xF000 0x001C      AND      R0,R0,#0x1C
   \       0x3C   0x2808             CMP      R0,#+8
   \       0x3E   0xD1FA             BNE.N    ??CLOCK_SetPbeMode_1
   1479              {
   1480              }
   1481          
   1482              /* Disable PLL first, then configure PLL. */
   1483              MCG->C6 &= ~MCG_C6_PLLS_MASK;
   \       0x40   0x....             LDR.N    R6,??DataTable49_3  ;; 0x40064005
   \       0x42   0x7830             LDRB     R0,[R6, #+0]
   \       0x44   0xF000 0x00BF      AND      R0,R0,#0xBF
   \       0x48   0x7030             STRB     R0,[R6, #+0]
   1484              while (MCG->S & MCG_S_PLLST_MASK)
   \                     ??CLOCK_SetPbeMode_2: (+1)
   \       0x4A   0x7828             LDRB     R0,[R5, #+0]
   \       0x4C   0x0680             LSLS     R0,R0,#+26
   \       0x4E   0xD4FC             BMI.N    ??CLOCK_SetPbeMode_2
   1485              {
   1486              }
   1487          
   1488              /* Configure the PLL. */
   1489              {
   1490                  CLOCK_EnablePll0(config);
   \       0x50   0x4620             MOV      R0,R4
   \       0x52   0x.... 0x....      BL       CLOCK_EnablePll0
   1491              }
   1492          
   1493              /* Change to PLL mode. */
   1494              MCG->C6 |= MCG_C6_PLLS_MASK;
   \       0x56   0x7830             LDRB     R0,[R6, #+0]
   \       0x58   0xF040 0x0040      ORR      R0,R0,#0x40
   \       0x5C   0x7030             STRB     R0,[R6, #+0]
   1495          
   1496              /* Wait for PLL mode changed. */
   1497              while (!(MCG->S & MCG_S_PLLST_MASK))
   \                     ??CLOCK_SetPbeMode_3: (+1)
   \       0x5E   0x7828             LDRB     R0,[R5, #+0]
   \       0x60   0x0680             LSLS     R0,R0,#+26
   \       0x62   0xD5FC             BPL.N    ??CLOCK_SetPbeMode_3
   1498              {
   1499              }
   1500          
   1501              return kStatus_Success;
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0xBD70             POP      {R4-R6,PC}       ;; return
   1502          }
   1503          

   \                                 In section .text, align 2, keep-with-next
   1504          status_t CLOCK_SetPeeMode(void)
   1505          {
   1506          #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
   1507              mcg_mode_t mode = CLOCK_GetMode();
   1508              if (kMCG_ModePBE != mode)
   1509              {
   1510                  return kStatus_MCG_ModeUnreachable;
   1511              }
   1512          #endif
   1513          
   1514              /* Change to use PLL/FLL output clock first. */
   1515              MCG->C1 = (MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcOut);
   \                     CLOCK_SetPeeMode: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable49_2  ;; 0x40064000
   \        0x2   0x7801             LDRB     R1,[R0, #+0]
   \        0x4   0xF001 0x013F      AND      R1,R1,#0x3F
   \        0x8   0x7001             STRB     R1,[R0, #+0]
   1516          
   1517              /* Wait for clock status bits to update */
   1518              while (MCG_S_CLKST_VAL != kMCG_ClkOutStatPll)
   \                     ??CLOCK_SetPeeMode_0: (+1)
   \        0xA   0x....             LDR.N    R0,??DataTable49  ;; 0x40064006
   \        0xC   0x7800             LDRB     R0,[R0, #+0]
   \        0xE   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \       0x12   0x2803             CMP      R0,#+3
   \       0x14   0xD1F9             BNE.N    ??CLOCK_SetPeeMode_0
   1519              {
   1520              }
   1521          
   1522              return kStatus_Success;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x4770             BX       LR               ;; return
   1523          }
   1524          

   \                                 In section .text, align 2, keep-with-next
   1525          status_t CLOCK_ExternalModeToFbeModeQuick(void)
   1526          {
   1527          #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
   1528              if (MCG->S & MCG_S_IREFST_MASK)
   1529              {
   1530                  return kStatus_MCG_ModeInvalid;
   1531              }
   1532          #endif /* MCG_CONFIG_CHECK_PARAM */
   1533          
   1534              /* Disable low power */
   1535              MCG->C2 &= ~MCG_C2_LP_MASK;
   \                     CLOCK_ExternalModeToFbeModeQuick: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable49_12  ;; 0x40064001
   \        0x2   0x7801             LDRB     R1,[R0, #+0]
   \        0x4   0xF001 0x01FD      AND      R1,R1,#0xFD
   \        0x8   0x7001             STRB     R1,[R0, #+0]
   1536          
   1537              MCG->C1 = ((MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcExternal));
   \        0xA   0x....             LDR.N    R0,??DataTable49_2  ;; 0x40064000
   \        0xC   0x7801             LDRB     R1,[R0, #+0]
   \        0xE   0xF001 0x013F      AND      R1,R1,#0x3F
   \       0x12   0xF041 0x0180      ORR      R1,R1,#0x80
   \       0x16   0x7001             STRB     R1,[R0, #+0]
   \       0x18   0x....             LDR.N    R0,??DataTable49  ;; 0x40064006
   1538              while (MCG_S_CLKST_VAL != kMCG_ClkOutStatExt)
   \                     ??CLOCK_ExternalModeToFbeModeQuick_0: (+1)
   \       0x1A   0x7801             LDRB     R1,[R0, #+0]
   \       0x1C   0xF3C1 0x0181      UBFX     R1,R1,#+2,#+2
   \       0x20   0x2902             CMP      R1,#+2
   \       0x22   0xD1FA             BNE.N    ??CLOCK_ExternalModeToFbeModeQuick_0
   1539              {
   1540              }
   1541          
   1542              /* Disable PLL. */
   1543              MCG->C6 &= ~MCG_C6_PLLS_MASK;
   \       0x24   0x....             LDR.N    R1,??DataTable49_3  ;; 0x40064005
   \       0x26   0x780A             LDRB     R2,[R1, #+0]
   \       0x28   0xF002 0x02BF      AND      R2,R2,#0xBF
   \       0x2C   0x700A             STRB     R2,[R1, #+0]
   1544              while (MCG->S & MCG_S_PLLST_MASK)
   \                     ??CLOCK_ExternalModeToFbeModeQuick_1: (+1)
   \       0x2E   0x7801             LDRB     R1,[R0, #+0]
   \       0x30   0x0689             LSLS     R1,R1,#+26
   \       0x32   0xD4FC             BMI.N    ??CLOCK_ExternalModeToFbeModeQuick_1
   1545              {
   1546              }
   1547          
   1548              return kStatus_Success;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0x4770             BX       LR               ;; return
   1549          }
   1550          

   \                                 In section .text, align 2, keep-with-next
   1551          status_t CLOCK_InternalModeToFbiModeQuick(void)
   1552          {
   1553          #if (defined(MCG_CONFIG_CHECK_PARAM) && MCG_CONFIG_CHECK_PARAM)
   1554              if (!(MCG->S & MCG_S_IREFST_MASK))
   1555              {
   1556                  return kStatus_MCG_ModeInvalid;
   1557              }
   1558          #endif
   1559          
   1560              /* Disable low power */
   1561              MCG->C2 &= ~MCG_C2_LP_MASK;
   \                     CLOCK_InternalModeToFbiModeQuick: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable49_12  ;; 0x40064001
   \        0x2   0x7801             LDRB     R1,[R0, #+0]
   \        0x4   0xF001 0x01FD      AND      R1,R1,#0xFD
   \        0x8   0x7001             STRB     R1,[R0, #+0]
   1562          
   1563              MCG->C1 = ((MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcInternal));
   \        0xA   0x....             LDR.N    R0,??DataTable49_2  ;; 0x40064000
   \        0xC   0x7801             LDRB     R1,[R0, #+0]
   \        0xE   0xF001 0x013F      AND      R1,R1,#0x3F
   \       0x12   0xF041 0x0140      ORR      R1,R1,#0x40
   \       0x16   0x7001             STRB     R1,[R0, #+0]
   1564              while (MCG_S_CLKST_VAL != kMCG_ClkOutStatInt)
   \                     ??CLOCK_InternalModeToFbiModeQuick_0: (+1)
   \       0x18   0x....             LDR.N    R0,??DataTable49  ;; 0x40064006
   \       0x1A   0x7800             LDRB     R0,[R0, #+0]
   \       0x1C   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD1F9             BNE.N    ??CLOCK_InternalModeToFbiModeQuick_0
   1565              {
   1566              }
   1567          
   1568              return kStatus_Success;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x4770             BX       LR               ;; return
   1569          }
   1570          

   \                                 In section .text, align 2, keep-with-next
   1571          status_t CLOCK_BootToFeiMode(mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(void))
   1572          {
   1573              return CLOCK_SetFeiMode(dmx32, drs, fllStableDelay);
   \                     CLOCK_BootToFeiMode: (+1)
   \        0x0   0x....             B.N      CLOCK_SetFeiMode
   1574          }
   1575          

   \                                 In section .text, align 2, keep-with-next
   1576          status_t CLOCK_BootToFeeMode(
   1577              mcg_oscsel_t oscsel, uint8_t frdiv, mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(void))
   1578          {
   \                     CLOCK_BootToFeeMode: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x460C             MOV      R4,R1
   \        0x4   0x4615             MOV      R5,R2
   \        0x6   0x461E             MOV      R6,R3
   \        0x8   0x9F06             LDR      R7,[SP, #+24]
   1579              CLOCK_SetExternalRefClkConfig(oscsel);
   \        0xA   0x.... 0x....      BL       CLOCK_SetExternalRefClkConfig
   1580          
   1581              return CLOCK_SetFeeMode(frdiv, dmx32, drs, fllStableDelay);
   \        0xE   0x463B             MOV      R3,R7
   \       0x10   0x4632             MOV      R2,R6
   \       0x12   0x4629             MOV      R1,R5
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0xB001             ADD      SP,SP,#+4
   \       0x18   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \       0x1C   0x....             B.N      CLOCK_SetFeeMode
   1582          }
   1583          

   \                                 In section .text, align 2, keep-with-next
   1584          status_t CLOCK_BootToBlpiMode(uint8_t fcrdiv, mcg_irc_mode_t ircs, uint8_t ircEnableMode)
   1585          {
   \                     CLOCK_BootToBlpiMode: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x4613             MOV      R3,R2
   1586              /* If reset mode is FEI mode, set MCGIRCLK and always success. */
   1587              CLOCK_SetInternalRefClkConfig(ircEnableMode, ircs, fcrdiv);
   \        0x4   0x4602             MOV      R2,R0
   \        0x6   0x4618             MOV      R0,R3
   \        0x8   0x.... 0x....      BL       CLOCK_SetInternalRefClkConfig
   1588          
   1589              /* If reset mode is not BLPI, first enter FBI mode. */
   1590              MCG->C1 = (MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcInternal);
   \        0xC   0x....             LDR.N    R0,??DataTable49_2  ;; 0x40064000
   \        0xE   0x7801             LDRB     R1,[R0, #+0]
   \       0x10   0xF001 0x013F      AND      R1,R1,#0x3F
   \       0x14   0xF041 0x0140      ORR      R1,R1,#0x40
   \       0x18   0x7001             STRB     R1,[R0, #+0]
   1591              while (MCG_S_CLKST_VAL != kMCG_ClkOutStatInt)
   \                     ??CLOCK_BootToBlpiMode_0: (+1)
   \       0x1A   0x....             LDR.N    R0,??DataTable49  ;; 0x40064006
   \       0x1C   0x7800             LDRB     R0,[R0, #+0]
   \       0x1E   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \       0x22   0x2801             CMP      R0,#+1
   \       0x24   0xD1F9             BNE.N    ??CLOCK_BootToBlpiMode_0
   1592              {
   1593              }
   1594          
   1595              /* Enter BLPI mode. */
   1596              MCG->C2 |= MCG_C2_LP_MASK;
   \       0x26   0x....             LDR.N    R0,??DataTable49_12  ;; 0x40064001
   \       0x28   0x7801             LDRB     R1,[R0, #+0]
   \       0x2A   0xF041 0x0102      ORR      R1,R1,#0x2
   \       0x2E   0x7001             STRB     R1,[R0, #+0]
   1597          
   1598              return kStatus_Success;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0xBD02             POP      {R1,PC}          ;; return
   1599          }
   1600          

   \                                 In section .text, align 2, keep-with-next
   1601          status_t CLOCK_BootToBlpeMode(mcg_oscsel_t oscsel)
   1602          {
   \                     CLOCK_BootToBlpeMode: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1603              CLOCK_SetExternalRefClkConfig(oscsel);
   \        0x2   0x.... 0x....      BL       CLOCK_SetExternalRefClkConfig
   1604          
   1605              /* Set to FBE mode. */
   1606              MCG->C1 =
   1607                  ((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK)) | (MCG_C1_CLKS(kMCG_ClkOutSrcExternal)    /* CLKS = 2 */
   1608                                                                          | MCG_C1_IREFS(kMCG_FllSrcExternal))); /* IREFS = 0 */
   \        0x6   0x....             LDR.N    R0,??DataTable49_2  ;; 0x40064000
   \        0x8   0x7801             LDRB     R1,[R0, #+0]
   \        0xA   0xF001 0x013B      AND      R1,R1,#0x3B
   \        0xE   0xF041 0x0180      ORR      R1,R1,#0x80
   \       0x12   0x7001             STRB     R1,[R0, #+0]
   1609          
   1610              /* If use external crystal as clock source, wait for it stable. */
   1611              if (MCG_C7_OSCSEL(kMCG_OscselOsc) == (MCG->C7 & MCG_C7_OSCSEL_MASK))
   \       0x14   0x....             LDR.N    R0,??DataTable49_4  ;; 0x4006400c
   \       0x16   0x7800             LDRB     R0,[R0, #+0]
   \       0x18   0x07C0             LSLS     R0,R0,#+31
   \       0x1A   0xD407             BMI.N    ??CLOCK_BootToBlpeMode_0
   1612              {
   1613                  if (MCG->C2 & MCG_C2_EREFS_MASK)
   \       0x1C   0x....             LDR.N    R0,??DataTable49_12  ;; 0x40064001
   \       0x1E   0x7800             LDRB     R0,[R0, #+0]
   \       0x20   0x0740             LSLS     R0,R0,#+29
   \       0x22   0xD503             BPL.N    ??CLOCK_BootToBlpeMode_0
   1614                  {
   1615                      while (!(MCG->S & MCG_S_OSCINIT0_MASK))
   \                     ??CLOCK_BootToBlpeMode_1: (+1)
   \       0x24   0x....             LDR.N    R0,??DataTable49  ;; 0x40064006
   \       0x26   0x7800             LDRB     R0,[R0, #+0]
   \       0x28   0x0780             LSLS     R0,R0,#+30
   \       0x2A   0xD5FB             BPL.N    ??CLOCK_BootToBlpeMode_1
   1616                      {
   1617                      }
   1618                  }
   1619              }
   1620          
   1621              /* Wait for MCG_S[CLKST] and MCG_S[IREFST]. */
   1622              while ((MCG->S & (MCG_S_IREFST_MASK | MCG_S_CLKST_MASK)) !=
   1623                     (MCG_S_IREFST(kMCG_FllSrcExternal) | MCG_S_CLKST(kMCG_ClkOutStatExt)))
   \                     ??CLOCK_BootToBlpeMode_0: (+1)
   \       0x2C   0x....             LDR.N    R0,??DataTable49  ;; 0x40064006
   \       0x2E   0x7800             LDRB     R0,[R0, #+0]
   \       0x30   0xF000 0x001C      AND      R0,R0,#0x1C
   \       0x34   0x2808             CMP      R0,#+8
   \       0x36   0xD1F9             BNE.N    ??CLOCK_BootToBlpeMode_0
   1624              {
   1625              }
   1626          
   1627              /* In FBE now, start to enter BLPE. */
   1628              MCG->C2 |= MCG_C2_LP_MASK;
   \       0x38   0x....             LDR.N    R0,??DataTable49_12  ;; 0x40064001
   \       0x3A   0x7801             LDRB     R1,[R0, #+0]
   \       0x3C   0xF041 0x0102      ORR      R1,R1,#0x2
   \       0x40   0x7001             STRB     R1,[R0, #+0]
   1629          
   1630              return kStatus_Success;
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0xBD02             POP      {R1,PC}          ;; return
   1631          }
   1632          

   \                                 In section .text, align 2, keep-with-next
   1633          status_t CLOCK_BootToPeeMode(mcg_oscsel_t oscsel, mcg_pll_clk_select_t pllcs, mcg_pll_config_t const *config)
   1634          {
   \                     CLOCK_BootToPeeMode: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460E             MOV      R6,R1
   \        0x6   0x0014             MOVS     R4,R2
   1635              assert(config);
   \        0x8   0xD107             BNE.N    ??CLOCK_BootToPeeMode_0
   \        0xA   0xF240 0x6263      MOVW     R2,#+1635
   \        0xE   0x....             LDR.N    R1,??DataTable49_17
   \       0x10   0x....             LDR.N    R0,??DataTable49_10
   \       0x12   0x.... 0x....      BL       __aeabi_assert
   \       0x16   0x.... 0x....      BL       __iar_EmptyStepPoint
   1636          
   1637              CLOCK_SetExternalRefClkConfig(oscsel);
   \                     ??CLOCK_BootToPeeMode_0: (+1)
   \       0x1A   0x4628             MOV      R0,R5
   \       0x1C   0x.... 0x....      BL       CLOCK_SetExternalRefClkConfig
   1638          
   1639              CLOCK_SetPbeMode(pllcs, config);
   \       0x20   0x4621             MOV      R1,R4
   \       0x22   0x4630             MOV      R0,R6
   \       0x24   0x.... 0x....      BL       CLOCK_SetPbeMode
   1640          
   1641              /* Change to use PLL output clock. */
   1642              MCG->C1 = (MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcOut);
   \       0x28   0x....             LDR.N    R0,??DataTable49_2  ;; 0x40064000
   \       0x2A   0x7801             LDRB     R1,[R0, #+0]
   \       0x2C   0xF001 0x013F      AND      R1,R1,#0x3F
   \       0x30   0x7001             STRB     R1,[R0, #+0]
   1643              while (MCG_S_CLKST_VAL != kMCG_ClkOutStatPll)
   \                     ??CLOCK_BootToPeeMode_1: (+1)
   \       0x32   0x....             LDR.N    R0,??DataTable49  ;; 0x40064006
   \       0x34   0x7800             LDRB     R0,[R0, #+0]
   \       0x36   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \       0x3A   0x2803             CMP      R0,#+3
   \       0x3C   0xD1F9             BNE.N    ??CLOCK_BootToPeeMode_1
   1644              {
   1645              }
   1646          
   1647              return kStatus_Success;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0xBD70             POP      {R4-R6,PC}       ;; return
   1648          }
   1649          
   1650          /*
   1651             The transaction matrix. It defines the path for mode switch, the row is for
   1652             current mode and the column is target mode.
   1653             For example, switch from FEI to PEE:
   1654             1. Current mode FEI, next mode is mcgModeMatrix[FEI][PEE] = FBE, so swith to FBE.
   1655             2. Current mode FBE, next mode is mcgModeMatrix[FBE][PEE] = PBE, so swith to PBE.
   1656             3. Current mode PBE, next mode is mcgModeMatrix[PBE][PEE] = PEE, so swith to PEE.
   1657             Thus the MCG mode has changed from FEI to PEE.
   1658           */

   \                                 In section .rodata, align 4
   1659          static const mcg_mode_t mcgModeMatrix[8][8] = {
   \                     mcgModeMatrix:
   \        0x0   0x00 0x01          DC8 0, 1, 1, 3, 4, 4, 4, 4, 0, 1, 2, 3, 4, 4, 4, 4, 1, 1, 2, 1, 1, 1, 1
   \              0x01 0x03    
   \              0x04 0x04    
   \              0x04 0x04    
   \              0x00 0x01    
   \              0x02 0x03    
   \              0x04 0x04    
   \              0x04 0x04    
   \              0x01 0x01    
   \              0x02 0x01    
   \              0x01 0x01    
   \              0x01         
   \       0x17   0x01 0x00          DC8 1, 0, 1, 1, 3, 4, 4, 4, 4, 0, 1, 1, 3, 4, 5, 6, 6, 4, 4, 4, 4, 4, 5
   \              0x01 0x01    
   \              0x03 0x04    
   \              0x04 0x04    
   \              0x04 0x00    
   \              0x01 0x01    
   \              0x03 0x04    
   \              0x05 0x06    
   \              0x06 0x04    
   \              0x04 0x04    
   \              0x04 0x04    
   \              0x05         
   \       0x2E   0x06 0x06          DC8 6, 6, 4, 4, 4, 4, 4, 5, 6, 7, 6, 6, 6, 6, 6, 6, 6, 6
   \              0x04 0x04    
   \              0x04 0x04    
   \              0x04 0x05    
   \              0x06 0x07    
   \              0x06 0x06    
   \              0x06 0x06    
   \              0x06 0x06    
   \              0x06 0x06    
   1660              {kMCG_ModeFEI, kMCG_ModeFBI, kMCG_ModeFBI, kMCG_ModeFEE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE,
   1661               kMCG_ModeFBE}, /* FEI */
   1662              {kMCG_ModeFEI, kMCG_ModeFBI, kMCG_ModeBLPI, kMCG_ModeFEE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE,
   1663               kMCG_ModeFBE}, /* FBI */
   1664              {kMCG_ModeFBI, kMCG_ModeFBI, kMCG_ModeBLPI, kMCG_ModeFBI, kMCG_ModeFBI, kMCG_ModeFBI, kMCG_ModeFBI,
   1665               kMCG_ModeFBI}, /* BLPI */
   1666              {kMCG_ModeFEI, kMCG_ModeFBI, kMCG_ModeFBI, kMCG_ModeFEE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE,
   1667               kMCG_ModeFBE}, /* FEE */
   1668              {kMCG_ModeFEI, kMCG_ModeFBI, kMCG_ModeFBI, kMCG_ModeFEE, kMCG_ModeFBE, kMCG_ModeBLPE, kMCG_ModePBE,
   1669               kMCG_ModePBE}, /* FBE */
   1670              {kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeBLPE, kMCG_ModePBE,
   1671               kMCG_ModePBE}, /* BLPE */
   1672              {kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeFBE, kMCG_ModeBLPE, kMCG_ModePBE,
   1673               kMCG_ModePEE}, /* PBE */
   1674              {kMCG_ModePBE, kMCG_ModePBE, kMCG_ModePBE, kMCG_ModePBE, kMCG_ModePBE, kMCG_ModePBE, kMCG_ModePBE,
   1675               kMCG_ModePBE} /* PEE */
   1676              /*    FEI           FBI           BLPI           FEE           FBE           BLPE           PBE           PEE */
   1677          };
   1678          

   \                                 In section .text, align 4, keep-with-next
   1679          status_t CLOCK_SetMcgConfig(const mcg_config_t *config)
   1680          {
   \                     CLOCK_SetMcgConfig: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   1681              mcg_mode_t next_mode;
   1682              status_t status = kStatus_Success;
   \        0x4   0x2400             MOVS     R4,#+0
   1683          
   1684              mcg_pll_clk_select_t pllcs = kMCG_PllClkSelPll0;
   1685          
   1686              /* If need to change external clock, MCG_C7[OSCSEL]. */
   1687              if (MCG_C7_OSCSEL_VAL != config->oscsel)
   \        0x6   0x....             LDR.N    R0,??DataTable49_4  ;; 0x4006400c
   \        0x8   0x7800             LDRB     R0,[R0, #+0]
   \        0xA   0xF000 0x0001      AND      R0,R0,#0x1
   \        0xE   0x79E9             LDRB     R1,[R5, #+7]
   \       0x10   0x4288             CMP      R0,R1
   \       0x12   0xD00D             BEQ.N    ??CLOCK_SetMcgConfig_1
   1688              {
   1689                  /* If external clock is in use, change to FEI first. */
   1690                  if (!(MCG->S & MCG_S_IRCST_MASK))
   \       0x14   0x....             LDR.N    R0,??DataTable49  ;; 0x40064006
   \       0x16   0x7800             LDRB     R0,[R0, #+0]
   \       0x18   0x07C0             LSLS     R0,R0,#+31
   \       0x1A   0xD406             BMI.N    ??CLOCK_SetMcgConfig_2
   1691                  {
   1692                      CLOCK_ExternalModeToFbeModeQuick();
   \       0x1C   0x.... 0x....      BL       CLOCK_ExternalModeToFbeModeQuick
   1693                      CLOCK_SetFeiMode(config->dmx32, config->drs, (void (*)(void))0);
   \       0x20   0x4622             MOV      R2,R4
   \       0x22   0x7969             LDRB     R1,[R5, #+5]
   \       0x24   0x79A8             LDRB     R0,[R5, #+6]
   \       0x26   0x.... 0x....      BL       CLOCK_SetFeiMode
   1694                  }
   1695          
   1696                  CLOCK_SetExternalRefClkConfig(config->oscsel);
   \                     ??CLOCK_SetMcgConfig_2: (+1)
   \       0x2A   0x79E8             LDRB     R0,[R5, #+7]
   \       0x2C   0x.... 0x....      BL       CLOCK_SetExternalRefClkConfig
   1697              }
   1698          
   1699              /* Re-configure MCGIRCLK, if MCGIRCLK is used as system clock source, then change to FEI/PEI first. */
   1700              if (MCG_S_CLKST_VAL == kMCG_ClkOutStatInt)
   \                     ??CLOCK_SetMcgConfig_1: (+1)
   \       0x30   0x....             LDR.N    R6,??DataTable49  ;; 0x40064006
   \       0x32   0x7830             LDRB     R0,[R6, #+0]
   \       0x34   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \       0x38   0x2801             CMP      R0,#+1
   \       0x3A   0xD109             BNE.N    ??CLOCK_SetMcgConfig_3
   1701              {
   1702                  MCG->C2 &= ~MCG_C2_LP_MASK; /* Disable lowpower. */
   \       0x3C   0x....             LDR.N    R0,??DataTable49_12  ;; 0x40064001
   \       0x3E   0x7801             LDRB     R1,[R0, #+0]
   \       0x40   0xF001 0x01FD      AND      R1,R1,#0xFD
   \       0x44   0x7001             STRB     R1,[R0, #+0]
   1703          
   1704                  {
   1705                      CLOCK_SetFeiMode(config->dmx32, config->drs, CLOCK_FllStableDelay);
   \       0x46   0x....             LDR.N    R2,??DataTable49_18
   \       0x48   0x7969             LDRB     R1,[R5, #+5]
   \       0x4A   0x79A8             LDRB     R0,[R5, #+6]
   \       0x4C   0x.... 0x....      BL       CLOCK_SetFeiMode
   1706                  }
   1707              }
   1708          
   1709              /* Configure MCGIRCLK. */
   1710              CLOCK_SetInternalRefClkConfig(config->irclkEnableMode, config->ircs, config->fcrdiv);
   \                     ??CLOCK_SetMcgConfig_3: (+1)
   \       0x50   0x78EA             LDRB     R2,[R5, #+3]
   \       0x52   0x78A9             LDRB     R1,[R5, #+2]
   \       0x54   0x7868             LDRB     R0,[R5, #+1]
   \       0x56   0x.... 0x....      BL       CLOCK_SetInternalRefClkConfig
   1711          
   1712              next_mode = CLOCK_GetMode();
   \       0x5A   0x.... 0x....      BL       CLOCK_GetMode
   \       0x5E   0x4607             MOV      R7,R0
   1713          
   1714              do
   1715              {
   1716                  next_mode = mcgModeMatrix[next_mode][config->mcgMode];
   \                     ??CLOCK_SetMcgConfig_4: (+1)
   \       0x60   0x....             LDR.N    R0,??DataTable49_19
   \       0x62   0xEB00 0x00C7      ADD      R0,R0,R7, LSL #+3
   \       0x66   0x7829             LDRB     R1,[R5, #+0]
   \       0x68   0x5C47             LDRB     R7,[R0, R1]
   1717          
   1718                  switch (next_mode)
   \       0x6A   0x4638             MOV      R0,R7
   \       0x6C   0x2807             CMP      R0,#+7
   \       0x6E   0xD847             BHI.N    ??CLOCK_SetMcgConfig_5
   \       0x70   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??CLOCK_SetMcgConfig_0:
   \       0x74   0x04 0x13          DC8      0x4,0x13,0x22,0xB
   \              0x22 0x0B    
   \       0x78   0x1A 0x26          DC8      0x1A,0x26,0x2A,0x43
   \              0x2A 0x43    
   1719                  {
   1720                      case kMCG_ModeFEI:
   1721                          status = CLOCK_SetFeiMode(config->dmx32, config->drs, CLOCK_FllStableDelay);
   \                     ??CLOCK_SetMcgConfig_6: (+1)
   \       0x7C   0x....             LDR.N    R2,??DataTable49_18
   \       0x7E   0x7969             LDRB     R1,[R5, #+5]
   \       0x80   0x79A8             LDRB     R0,[R5, #+6]
   \       0x82   0x.... 0x....      BL       CLOCK_SetFeiMode
   \       0x86   0x4604             MOV      R4,R0
   1722                          break;
   \       0x88   0xE03A             B.N      ??CLOCK_SetMcgConfig_5
   1723                      case kMCG_ModeFEE:
   1724                          status = CLOCK_SetFeeMode(config->frdiv, config->dmx32, config->drs, CLOCK_FllStableDelay);
   \                     ??CLOCK_SetMcgConfig_7: (+1)
   \       0x8A   0x....             LDR.N    R3,??DataTable49_18
   \       0x8C   0x796A             LDRB     R2,[R5, #+5]
   \       0x8E   0x79A9             LDRB     R1,[R5, #+6]
   \       0x90   0x7928             LDRB     R0,[R5, #+4]
   \       0x92   0x.... 0x....      BL       CLOCK_SetFeeMode
   \       0x96   0x4604             MOV      R4,R0
   1725                          break;
   \       0x98   0xE032             B.N      ??CLOCK_SetMcgConfig_5
   1726                      case kMCG_ModeFBI:
   1727                          status = CLOCK_SetFbiMode(config->dmx32, config->drs, (void (*)(void))0);
   \                     ??CLOCK_SetMcgConfig_8: (+1)
   \       0x9A   0x2200             MOVS     R2,#+0
   \       0x9C   0x7969             LDRB     R1,[R5, #+5]
   \       0x9E   0x79A8             LDRB     R0,[R5, #+6]
   \       0xA0   0x.... 0x....      BL       CLOCK_SetFbiMode
   \       0xA4   0x4604             MOV      R4,R0
   1728                          break;
   \       0xA6   0xE02B             B.N      ??CLOCK_SetMcgConfig_5
   1729                      case kMCG_ModeFBE:
   1730                          status = CLOCK_SetFbeMode(config->frdiv, config->dmx32, config->drs, (void (*)(void))0);
   \                     ??CLOCK_SetMcgConfig_9: (+1)
   \       0xA8   0x2300             MOVS     R3,#+0
   \       0xAA   0x796A             LDRB     R2,[R5, #+5]
   \       0xAC   0x79A9             LDRB     R1,[R5, #+6]
   \       0xAE   0x7928             LDRB     R0,[R5, #+4]
   \       0xB0   0x.... 0x....      BL       CLOCK_SetFbeMode
   \       0xB4   0x4604             MOV      R4,R0
   1731                          break;
   \       0xB6   0xE023             B.N      ??CLOCK_SetMcgConfig_5
   1732                      case kMCG_ModeBLPI:
   1733                          status = CLOCK_SetBlpiMode();
   \                     ??CLOCK_SetMcgConfig_10: (+1)
   \       0xB8   0x.... 0x....      BL       CLOCK_SetBlpiMode
   \       0xBC   0x4604             MOV      R4,R0
   1734                          break;
   \       0xBE   0xE01F             B.N      ??CLOCK_SetMcgConfig_5
   1735                      case kMCG_ModeBLPE:
   1736                          status = CLOCK_SetBlpeMode();
   \                     ??CLOCK_SetMcgConfig_11: (+1)
   \       0xC0   0x.... 0x....      BL       CLOCK_SetBlpeMode
   \       0xC4   0x4604             MOV      R4,R0
   1737                          break;
   \       0xC6   0xE01B             B.N      ??CLOCK_SetMcgConfig_5
   1738                      case kMCG_ModePBE:
   1739                          /* If target mode is not PBE or PEE, then only need to set CLKS = EXT here. */
   1740                          if ((kMCG_ModePEE == config->mcgMode) || (kMCG_ModePBE == config->mcgMode))
   \                     ??CLOCK_SetMcgConfig_12: (+1)
   \       0xC8   0x4608             MOV      R0,R1
   \       0xCA   0x2807             CMP      R0,#+7
   \       0xCC   0xD001             BEQ.N    ??CLOCK_SetMcgConfig_13
   \       0xCE   0x2806             CMP      R0,#+6
   \       0xD0   0xD106             BNE.N    ??CLOCK_SetMcgConfig_14
   1741                          {
   1742                              {
   1743                                  status = CLOCK_SetPbeMode(pllcs, &config->pll0Config);
   \                     ??CLOCK_SetMcgConfig_13: (+1)
   \       0xD2   0xF105 0x0108      ADD      R1,R5,#+8
   \       0xD6   0x2000             MOVS     R0,#+0
   \       0xD8   0x.... 0x....      BL       CLOCK_SetPbeMode
   \       0xDC   0x4604             MOV      R4,R0
   \       0xDE   0xE00F             B.N      ??CLOCK_SetMcgConfig_5
   1744                              }
   1745                          }
   1746                          else
   1747                          {
   1748                              MCG->C1 = ((MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcExternal));
   \                     ??CLOCK_SetMcgConfig_14: (+1)
   \       0xE0   0x....             LDR.N    R0,??DataTable49_2  ;; 0x40064000
   \       0xE2   0x7801             LDRB     R1,[R0, #+0]
   \       0xE4   0xF001 0x013F      AND      R1,R1,#0x3F
   \       0xE8   0xF041 0x0180      ORR      R1,R1,#0x80
   \       0xEC   0x7001             STRB     R1,[R0, #+0]
   1749                              while (MCG_S_CLKST_VAL != kMCG_ClkOutStatExt)
   \                     ??CLOCK_SetMcgConfig_15: (+1)
   \       0xEE   0x7830             LDRB     R0,[R6, #+0]
   \       0xF0   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \       0xF4   0x2802             CMP      R0,#+2
   \       0xF6   0xD1FA             BNE.N    ??CLOCK_SetMcgConfig_15
   \       0xF8   0xE002             B.N      ??CLOCK_SetMcgConfig_5
   1750                              {
   1751                              }
   1752                          }
   1753                          break;
   1754                      case kMCG_ModePEE:
   1755                          status = CLOCK_SetPeeMode();
   \                     ??CLOCK_SetMcgConfig_16: (+1)
   \       0xFA   0x.... 0x....      BL       CLOCK_SetPeeMode
   \       0xFE   0x4604             MOV      R4,R0
   1756                          break;
   1757                      default:
   1758                          break;
   1759                  }
   1760                  if (kStatus_Success != status)
   \                     ??CLOCK_SetMcgConfig_5: (+1)
   \      0x100   0x2C00             CMP      R4,#+0
   \      0x102   0xD10A             BNE.N    ??CLOCK_SetMcgConfig_17
   1761                  {
   1762                      return status;
   1763                  }
   1764              } while (next_mode != config->mcgMode);
   \      0x104   0x7828             LDRB     R0,[R5, #+0]
   \      0x106   0x4287             CMP      R7,R0
   \      0x108   0xD1AA             BNE.N    ??CLOCK_SetMcgConfig_4
   1765          
   1766              if (config->pll0Config.enableMode & kMCG_PllEnableIndependent)
   \      0x10A   0x7A28             LDRB     R0,[R5, #+8]
   \      0x10C   0x0640             LSLS     R0,R0,#+25
   \      0x10E   0xD506             BPL.N    ??CLOCK_SetMcgConfig_18
   1767              {
   1768                  CLOCK_EnablePll0(&config->pll0Config);
   \      0x110   0xF105 0x0008      ADD      R0,R5,#+8
   \      0x114   0x.... 0x....      BL       CLOCK_EnablePll0
   \      0x118   0xE006             B.N      ??CLOCK_SetMcgConfig_19
   1769              }
   \                     ??CLOCK_SetMcgConfig_17: (+1)
   \      0x11A   0x4620             MOV      R0,R4
   \      0x11C   0xBDF2             POP      {R1,R4-R7,PC}
   1770              else
   1771              {
   1772                  MCG->C5 &= ~(uint32_t)kMCG_PllEnableIndependent;
   \                     ??CLOCK_SetMcgConfig_18: (+1)
   \      0x11E   0x....             LDR.N    R0,??DataTable49_20  ;; 0x40064004
   \      0x120   0x7801             LDRB     R1,[R0, #+0]
   \      0x122   0xF001 0x01BF      AND      R1,R1,#0xBF
   \      0x126   0x7001             STRB     R1,[R0, #+0]
   1773              }
   1774              return kStatus_Success;
   \                     ??CLOCK_SetMcgConfig_19: (+1)
   \      0x128   0x2000             MOVS     R0,#+0
   \      0x12A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1775          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38:
   \        0x0   0x4006'400C        DC32     0x4006400c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_1:
   \        0x0   0x....'....        DC32     g_xtal0Freq

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_2:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_3:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_4:
   \        0x0   0x....'....        DC32     g_xtal32Freq

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_5:
   \        0x0   0x4006'4000        DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_6:
   \        0x0   0x4006'4001        DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40:
   \        0x0   0x4006'4006        DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41:
   \        0x0   0x....'....        DC32     s_slowIrcFreq

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41_1:
   \        0x0   0x....'....        DC32     s_fastIrcFreq

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41_2:
   \        0x0   0x4006'5000        DC32     0x40065000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42:
   \        0x0   0x4004'7000        DC32     0x40047000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43:
   \        0x0   0x4004'8004        DC32     0x40048004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47:
   \        0x0   0x4006'4008        DC32     0x40064008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47_1:
   \        0x0   0x1034'0012        DC32     0x10340012

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47_2:
   \        0x0   0x02DC'6C00        DC32     0x2dc6c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47_3:
   \        0x0   0x044A'A200        DC32     0x44aa200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48:
   \        0x0   0x007A'1201        DC32     0x7a1201

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_1:
   \        0x0   0x4004'8044        DC32     0x40048044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_2:
   \        0x0   0x05B8'D800        DC32     0x5b8d800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_3:
   \        0x0   0x0727'0E00        DC32     0x7270e00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_4:
   \        0x0   0x4004'8048        DC32     0x40048048

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_5:
   \        0x0   0x4006'4003        DC32     0x40064003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_6:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_7:
   \        0x0   0x4006'4004        DC32     0x40064004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49:
   \        0x0   0x4006'4006        DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49_1:
   \        0x0   0x....'....        DC32     `CLOCK_GetFllFreq::fllFactorTable`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49_2:
   \        0x0   0x4006'4000        DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49_3:
   \        0x0   0x4006'4005        DC32     0x40064005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49_4:
   \        0x0   0x4006'400C        DC32     0x4006400c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49_5:
   \        0x0   0xFFE1'7B80        DC32     0xffe17b80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49_6:
   \        0x0   0x05D7'5C81        DC32     0x5d75c81

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49_7:
   \        0x0   0x003D'08FF        DC32     0x3d08ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49_8:
   \        0x0   0x003D'0900        DC32     0x3d0900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49_9:
   \        0x0   0x001E'8480        DC32     0x1e8480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49_10:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49_11:
   \        0x0   0x4006'400D        DC32     0x4006400d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49_12:
   \        0x0   0x4006'4001        DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49_13:
   \        0x0   0xFF85'EE00        DC32     0xff85ee00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49_14:
   \        0x0   0x....'....        DC32     `CLOCK_TrimInternalRefClk::trimRange`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49_15:
   \        0x0   0x4006'400B        DC32     0x4006400b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49_16:
   \        0x0   0x4006'400A        DC32     0x4006400a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49_17:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49_18:
   \        0x0   0x....'....        DC32     CLOCK_FllStableDelay

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49_19:
   \        0x0   0x....'....        DC32     mcgModeMatrix

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49_20:
   \        0x0   0x4006'4004        DC32     0x40064004

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x67 0x5F          DC8 "g_xtal0Freq"
   \              0x78 0x74    
   \              0x61 0x6C    
   \              0x30 0x46    
   \              0x72 0x65    
   \              0x71 0x00    

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x66 0x73          DC8 "fsl_clock.c"
   \              0x6C 0x5F    
   \              0x63 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x2E    
   \              0x63 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x67 0x5F          DC8 "g_xtal32Freq"
   \              0x78 0x74    
   \              0x61 0x6C    
   \              0x33 0x32    
   \              0x46 0x72    
   \              0x65 0x71    
   \              0x00         
   \        0xD   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x6D 0x63          DC8 "mcgpll0clk"
   \              0x67 0x70    
   \              0x6C 0x6C    
   \              0x30 0x63    
   \              0x6C 0x6B    
   \              0x00         
   \        0xB   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x63 0x6F          DC8 "config"
   \              0x6E 0x66    
   \              0x69 0x67    
   \              0x00         
   \        0x7   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   CLOCK_BootToBlpeMode
         8   -> CLOCK_SetExternalRefClkConfig
       8   CLOCK_BootToBlpiMode
         8   -> CLOCK_SetInternalRefClkConfig
      24   CLOCK_BootToFeeMode
        24   -> CLOCK_SetExternalRefClkConfig
         0   -> CLOCK_SetFeeMode
       0   CLOCK_BootToFeiMode
         0   -> CLOCK_SetFeiMode
      16   CLOCK_BootToPeeMode
        16   -> CLOCK_SetExternalRefClkConfig
        16   -> CLOCK_SetPbeMode
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      32   CLOCK_CalcPllDiv
       0   CLOCK_ClearStatusFlags
       0   CLOCK_DeinitOsc0
       0   CLOCK_DisableClock
       0   CLOCK_EnableClock
       8   CLOCK_EnablePll0
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
      24   CLOCK_EnableUsbfs0Clock
        24   -> CLOCK_DisableClock
        24   -> CLOCK_EnableClock
       0   CLOCK_ExternalModeToFbeModeQuick
       4   CLOCK_FllStableDelay
       8   CLOCK_GetBusClkFreq
         8   -> CLOCK_GetOutClkFreq
       8   CLOCK_GetCoreSysClkFreq
         8   -> CLOCK_GetOutClkFreq
       8   CLOCK_GetEr32kClkFreq
         8   -> CLOCK_GetOsc0ErClkFreq
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   CLOCK_GetFixedFreqClkFreq
         8   -> CLOCK_GetFllRefClkFreq
         8   -> CLOCK_GetOutClkFreq
       8   CLOCK_GetFlashClkFreq
         8   -> CLOCK_GetOutClkFreq
       8   CLOCK_GetFllExtRefClkFreq
         8   -> CLOCK_GetMcgExtClkFreq
       8   CLOCK_GetFllFreq
         8   -> CLOCK_GetFllRefClkFreq
       0   CLOCK_GetFllRefClkFreq
         0   -> CLOCK_GetFllExtRefClkFreq
       8   CLOCK_GetFreq
         0   -> CLOCK_GetEr32kClkFreq
         0   -> CLOCK_GetFixedFreqClkFreq
         0   -> CLOCK_GetFllFreq
         0   -> CLOCK_GetInternalRefClkFreq
         0   -> CLOCK_GetOsc0ErClkFreq
         8   -> CLOCK_GetOutClkFreq
         0   -> CLOCK_GetPll0Freq
         0   -> CLOCK_GetPllFllSelClkFreq
       0   CLOCK_GetInternalRefClkFreq
         0   -> CLOCK_GetInternalRefClkSelectFreq
       0   CLOCK_GetInternalRefClkSelectFreq
       8   CLOCK_GetMcgExtClkFreq
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       4   CLOCK_GetMode
       8   CLOCK_GetOsc0ErClkFreq
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       0   CLOCK_GetOscRangeFromFreq
       0   CLOCK_GetOutClkFreq
         0   -> CLOCK_GetFllFreq
         0   -> CLOCK_GetInternalRefClkSelectFreq
         0   -> CLOCK_GetMcgExtClkFreq
         0   -> CLOCK_GetPll0Freq
       8   CLOCK_GetPlatClkFreq
         8   -> CLOCK_GetOutClkFreq
       8   CLOCK_GetPll0Freq
         8   -> CLOCK_GetPll0RefFreq
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       0   CLOCK_GetPll0RefFreq
         0   -> CLOCK_GetMcgExtClkFreq
       0   CLOCK_GetPllFllSelClkFreq
         0   -> CLOCK_GetFllFreq
         0   -> CLOCK_GetPll0Freq
       0   CLOCK_GetStatusFlags
      16   CLOCK_InitOsc0
        16   -> CLOCK_GetOscRangeFromFreq
        16   -> OSC_SetCapLoad
        16   -> OSC_SetExtRefClkConfig
       0   CLOCK_InternalModeToFbiModeQuick
       0   CLOCK_SetBlpeMode
       0   CLOCK_SetBlpiMode
       0   CLOCK_SetEr32kClock
       0   CLOCK_SetExternalRefClkConfig
      24   CLOCK_SetFbeMode
        24   -- Indirect call
      24   CLOCK_SetFbiMode
        24   -- Indirect call
      24   CLOCK_SetFeeMode
        24   -- Indirect call
      24   CLOCK_SetFeiMode
        24   -- Indirect call
      16   CLOCK_SetInternalRefClkConfig
      24   CLOCK_SetMcgConfig
        24   -> CLOCK_EnablePll0
        24   -> CLOCK_ExternalModeToFbeModeQuick
        24   -> CLOCK_GetMode
        24   -> CLOCK_SetBlpeMode
        24   -> CLOCK_SetBlpiMode
        24   -> CLOCK_SetExternalRefClkConfig
        24   -> CLOCK_SetFbeMode
        24   -> CLOCK_SetFbiMode
        24   -> CLOCK_SetFeeMode
        24   -> CLOCK_SetFeiMode
        24   -> CLOCK_SetInternalRefClkConfig
        24   -> CLOCK_SetPbeMode
        24   -> CLOCK_SetPeeMode
       0   CLOCK_SetOsc0MonitorMode
      16   CLOCK_SetPbeMode
        16   -> CLOCK_EnablePll0
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       0   CLOCK_SetPeeMode
       0   CLOCK_SetPll0MonitorMode
       0   CLOCK_SetPllFllSelClock
       0   CLOCK_SetRtcOscMonitorMode
       8   CLOCK_SetSimConfig
         0   -> CLOCK_SetEr32kClock
         8   -> CLOCK_SetPllFllSelClock
      12   CLOCK_TrimInternalRefClk
       0   OSC_SetCapLoad
       0   OSC_SetExtRefClkConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable38
       4  ??DataTable38_1
       4  ??DataTable38_2
       4  ??DataTable38_3
       4  ??DataTable38_4
       4  ??DataTable38_5
       4  ??DataTable38_6
       4  ??DataTable40
       4  ??DataTable41
       4  ??DataTable41_1
       4  ??DataTable41_2
       4  ??DataTable42
       4  ??DataTable43
       4  ??DataTable45
       4  ??DataTable47
       4  ??DataTable47_1
       4  ??DataTable47_2
       4  ??DataTable47_3
       4  ??DataTable48
       4  ??DataTable48_1
       4  ??DataTable48_2
       4  ??DataTable48_3
       4  ??DataTable48_4
       4  ??DataTable48_5
       4  ??DataTable48_6
       4  ??DataTable48_7
       4  ??DataTable49
       4  ??DataTable49_1
       4  ??DataTable49_10
       4  ??DataTable49_11
       4  ??DataTable49_12
       4  ??DataTable49_13
       4  ??DataTable49_14
       4  ??DataTable49_15
       4  ??DataTable49_16
       4  ??DataTable49_17
       4  ??DataTable49_18
       4  ??DataTable49_19
       4  ??DataTable49_2
       4  ??DataTable49_20
       4  ??DataTable49_3
       4  ??DataTable49_4
       4  ??DataTable49_5
       4  ??DataTable49_6
       4  ??DataTable49_7
       4  ??DataTable49_8
       4  ??DataTable49_9
      12  ?_0
      12  ?_1
      16  ?_2
      12  ?_3
       8  ?_4
      70  CLOCK_BootToBlpeMode
      52  CLOCK_BootToBlpiMode
      30  CLOCK_BootToFeeMode
       2  CLOCK_BootToFeiMode
      66  CLOCK_BootToPeeMode
     212  CLOCK_CalcPllDiv
      42  CLOCK_ClearStatusFlags
      22  CLOCK_DeinitOsc0
      24  CLOCK_DisableClock
      22  CLOCK_EnableClock
      82  CLOCK_EnablePll0
     134  CLOCK_EnableUsbfs0Clock
      56  CLOCK_ExternalModeToFbeModeQuick
      26  CLOCK_FllStableDelay
      24  CLOCK_GetBusClkFreq
      22  CLOCK_GetCoreSysClkFreq
      90  CLOCK_GetEr32kClkFreq
      28  CLOCK_GetFixedFreqClkFreq
      24  CLOCK_GetFlashClkFreq
      88  CLOCK_GetFllExtRefClkFreq
      68  CLOCK_GetFllFreq
      24  CLOCK_GetFllRefClkFreq
     142  CLOCK_GetFreq
      16  CLOCK_GetInternalRefClkFreq
      38  CLOCK_GetInternalRefClkSelectFreq
      88  CLOCK_GetMcgExtClkFreq
      96  CLOCK_GetMode
      50  CLOCK_GetOsc0ErClkFreq
      28  CLOCK_GetOscRangeFromFreq
      34  CLOCK_GetOutClkFreq
      22  CLOCK_GetPlatClkFreq
      76  CLOCK_GetPll0Freq
       2  CLOCK_GetPll0RefFreq
      28  CLOCK_GetPllFllSelClkFreq
      60  CLOCK_GetStatusFlags
      78  CLOCK_InitOsc0
      40  CLOCK_InternalModeToFbiModeQuick
      16  CLOCK_SetBlpeMode
      16  CLOCK_SetBlpiMode
      22  CLOCK_SetEr32kClock
      60  CLOCK_SetExternalRefClkConfig
     146  CLOCK_SetFbeMode
     118  CLOCK_SetFbiMode
     146  CLOCK_SetFeeMode
     108  CLOCK_SetFeiMode
     144  CLOCK_SetInternalRefClkConfig
     300  CLOCK_SetMcgConfig
      68  CLOCK_SetOsc0MonitorMode
     104  CLOCK_SetPbeMode
      26  CLOCK_SetPeeMode
      66  CLOCK_SetPll0MonitorMode
      22  CLOCK_SetPllFllSelClock
      30  CLOCK_SetRtcOscMonitorMode
      26  CLOCK_SetSimConfig
     170  CLOCK_TrimInternalRefClk
      12  OSC_SetCapLoad
      14  OSC_SetExtRefClkConfig
      16  fllFactorTable
       4  g_xtal0Freq
       4  g_xtal32Freq
      64  mcgModeMatrix
       4  s_fastIrcFreq
       4  s_slowIrcFreq
      16  trimRange

 
     8 bytes in section .bss
     8 bytes in section .data
   156 bytes in section .rodata
 3 808 bytes in section .text
 
 3 808 bytes of CODE  memory
   156 bytes of CONST memory
    16 bytes of DATA  memory

Errors: none
Warnings: none
