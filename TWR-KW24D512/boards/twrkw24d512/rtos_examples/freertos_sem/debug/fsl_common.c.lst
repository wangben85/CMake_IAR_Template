###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         03/Mar/2020  16:31:34
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_common.c
#    Command line =  
#        C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_common.c
#        "-IC:\Program Files (x86)\IAR Systems\Embedded Workbench 8.1\arm\inc"
#        -I..\..\..\..\..\CMSIS\Include -I..\..\..\..\..\devices -I..\..\..
#        -I..\..\..\..\..\devices\MKW24D5\drivers
#        -I..\..\..\..\..\devices\MKW24D5\utilities
#        -I..\..\..\..\..\devices\MKW24D5 -I..\..\iar -I..\.. -I..\
#        -I..\..\..\..\..\rtos\freertos_9.0.0\Source\portable\IAR\ARM_CM3
#        -I..\..\..\..\..\rtos\freertos_9.0.0\Source\include
#        -DCPU_MKW24D512VHA5 -DIAR -DFSL_RTOS_FREE_RTOS -DPRINTF_FLOAT_ENABLE=0
#        -DSCANF_FLOAT_ENABLE=0 -DPRINTF_ADVANCED_ENABLE=0
#        -DSCANF_ADVANCED_ENABLE=0 -DTWR_KW24D512 -DTOWER --diag_suppress
#        Pa082,Pa050,Pe167,Pa182 --endian=little --cpu=Cortex-M4 --fpu=None
#        --no_path_in_file_macros --silent -lC . -e --dlib_config "C:/Program
#        Files (x86)/IAR Systems/Embedded Workbench
#        8.1/arm/inc/c/DLib_Config_Normal.h" -Om --debug --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --dependencies=ns
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_common.c.obj.d
#        -o
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_common.c.obj
#    Locale       =  C
#    List file    =  .\fsl_common.c.lst
#    Object file  =  
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_common.c.obj
#
###############################################################################

C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_common.c
      1          /*
      2           * Copyright (c) 2015-2016, Freescale Semiconductor, Inc.
      3           * Copyright 2016-2017 NXP
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of the copyright holder nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "fsl_common.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t DisableGlobalIRQ(void)
   \                     DisableGlobalIRQ: (+1)
   \        0x0   0xF3EF 0x8010      MRS      R0,PRIMASK
   \        0x4   0xB672             CPSID    I
   \        0x6   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void EnableGlobalIRQ(uint32_t)
   \                     EnableGlobalIRQ: (+1)
   \        0x0   0xF380 0x8810      MSR      PRIMASK,R0
   \        0x4   0x4770             BX       LR               ;; return
     32          #include "fsl_debug_console.h"
     33          
     34          #ifndef NDEBUG
     35          #if (defined(__CC_ARM)) || (defined(__ICCARM__))

   \                                 In section .text, align 4, keep-with-next
     36          void __aeabi_assert(const char *failedExpr, const char *file, int line)
     37          {
   \                     __aeabi_assert: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x4613             MOV      R3,R2
     38              PRINTF("ASSERT ERROR \" %s \": file \"%s\" Line \"%d\" \n", failedExpr, file, line);
   \        0x4   0x460A             MOV      R2,R1
   \        0x6   0x4601             MOV      R1,R0
   \        0x8   0x....             LDR.N    R0,??DataTable2
   \        0xA   0x.... 0x....      BL       DbgConsole_Printf
     39              for (;;)
     40              {
     41                  __BKPT(0);
   \                     ??__aeabi_assert_0: (+1)
   \        0xE   0xBE00             BKPT     #0x0
   \       0x10   0xE7FD             B.N      ??__aeabi_assert_0
     42              }
     43          }
     44          #elif(defined(__REDLIB__))
     45          
     46          #if SDK_DEBUGCONSOLE
     47          void __assertion_failed(char *_Expr)
     48          {
     49              PRINTF("%s\n", _Expr);
     50              for (;;)
     51              {
     52                  __asm("bkpt #0");
     53              }
     54          }
     55          #endif
     56          
     57          #elif(defined(__GNUC__))
     58          void __assert_func(const char *file, int line, const char *func, const char *failedExpr)
     59          {
     60              PRINTF("ASSERT ERROR \" %s \": file \"%s\" Line \"%d\" function name \"%s\" \n", failedExpr, file, line, func);
     61              for (;;)
     62              {
     63                  __BKPT(0);
     64              }
     65          }
     66          #endif /* (defined(__CC_ARM)) ||  (defined (__ICCARM__)) */
     67          #endif /* NDEBUG */
     68          
     69          #ifndef __GIC_PRIO_BITS

   \                                 In section .text, align 2, keep-with-next
     70          uint32_t InstallIRQHandler(IRQn_Type irq, uint32_t irqHandler)
     71          {
   \                     InstallIRQHandler: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
     72          /* Addresses for VECTOR_TABLE and VECTOR_RAM come from the linker file */
     73          #if defined(__CC_ARM)
     74              extern uint32_t Image$$VECTOR_ROM$$Base[];
     75              extern uint32_t Image$$VECTOR_RAM$$Base[];
     76              extern uint32_t Image$$RW_m_data$$Base[];
     77          
     78          #define __VECTOR_TABLE Image$$VECTOR_ROM$$Base
     79          #define __VECTOR_RAM Image$$VECTOR_RAM$$Base
     80          #define __RAM_VECTOR_TABLE_SIZE (((uint32_t)Image$$RW_m_data$$Base - (uint32_t)Image$$VECTOR_RAM$$Base))
     81          #elif defined(__ICCARM__)
     82              extern uint32_t __RAM_VECTOR_TABLE_SIZE[];
     83              extern uint32_t __VECTOR_TABLE[];
     84              extern uint32_t __VECTOR_RAM[];
     85          #elif defined(__GNUC__)
     86              extern uint32_t __VECTOR_TABLE[];
     87              extern uint32_t __VECTOR_RAM[];
     88              extern uint32_t __RAM_VECTOR_TABLE_SIZE_BYTES[];
     89              uint32_t __RAM_VECTOR_TABLE_SIZE = (uint32_t)(__RAM_VECTOR_TABLE_SIZE_BYTES);
     90          #endif /* defined(__CC_ARM) */
     91              uint32_t n;
     92              uint32_t ret;
     93              uint32_t irqMaskValue;
     94          
     95              irqMaskValue = DisableGlobalIRQ();
   \        0x6   0x.... 0x....      BL       DisableGlobalIRQ
     96              if (SCB->VTOR != (uint32_t)__VECTOR_RAM)
   \        0xA   0x....             LDR.N    R1,??DataTable2_1
   \        0xC   0x....             LDR.N    R2,??DataTable2_2  ;; 0xe000ed08
   \        0xE   0x6813             LDR      R3,[R2, #+0]
   \       0x10   0x428B             CMP      R3,R1
   \       0x12   0xD00C             BEQ.N    ??InstallIRQHandler_0
     97              {
     98                  /* Copy the vector table from ROM to RAM */
     99                  for (n = 0; n < ((uint32_t)__RAM_VECTOR_TABLE_SIZE) / sizeof(uint32_t); n++)
   \       0x14   0x2300             MOVS     R3,#+0
   \       0x16   0xE005             B.N      ??InstallIRQHandler_1
    100                  {
    101                      __VECTOR_RAM[n] = __VECTOR_TABLE[n];
   \                     ??InstallIRQHandler_2: (+1)
   \       0x18   0x....             LDR.N    R6,??DataTable2_3
   \       0x1A   0xF856 0x6023      LDR      R6,[R6, R3, LSL #+2]
   \       0x1E   0xF841 0x6023      STR      R6,[R1, R3, LSL #+2]
    102                  }
   \       0x22   0x1C5B             ADDS     R3,R3,#+1
   \                     ??InstallIRQHandler_1: (+1)
   \       0x24   0x....             LDR.N    R6,??DataTable2_4
   \       0x26   0xEBB3 0x0F96      CMP      R3,R6, LSR #+2
   \       0x2A   0xD3F5             BCC.N    ??InstallIRQHandler_2
    103                  /* Point the VTOR to the position of vector table */
    104                  SCB->VTOR = (uint32_t)__VECTOR_RAM;
   \       0x2C   0x6011             STR      R1,[R2, #+0]
    105              }
    106          
    107              ret = __VECTOR_RAM[irq + 16];
   \                     ??InstallIRQHandler_0: (+1)
   \       0x2E   0x4622             MOV      R2,R4
   \       0x30   0xEB01 0x0282      ADD      R2,R1,R2, LSL #+2
   \       0x34   0x6C16             LDR      R6,[R2, #+64]
    108              /* make sure the __VECTOR_RAM is noncachable */
    109              __VECTOR_RAM[irq + 16] = irqHandler;
   \       0x36   0xEB01 0x0184      ADD      R1,R1,R4, LSL #+2
   \       0x3A   0x640D             STR      R5,[R1, #+64]
    110          
    111              EnableGlobalIRQ(irqMaskValue);
   \       0x3C   0x.... 0x....      BL       EnableGlobalIRQ
    112          
    113              return ret;
   \       0x40   0x4630             MOV      R0,R6
   \       0x42   0xBD70             POP      {R4-R6,PC}       ;; return
    114          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x....'....        DC32     __VECTOR_RAM

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \        0x0   0xE000'ED08        DC32     0xe000ed08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \        0x0   0x....'....        DC32     __VECTOR_TABLE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \        0x0   0x....'....        DC32     __RAM_VECTOR_TABLE_SIZE

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x41 0x53          DC8 "ASSERT ERROR \" %s \": file \"%s\" Line \"%d\" \012"
   \              0x53 0x45    
   \              0x52 0x54    
   \              0x20 0x45    
   \              0x52 0x52    
   \              0x4F 0x52    
   \              0x20 0x22    
   \              0x20 0x25    
   \              0x73 0x20    
   \              0x22 0x3A    
   \              0x20 0x66    
   \              0x69 0x6C    
   \              0x65 0x20    
   \              0x22 0x25    
   \              0x73 0x22    
   \              0x20 0x4C    
   \              0x69 0x6E    
   \              0x65 0x20    
   \              0x22 0x25    
   \              0x64 0x22    
   \              0x20 0x0A    
   \              0x00         
   \       0x2B   0x00               DC8 0
    115          #endif
    116          
    117          #ifndef CPU_QN908X
    118          #if (defined(FSL_FEATURE_SOC_SYSCON_COUNT) && (FSL_FEATURE_SOC_SYSCON_COUNT > 0))
    119          
    120          void EnableDeepSleepIRQ(IRQn_Type interrupt)
    121          {
    122              uint32_t index = 0;
    123              uint32_t intNumber = (uint32_t)interrupt;
    124              while (intNumber >= 32u)
    125              {
    126                  index++;
    127                  intNumber -= 32u;
    128              }
    129          
    130              SYSCON->STARTERSET[index] = 1u << intNumber;
    131              EnableIRQ(interrupt); /* also enable interrupt at NVIC */
    132          }
    133          
    134          void DisableDeepSleepIRQ(IRQn_Type interrupt)
    135          {
    136              uint32_t index = 0;
    137              uint32_t intNumber = (uint32_t)interrupt;
    138              while (intNumber >= 32u)
    139              {
    140                  index++;
    141                  intNumber -= 32u;
    142              }
    143          
    144              DisableIRQ(interrupt); /* also disable interrupt at NVIC */
    145              SYSCON->STARTERCLR[index] = 1u << intNumber;
    146          }
    147          #endif /* FSL_FEATURE_SOC_SYSCON_COUNT */
    148          #else
    149          void EnableDeepSleepIRQ(IRQn_Type interrupt)
    150          {
    151              uint32_t index = 0;
    152              uint32_t intNumber = (uint32_t)interrupt;
    153              while (intNumber >= 32u)
    154              {
    155                  index++;
    156                  intNumber -= 32u;
    157              }
    158          
    159              /*   SYSCON->STARTERSET[index] = 1u << intNumber; */
    160              EnableIRQ(interrupt); /* also enable interrupt at NVIC */
    161          }
    162          
    163          void DisableDeepSleepIRQ(IRQn_Type interrupt)
    164          {
    165              uint32_t index = 0;
    166              uint32_t intNumber = (uint32_t)interrupt;
    167              while (intNumber >= 32u)
    168              {
    169                  index++;
    170                  intNumber -= 32u;
    171              }
    172          
    173              DisableIRQ(interrupt); /* also disable interrupt at NVIC */
    174                                     /*   SYSCON->STARTERCLR[index] = 1u << intNumber; */
    175          }
    176          #endif /*CPU_QN908X */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   DisableGlobalIRQ
       0   EnableGlobalIRQ
      16   InstallIRQHandler
        16   -> DisableGlobalIRQ
        16   -> EnableGlobalIRQ
       8   __aeabi_assert
         8   -> DbgConsole_Printf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
      44  ?_0
       8  DisableGlobalIRQ
       6  EnableGlobalIRQ
      68  InstallIRQHandler
      18  __aeabi_assert

 
  44 bytes in section .rodata
 120 bytes in section .text
 
 120 bytes of CODE  memory
  44 bytes of CONST memory

Errors: none
Warnings: none
