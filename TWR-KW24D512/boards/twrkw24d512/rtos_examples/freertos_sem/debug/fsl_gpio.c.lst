###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         03/Mar/2020  16:31:35
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_gpio.c
#    Command line =  
#        C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_gpio.c
#        "-IC:\Program Files (x86)\IAR Systems\Embedded Workbench 8.1\arm\inc"
#        -I..\..\..\..\..\CMSIS\Include -I..\..\..\..\..\devices -I..\..\..
#        -I..\..\..\..\..\devices\MKW24D5\drivers
#        -I..\..\..\..\..\devices\MKW24D5\utilities
#        -I..\..\..\..\..\devices\MKW24D5 -I..\..\iar -I..\.. -I..\
#        -I..\..\..\..\..\rtos\freertos_9.0.0\Source\portable\IAR\ARM_CM3
#        -I..\..\..\..\..\rtos\freertos_9.0.0\Source\include
#        -DCPU_MKW24D512VHA5 -DIAR -DFSL_RTOS_FREE_RTOS -DPRINTF_FLOAT_ENABLE=0
#        -DSCANF_FLOAT_ENABLE=0 -DPRINTF_ADVANCED_ENABLE=0
#        -DSCANF_ADVANCED_ENABLE=0 -DTWR_KW24D512 -DTOWER --diag_suppress
#        Pa082,Pa050,Pe167,Pa182 --endian=little --cpu=Cortex-M4 --fpu=None
#        --no_path_in_file_macros --silent -lC . -e --dlib_config "C:/Program
#        Files (x86)/IAR Systems/Embedded Workbench
#        8.1/arm/inc/c/DLib_Config_Normal.h" -Om --debug --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --dependencies=ns
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_gpio.c.obj.d
#        -o
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_gpio.c.obj
#    Locale       =  C
#    List file    =  .\fsl_gpio.c.lst
#    Object file  =  
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_gpio.c.obj
#
###############################################################################

C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_gpio.c
      1          /*
      2           * Copyright (c) 2015, Freescale Semiconductor, Inc.
      3           * Copyright 2016-2017 NXP
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of the copyright holder nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "fsl_gpio.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void GPIO_WritePinOutput(GPIO_Type *, uint32_t, uint8_t)
   \                     GPIO_WritePinOutput: (+1)
   \        0x0   0x2A00             CMP      R2,#+0
   \        0x2   0xD104             BNE.N    ??GPIO_WritePinOutput_0
   \        0x4   0x2201             MOVS     R2,#+1
   \        0x6   0xFA02 0xF101      LSL      R1,R2,R1
   \        0xA   0x6081             STR      R1,[R0, #+8]
   \        0xC   0x4770             BX       LR
   \                     ??GPIO_WritePinOutput_0: (+1)
   \        0xE   0x2201             MOVS     R2,#+1
   \       0x10   0xFA02 0xF101      LSL      R1,R2,R1
   \       0x14   0x6041             STR      R1,[R0, #+4]
   \       0x16   0x4770             BX       LR               ;; return
     32          
     33          /*******************************************************************************
     34           * Variables
     35           ******************************************************************************/

   \                                 In section .rodata, align 4
     36          static PORT_Type *const s_portBases[] = PORT_BASE_PTRS;
   \                     s_portBases:
   \        0x0   0x4004'9000        DC32 40049000H, 4004A000H, 4004B000H, 4004C000H, 4004D000H
   \              0x4004'A000  
   \              0x4004'B000  
   \              0x4004'C000  
   \              0x4004'D000  

   \                                 In section .rodata, align 4
     37          static GPIO_Type *const s_gpioBases[] = GPIO_BASE_PTRS;
   \                     s_gpioBases:
   \        0x0   0x400F'F000        DC32 400FF000H, 400FF040H, 400FF080H, 400FF0C0H, 400FF100H
   \              0x400F'F040  
   \              0x400F'F080  
   \              0x400F'F0C0  
   \              0x400F'F100  
     38          
     39          /*******************************************************************************
     40          * Prototypes
     41          ******************************************************************************/
     42          
     43          /*!
     44          * @brief Gets the GPIO instance according to the GPIO base
     45          *
     46          * @param base    GPIO peripheral base pointer(PTA, PTB, PTC, etc.)
     47          * @retval GPIO instance
     48          */
     49          static uint32_t GPIO_GetInstance(GPIO_Type *base);
     50          
     51          /*******************************************************************************
     52           * Code
     53           ******************************************************************************/
     54          

   \                                 In section .text, align 2, keep-with-next
     55          static uint32_t GPIO_GetInstance(GPIO_Type *base)
     56          {
   \                     GPIO_GetInstance: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
     57              uint32_t instance;
     58          
     59              /* Find the instance index from base address mappings. */
     60              for (instance = 0; instance < ARRAY_SIZE(s_gpioBases); instance++)
   \        0x2   0x2400             MOVS     R4,#+0
   \                     ??GPIO_GetInstance_0: (+1)
   \        0x4   0x2C05             CMP      R4,#+5
   \        0x6   0xD206             BCS.N    ??GPIO_GetInstance_1
     61              {
     62                  if (s_gpioBases[instance] == base)
   \        0x8   0x....             LDR.N    R1,??DataTable4
   \        0xA   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \        0xE   0x4281             CMP      R1,R0
   \       0x10   0xD001             BEQ.N    ??GPIO_GetInstance_1
     63                  {
     64                      break;
     65                  }
     66              }
   \       0x12   0x1C64             ADDS     R4,R4,#+1
   \       0x14   0xE7F6             B.N      ??GPIO_GetInstance_0
     67          
     68              assert(instance < ARRAY_SIZE(s_gpioBases));
   \                     ??GPIO_GetInstance_1: (+1)
   \       0x16   0x2C05             CMP      R4,#+5
   \       0x18   0xD306             BCC.N    ??GPIO_GetInstance_2
   \       0x1A   0x2244             MOVS     R2,#+68
   \       0x1C   0x....             LDR.N    R1,??DataTable4_1
   \       0x1E   0x....             LDR.N    R0,??DataTable4_2
   \       0x20   0x.... 0x....      BL       __aeabi_assert
   \       0x24   0x.... 0x....      BL       __iar_EmptyStepPoint
     69          
     70              return instance;
   \                     ??GPIO_GetInstance_2: (+1)
   \       0x28   0x4620             MOV      R0,R4
   \       0x2A   0xBD10             POP      {R4,PC}          ;; return
     71          }
     72          

   \                                 In section .text, align 2, keep-with-next
     73          void GPIO_PinInit(GPIO_Type *base, uint32_t pin, const gpio_pin_config_t *config)
     74          {
   \                     GPIO_PinInit: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460E             MOV      R6,R1
   \        0x6   0x0014             MOVS     R4,R2
     75              assert(config);
   \        0x8   0xD106             BNE.N    ??GPIO_PinInit_0
   \        0xA   0x224B             MOVS     R2,#+75
   \        0xC   0x....             LDR.N    R1,??DataTable4_1
   \        0xE   0x....             LDR.N    R0,??DataTable4_3
   \       0x10   0x.... 0x....      BL       __aeabi_assert
   \       0x14   0x.... 0x....      BL       __iar_EmptyStepPoint
     76          
     77              if (config->pinDirection == kGPIO_DigitalInput)
   \                     ??GPIO_PinInit_0: (+1)
   \       0x18   0x7820             LDRB     R0,[R4, #+0]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD107             BNE.N    ??GPIO_PinInit_1
     78              {
     79                  base->PDDR &= ~(1U << pin);
   \       0x1E   0x6968             LDR      R0,[R5, #+20]
   \       0x20   0x2101             MOVS     R1,#+1
   \       0x22   0xFA01 0xF606      LSL      R6,R1,R6
   \       0x26   0xEA20 0x0606      BIC      R6,R0,R6
   \       0x2A   0x616E             STR      R6,[R5, #+20]
   \       0x2C   0xBD70             POP      {R4-R6,PC}
     80              }
     81              else
     82              {
     83                  GPIO_WritePinOutput(base, pin, config->outputLogic);
   \                     ??GPIO_PinInit_1: (+1)
   \       0x2E   0x7862             LDRB     R2,[R4, #+1]
   \       0x30   0x4631             MOV      R1,R6
   \       0x32   0x4628             MOV      R0,R5
   \       0x34   0x.... 0x....      BL       GPIO_WritePinOutput
     84                  base->PDDR |= (1U << pin);
   \       0x38   0x6968             LDR      R0,[R5, #+20]
   \       0x3A   0x2101             MOVS     R1,#+1
   \       0x3C   0xFA01 0xF606      LSL      R6,R1,R6
   \       0x40   0x4306             ORRS     R6,R6,R0
   \       0x42   0x616E             STR      R6,[R5, #+20]
     85              }
     86          }
   \       0x44   0xBD70             POP      {R4-R6,PC}       ;; return
     87          

   \                                 In section .text, align 2, keep-with-next
     88          uint32_t GPIO_GetPinsInterruptFlags(GPIO_Type *base)
     89          {
   \                     GPIO_GetPinsInterruptFlags: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
     90              uint8_t instance;
     91              PORT_Type *portBase;
     92              instance = GPIO_GetInstance(base);
   \        0x2   0x.... 0x....      BL       GPIO_GetInstance
     93              portBase = s_portBases[instance];
     94              return portBase->ISFR;
   \        0x6   0x....             LDR.N    R1,??DataTable4_4
   \        0x8   0xB2C0             UXTB     R0,R0
   \        0xA   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \        0xE   0xF8D0 0x00A0      LDR      R0,[R0, #+160]
   \       0x12   0xBD02             POP      {R1,PC}          ;; return
     95          }
     96          

   \                                 In section .text, align 2, keep-with-next
     97          void GPIO_ClearPinsInterruptFlags(GPIO_Type *base, uint32_t mask)
     98          {
   \                     GPIO_ClearPinsInterruptFlags: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x460C             MOV      R4,R1
     99              uint8_t instance;
    100              PORT_Type *portBase;
    101              instance = GPIO_GetInstance(base);
   \        0x4   0x.... 0x....      BL       GPIO_GetInstance
    102              portBase = s_portBases[instance];
    103              portBase->ISFR = mask;
   \        0x8   0x....             LDR.N    R1,??DataTable4_4
   \        0xA   0xB2C0             UXTB     R0,R0
   \        0xC   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \       0x10   0xF8C0 0x40A0      STR      R4,[R0, #+160]
    104          }
   \       0x14   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0x....'....        DC32     s_gpioBases

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \        0x0   0x....'....        DC32     s_portBases

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x69 0x6E          DC8 69H, 6EH, 73H, 74H, 61H, 6EH, 63H, 65H
   \              0x73 0x74    
   \              0x61 0x6E    
   \              0x63 0x65    
   \        0x8   0x20 0x3C          DC8 20H, 3CH, 20H, 28H, 73H, 69H, 7AH, 65H
   \              0x20 0x28    
   \              0x73 0x69    
   \              0x7A 0x65    
   \       0x10   0x6F 0x66          DC8 6FH, 66H, 28H, 73H, 5FH, 67H, 70H, 69H
   \              0x28 0x73    
   \              0x5F 0x67    
   \              0x70 0x69    
   \       0x18   0x6F 0x42          DC8 6FH, 42H, 61H, 73H, 65H, 73H, 29H, 20H
   \              0x61 0x73    
   \              0x65 0x73    
   \              0x29 0x20    
   \       0x20   0x2F 0x20          DC8 2FH, 20H, 73H, 69H, 7AH, 65H, 6FH, 66H
   \              0x73 0x69    
   \              0x7A 0x65    
   \              0x6F 0x66    
   \       0x28   0x28 0x28          DC8 28H, 28H, 73H, 5FH, 67H, 70H, 69H, 6FH
   \              0x73 0x5F    
   \              0x67 0x70    
   \              0x69 0x6F    
   \       0x30   0x42 0x61          DC8 42H, 61H, 73H, 65H, 73H, 29H, 5BH, 30H
   \              0x73 0x65    
   \              0x73 0x29    
   \              0x5B 0x30    
   \       0x38   0x5D 0x29          DC8 5DH, 29H, 29H, 0
   \              0x29 0x00    

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x66 0x73          DC8 "fsl_gpio.c"
   \              0x6C 0x5F    
   \              0x67 0x70    
   \              0x69 0x6F    
   \              0x2E 0x63    
   \              0x00         
   \        0xB   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x63 0x6F          DC8 "config"
   \              0x6E 0x66    
   \              0x69 0x67    
   \              0x00         
   \        0x7   0x00               DC8 0
    105          
    106          #if defined(FSL_FEATURE_GPIO_HAS_ATTRIBUTE_CHECKER) && FSL_FEATURE_GPIO_HAS_ATTRIBUTE_CHECKER
    107          void GPIO_CheckAttributeBytes(GPIO_Type *base, gpio_checker_attribute_t attribute)
    108          {
    109              base->GACR = ((uint32_t)attribute << GPIO_GACR_ACB0_SHIFT) | ((uint32_t)attribute << GPIO_GACR_ACB1_SHIFT) |
    110                           ((uint32_t)attribute << GPIO_GACR_ACB2_SHIFT) | ((uint32_t)attribute << GPIO_GACR_ACB3_SHIFT);
    111          }
    112          #endif
    113          
    114          #if defined(FSL_FEATURE_SOC_FGPIO_COUNT) && FSL_FEATURE_SOC_FGPIO_COUNT
    115          
    116          /*******************************************************************************
    117           * Variables
    118           ******************************************************************************/
    119          static FGPIO_Type *const s_fgpioBases[] = FGPIO_BASE_PTRS;
    120          
    121          /*******************************************************************************
    122          * Prototypes
    123          ******************************************************************************/
    124          /*!
    125          * @brief Gets the FGPIO instance according to the GPIO base
    126          *
    127          * @param base    FGPIO peripheral base pointer(PTA, PTB, PTC, etc.)
    128          * @retval FGPIO instance
    129          */
    130          static uint32_t FGPIO_GetInstance(FGPIO_Type *base);
    131          
    132          /*******************************************************************************
    133           * Code
    134           ******************************************************************************/
    135          
    136          static uint32_t FGPIO_GetInstance(FGPIO_Type *base)
    137          {
    138              uint32_t instance;
    139          
    140              /* Find the instance index from base address mappings. */
    141              for (instance = 0; instance < ARRAY_SIZE(s_fgpioBases); instance++)
    142              {
    143                  if (s_fgpioBases[instance] == base)
    144                  {
    145                      break;
    146                  }
    147              }
    148          
    149              assert(instance < ARRAY_SIZE(s_fgpioBases));
    150          
    151              return instance;
    152          }
    153          
    154          void FGPIO_PinInit(FGPIO_Type *base, uint32_t pin, const gpio_pin_config_t *config)
    155          {
    156              assert(config);
    157          
    158              if (config->pinDirection == kGPIO_DigitalInput)
    159              {
    160                  base->PDDR &= ~(1U << pin);
    161              }
    162              else
    163              {
    164                  FGPIO_WritePinOutput(base, pin, config->outputLogic);
    165                  base->PDDR |= (1U << pin);
    166              }
    167          }
    168          
    169          uint32_t FGPIO_GetPinsInterruptFlags(FGPIO_Type *base)
    170          {
    171              uint8_t instance;
    172              instance = FGPIO_GetInstance(base);
    173              PORT_Type *portBase;
    174              portBase = s_portBases[instance];
    175              return portBase->ISFR;
    176          }
    177          
    178          void FGPIO_ClearPinsInterruptFlags(FGPIO_Type *base, uint32_t mask)
    179          {
    180              uint8_t instance;
    181              instance = FGPIO_GetInstance(base);
    182              PORT_Type *portBase;
    183              portBase = s_portBases[instance];
    184              portBase->ISFR = mask;
    185          }
    186          
    187          #if defined(FSL_FEATURE_FGPIO_HAS_ATTRIBUTE_CHECKER) && FSL_FEATURE_FGPIO_HAS_ATTRIBUTE_CHECKER
    188          void FGPIO_CheckAttributeBytes(FGPIO_Type *base, gpio_checker_attribute_t attribute)
    189          {
    190              base->GACR = (attribute << FGPIO_GACR_ACB0_SHIFT) | (attribute << FGPIO_GACR_ACB1_SHIFT) |
    191                           (attribute << FGPIO_GACR_ACB2_SHIFT) | (attribute << FGPIO_GACR_ACB3_SHIFT);
    192          }
    193          #endif
    194          
    195          #endif /* FSL_FEATURE_SOC_FGPIO_COUNT */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   GPIO_ClearPinsInterruptFlags
         8   -> GPIO_GetInstance
       8   GPIO_GetInstance
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       8   GPIO_GetPinsInterruptFlags
         8   -> GPIO_GetInstance
      16   GPIO_PinInit
        16   -> GPIO_WritePinOutput
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       0   GPIO_WritePinOutput


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
      60  ?_0
      12  ?_1
       8  ?_2
      22  GPIO_ClearPinsInterruptFlags
      44  GPIO_GetInstance
      20  GPIO_GetPinsInterruptFlags
      70  GPIO_PinInit
      24  GPIO_WritePinOutput
      20  s_gpioBases
      20  s_portBases

 
 120 bytes in section .rodata
 200 bytes in section .text
 
 200 bytes of CODE  memory
 120 bytes of CONST memory

Errors: none
Warnings: none
