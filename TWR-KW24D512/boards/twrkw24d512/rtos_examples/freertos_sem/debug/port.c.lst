###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         03/Mar/2020  16:31:38
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\portable\IAR\ARM_CM3\port.c
#    Command line =  
#        C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\portable\IAR\ARM_CM3\port.c
#        "-IC:\Program Files (x86)\IAR Systems\Embedded Workbench 8.1\arm\inc"
#        -I..\..\..\..\..\CMSIS\Include -I..\..\..\..\..\devices -I..\..\..
#        -I..\..\..\..\..\devices\MKW24D5\drivers
#        -I..\..\..\..\..\devices\MKW24D5\utilities
#        -I..\..\..\..\..\devices\MKW24D5 -I..\..\iar -I..\.. -I..\
#        -I..\..\..\..\..\rtos\freertos_9.0.0\Source\portable\IAR\ARM_CM3
#        -I..\..\..\..\..\rtos\freertos_9.0.0\Source\include
#        -DCPU_MKW24D512VHA5 -DIAR -DFSL_RTOS_FREE_RTOS -DPRINTF_FLOAT_ENABLE=0
#        -DSCANF_FLOAT_ENABLE=0 -DPRINTF_ADVANCED_ENABLE=0
#        -DSCANF_ADVANCED_ENABLE=0 -DTWR_KW24D512 -DTOWER --diag_suppress
#        Pa082,Pa050,Pe167,Pa182 --endian=little --cpu=Cortex-M4 --fpu=None
#        --no_path_in_file_macros --silent -lC . -e --dlib_config "C:/Program
#        Files (x86)/IAR Systems/Embedded Workbench
#        8.1/arm/inc/c/DLib_Config_Normal.h" -Om --debug --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --dependencies=ns
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\portable\IAR\ARM_CM3\port.c.obj.d
#        -o
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\portable\IAR\ARM_CM3\port.c.obj
#    Locale       =  C
#    List file    =  .\port.c.lst
#    Object file  =  
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\portable\IAR\ARM_CM3\port.c.obj
#
###############################################################################

C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\rtos\freertos_9.0.0\Source\portable\IAR\ARM_CM3\port.c
      1          /*
      2              FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
      3              All rights reserved
      4          
      5              VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              This file is part of the FreeRTOS distribution.
      8          
      9              FreeRTOS is free software; you can redistribute it and/or modify it under
     10              the terms of the GNU General Public License (version 2) as published by the
     11              Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
     12          
     13              ***************************************************************************
     14              >>!   NOTE: The modification to the GPL is included to allow you to     !<<
     15              >>!   distribute a combined work that includes FreeRTOS without being   !<<
     16              >>!   obliged to provide the source code for proprietary components     !<<
     17              >>!   outside of the FreeRTOS kernel.                                   !<<
     18              ***************************************************************************
     19          
     20              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
     21              WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     22              FOR A PARTICULAR PURPOSE.  Full license text is available on the following
     23              link: http://www.freertos.org/a00114.html
     24          
     25              ***************************************************************************
     26               *                                                                       *
     27               *    FreeRTOS provides completely free yet professionally developed,    *
     28               *    robust, strictly quality controlled, supported, and cross          *
     29               *    platform software that is more than just the market leader, it     *
     30               *    is the industry's de facto standard.                               *
     31               *                                                                       *
     32               *    Help yourself get started quickly while simultaneously helping     *
     33               *    to support the FreeRTOS project by purchasing a FreeRTOS           *
     34               *    tutorial book, reference manual, or both:                          *
     35               *    http://www.FreeRTOS.org/Documentation                              *
     36               *                                                                       *
     37              ***************************************************************************
     38          
     39              http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
     40              the FAQ page "My application does not run, what could be wrong?".  Have you
     41              defined configASSERT()?
     42          
     43              http://www.FreeRTOS.org/support - In return for receiving this top quality
     44              embedded software for free we request you assist our global community by
     45              participating in the support forum.
     46          
     47              http://www.FreeRTOS.org/training - Investing in training allows your team to
     48              be as productive as possible as early as possible.  Now you can receive
     49              FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
     50              Ltd, and the world's leading authority on the world's leading RTOS.
     51          
     52              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     53              including FreeRTOS+Trace - an indispensable productivity tool, a DOS
     54              compatible FAT file system, and our tiny thread aware UDP/IP stack.
     55          
     56              http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
     57              Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
     58          
     59              http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
     60              Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
     61              licenses offer ticketed support, indemnification and commercial middleware.
     62          
     63              http://www.SafeRTOS.com - High Integrity Systems also provide a safety
     64              engineered and independently SIL3 certified version for use in safety and
     65              mission critical applications that require provable dependability.
     66          
     67              1 tab == 4 spaces!
     68          */
     69          
     70          /*-----------------------------------------------------------
     71           * Implementation of functions defined in portable.h for the ARM CM3 port.
     72           *----------------------------------------------------------*/
     73          
     74          /* IAR includes. */
     75          #include <intrinsics.h>
     76          
     77          /* Scheduler includes. */
     78          #include "FreeRTOS.h"
     79          #include "task.h"
     80          #include "fsl_tickless_generic.h"
     81          
     82          extern uint32_t SystemCoreClock; /* in Kinetis SDK, this contains the system core clock speed */
     83          
     84          #if configMAX_SYSCALL_INTERRUPT_PRIORITY == 0
     85          	#error configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.  See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html
     86          #endif
     87          #define portNVIC_PENDSV_PRI					( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 16UL )
     88          #define portNVIC_SYSTICK_PRI				( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 24UL )
     89          
     90          /* Constants required to check the validity of an interrupt priority. */
     91          #define portFIRST_USER_INTERRUPT_NUMBER		( 16 )
     92          #define portNVIC_IP_REGISTERS_OFFSET_16 	( 0xE000E3F0 )
     93          #define portAIRCR_REG						( * ( ( volatile uint32_t * ) 0xE000ED0C ) )
     94          #define portMAX_8_BIT_VALUE					( ( uint8_t ) 0xff )
     95          #define portTOP_BIT_OF_BYTE					( ( uint8_t ) 0x80 )
     96          #define portMAX_PRIGROUP_BITS				( ( uint8_t ) 7 )
     97          #define portPRIORITY_GROUP_MASK				( 0x07UL << 8UL )
     98          #define portPRIGROUP_SHIFT					( 8UL )
     99          
    100          /* Masks off all bits but the VECTACTIVE bits in the ICSR register. */
    101          #define portVECTACTIVE_MASK					( 0xFFUL )
    102          
    103          /* Constants required to set up the initial stack. */
    104          #define portINITIAL_XPSR					( 0x01000000 )
    105          
    106          /* For strict compliance with the Cortex-M spec the task start address should
    107          have bit-0 clear, as it is loaded into the PC on exit from an ISR. */
    108          #define portSTART_ADDRESS_MASK				( ( StackType_t ) 0xfffffffeUL )
    109          
    110          /* For backward compatibility, ensure configKERNEL_INTERRUPT_PRIORITY is
    111          defined.  The value 255 should also ensure backward compatibility.
    112          FreeRTOS.org versions prior to V4.3.0 did not include this definition. */
    113          #ifndef configKERNEL_INTERRUPT_PRIORITY
    114          	#define configKERNEL_INTERRUPT_PRIORITY 255
    115          #endif
    116          
    117          /* Each task maintains its own interrupt status in the critical nesting
    118          variable. */

   \                                 In section .data, align 4
    119          static UBaseType_t uxCriticalNesting = 0xaaaaaaaa;
   \                     uxCriticalNesting:
   \        0x0   0xAAAA'AAAA        DC32 2863311530
    120          
    121          /*
    122           * Exception handlers.
    123           */
    124          void xPortSysTickHandler( void );
    125          
    126          /*
    127           * Start first task is a separate function so it can be tested in isolation.
    128           */
    129          extern void vPortStartFirstTask( void );
    130          
    131          /*
    132           * Used to catch tasks that attempt to return from their implementing function.
    133           */
    134          static void prvTaskExitError( void );
    135          /*-----------------------------------------------------------*/
    136          
    137          /*
    138           * Used by the portASSERT_IF_INTERRUPT_PRIORITY_INVALID() macro to ensure
    139           * FreeRTOS API functions are not called from interrupts that have been assigned
    140           * a priority above configMAX_SYSCALL_INTERRUPT_PRIORITY.
    141           */
    142          #if ( configASSERT_DEFINED == 1 )

   \                                 In section .bss, align 1
    143          	 static uint8_t ucMaxSysCallPriority = 0;
   \                     ucMaxSysCallPriority:
   \        0x0                      DS8 1

   \                                 In section .bss, align 4
    144          	 static uint32_t ulMaxPRIGROUPValue = 0;
   \                     ulMaxPRIGROUPValue:
   \        0x0                      DS8 4
    145          	 static const volatile uint8_t * const pcInterruptPriorityRegisters = ( const volatile uint8_t * const ) portNVIC_IP_REGISTERS_OFFSET_16;
    146          #endif /* configASSERT_DEFINED */
    147          
    148          /*-----------------------------------------------------------*/
    149          
    150          /*
    151           * See header file for description.
    152           */

   \                                 In section .text, align 2, keep-with-next
    153          StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
    154          {
    155          	/* Simulate the stack frame as it would be created by a context switch
    156          	interrupt. */
    157          	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
    158          	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
   \                     pxPortInitialiseStack: (+1)
   \        0x0   0xF04F 0x7380      MOV      R3,#+16777216
   \        0x4   0xF840 0x3C04      STR      R3,[R0, #-4]
    159          	pxTopOfStack--;
    160          	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
   \        0x8   0x0849             LSRS     R1,R1,#+1
   \        0xA   0x0049             LSLS     R1,R1,#+1
   \        0xC   0xF840 0x1C08      STR      R1,[R0, #-8]
    161          	pxTopOfStack--;
    162          	*pxTopOfStack = ( StackType_t ) prvTaskExitError;	/* LR */
   \       0x10   0x.... 0x....      ADR.W    R1,prvTaskExitError
   \       0x14   0xF840 0x1C0C      STR      R1,[R0, #-12]
    163          	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
    164          	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
   \       0x18   0xF840 0x2D20      STR      R2,[R0, #-32]!
    165          	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
    166          
    167          	return pxTopOfStack;
   \       0x1C   0x3820             SUBS     R0,R0,#+32
   \       0x1E   0x4770             BX       LR               ;; return
    168          }
    169          /*-----------------------------------------------------------*/
    170          

   \                                 In section .text, align 4, keep-with-next
    171          static void prvTaskExitError( void )
    172          {
    173          	/* A function that implements a task must not exit or attempt to return to
    174          	its caller as there is nothing to return to.  If a task wants to exit it
    175          	should instead call vTaskDelete( NULL ).
    176          
    177          	Artificially force an assert() to be triggered if configASSERT() is
    178          	defined, then stop here so application writers can catch the error. */
    179          	configASSERT( uxCriticalNesting == ~0UL );
   \                     prvTaskExitError: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable7
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0xF110 0x0F01      CMN      R0,#+1
   \        0x8   0xD007             BEQ.N    ??prvTaskExitError_0
   \        0xA   0x2020             MOVS     R0,#+32
   \        0xC   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x10   0xF3BF 0x8F4F      DSB      SY
   \       0x14   0xF3BF 0x8F6F      ISB      SY
   \                     ??prvTaskExitError_1: (+1)
   \       0x18   0xE7FE             B.N      ??prvTaskExitError_1
    180          	portDISABLE_INTERRUPTS();
   \                     ??prvTaskExitError_0: (+1)
   \       0x1A   0x2020             MOVS     R0,#+32
   \       0x1C   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x20   0xF3BF 0x8F4F      DSB      SY
   \       0x24   0xF3BF 0x8F6F      ISB      SY
    181          	for( ;; );
   \                     ??prvTaskExitError_2: (+1)
   \       0x28   0xE7FE             B.N      ??prvTaskExitError_2
    182          }
    183          /*-----------------------------------------------------------*/
    184          
    185          /*
    186           * See header file for description.
    187           */

   \                                 In section .text, align 2, keep-with-next
    188          BaseType_t xPortStartScheduler( void )
    189          {
   \                     xPortStartScheduler: (+1)
   \        0x0   0xB5E0             PUSH     {R5-R7,LR}
    190          	#if( configASSERT_DEFINED == 1 )
    191          	{
    192          		volatile uint32_t ulOriginalPriority;
    193          		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
    194          		volatile uint8_t ucMaxPriorityValue;
    195          
    196          		/* Determine the maximum priority from which ISR safe FreeRTOS API
    197          		functions can be called.  ISR safe functions are those that end in
    198          		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
    199          		ensure interrupt entry is as fast and simple as possible.
    200          
    201          		Save the interrupt priority value that is about to be clobbered. */
    202          		ulOriginalPriority = *pucFirstUserPriorityRegister;
   \        0x2   0x....             LDR.N    R0,??DataTable7_1  ;; 0xe000e400
   \        0x4   0x7801             LDRB     R1,[R0, #+0]
   \        0x6   0x9101             STR      R1,[SP, #+4]
    203          
    204          		/* Determine the number of priority bits available.  First write to all
    205          		possible bits. */
    206          		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
   \        0x8   0x21FF             MOVS     R1,#+255
   \        0xA   0x7001             STRB     R1,[R0, #+0]
    207          
    208          		/* Read the value back to see how many bits stuck. */
    209          		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
   \        0xC   0x7801             LDRB     R1,[R0, #+0]
   \        0xE   0xF88D 0x1000      STRB     R1,[SP, #+0]
    210          
    211          		/* Use the same mask on the maximum system call priority. */
    212          		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
   \       0x12   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \       0x16   0xF001 0x0120      AND      R1,R1,#0x20
   \       0x1A   0x....             LDR.N    R2,??DataTable7_2
   \       0x1C   0x7011             STRB     R1,[R2, #+0]
    213          
    214          		/* Calculate the maximum acceptable priority group value for the number
    215          		of bits read back. */
    216          		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
   \       0x1E   0x....             LDR.N    R1,??DataTable7_3
   \       0x20   0x2207             MOVS     R2,#+7
   \       0x22   0x600A             STR      R2,[R1, #+0]
   \       0x24   0xE006             B.N      ??xPortStartScheduler_0
    217          		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
    218          		{
    219          			ulMaxPRIGROUPValue--;
   \                     ??xPortStartScheduler_1: (+1)
   \       0x26   0x1E52             SUBS     R2,R2,#+1
   \       0x28   0x600A             STR      R2,[R1, #+0]
    220          			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
   \       0x2A   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \       0x2E   0x0052             LSLS     R2,R2,#+1
   \       0x30   0xF88D 0x2000      STRB     R2,[SP, #+0]
    221          		}
   \                     ??xPortStartScheduler_0: (+1)
   \       0x34   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \       0x38   0x0612             LSLS     R2,R2,#+24
   \       0x3A   0x680A             LDR      R2,[R1, #+0]
   \       0x3C   0xD4F3             BMI.N    ??xPortStartScheduler_1
    222          
    223          		/* Shift the priority group value back to its position within the AIRCR
    224          		register. */
    225          		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
    226          		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
   \       0x3E   0x0212             LSLS     R2,R2,#+8
   \       0x40   0xF402 0x62E0      AND      R2,R2,#0x700
   \       0x44   0x600A             STR      R2,[R1, #+0]
    227          
    228          		/* Restore the clobbered interrupt priority register to its original
    229          		value. */
    230          		*pucFirstUserPriorityRegister = ulOriginalPriority;
   \       0x46   0x9901             LDR      R1,[SP, #+4]
   \       0x48   0x7001             STRB     R1,[R0, #+0]
    231          	}
    232          	#endif /* conifgASSERT_DEFINED */
    233          
    234          	/* Make PendSV and SysTick the lowest priority interrupts. */
    235          	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
   \       0x4A   0x....             LDR.N    R0,??DataTable7_4  ;; 0xe000ed20
   \       0x4C   0x6801             LDR      R1,[R0, #+0]
   \       0x4E   0xF441 0x0170      ORR      R1,R1,#0xF00000
   \       0x52   0x6001             STR      R1,[R0, #+0]
    236          	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
   \       0x54   0x6801             LDR      R1,[R0, #+0]
   \       0x56   0xF041 0x4170      ORR      R1,R1,#0xF0000000
   \       0x5A   0x6001             STR      R1,[R0, #+0]
    237          
    238          	/* Start the timer that generates the tick ISR.  Interrupts are disabled
    239          	here already. */
    240          	vPortSetupTimerInterrupt();
   \       0x5C   0x.... 0x....      BL       vPortSetupTimerInterrupt
    241          
    242          	/* Initialise the critical nesting count ready for the first task. */
    243          	uxCriticalNesting = 0;
   \       0x60   0x2000             MOVS     R0,#+0
   \       0x62   0x....             LDR.N    R1,??DataTable7
   \       0x64   0x6008             STR      R0,[R1, #+0]
    244          
    245          	/* Start the first task. */
    246          	vPortStartFirstTask();
   \       0x66   0x.... 0x....      BL       vPortStartFirstTask
    247          
    248          	/* Should not get here! */
    249          	return 0;
   \       0x6A   0x2000             MOVS     R0,#+0
   \       0x6C   0xBD0E             POP      {R1-R3,PC}       ;; return
    250          }
    251          /*-----------------------------------------------------------*/
    252          

   \                                 In section .text, align 2, keep-with-next
    253          void vPortEndScheduler( void )
    254          {
    255          	/* Not implemented in ports where there is nothing to return to.
    256          	Artificially force an assert. */
    257          	configASSERT( uxCriticalNesting == 1000UL );
   \                     vPortEndScheduler: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable7
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0xF5B0 0x7F7A      CMP      R0,#+1000
   \        0x8   0xD007             BEQ.N    ??vPortEndScheduler_0
   \        0xA   0x2020             MOVS     R0,#+32
   \        0xC   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x10   0xF3BF 0x8F4F      DSB      SY
   \       0x14   0xF3BF 0x8F6F      ISB      SY
   \                     ??vPortEndScheduler_1: (+1)
   \       0x18   0xE7FE             B.N      ??vPortEndScheduler_1
    258          }
   \                     ??vPortEndScheduler_0: (+1)
   \       0x1A   0x4770             BX       LR               ;; return
    259          /*-----------------------------------------------------------*/
    260          

   \                                 In section .text, align 2, keep-with-next
    261          void vPortEnterCritical( void )
    262          {
    263          	portDISABLE_INTERRUPTS();
   \                     vPortEnterCritical: (+1)
   \        0x0   0x2020             MOVS     R0,#+32
   \        0x2   0xF380 0x8811      MSR      BASEPRI,R0
   \        0x6   0xF3BF 0x8F4F      DSB      SY
   \        0xA   0xF3BF 0x8F6F      ISB      SY
    264          	uxCriticalNesting++;
   \        0xE   0x....             LDR.N    R1,??DataTable7
   \       0x10   0x680A             LDR      R2,[R1, #+0]
   \       0x12   0x1C52             ADDS     R2,R2,#+1
   \       0x14   0x600A             STR      R2,[R1, #+0]
    265          
    266          	/* This is not the interrupt safe version of the enter critical function so
    267          	assert() if it is being called from an interrupt context.  Only API
    268          	functions that end in "FromISR" can be used in an interrupt.  Only assert if
    269          	the critical nesting count is 1 to protect against recursive calls if the
    270          	assert function also uses a critical section. */
    271          	if( uxCriticalNesting == 1 )
   \       0x16   0x4611             MOV      R1,R2
   \       0x18   0x2901             CMP      R1,#+1
   \       0x1A   0xD10A             BNE.N    ??vPortEnterCritical_0
    272          	{
    273          		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
   \       0x1C   0x....             LDR.N    R1,??DataTable7_5  ;; 0xe000ed04
   \       0x1E   0x6809             LDR      R1,[R1, #+0]
   \       0x20   0x0609             LSLS     R1,R1,#+24
   \       0x22   0xD006             BEQ.N    ??vPortEnterCritical_0
   \       0x24   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x28   0xF3BF 0x8F4F      DSB      SY
   \       0x2C   0xF3BF 0x8F6F      ISB      SY
   \                     ??vPortEnterCritical_1: (+1)
   \       0x30   0xE7FE             B.N      ??vPortEnterCritical_1
    274          	}
    275          }
   \                     ??vPortEnterCritical_0: (+1)
   \       0x32   0x4770             BX       LR               ;; return
    276          /*-----------------------------------------------------------*/
    277          

   \                                 In section .text, align 2, keep-with-next
    278          void vPortExitCritical( void )
    279          {
    280          	configASSERT( uxCriticalNesting );
   \                     vPortExitCritical: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable7
   \        0x2   0x6808             LDR      R0,[R1, #+0]
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD107             BNE.N    ??vPortExitCritical_0
   \        0x8   0x2020             MOVS     R0,#+32
   \        0xA   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xE   0xF3BF 0x8F4F      DSB      SY
   \       0x12   0xF3BF 0x8F6F      ISB      SY
   \                     ??vPortExitCritical_1: (+1)
   \       0x16   0xE7FE             B.N      ??vPortExitCritical_1
    281          	uxCriticalNesting--;
   \                     ??vPortExitCritical_0: (+1)
   \       0x18   0x1E40             SUBS     R0,R0,#+1
   \       0x1A   0x6008             STR      R0,[R1, #+0]
    282          	if( uxCriticalNesting == 0 )
   \       0x1C   0xD102             BNE.N    ??vPortExitCritical_2
    283          	{
    284          		portENABLE_INTERRUPTS();
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xF380 0x8811      MSR      BASEPRI,R0
    285          	}
    286          }
   \                     ??vPortExitCritical_2: (+1)
   \       0x24   0x4770             BX       LR               ;; return
    287          /*-----------------------------------------------------------*/
    288          

   \                                 In section .text, align 2, keep-with-next
    289          void xPortSysTickHandler( void )
    290          {
   \                     SysTick_Handler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    291          	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
    292          	executes all interrupts must be unmasked.  There is therefore no need to
    293          	save and then restore the interrupt mask value as its value is already
    294          	known. */
    295          	portDISABLE_INTERRUPTS();
   \        0x2   0x2020             MOVS     R0,#+32
   \        0x4   0xF380 0x8811      MSR      BASEPRI,R0
   \        0x8   0xF3BF 0x8F4F      DSB      SY
   \        0xC   0xF3BF 0x8F6F      ISB      SY
    296          	{
    297          		/* Increment the RTOS tick. */
    298          		if( xTaskIncrementTick() != pdFALSE )
   \       0x10   0x.... 0x....      BL       xTaskIncrementTick
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD003             BEQ.N    ??SysTick_Handler_0
    299          		{
    300          			/* A context switch is required.  Context switching is performed in
    301          			the PendSV interrupt.  Pend the PendSV interrupt. */
    302          			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
   \       0x18   0xF04F 0x5080      MOV      R0,#+268435456
   \       0x1C   0x....             LDR.N    R1,??DataTable7_5  ;; 0xe000ed04
   \       0x1E   0x6008             STR      R0,[R1, #+0]
    303          		}
    304          	}
    305          	portENABLE_INTERRUPTS();
   \                     ??SysTick_Handler_0: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xF380 0x8811      MSR      BASEPRI,R0
    306          }
   \       0x26   0xBD01             POP      {R0,PC}          ;; return
    307          /*-----------------------------------------------------------*/
    308          
    309          #if( configASSERT_DEFINED == 1 )
    310          

   \                                 In section .text, align 4, keep-with-next
    311          	void vPortValidateInterruptPriority( void )
    312          	{
    313          	uint32_t ulCurrentInterrupt;
    314          	uint8_t ucCurrentPriority;
    315          
    316          		/* Obtain the number of the currently executing interrupt. */
    317          		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
   \                     vPortValidateInterruptPriority: (+1)
   \        0x0   0xF3EF 0x8005      mrs R0, ipsr
    318          
    319          		/* Is the interrupt number a user defined interrupt? */
    320          		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
   \        0x4   0x2810             CMP      R0,#+16
   \        0x6   0xD30D             BCC.N    ??vPortValidateInterruptPriority_0
    321          		{
    322          			/* Look up the interrupt's priority. */
    323          			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
   \        0x8   0x....             LDR.N    R1,??DataTable7_6  ;; 0xe000e3f0
   \        0xA   0x5C08             LDRB     R0,[R1, R0]
    324          
    325          			/* The following assertion will fail if a service routine (ISR) for
    326          			an interrupt that has been assigned a priority above
    327          			configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
    328          			function.  ISR safe FreeRTOS API functions must *only* be called
    329          			from interrupts that have been assigned a priority at or below
    330          			configMAX_SYSCALL_INTERRUPT_PRIORITY.
    331          
    332          			Numerically low interrupt priority numbers represent logically high
    333          			interrupt priorities, therefore the priority of the interrupt must
    334          			be set to a value equal to or numerically *higher* than
    335          			configMAX_SYSCALL_INTERRUPT_PRIORITY.
    336          
    337          			Interrupts that	use the FreeRTOS API must not be left at their
    338          			default priority of	zero as that is the highest possible priority,
    339          			which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
    340          			and	therefore also guaranteed to be invalid.
    341          
    342          			FreeRTOS maintains separate thread and ISR API functions to ensure
    343          			interrupt entry is as fast and simple as possible.
    344          
    345          			The following links provide detailed information:
    346          			http://www.freertos.org/RTOS-Cortex-M3-M4.html
    347          			http://www.freertos.org/FAQHelp.html */
    348          			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
   \        0xC   0x....             LDR.N    R1,??DataTable7_2
   \        0xE   0x7809             LDRB     R1,[R1, #+0]
   \       0x10   0x4288             CMP      R0,R1
   \       0x12   0xD207             BCS.N    ??vPortValidateInterruptPriority_0
   \       0x14   0x2020             MOVS     R0,#+32
   \       0x16   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x1A   0xF3BF 0x8F4F      DSB      SY
   \       0x1E   0xF3BF 0x8F6F      ISB      SY
   \                     ??vPortValidateInterruptPriority_1: (+1)
   \       0x22   0xE7FE             B.N      ??vPortValidateInterruptPriority_1
    349          		}
    350          
    351          		/* Priority grouping:  The interrupt controller (NVIC) allows the bits
    352          		that define each interrupt's priority to be split between bits that
    353          		define the interrupt's pre-emption priority bits and bits that define
    354          		the interrupt's sub-priority.  For simplicity all bits must be defined
    355          		to be pre-emption priority bits.  The following assertion will fail if
    356          		this is not the case (if some bits represent a sub-priority).
    357          
    358          		If the application only uses CMSIS libraries for interrupt
    359          		configuration then the correct setting can be achieved on all Cortex-M
    360          		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
    361          		scheduler.  Note however that some vendor specific peripheral libraries
    362          		assume a non-zero priority group setting, in which cases using a value
    363          		of zero will result in unpredicable behaviour. */
    364          		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
   \                     ??vPortValidateInterruptPriority_0: (+1)
   \       0x24   0x....             LDR.N    R0,??DataTable7_3
   \       0x26   0x6800             LDR      R0,[R0, #+0]
   \       0x28   0x....             LDR.N    R1,??DataTable7_7  ;; 0xe000ed0c
   \       0x2A   0x6809             LDR      R1,[R1, #+0]
   \       0x2C   0xF401 0x61E0      AND      R1,R1,#0x700
   \       0x30   0x4288             CMP      R0,R1
   \       0x32   0xD207             BCS.N    ??vPortValidateInterruptPriority_2
   \       0x34   0x2020             MOVS     R0,#+32
   \       0x36   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x3A   0xF3BF 0x8F4F      DSB      SY
   \       0x3E   0xF3BF 0x8F6F      ISB      SY
   \                     ??vPortValidateInterruptPriority_3: (+1)
   \       0x42   0xE7FE             B.N      ??vPortValidateInterruptPriority_3
    365          	}
   \                     ??vPortValidateInterruptPriority_2: (+1)
   \       0x44   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x....'....        DC32     uxCriticalNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \        0x0   0xE000'E400        DC32     0xe000e400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \        0x0   0x....'....        DC32     ucMaxSysCallPriority

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \        0x0   0x....'....        DC32     ulMaxPRIGROUPValue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \        0x0   0xE000'ED20        DC32     0xe000ed20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \        0x0   0xE000'ED04        DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \        0x0   0xE000'E3F0        DC32     0xe000e3f0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \        0x0   0xE000'ED0C        DC32     0xe000ed0c
    366          
    367          #endif /* configASSERT_DEFINED */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   SysTick_Handler
         8   -> xTaskIncrementTick
       0   prvTaskExitError
       0   pxPortInitialiseStack
       0   vPortEndScheduler
       0   vPortEnterCritical
       0   vPortExitCritical
       0   vPortValidateInterruptPriority
      16   xPortStartScheduler
        16   -> vPortSetupTimerInterrupt
        16   -> vPortStartFirstTask


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
      40  SysTick_Handler
      42  prvTaskExitError
      32  pxPortInitialiseStack
       1  ucMaxSysCallPriority
       4  ulMaxPRIGROUPValue
       4  uxCriticalNesting
      28  vPortEndScheduler
      52  vPortEnterCritical
      38  vPortExitCritical
      70  vPortValidateInterruptPriority
     110  xPortStartScheduler

 
   5 bytes in section .bss
   4 bytes in section .data
 444 bytes in section .text
 
 444 bytes of CODE memory
   9 bytes of DATA memory

Errors: none
Warnings: none
