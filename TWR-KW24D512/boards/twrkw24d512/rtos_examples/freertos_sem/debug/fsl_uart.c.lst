###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         03/Mar/2020  16:31:35
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_uart.c
#    Command line =  
#        C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_uart.c
#        "-IC:\Program Files (x86)\IAR Systems\Embedded Workbench 8.1\arm\inc"
#        -I..\..\..\..\..\CMSIS\Include -I..\..\..\..\..\devices -I..\..\..
#        -I..\..\..\..\..\devices\MKW24D5\drivers
#        -I..\..\..\..\..\devices\MKW24D5\utilities
#        -I..\..\..\..\..\devices\MKW24D5 -I..\..\iar -I..\.. -I..\
#        -I..\..\..\..\..\rtos\freertos_9.0.0\Source\portable\IAR\ARM_CM3
#        -I..\..\..\..\..\rtos\freertos_9.0.0\Source\include
#        -DCPU_MKW24D512VHA5 -DIAR -DFSL_RTOS_FREE_RTOS -DPRINTF_FLOAT_ENABLE=0
#        -DSCANF_FLOAT_ENABLE=0 -DPRINTF_ADVANCED_ENABLE=0
#        -DSCANF_ADVANCED_ENABLE=0 -DTWR_KW24D512 -DTOWER --diag_suppress
#        Pa082,Pa050,Pe167,Pa182 --endian=little --cpu=Cortex-M4 --fpu=None
#        --no_path_in_file_macros --silent -lC . -e --dlib_config "C:/Program
#        Files (x86)/IAR Systems/Embedded Workbench
#        8.1/arm/inc/c/DLib_Config_Normal.h" -Om --debug --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --dependencies=ns
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_uart.c.obj.d
#        -o
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_uart.c.obj
#    Locale       =  C
#    List file    =  .\fsl_uart.c.lst
#    Object file  =  
#        CMakeFiles\freertos_sem.dir\C_\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_uart.c.obj
#
###############################################################################

C:\Other_Code_Repo\CMake_IAR_Template\TWR-KW24D512\devices\MKW24D5\drivers\fsl_uart.c
      1          /*
      2           * Copyright (c) 2015-2016, Freescale Semiconductor, Inc.
      3           * Copyright 2016-2017 NXP
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of the copyright holder nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include "fsl_uart.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \        0x0   0x2201             MOVS     R2,#+1
   \        0x2   0xF000 0x011F      AND      R1,R0,#0x1F
   \        0x6   0x408A             LSLS     R2,R2,R1
   \        0x8   0x.... 0x....      LDR.W    R1,??DataTable28  ;; 0xe000e100
   \        0xC   0x0940             LSRS     R0,R0,#+5
   \        0xE   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   \       0x12   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_EnableClock(clock_ip_name_t)
   \                     CLOCK_EnableClock: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable28_1  ;; 0x40047000
   \        0x4   0xEB01 0x4110      ADD      R1,R1,R0, LSR #+16
   \        0x8   0x680A             LDR      R2,[R1, #+0]
   \        0xA   0x2301             MOVS     R3,#+1
   \        0xC   0xFA03 0xF000      LSL      R0,R3,R0
   \       0x10   0x4310             ORRS     R0,R0,R2
   \       0x12   0x6008             STR      R0,[R1, #+0]
   \       0x14   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void CLOCK_DisableClock(clock_ip_name_t)
   \                     CLOCK_DisableClock: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable28_1  ;; 0x40047000
   \        0x4   0xEB01 0x4110      ADD      R1,R1,R0, LSR #+16
   \        0x8   0x680A             LDR      R2,[R1, #+0]
   \        0xA   0x2301             MOVS     R3,#+1
   \        0xC   0xFA03 0xF000      LSL      R0,R3,R0
   \       0x10   0xEA22 0x0000      BIC      R0,R2,R0
   \       0x14   0x6008             STR      R0,[R1, #+0]
   \       0x16   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void EnableIRQ(IRQn_Type)
   \                     EnableIRQ: (+1)
   \        0x0   0x4601             MOV      R1,R0
   \        0x2   0xF06F 0x027F      MVN      R2,#+127
   \        0x6   0x4291             CMP      R1,R2
   \        0x8   0xD000             BEQ.N    ??EnableIRQ_0
   \        0xA   0x....             B.N      NVIC_EnableIRQ
   \                     ??EnableIRQ_0: (+1)
   \        0xC   0x4770             BX       LR               ;; return
     32          
     33          /*******************************************************************************
     34           * Definitions
     35           ******************************************************************************/
     36          
     37          /* UART transfer state. */
     38          enum _uart_tansfer_states
     39          {
     40              kUART_TxIdle,         /* TX idle. */
     41              kUART_TxBusy,         /* TX busy. */
     42              kUART_RxIdle,         /* RX idle. */
     43              kUART_RxBusy,         /* RX busy. */
     44              kUART_RxFramingError, /* Rx framing error */
     45              kUART_RxParityError   /* Rx parity error */
     46          };
     47          
     48          /* Typedef for interrupt handler. */
     49          typedef void (*uart_isr_t)(UART_Type *base, uart_handle_t *handle);
     50          
     51          /*******************************************************************************
     52           * Prototypes
     53           ******************************************************************************/
     54          
     55          /*!
     56           * @brief Get the UART instance from peripheral base address.
     57           *
     58           * @param base UART peripheral base address.
     59           * @return UART instance.
     60           */
     61          uint32_t UART_GetInstance(UART_Type *base);
     62          
     63          /*!
     64           * @brief Get the length of received data in RX ring buffer.
     65           *
     66           * @param handle UART handle pointer.
     67           * @return Length of received data in RX ring buffer.
     68           */
     69          static size_t UART_TransferGetRxRingBufferLength(uart_handle_t *handle);
     70          
     71          /*!
     72           * @brief Check whether the RX ring buffer is full.
     73           *
     74           * @param handle UART handle pointer.
     75           * @retval true  RX ring buffer is full.
     76           * @retval false RX ring buffer is not full.
     77           */
     78          static bool UART_TransferIsRxRingBufferFull(uart_handle_t *handle);
     79          
     80          /*!
     81           * @brief Read RX register using non-blocking method.
     82           *
     83           * This function reads data from the TX register directly, upper layer must make
     84           * sure the RX register is full or TX FIFO has data before calling this function.
     85           *
     86           * @param base UART peripheral base address.
     87           * @param data Start addresss of the buffer to store the received data.
     88           * @param length Size of the buffer.
     89           */
     90          static void UART_ReadNonBlocking(UART_Type *base, uint8_t *data, size_t length);
     91          
     92          /*!
     93           * @brief Write to TX register using non-blocking method.
     94           *
     95           * This function writes data to the TX register directly, upper layer must make
     96           * sure the TX register is empty or TX FIFO has empty room before calling this function.
     97           *
     98           * @note This function does not check whether all the data has been sent out to bus,
     99           * so before disable TX, check kUART_TransmissionCompleteFlag to ensure the TX is
    100           * finished.
    101           *
    102           * @param base UART peripheral base address.
    103           * @param data Start addresss of the data to write.
    104           * @param length Size of the buffer to be sent.
    105           */
    106          static void UART_WriteNonBlocking(UART_Type *base, const uint8_t *data, size_t length);
    107          
    108          /*******************************************************************************
    109           * Variables
    110           ******************************************************************************/
    111          /* Array of UART handle. */
    112          #if (defined(UART5))
    113          #define UART_HANDLE_ARRAY_SIZE 6
    114          #else /* UART5 */
    115          #if (defined(UART4))
    116          #define UART_HANDLE_ARRAY_SIZE 5
    117          #else /* UART4 */
    118          #if (defined(UART3))
    119          #define UART_HANDLE_ARRAY_SIZE 4
    120          #else /* UART3 */
    121          #if (defined(UART2))
    122          #define UART_HANDLE_ARRAY_SIZE 3
    123          #else /* UART2 */
    124          #if (defined(UART1))
    125          #define UART_HANDLE_ARRAY_SIZE 2
    126          #else /* UART1 */
    127          #if (defined(UART0))
    128          #define UART_HANDLE_ARRAY_SIZE 1
    129          #else /* UART0 */
    130          #error No UART instance.
    131          #endif /* UART 0 */
    132          #endif /* UART 1 */
    133          #endif /* UART 2 */
    134          #endif /* UART 3 */
    135          #endif /* UART 4 */
    136          #endif /* UART 5 */

   \                                 In section .bss, align 4
    137          static uart_handle_t *s_uartHandle[UART_HANDLE_ARRAY_SIZE];
   \                     s_uartHandle:
   \        0x0                      DS8 12
    138          /* Array of UART peripheral base address. */

   \                                 In section .rodata, align 4
    139          static UART_Type *const s_uartBases[] = UART_BASE_PTRS;
   \                     s_uartBases:
   \        0x0   0x4006'A000        DC32 4006A000H, 4006B000H, 4006C000H
   \              0x4006'B000  
   \              0x4006'C000  
    140          
    141          /* Array of UART IRQ number. */

   \                                 In section .rodata, align 4
    142          static const IRQn_Type s_uartIRQ[] = UART_RX_TX_IRQS;
   \                     s_uartIRQ:
   \        0x0   0x1F 0x21          DC8 31, 33, 35, 0
   \              0x23 0x00    
    143          #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
    144          /* Array of UART clock name. */

   \                                 In section .rodata, align 4
    145          static const clock_ip_name_t s_uartClock[] = UART_CLOCKS;
   \                     s_uartClock:
   \        0x0   0x1034'000A        DC32 271843338, 271843339, 271843340
   \              0x1034'000B  
   \              0x1034'000C  
    146          #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
    147          
    148          /* UART ISR for transactional APIs. */

   \                                 In section .bss, align 4
    149          static uart_isr_t s_uartIsr;
   \                     s_uartIsr:
   \        0x0                      DS8 4
    150          
    151          /*******************************************************************************
    152           * Code
    153           ******************************************************************************/
    154          

   \                                 In section .text, align 2, keep-with-next
    155          uint32_t UART_GetInstance(UART_Type *base)
    156          {
   \                     UART_GetInstance: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    157              uint32_t instance;
    158              uint32_t uartArrayCount = (sizeof(s_uartBases) / sizeof(s_uartBases[0]));
    159          
    160              /* Find the instance index from base address mappings. */
    161              for (instance = 0; instance < uartArrayCount; instance++)
   \        0x2   0x2400             MOVS     R4,#+0
   \                     ??UART_GetInstance_0: (+1)
   \        0x4   0x2C03             CMP      R4,#+3
   \        0x6   0xD207             BCS.N    ??UART_GetInstance_1
    162              {
    163                  if (s_uartBases[instance] == base)
   \        0x8   0x.... 0x....      LDR.W    R1,??DataTable26
   \        0xC   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \       0x10   0x4281             CMP      R1,R0
   \       0x12   0xD001             BEQ.N    ??UART_GetInstance_1
    164                  {
    165                      break;
    166                  }
    167              }
   \       0x14   0x1C64             ADDS     R4,R4,#+1
   \       0x16   0xE7F5             B.N      ??UART_GetInstance_0
    168          
    169              assert(instance < uartArrayCount);
   \                     ??UART_GetInstance_1: (+1)
   \       0x18   0x2C03             CMP      R4,#+3
   \       0x1A   0xD308             BCC.N    ??UART_GetInstance_2
   \       0x1C   0x22A9             MOVS     R2,#+169
   \       0x1E   0x.... 0x....      LDR.W    R1,??DataTable27
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable28_2
   \       0x26   0x.... 0x....      BL       __aeabi_assert
   \       0x2A   0x.... 0x....      BL       __iar_EmptyStepPoint
    170          
    171              return instance;
   \                     ??UART_GetInstance_2: (+1)
   \       0x2E   0x4620             MOV      R0,R4
   \       0x30   0xBD10             POP      {R4,PC}          ;; return
    172          }
    173          

   \                                 In section .text, align 2, keep-with-next
    174          static size_t UART_TransferGetRxRingBufferLength(uart_handle_t *handle)
    175          {
   \                     UART_TransferGetRxRingBufferLength: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    176              assert(handle);
   \        0x4   0xD108             BNE.N    ??UART_TransferGetRxRingBufferLength_0
   \        0x6   0x22B0             MOVS     R2,#+176
   \        0x8   0x.... 0x....      LDR.W    R1,??DataTable27
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable28_3
   \       0x10   0x.... 0x....      BL       __aeabi_assert
   \       0x14   0x.... 0x....      BL       __iar_EmptyStepPoint
    177          
    178              size_t size;
    179          
    180              if (handle->rxRingBufferTail > handle->rxRingBufferHead)
   \                     ??UART_TransferGetRxRingBufferLength_0: (+1)
   \       0x18   0x8C20             LDRH     R0,[R4, #+32]
   \       0x1A   0x8C61             LDRH     R1,[R4, #+34]
   \       0x1C   0x4288             CMP      R0,R1
   \       0x1E   0xD205             BCS.N    ??UART_TransferGetRxRingBufferLength_1
    181              {
    182                  size = (size_t)(handle->rxRingBufferHead + handle->rxRingBufferSize - handle->rxRingBufferTail);
   \       0x20   0x8C20             LDRH     R0,[R4, #+32]
   \       0x22   0x69E1             LDR      R1,[R4, #+28]
   \       0x24   0x1809             ADDS     R1,R1,R0
   \       0x26   0x8C60             LDRH     R0,[R4, #+34]
   \       0x28   0x1A08             SUBS     R0,R1,R0
   \       0x2A   0xBD10             POP      {R4,PC}
    183              }
    184              else
    185              {
    186                  size = (size_t)(handle->rxRingBufferHead - handle->rxRingBufferTail);
   \                     ??UART_TransferGetRxRingBufferLength_1: (+1)
   \       0x2C   0x8C21             LDRH     R1,[R4, #+32]
   \       0x2E   0x8C60             LDRH     R0,[R4, #+34]
   \       0x30   0x1A08             SUBS     R0,R1,R0
    187              }
    188          
    189              return size;
   \       0x32   0xBD10             POP      {R4,PC}          ;; return
    190          }
    191          

   \                                 In section .text, align 2, keep-with-next
    192          static bool UART_TransferIsRxRingBufferFull(uart_handle_t *handle)
    193          {
   \                     UART_TransferIsRxRingBufferFull: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    194              assert(handle);
   \        0x4   0xD108             BNE.N    ??UART_TransferIsRxRingBufferFull_0
   \        0x6   0x22C2             MOVS     R2,#+194
   \        0x8   0x.... 0x....      LDR.W    R1,??DataTable27
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable28_3
   \       0x10   0x.... 0x....      BL       __aeabi_assert
   \       0x14   0x.... 0x....      BL       __iar_EmptyStepPoint
    195          
    196              bool full;
    197          
    198              if (UART_TransferGetRxRingBufferLength(handle) == (handle->rxRingBufferSize - 1U))
   \                     ??UART_TransferIsRxRingBufferFull_0: (+1)
   \       0x18   0x4620             MOV      R0,R4
   \       0x1A   0x.... 0x....      BL       UART_TransferGetRxRingBufferLength
   \       0x1E   0x69E1             LDR      R1,[R4, #+28]
   \       0x20   0x1E49             SUBS     R1,R1,#+1
   \       0x22   0x4288             CMP      R0,R1
   \       0x24   0xD101             BNE.N    ??UART_TransferIsRxRingBufferFull_1
    199              {
    200                  full = true;
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0xBD10             POP      {R4,PC}
    201              }
    202              else
    203              {
    204                  full = false;
   \                     ??UART_TransferIsRxRingBufferFull_1: (+1)
   \       0x2A   0x2000             MOVS     R0,#+0
    205              }
    206          
    207              return full;
   \       0x2C   0xBD10             POP      {R4,PC}          ;; return
    208          }
    209          

   \                                 In section .text, align 2, keep-with-next
    210          status_t UART_Init(UART_Type *base, const uart_config_t *config, uint32_t srcClock_Hz)
    211          {
   \                     UART_Init: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x4617             MOV      R7,R2
    212              assert(config);
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD108             BNE.N    ??UART_Init_0
   \        0xE   0x22D4             MOVS     R2,#+212
   \       0x10   0x.... 0x....      LDR.W    R1,??DataTable27
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable28_4
   \       0x18   0x.... 0x....      BL       __aeabi_assert
   \       0x1C   0x.... 0x....      BL       __iar_EmptyStepPoint
    213              assert(config->baudRate_Bps);
   \                     ??UART_Init_0: (+1)
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD108             BNE.N    ??UART_Init_1
   \       0x26   0x22D5             MOVS     R2,#+213
   \       0x28   0x.... 0x....      LDR.W    R1,??DataTable27
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable28_5
   \       0x30   0x.... 0x....      BL       __aeabi_assert
   \       0x34   0x.... 0x....      BL       __iar_EmptyStepPoint
    214          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    215              assert(FSL_FEATURE_UART_FIFO_SIZEn(base) >= config->txFifoWatermark);
   \                     ??UART_Init_1: (+1)
   \       0x38   0x.... 0x....      LDR.W    R5,??DataTable28_6  ;; 0x4006a000
   \       0x3C   0x42AE             CMP      R6,R5
   \       0x3E   0xD101             BNE.N    ??UART_Init_2
   \       0x40   0x2008             MOVS     R0,#+8
   \       0x42   0xE00D             B.N      ??UART_Init_3
   \                     ??UART_Init_2: (+1)
   \       0x44   0x.... 0x....      LDR.W    R0,??DataTable28_7  ;; 0x4006b000
   \       0x48   0x4286             CMP      R6,R0
   \       0x4A   0xD101             BNE.N    ??UART_Init_4
   \       0x4C   0x2001             MOVS     R0,#+1
   \       0x4E   0xE007             B.N      ??UART_Init_3
   \                     ??UART_Init_4: (+1)
   \       0x50   0x.... 0x....      LDR.W    R0,??DataTable28_8  ;; 0x4006c000
   \       0x54   0x4286             CMP      R6,R0
   \       0x56   0xD101             BNE.N    ??UART_Init_5
   \       0x58   0x2001             MOVS     R0,#+1
   \       0x5A   0xE001             B.N      ??UART_Init_3
   \                     ??UART_Init_5: (+1)
   \       0x5C   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??UART_Init_3: (+1)
   \       0x60   0x7961             LDRB     R1,[R4, #+5]
   \       0x62   0x4288             CMP      R0,R1
   \       0x64   0xDA08             BGE.N    ??UART_Init_6
   \       0x66   0x22D7             MOVS     R2,#+215
   \       0x68   0x.... 0x....      LDR.W    R1,??DataTable27
   \       0x6C   0x.... 0x....      LDR.W    R0,??DataTable28_9
   \       0x70   0x.... 0x....      BL       __aeabi_assert
   \       0x74   0x.... 0x....      BL       __iar_EmptyStepPoint
    216              assert(FSL_FEATURE_UART_FIFO_SIZEn(base) >= config->rxFifoWatermark);
   \                     ??UART_Init_6: (+1)
   \       0x78   0x42AE             CMP      R6,R5
   \       0x7A   0xD101             BNE.N    ??UART_Init_7
   \       0x7C   0x2008             MOVS     R0,#+8
   \       0x7E   0xE00D             B.N      ??UART_Init_8
   \                     ??UART_Init_7: (+1)
   \       0x80   0x.... 0x....      LDR.W    R0,??DataTable28_7  ;; 0x4006b000
   \       0x84   0x4286             CMP      R6,R0
   \       0x86   0xD101             BNE.N    ??UART_Init_9
   \       0x88   0x2001             MOVS     R0,#+1
   \       0x8A   0xE007             B.N      ??UART_Init_8
   \                     ??UART_Init_9: (+1)
   \       0x8C   0x.... 0x....      LDR.W    R0,??DataTable28_8  ;; 0x4006c000
   \       0x90   0x4286             CMP      R6,R0
   \       0x92   0xD101             BNE.N    ??UART_Init_10
   \       0x94   0x2001             MOVS     R0,#+1
   \       0x96   0xE001             B.N      ??UART_Init_8
   \                     ??UART_Init_10: (+1)
   \       0x98   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??UART_Init_8: (+1)
   \       0x9C   0x79A1             LDRB     R1,[R4, #+6]
   \       0x9E   0x4288             CMP      R0,R1
   \       0xA0   0xDA08             BGE.N    ??UART_Init_11
   \       0xA2   0x22D8             MOVS     R2,#+216
   \       0xA4   0x.... 0x....      LDR.W    R1,??DataTable27
   \       0xA8   0x.... 0x....      LDR.W    R0,??DataTable28_10
   \       0xAC   0x.... 0x....      BL       __aeabi_assert
   \       0xB0   0x.... 0x....      BL       __iar_EmptyStepPoint
    217          #endif
    218          
    219              uint16_t sbr = 0;
    220              uint8_t temp = 0;
    221              uint32_t baudDiff = 0;
    222          
    223              /* Calculate the baud rate modulo divisor, sbr*/
    224              sbr = srcClock_Hz / (config->baudRate_Bps * 16);
   \                     ??UART_Init_11: (+1)
   \       0xB4   0x6820             LDR      R0,[R4, #+0]
   \       0xB6   0x0100             LSLS     R0,R0,#+4
   \       0xB8   0xFBB7 0xF5F0      UDIV     R5,R7,R0
   \       0xBC   0xB2AD             UXTH     R5,R5
    225              /* set sbrTemp to 1 if the sourceClockInHz can not satisfy the desired baud rate */
    226              if (sbr == 0)
   \       0xBE   0x2D00             CMP      R5,#+0
   \       0xC0   0xD100             BNE.N    ??UART_Init_12
    227              {
    228                  sbr = 1;
   \       0xC2   0x2501             MOVS     R5,#+1
    229              }
    230          #if defined(FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT) && FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT
    231              /* Determine if a fractional divider is needed to fine tune closer to the
    232               * desired baud, each value of brfa is in 1/32 increments,
    233               * hence the multiply-by-32. */
    234              uint32_t tempBaud = 0;
    235          
    236              uint16_t brfa = (2 * srcClock_Hz / (config->baudRate_Bps)) - 32 * sbr;
   \                     ??UART_Init_12: (+1)
   \       0xC4   0x0078             LSLS     R0,R7,#+1
   \       0xC6   0x6821             LDR      R1,[R4, #+0]
   \       0xC8   0xFBB0 0xF8F1      UDIV     R8,R0,R1
   \       0xCC   0xEBA8 0x1845      SUB      R8,R8,R5, LSL #+5
    237          
    238              /* Calculate the baud rate based on the temporary SBR values and BRFA */
    239              tempBaud = (srcClock_Hz * 2 / ((sbr * 32 + brfa)));
   \       0xD0   0x007F             LSLS     R7,R7,#+1
   \       0xD2   0x0168             LSLS     R0,R5,#+5
   \       0xD4   0xFA10 0xF088      UXTAH    R0,R0,R8
   \       0xD8   0xFBB7 0xF1F0      UDIV     R1,R7,R0
    240              baudDiff =
    241                  (tempBaud > config->baudRate_Bps) ? (tempBaud - config->baudRate_Bps) : (config->baudRate_Bps - tempBaud);
   \       0xDC   0x6820             LDR      R0,[R4, #+0]
   \       0xDE   0x4288             CMP      R0,R1
   \       0xE0   0xD201             BCS.N    ??UART_Init_13
   \       0xE2   0x1A09             SUBS     R1,R1,R0
   \       0xE4   0xE000             B.N      ??UART_Init_14
   \                     ??UART_Init_13: (+1)
   \       0xE6   0x1A41             SUBS     R1,R0,R1
    242          
    243          #else
    244              /* Calculate the baud rate based on the temporary SBR values */
    245              baudDiff = (srcClock_Hz / (sbr * 16)) - config->baudRate_Bps;
    246          
    247              /* Select the better value between sbr and (sbr + 1) */
    248              if (baudDiff > (config->baudRate_Bps - (srcClock_Hz / (16 * (sbr + 1)))))
    249              {
    250                  baudDiff = config->baudRate_Bps - (srcClock_Hz / (16 * (sbr + 1)));
    251                  sbr++;
    252              }
    253          #endif
    254          
    255              /* next, check to see if actual baud rate is within 3% of desired baud rate
    256               * based on the calculate SBR value */
    257              if (baudDiff > ((config->baudRate_Bps / 100) * 3))
   \                     ??UART_Init_14: (+1)
   \       0xE8   0x2264             MOVS     R2,#+100
   \       0xEA   0xFBB0 0xF0F2      UDIV     R0,R0,R2
   \       0xEE   0xEB00 0x0040      ADD      R0,R0,R0, LSL #+1
   \       0xF2   0x4288             CMP      R0,R1
   \       0xF4   0xD202             BCS.N    ??UART_Init_15
    258              {
    259                  /* Unacceptable baud rate difference of more than 3%*/
    260                  return kStatus_UART_BaudrateNotSupport;
   \       0xF6   0xF240 0x30F5      MOVW     R0,#+1013
   \       0xFA   0xE040             B.N      ??UART_Init_16
    261              }
    262          
    263          #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
    264              /* Enable uart clock */
    265              CLOCK_EnableClock(s_uartClock[UART_GetInstance(base)]);
   \                     ??UART_Init_15: (+1)
   \       0xFC   0x4630             MOV      R0,R6
   \       0xFE   0x.... 0x....      BL       UART_GetInstance
   \      0x102   0x.... 0x....      LDR.W    R1,??DataTable28_11
   \      0x106   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \      0x10A   0x.... 0x....      BL       CLOCK_EnableClock
    266          #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
    267          
    268              /* Disable UART TX RX before setting. */
    269              base->C2 &= ~(UART_C2_TE_MASK | UART_C2_RE_MASK);
   \      0x10E   0x78F0             LDRB     R0,[R6, #+3]
   \      0x110   0xF000 0x00F3      AND      R0,R0,#0xF3
   \      0x114   0x70F0             STRB     R0,[R6, #+3]
    270          
    271              /* Write the sbr value to the BDH and BDL registers*/
    272              base->BDH = (base->BDH & ~UART_BDH_SBR_MASK) | (uint8_t)(sbr >> 8);
   \      0x116   0x7831             LDRB     R1,[R6, #+0]
   \      0x118   0xF001 0x01E0      AND      R1,R1,#0xE0
   \      0x11C   0x4628             MOV      R0,R5
   \      0x11E   0xEA51 0x2120      ORRS     R1,R1,R0, ASR #+8
   \      0x122   0x7031             STRB     R1,[R6, #+0]
    273              base->BDL = (uint8_t)sbr;
   \      0x124   0x7075             STRB     R5,[R6, #+1]
    274          
    275          #if defined(FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT) && FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT
    276              /* Write the brfa value to the register*/
    277              base->C4 = (base->C4 & ~UART_C4_BRFA_MASK) | (brfa & UART_C4_BRFA_MASK);
   \      0x126   0x7AB0             LDRB     R0,[R6, #+10]
   \      0x128   0xF000 0x00E0      AND      R0,R0,#0xE0
   \      0x12C   0xF008 0x081F      AND      R8,R8,#0x1F
   \      0x130   0xEA48 0x0800      ORR      R8,R8,R0
   \      0x134   0xF886 0x800A      STRB     R8,[R6, #+10]
    278          #endif
    279          
    280              /* Set bit count and parity mode. */
    281              temp = base->C1 & ~(UART_C1_PE_MASK | UART_C1_PT_MASK | UART_C1_M_MASK);
   \      0x138   0x78B1             LDRB     R1,[R6, #+2]
   \      0x13A   0xF021 0x0113      BIC      R1,R1,#0x13
    282          
    283              if (kUART_ParityDisabled != config->parityMode)
   \      0x13E   0x7920             LDRB     R0,[R4, #+4]
   \      0x140   0x2800             CMP      R0,#+0
   \      0x142   0xD002             BEQ.N    ??UART_Init_17
    284              {
    285                  temp |= (UART_C1_M_MASK | (uint8_t)config->parityMode);
   \      0x144   0xF040 0x0010      ORR      R0,R0,#0x10
   \      0x148   0x4301             ORRS     R1,R0,R1
    286              }
    287          
    288              base->C1 = temp;
   \                     ??UART_Init_17: (+1)
   \      0x14A   0x70B1             STRB     R1,[R6, #+2]
    289          
    290          #if defined(FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_SUPPORT) && FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_SUPPORT
    291              /* Set stop bit per char */
    292              base->BDH = (base->BDH & ~UART_BDH_SBNS_MASK) | UART_BDH_SBNS((uint8_t)config->stopBitCount);
    293          #endif
    294          
    295          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    296              /* Set tx/rx FIFO watermark */
    297              base->TWFIFO = config->txFifoWatermark;
   \      0x14C   0x7960             LDRB     R0,[R4, #+5]
   \      0x14E   0x74F0             STRB     R0,[R6, #+19]
    298              base->RWFIFO = config->rxFifoWatermark;
   \      0x150   0x79A0             LDRB     R0,[R4, #+6]
   \      0x152   0x7570             STRB     R0,[R6, #+21]
    299          
    300              /* Enable tx/rx FIFO */
    301              base->PFIFO |= (UART_PFIFO_TXFE_MASK | UART_PFIFO_RXFE_MASK);
   \      0x154   0x7C30             LDRB     R0,[R6, #+16]
   \      0x156   0xF040 0x0088      ORR      R0,R0,#0x88
   \      0x15A   0x7430             STRB     R0,[R6, #+16]
    302          
    303              /* Flush FIFO */
    304              base->CFIFO |= (UART_CFIFO_TXFLUSH_MASK | UART_CFIFO_RXFLUSH_MASK);
   \      0x15C   0x7C70             LDRB     R0,[R6, #+17]
   \      0x15E   0xF040 0x00C0      ORR      R0,R0,#0xC0
   \      0x162   0x7470             STRB     R0,[R6, #+17]
    305          #endif
    306          
    307              /* Enable TX/RX base on configure structure. */
    308              temp = base->C2;
   \      0x164   0x78F1             LDRB     R1,[R6, #+3]
    309          
    310              if (config->enableTx)
   \      0x166   0x79E0             LDRB     R0,[R4, #+7]
   \      0x168   0x2800             CMP      R0,#+0
   \      0x16A   0xD001             BEQ.N    ??UART_Init_18
    311              {
    312                  temp |= UART_C2_TE_MASK;
   \      0x16C   0xF041 0x0108      ORR      R1,R1,#0x8
    313              }
    314          
    315              if (config->enableRx)
   \                     ??UART_Init_18: (+1)
   \      0x170   0x7A20             LDRB     R0,[R4, #+8]
   \      0x172   0x2800             CMP      R0,#+0
   \      0x174   0xD001             BEQ.N    ??UART_Init_19
    316              {
    317                  temp |= UART_C2_RE_MASK;
   \      0x176   0xF041 0x0104      ORR      R1,R1,#0x4
    318              }
    319          
    320              base->C2 = temp;
   \                     ??UART_Init_19: (+1)
   \      0x17A   0x70F1             STRB     R1,[R6, #+3]
    321          
    322              return kStatus_Success;
   \      0x17C   0x2000             MOVS     R0,#+0
   \                     ??UART_Init_16: (+1)
   \      0x17E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    323          }
    324          

   \                                 In section .text, align 2, keep-with-next
    325          void UART_Deinit(UART_Type *base)
    326          {
   \                     UART_Deinit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    327          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    328              /* Wait tx FIFO send out*/
    329              while (0 != base->TCFIFO)
   \                     ??UART_Deinit_0: (+1)
   \        0x2   0x7D01             LDRB     R1,[R0, #+20]
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD1FC             BNE.N    ??UART_Deinit_0
    330              {
    331              }
    332          #endif
    333              /* Wait last char shoft out */
    334              while (0 == (base->S1 & UART_S1_TC_MASK))
   \                     ??UART_Deinit_1: (+1)
   \        0x8   0x7901             LDRB     R1,[R0, #+4]
   \        0xA   0x0649             LSLS     R1,R1,#+25
   \        0xC   0xD5FC             BPL.N    ??UART_Deinit_1
    335              {
    336              }
    337          
    338              /* Disable the module. */
    339              base->C2 = 0;
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0x70C1             STRB     R1,[R0, #+3]
    340          
    341          #if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
    342              /* Disable uart clock */
    343              CLOCK_DisableClock(s_uartClock[UART_GetInstance(base)]);
   \       0x12   0x.... 0x....      BL       UART_GetInstance
   \       0x16   0x.... 0x....      LDR.W    R1,??DataTable28_11
   \       0x1A   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \       0x1E   0xE8BD 0x4002      POP      {R1,LR}
   \       0x22   0x....             B.N      CLOCK_DisableClock
    344          #endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
    345          }
    346          

   \                                 In section .text, align 2, keep-with-next
    347          void UART_GetDefaultConfig(uart_config_t *config)
    348          {
   \                     UART_GetDefaultConfig: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    349              assert(config);
   \        0x4   0xD109             BNE.N    ??UART_GetDefaultConfig_0
   \        0x6   0xF240 0x125D      MOVW     R2,#+349
   \        0xA   0x.... 0x....      LDR.W    R1,??DataTable27
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable28_4
   \       0x12   0x.... 0x....      BL       __aeabi_assert
   \       0x16   0x.... 0x....      BL       __iar_EmptyStepPoint
    350          
    351              config->baudRate_Bps = 115200U;
   \                     ??UART_GetDefaultConfig_0: (+1)
   \       0x1A   0xF44F 0x30E1      MOV      R0,#+115200
   \       0x1E   0x6020             STR      R0,[R4, #+0]
    352              config->parityMode = kUART_ParityDisabled;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x7120             STRB     R0,[R4, #+4]
    353          #if defined(FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_SUPPORT) && FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_SUPPORT
    354              config->stopBitCount = kUART_OneStopBit;
    355          #endif
    356          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    357              config->txFifoWatermark = 0;
   \       0x24   0x7160             STRB     R0,[R4, #+5]
    358              config->rxFifoWatermark = 1;
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0x71A0             STRB     R0,[R4, #+6]
    359          #endif
    360              config->enableTx = false;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x71E0             STRB     R0,[R4, #+7]
    361              config->enableRx = false;
   \       0x2E   0x7220             STRB     R0,[R4, #+8]
    362          }
   \       0x30   0xBD10             POP      {R4,PC}          ;; return
    363          

   \                                 In section .text, align 2, keep-with-next
    364          status_t UART_SetBaudRate(UART_Type *base, uint32_t baudRate_Bps, uint32_t srcClock_Hz)
    365          {
   \                     UART_SetBaudRate: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4616             MOV      R6,R2
    366              assert(baudRate_Bps);
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD109             BNE.N    ??UART_SetBaudRate_0
   \        0xC   0xF44F 0x72B7      MOV      R2,#+366
   \       0x10   0x.... 0x....      LDR.W    R1,??DataTable27
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable28_12
   \       0x18   0x.... 0x....      BL       __aeabi_assert
   \       0x1C   0x.... 0x....      BL       __iar_EmptyStepPoint
    367          
    368              uint16_t sbr = 0;
    369              uint32_t baudDiff = 0;
    370              uint8_t oldCtrl;
    371          
    372              /* Calculate the baud rate modulo divisor, sbr*/
    373              sbr = srcClock_Hz / (baudRate_Bps * 16);
   \                     ??UART_SetBaudRate_0: (+1)
   \       0x20   0x0120             LSLS     R0,R4,#+4
   \       0x22   0xFBB6 0xF0F0      UDIV     R0,R6,R0
   \       0x26   0xB280             UXTH     R0,R0
    374              /* set sbrTemp to 1 if the sourceClockInHz can not satisfy the desired baud rate */
    375              if (sbr == 0)
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD100             BNE.N    ??UART_SetBaudRate_1
    376              {
    377                  sbr = 1;
   \       0x2C   0x2001             MOVS     R0,#+1
    378              }
    379          #if defined(FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT) && FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT
    380              /* Determine if a fractional divider is needed to fine tune closer to the
    381               * desired baud, each value of brfa is in 1/32 increments,
    382               * hence the multiply-by-32. */
    383              uint32_t tempBaud = 0;
    384          
    385              uint16_t brfa = (2 * srcClock_Hz / (baudRate_Bps)) - 32 * sbr;
   \                     ??UART_SetBaudRate_1: (+1)
   \       0x2E   0x0071             LSLS     R1,R6,#+1
   \       0x30   0xFBB1 0xF2F4      UDIV     R2,R1,R4
   \       0x34   0xEBA2 0x1240      SUB      R2,R2,R0, LSL #+5
    386          
    387              /* Calculate the baud rate based on the temporary SBR values and BRFA */
    388              tempBaud = (srcClock_Hz * 2 / ((sbr * 32 + brfa)));
   \       0x38   0x0076             LSLS     R6,R6,#+1
   \       0x3A   0x0141             LSLS     R1,R0,#+5
   \       0x3C   0xFA11 0xF182      UXTAH    R1,R1,R2
   \       0x40   0xFBB6 0xF1F1      UDIV     R1,R6,R1
    389              baudDiff = (tempBaud > baudRate_Bps) ? (tempBaud - baudRate_Bps) : (baudRate_Bps - tempBaud);
   \       0x44   0x428C             CMP      R4,R1
   \       0x46   0xD201             BCS.N    ??UART_SetBaudRate_2
   \       0x48   0x1B09             SUBS     R1,R1,R4
   \       0x4A   0xE000             B.N      ??UART_SetBaudRate_3
   \                     ??UART_SetBaudRate_2: (+1)
   \       0x4C   0x1A61             SUBS     R1,R4,R1
    390          #else
    391              /* Calculate the baud rate based on the temporary SBR values */
    392              baudDiff = (srcClock_Hz / (sbr * 16)) - baudRate_Bps;
    393          
    394              /* Select the better value between sbr and (sbr + 1) */
    395              if (baudDiff > (baudRate_Bps - (srcClock_Hz / (16 * (sbr + 1)))))
    396              {
    397                  baudDiff = baudRate_Bps - (srcClock_Hz / (16 * (sbr + 1)));
    398                  sbr++;
    399              }
    400          #endif
    401          
    402              /* next, check to see if actual baud rate is within 3% of desired baud rate
    403               * based on the calculate SBR value */
    404              if (baudDiff < ((baudRate_Bps / 100) * 3))
   \                     ??UART_SetBaudRate_3: (+1)
   \       0x4E   0x2364             MOVS     R3,#+100
   \       0x50   0xFBB4 0xF3F3      UDIV     R3,R4,R3
   \       0x54   0xEB03 0x0343      ADD      R3,R3,R3, LSL #+1
   \       0x58   0x4299             CMP      R1,R3
   \       0x5A   0xD216             BCS.N    ??UART_SetBaudRate_4
    405              {
    406                  /* Store C2 before disable Tx and Rx */
    407                  oldCtrl = base->C2;
   \       0x5C   0x78EB             LDRB     R3,[R5, #+3]
    408          
    409                  /* Disable UART TX RX before setting. */
    410                  base->C2 &= ~(UART_C2_TE_MASK | UART_C2_RE_MASK);
   \       0x5E   0x78E9             LDRB     R1,[R5, #+3]
   \       0x60   0xF001 0x01F3      AND      R1,R1,#0xF3
   \       0x64   0x70E9             STRB     R1,[R5, #+3]
    411          
    412                  /* Write the sbr value to the BDH and BDL registers*/
    413                  base->BDH = (base->BDH & ~UART_BDH_SBR_MASK) | (uint8_t)(sbr >> 8);
   \       0x66   0x782C             LDRB     R4,[R5, #+0]
   \       0x68   0xF004 0x04E0      AND      R4,R4,#0xE0
   \       0x6C   0x4601             MOV      R1,R0
   \       0x6E   0xEA54 0x2421      ORRS     R4,R4,R1, ASR #+8
   \       0x72   0x702C             STRB     R4,[R5, #+0]
    414                  base->BDL = (uint8_t)sbr;
   \       0x74   0x7068             STRB     R0,[R5, #+1]
    415          
    416          #if defined(FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT) && FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT
    417                  /* Write the brfa value to the register*/
    418                  base->C4 = (base->C4 & ~UART_C4_BRFA_MASK) | (brfa & UART_C4_BRFA_MASK);
   \       0x76   0x7AA8             LDRB     R0,[R5, #+10]
   \       0x78   0xF000 0x00E0      AND      R0,R0,#0xE0
   \       0x7C   0xF002 0x021F      AND      R2,R2,#0x1F
   \       0x80   0x4302             ORRS     R2,R2,R0
   \       0x82   0x72AA             STRB     R2,[R5, #+10]
    419          #endif
    420                  /* Restore C2. */
    421                  base->C2 = oldCtrl;
   \       0x84   0x70EB             STRB     R3,[R5, #+3]
    422          
    423                  return kStatus_Success;
   \       0x86   0x2000             MOVS     R0,#+0
   \       0x88   0xBD70             POP      {R4-R6,PC}
    424              }
    425              else
    426              {
    427                  /* Unacceptable baud rate difference of more than 3%*/
    428                  return kStatus_UART_BaudrateNotSupport;
   \                     ??UART_SetBaudRate_4: (+1)
   \       0x8A   0xF240 0x30F5      MOVW     R0,#+1013
   \       0x8E   0xBD70             POP      {R4-R6,PC}       ;; return
    429              }
    430          }
    431          

   \                                 In section .text, align 2, keep-with-next
    432          void UART_EnableInterrupts(UART_Type *base, uint32_t mask)
    433          {
    434              mask &= kUART_AllInterruptsEnable;
   \                     UART_EnableInterrupts: (+1)
   \        0x0   0x.... 0x....      LDR.W    R2,??DataTable28_13  ;; 0x70ff0c0
   \        0x4   0x4011             ANDS     R1,R2,R1
    435          
    436              /* The interrupt mask is combined by control bits from several register: ((CFIFO<<24) | (C3<<16) | (C2<<8) |(BDH))
    437               */
    438              base->BDH |= mask;
   \        0x6   0x7802             LDRB     R2,[R0, #+0]
   \        0x8   0x430A             ORRS     R2,R1,R2
   \        0xA   0x7002             STRB     R2,[R0, #+0]
    439              base->C2 |= (mask >> 8);
   \        0xC   0x78C3             LDRB     R3,[R0, #+3]
   \        0xE   0x460A             MOV      R2,R1
   \       0x10   0xEA53 0x2312      ORRS     R3,R3,R2, LSR #+8
   \       0x14   0x70C3             STRB     R3,[R0, #+3]
    440              base->C3 |= (mask >> 16);
   \       0x16   0x7983             LDRB     R3,[R0, #+6]
   \       0x18   0x460A             MOV      R2,R1
   \       0x1A   0xEA53 0x4312      ORRS     R3,R3,R2, LSR #+16
   \       0x1E   0x7183             STRB     R3,[R0, #+6]
    441          
    442          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    443              base->CFIFO |= (mask >> 24);
   \       0x20   0x7C42             LDRB     R2,[R0, #+17]
   \       0x22   0xEA52 0x6111      ORRS     R1,R2,R1, LSR #+24
   \       0x26   0x7441             STRB     R1,[R0, #+17]
    444          #endif
    445          }
   \       0x28   0x4770             BX       LR               ;; return
    446          

   \                                 In section .text, align 2, keep-with-next
    447          void UART_DisableInterrupts(UART_Type *base, uint32_t mask)
    448          {
    449              mask &= kUART_AllInterruptsEnable;
   \                     UART_DisableInterrupts: (+1)
   \        0x0   0x.... 0x....      LDR.W    R2,??DataTable28_13  ;; 0x70ff0c0
   \        0x4   0x4011             ANDS     R1,R2,R1
    450          
    451              /* The interrupt mask is combined by control bits from several register: ((CFIFO<<24) | (C3<<16) | (C2<<8) |(BDH))
    452               */
    453              base->BDH &= ~mask;
   \        0x6   0x7802             LDRB     R2,[R0, #+0]
   \        0x8   0x438A             BICS     R2,R2,R1
   \        0xA   0x7002             STRB     R2,[R0, #+0]
    454              base->C2 &= ~(mask >> 8);
   \        0xC   0x78C3             LDRB     R3,[R0, #+3]
   \        0xE   0x460A             MOV      R2,R1
   \       0x10   0xEA33 0x2312      BICS     R3,R3,R2, LSR #+8
   \       0x14   0x70C3             STRB     R3,[R0, #+3]
    455              base->C3 &= ~(mask >> 16);
   \       0x16   0x7983             LDRB     R3,[R0, #+6]
   \       0x18   0x460A             MOV      R2,R1
   \       0x1A   0xEA33 0x4312      BICS     R3,R3,R2, LSR #+16
   \       0x1E   0x7183             STRB     R3,[R0, #+6]
    456          
    457          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    458              base->CFIFO &= ~(mask >> 24);
   \       0x20   0x7C42             LDRB     R2,[R0, #+17]
   \       0x22   0xEA22 0x6111      BIC      R1,R2,R1, LSR #+24
   \       0x26   0x7441             STRB     R1,[R0, #+17]
    459          #endif
    460          }
   \       0x28   0x4770             BX       LR               ;; return
    461          

   \                                 In section .text, align 2, keep-with-next
    462          uint32_t UART_GetEnabledInterrupts(UART_Type *base)
    463          {
   \                     UART_GetEnabledInterrupts: (+1)
   \        0x0   0x4601             MOV      R1,R0
    464              uint32_t temp;
    465          
    466              temp = base->BDH | ((uint32_t)(base->C2) << 8) | ((uint32_t)(base->C3) << 16);
   \        0x2   0x7808             LDRB     R0,[R1, #+0]
   \        0x4   0x78CA             LDRB     R2,[R1, #+3]
   \        0x6   0xEA40 0x2002      ORR      R0,R0,R2, LSL #+8
   \        0xA   0x798A             LDRB     R2,[R1, #+6]
   \        0xC   0xEA40 0x4002      ORR      R0,R0,R2, LSL #+16
    467          
    468          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    469              temp |= ((uint32_t)(base->CFIFO) << 24);
   \       0x10   0x7C49             LDRB     R1,[R1, #+17]
   \       0x12   0xEA40 0x6001      ORR      R0,R0,R1, LSL #+24
    470          #endif
    471          
    472              return temp & kUART_AllInterruptsEnable;
   \       0x16   0x.... 0x....      LDR.W    R1,??DataTable28_13  ;; 0x70ff0c0
   \       0x1A   0x4008             ANDS     R0,R1,R0
   \       0x1C   0x4770             BX       LR               ;; return
    473          }
    474          

   \                                 In section .text, align 2, keep-with-next
    475          uint32_t UART_GetStatusFlags(UART_Type *base)
    476          {
   \                     UART_GetStatusFlags: (+1)
   \        0x0   0x4601             MOV      R1,R0
    477              uint32_t status_flag;
    478          
    479              status_flag = base->S1 | ((uint32_t)(base->S2) << 8);
   \        0x2   0x7908             LDRB     R0,[R1, #+4]
   \        0x4   0x794A             LDRB     R2,[R1, #+5]
   \        0x6   0xEA40 0x2002      ORR      R0,R0,R2, LSL #+8
    480          
    481          #if defined(FSL_FEATURE_UART_HAS_EXTENDED_DATA_REGISTER_FLAGS) && FSL_FEATURE_UART_HAS_EXTENDED_DATA_REGISTER_FLAGS
    482              status_flag |= ((uint32_t)(base->ED) << 16);
   \        0xA   0x7B0A             LDRB     R2,[R1, #+12]
   \        0xC   0xEA40 0x4002      ORR      R0,R0,R2, LSL #+16
    483          #endif
    484          
    485          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    486              status_flag |= ((uint32_t)(base->SFIFO) << 24);
   \       0x10   0x7C89             LDRB     R1,[R1, #+18]
   \       0x12   0xEA40 0x6001      ORR      R0,R0,R1, LSL #+24
    487          #endif
    488          
    489              return status_flag;
   \       0x16   0x4770             BX       LR               ;; return
    490          }
    491          

   \                                 In section .text, align 2, keep-with-next
    492          status_t UART_ClearStatusFlags(UART_Type *base, uint32_t mask)
    493          {
   \                     UART_ClearStatusFlags: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x460C             MOV      R4,R1
    494              uint8_t reg = base->S2;
   \        0x4   0x7942             LDRB     R2,[R0, #+5]
    495              status_t status;
    496          
    497          #if defined(FSL_FEATURE_UART_HAS_LIN_BREAK_DETECT) && FSL_FEATURE_UART_HAS_LIN_BREAK_DETECT
    498              reg &= ~(UART_S2_RXEDGIF_MASK | UART_S2_LBKDIF_MASK);
    499          #else
    500              reg &= ~UART_S2_RXEDGIF_MASK;
    501          #endif
    502          
    503              base->S2 = reg | (uint8_t)(mask >> 8);
   \        0x6   0xF002 0x023F      AND      R2,R2,#0x3F
   \        0xA   0xEA52 0x2211      ORRS     R2,R2,R1, LSR #+8
   \        0xE   0x7142             STRB     R2,[R0, #+5]
    504          
    505          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    506              base->SFIFO = (uint8_t)(mask >> 24);
   \       0x10   0x4621             MOV      R1,R4
   \       0x12   0x0E09             LSRS     R1,R1,#+24
   \       0x14   0x7481             STRB     R1,[R0, #+18]
    507          #endif
    508          
    509              if (mask & (kUART_IdleLineFlag | kUART_NoiseErrorFlag | kUART_FramingErrorFlag | kUART_ParityErrorFlag))
   \       0x16   0xF014 0x0F17      TST      R4,#0x17
   \       0x1A   0xD001             BEQ.N    ??UART_ClearStatusFlags_0
    510              {
    511                  /* Read base->D to clear the flags. */
    512                  (void)base->S1;
   \       0x1C   0x7901             LDRB     R1,[R0, #+4]
    513                  (void)base->D;
   \       0x1E   0x79C1             LDRB     R1,[R0, #+7]
    514              }
    515          
    516              if (mask & kUART_RxOverrunFlag)
   \                     ??UART_ClearStatusFlags_0: (+1)
   \       0x20   0x0721             LSLS     R1,R4,#+28
   \       0x22   0xD505             BPL.N    ??UART_ClearStatusFlags_1
    517              {
    518                  /* Read base->D to clear the flags and Flush all data in FIFO. */
    519                  (void)base->S1;
   \       0x24   0x7901             LDRB     R1,[R0, #+4]
    520                  (void)base->D;
   \       0x26   0x79C1             LDRB     R1,[R0, #+7]
    521          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    522                  /* Flush FIFO date, otherwise FIFO pointer will be in unknown state. */
    523                  base->CFIFO |= UART_CFIFO_RXFLUSH_MASK;
   \       0x28   0x7C41             LDRB     R1,[R0, #+17]
   \       0x2A   0xF041 0x0140      ORR      R1,R1,#0x40
   \       0x2E   0x7441             STRB     R1,[R0, #+17]
    524          #endif
    525              }
    526          
    527              /* If some flags still pending. */
    528              if (mask & UART_GetStatusFlags(base))
   \                     ??UART_ClearStatusFlags_1: (+1)
   \       0x30   0x.... 0x....      BL       UART_GetStatusFlags
   \       0x34   0x4204             TST      R4,R0
   \       0x36   0xD002             BEQ.N    ??UART_ClearStatusFlags_2
    529              {
    530                  /* Some flags can only clear or set by the hardware itself, these flags are: kUART_TxDataRegEmptyFlag,
    531                  kUART_TransmissionCompleteFlag, kUART_RxDataRegFullFlag, kUART_RxActiveFlag, kUART_NoiseErrorInRxDataRegFlag,
    532                  kUART_ParityErrorInRxDataRegFlag, kUART_TxFifoEmptyFlag, kUART_RxFifoEmptyFlag. */
    533                  status = kStatus_UART_FlagCannotClearManually;
   \       0x38   0xF240 0x30EE      MOVW     R0,#+1006
   \       0x3C   0xBD10             POP      {R4,PC}
    534              }
    535              else
    536              {
    537                  status = kStatus_Success;
   \                     ??UART_ClearStatusFlags_2: (+1)
   \       0x3E   0x2000             MOVS     R0,#+0
    538              }
    539          
    540              return status;
   \       0x40   0xBD10             POP      {R4,PC}          ;; return
    541          }
    542          

   \                                 In section .text, align 2, keep-with-next
    543          void UART_WriteBlocking(UART_Type *base, const uint8_t *data, size_t length)
    544          {
   \                     UART_WriteBlocking: (+1)
   \        0x0   0xE005             B.N      ??UART_WriteBlocking_0
    545              /* This API can only ensure that the data is written into the data buffer but can't
    546              ensure all data in the data buffer are sent into the transmit shift buffer. */
    547              while (length--)
    548              {
    549                  while (!(base->S1 & UART_S1_TDRE_MASK))
   \                     ??UART_WriteBlocking_1: (+1)
   \        0x2   0x7903             LDRB     R3,[R0, #+4]
   \        0x4   0x061B             LSLS     R3,R3,#+24
   \        0x6   0xD5FC             BPL.N    ??UART_WriteBlocking_1
    550                  {
    551                  }
    552                  base->D = *(data++);
   \        0x8   0xF811 0x3B01      LDRB     R3,[R1], #+1
   \        0xC   0x71C3             STRB     R3,[R0, #+7]
    553              }
   \                     ??UART_WriteBlocking_0: (+1)
   \        0xE   0x4613             MOV      R3,R2
   \       0x10   0x1E5A             SUBS     R2,R3,#+1
   \       0x12   0x2B00             CMP      R3,#+0
   \       0x14   0xD1F5             BNE.N    ??UART_WriteBlocking_1
    554          }
   \       0x16   0x4770             BX       LR               ;; return
    555          

   \                                 In section .text, align 2, keep-with-next
    556          static void UART_WriteNonBlocking(UART_Type *base, const uint8_t *data, size_t length)
    557          {
   \                     UART_WriteNonBlocking: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4616             MOV      R6,R2
    558              assert(data);
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD109             BNE.N    ??UART_WriteNonBlocking_0
   \        0xC   0xF240 0x222E      MOVW     R2,#+558
   \       0x10   0x.... 0x....      LDR.W    R1,??DataTable27
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable28_14
   \       0x18   0x.... 0x....      BL       __aeabi_assert
   \       0x1C   0x.... 0x....      BL       __iar_EmptyStepPoint
    559          
    560              size_t i;
    561          
    562              /* The Non Blocking write data API assume user have ensured there is enough space in
    563              peripheral to write. */
    564              for (i = 0; i < length; i++)
   \                     ??UART_WriteNonBlocking_0: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xE002             B.N      ??UART_WriteNonBlocking_1
    565              {
    566                  base->D = data[i];
   \                     ??UART_WriteNonBlocking_2: (+1)
   \       0x24   0x5C21             LDRB     R1,[R4, R0]
   \       0x26   0x71E9             STRB     R1,[R5, #+7]
    567              }
   \       0x28   0x1C40             ADDS     R0,R0,#+1
   \                     ??UART_WriteNonBlocking_1: (+1)
   \       0x2A   0x42B0             CMP      R0,R6
   \       0x2C   0xD3FA             BCC.N    ??UART_WriteNonBlocking_2
    568          }
   \       0x2E   0xBD70             POP      {R4-R6,PC}       ;; return
    569          

   \                                 In section .text, align 2, keep-with-next
    570          status_t UART_ReadBlocking(UART_Type *base, uint8_t *data, size_t length)
    571          {
   \                     UART_ReadBlocking: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4615             MOV      R5,R2
    572              assert(data);
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD118             BNE.N    ??UART_ReadBlocking_0
   \        0xC   0xF44F 0x720F      MOV      R2,#+572
   \       0x10   0x.... 0x....      LDR.W    R1,??DataTable27
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable28_14
   \       0x18   0x.... 0x....      BL       __aeabi_assert
   \       0x1C   0x.... 0x....      BL       __iar_EmptyStepPoint
   \       0x20   0xE00D             B.N      ??UART_ReadBlocking_0
    573          
    574              uint32_t statusFlag;
    575          
    576              while (length--)
    577              {
    578          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    579                  while (!base->RCFIFO)
    580          #else
    581                  while (!(base->S1 & UART_S1_RDRF_MASK))
    582          #endif
    583                  {
    584                      statusFlag = UART_GetStatusFlags(base);
    585          
    586                      if (statusFlag & kUART_RxOverrunFlag)
    587                      {
    588                          return kStatus_UART_RxHardwareOverrun;
   \                     ??UART_ReadBlocking_1: (+1)
   \       0x22   0xF240 0x30F1      MOVW     R0,#+1009
   \       0x26   0xBD70             POP      {R4-R6,PC}
    589                      }
    590          
    591                      if (statusFlag & kUART_NoiseErrorFlag)
    592                      {
    593                          return kStatus_UART_NoiseError;
   \                     ??UART_ReadBlocking_2: (+1)
   \       0x28   0xF240 0x30F2      MOVW     R0,#+1010
   \       0x2C   0xBD70             POP      {R4-R6,PC}
    594                      }
    595          
    596                      if (statusFlag & kUART_FramingErrorFlag)
    597                      {
    598                          return kStatus_UART_FramingError;
   \                     ??UART_ReadBlocking_3: (+1)
   \       0x2E   0xF240 0x30F3      MOVW     R0,#+1011
   \       0x32   0xBD70             POP      {R4-R6,PC}
    599                      }
    600          
    601                      if (statusFlag & kUART_ParityErrorFlag)
    602                      {
    603                          return kStatus_UART_ParityError;
    604                      }
    605                  }
    606                  *(data++) = base->D;
    607              }
    608          
    609              return kStatus_Success;
   \                     ??UART_ReadBlocking_4: (+1)
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??UART_ReadBlocking_5: (+1)
   \       0x38   0x79F0             LDRB     R0,[R6, #+7]
   \       0x3A   0xF804 0x0B01      STRB     R0,[R4], #+1
   \                     ??UART_ReadBlocking_0: (+1)
   \       0x3E   0x4628             MOV      R0,R5
   \       0x40   0x1E45             SUBS     R5,R0,#+1
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD0F6             BEQ.N    ??UART_ReadBlocking_4
   \                     ??UART_ReadBlocking_6: (+1)
   \       0x46   0x7DB0             LDRB     R0,[R6, #+22]
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD1F5             BNE.N    ??UART_ReadBlocking_5
   \       0x4C   0x4630             MOV      R0,R6
   \       0x4E   0x.... 0x....      BL       UART_GetStatusFlags
   \       0x52   0x0701             LSLS     R1,R0,#+28
   \       0x54   0xD4E5             BMI.N    ??UART_ReadBlocking_1
   \       0x56   0x0741             LSLS     R1,R0,#+29
   \       0x58   0xD4E6             BMI.N    ??UART_ReadBlocking_2
   \       0x5A   0x0781             LSLS     R1,R0,#+30
   \       0x5C   0xD4E7             BMI.N    ??UART_ReadBlocking_3
   \       0x5E   0x07C0             LSLS     R0,R0,#+31
   \       0x60   0xD5F1             BPL.N    ??UART_ReadBlocking_6
   \       0x62   0xF44F 0x707D      MOV      R0,#+1012
   \       0x66   0xBD70             POP      {R4-R6,PC}
    610          }
    611          

   \                                 In section .text, align 2, keep-with-next
    612          static void UART_ReadNonBlocking(UART_Type *base, uint8_t *data, size_t length)
    613          {
   \                     UART_ReadNonBlocking: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4616             MOV      R6,R2
    614              assert(data);
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD109             BNE.N    ??UART_ReadNonBlocking_0
   \        0xC   0xF240 0x2266      MOVW     R2,#+614
   \       0x10   0x.... 0x....      LDR.W    R1,??DataTable27
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable28_14
   \       0x18   0x.... 0x....      BL       __aeabi_assert
   \       0x1C   0x.... 0x....      BL       __iar_EmptyStepPoint
    615          
    616              size_t i;
    617          
    618              /* The Non Blocking read data API assume user have ensured there is enough space in
    619              peripheral to write. */
    620              for (i = 0; i < length; i++)
   \                     ??UART_ReadNonBlocking_0: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xE002             B.N      ??UART_ReadNonBlocking_1
    621              {
    622                  data[i] = base->D;
   \                     ??UART_ReadNonBlocking_2: (+1)
   \       0x24   0x79E9             LDRB     R1,[R5, #+7]
   \       0x26   0x5421             STRB     R1,[R4, R0]
    623              }
   \       0x28   0x1C40             ADDS     R0,R0,#+1
   \                     ??UART_ReadNonBlocking_1: (+1)
   \       0x2A   0x42B0             CMP      R0,R6
   \       0x2C   0xD3FA             BCC.N    ??UART_ReadNonBlocking_2
    624          }
   \       0x2E   0xBD70             POP      {R4-R6,PC}       ;; return
    625          

   \                                 In section .text, align 2, keep-with-next
    626          void UART_TransferCreateHandle(UART_Type *base,
    627                                         uart_handle_t *handle,
    628                                         uart_transfer_callback_t callback,
    629                                         void *userData)
    630          {
   \                     UART_TransferCreateHandle: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4616             MOV      R6,R2
   \        0x8   0x461F             MOV      R7,R3
    631              assert(handle);
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD109             BNE.N    ??UART_TransferCreateHandle_0
   \        0xE   0xF240 0x2277      MOVW     R2,#+631
   \       0x12   0x.... 0x....      LDR.W    R1,??DataTable27
   \       0x16   0x.... 0x....      LDR.W    R0,??DataTable28_3
   \       0x1A   0x.... 0x....      BL       __aeabi_assert
   \       0x1E   0x.... 0x....      BL       __iar_EmptyStepPoint
    632          
    633              uint32_t instance;
    634          
    635              /* Zero the handle. */
    636              memset(handle, 0, sizeof(*handle));
   \                     ??UART_TransferCreateHandle_0: (+1)
   \       0x22   0x2200             MOVS     R2,#+0
   \       0x24   0x2130             MOVS     R1,#+48
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0x.... 0x....      BL       __aeabi_memset4
    637          
    638              /* Set the TX/RX state. */
    639              handle->rxState = kUART_RxIdle;
   \       0x2C   0x2002             MOVS     R0,#+2
   \       0x2E   0xF884 0x002D      STRB     R0,[R4, #+45]
    640              handle->txState = kUART_TxIdle;
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xF884 0x002C      STRB     R0,[R4, #+44]
    641          
    642              /* Set the callback and user data. */
    643              handle->callback = callback;
   \       0x38   0x6266             STR      R6,[R4, #+36]
    644              handle->userData = userData;
   \       0x3A   0x62A7             STR      R7,[R4, #+40]
    645          
    646          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    647              /* Note:
    648                 Take care of the RX FIFO, RX interrupt request only assert when received bytes
    649                 equal or more than RX water mark, there is potential issue if RX water
    650                 mark larger than 1.
    651                 For example, if RX FIFO water mark is 2, upper layer needs 5 bytes and
    652                 5 bytes are received. the last byte will be saved in FIFO but not trigger
    653                 RX interrupt because the water mark is 2.
    654               */
    655              base->RWFIFO = 1U;
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0x7568             STRB     R0,[R5, #+21]
    656          #endif
    657          
    658              /* Get instance from peripheral base address. */
    659              instance = UART_GetInstance(base);
   \       0x40   0x4628             MOV      R0,R5
   \       0x42   0x.... 0x....      BL       UART_GetInstance
    660          
    661              /* Save the handle in global variables to support the double weak mechanism. */
    662              s_uartHandle[instance] = handle;
   \       0x46   0x.... 0x....      LDR.W    R1,??DataTable28_15
   \       0x4A   0xF841 0x4020      STR      R4,[R1, R0, LSL #+2]
    663          
    664              s_uartIsr = UART_TransferHandleIRQ;
   \       0x4E   0x.... 0x....      ADR.W    R1,UART_TransferHandleIRQ
   \       0x52   0x.... 0x....      LDR.W    R2,??DataTable28_16
   \       0x56   0x6011             STR      R1,[R2, #+0]
    665              /* Enable interrupt in NVIC. */
    666              EnableIRQ(s_uartIRQ[instance]);
   \       0x58   0x.... 0x....      LDR.W    R1,??DataTable28_17
   \       0x5C   0x5608             LDRSB    R0,[R1, R0]
   \       0x5E   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \       0x62   0x....             B.N      EnableIRQ
    667          }
    668          

   \                                 In section .text, align 2, keep-with-next
    669          void UART_TransferStartRingBuffer(UART_Type *base, uart_handle_t *handle, uint8_t *ringBuffer, size_t ringBufferSize)
    670          {
   \                     UART_TransferStartRingBuffer: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4614             MOV      R4,R2
   \        0x8   0x461F             MOV      R7,R3
    671              assert(handle);
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD109             BNE.N    ??UART_TransferStartRingBuffer_0
   \        0xE   0xF240 0x229F      MOVW     R2,#+671
   \       0x12   0x.... 0x....      LDR.W    R1,??DataTable27
   \       0x16   0x.... 0x....      LDR.W    R0,??DataTable28_3
   \       0x1A   0x.... 0x....      BL       __aeabi_assert
   \       0x1E   0x.... 0x....      BL       __iar_EmptyStepPoint
    672              assert(ringBuffer);
   \                     ??UART_TransferStartRingBuffer_0: (+1)
   \       0x22   0x2C00             CMP      R4,#+0
   \       0x24   0xD109             BNE.N    ??UART_TransferStartRingBuffer_1
   \       0x26   0xF44F 0x7228      MOV      R2,#+672
   \       0x2A   0x.... 0x....      LDR.W    R1,??DataTable27
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable28_18
   \       0x32   0x.... 0x....      BL       __aeabi_assert
   \       0x36   0x.... 0x....      BL       __iar_EmptyStepPoint
    673          
    674              /* Setup the ringbuffer address */
    675              handle->rxRingBuffer = ringBuffer;
   \                     ??UART_TransferStartRingBuffer_1: (+1)
   \       0x3A   0x61AC             STR      R4,[R5, #+24]
    676              handle->rxRingBufferSize = ringBufferSize;
   \       0x3C   0x61EF             STR      R7,[R5, #+28]
    677              handle->rxRingBufferHead = 0U;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x8428             STRH     R0,[R5, #+32]
    678              handle->rxRingBufferTail = 0U;
   \       0x42   0x8468             STRH     R0,[R5, #+34]
    679          
    680              /* Enable the interrupt to accept the data when user need the ring buffer. */
    681              UART_EnableInterrupts(
    682                  base, kUART_RxDataRegFullInterruptEnable | kUART_RxOverrunInterruptEnable | kUART_FramingErrorInterruptEnable);
   \       0x44   0xF44F 0x2122      MOV      R1,#+663552
   \       0x48   0x4630             MOV      R0,R6
   \       0x4A   0x.... 0x....      BL       UART_EnableInterrupts
    683              /* Enable parity error interrupt when parity mode is enable*/
    684              if (UART_C1_PE_MASK & base->C1)
   \       0x4E   0x78B0             LDRB     R0,[R6, #+2]
   \       0x50   0x0780             LSLS     R0,R0,#+30
   \       0x52   0xD505             BPL.N    ??UART_TransferStartRingBuffer_2
    685              {
    686                  UART_EnableInterrupts(base, kUART_ParityErrorInterruptEnable);
   \       0x54   0xF44F 0x3180      MOV      R1,#+65536
   \       0x58   0x4630             MOV      R0,R6
   \       0x5A   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \       0x5E   0x....             B.N      UART_EnableInterrupts
    687              }
    688          }
   \                     ??UART_TransferStartRingBuffer_2: (+1)
   \       0x60   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    689          

   \                                 In section .text, align 2, keep-with-next
    690          void UART_TransferStopRingBuffer(UART_Type *base, uart_handle_t *handle)
    691          {
   \                     UART_TransferStopRingBuffer: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    692              assert(handle);
   \        0x6   0xD109             BNE.N    ??UART_TransferStopRingBuffer_0
   \        0x8   0xF44F 0x722D      MOV      R2,#+692
   \        0xC   0x.... 0x....      LDR.W    R1,??DataTable27
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable28_3
   \       0x14   0x.... 0x....      BL       __aeabi_assert
   \       0x18   0x.... 0x....      BL       __iar_EmptyStepPoint
    693          
    694              if (handle->rxState == kUART_RxIdle)
   \                     ??UART_TransferStopRingBuffer_0: (+1)
   \       0x1C   0xF894 0x002D      LDRB     R0,[R4, #+45]
   \       0x20   0x2802             CMP      R0,#+2
   \       0x22   0xD10C             BNE.N    ??UART_TransferStopRingBuffer_1
    695              {
    696                  UART_DisableInterrupts(base, kUART_RxDataRegFullInterruptEnable | kUART_RxOverrunInterruptEnable |
    697                                                   kUART_FramingErrorInterruptEnable);
   \       0x24   0xF44F 0x2122      MOV      R1,#+663552
   \       0x28   0x4628             MOV      R0,R5
   \       0x2A   0x.... 0x....      BL       UART_DisableInterrupts
    698                  /* Disable parity error interrupt when parity mode is enable*/
    699                  if (UART_C1_PE_MASK & base->C1)
   \       0x2E   0x78A8             LDRB     R0,[R5, #+2]
   \       0x30   0x0780             LSLS     R0,R0,#+30
   \       0x32   0xD504             BPL.N    ??UART_TransferStopRingBuffer_1
    700                  {
    701                      UART_DisableInterrupts(base, kUART_ParityErrorInterruptEnable);
   \       0x34   0xF44F 0x3180      MOV      R1,#+65536
   \       0x38   0x4628             MOV      R0,R5
   \       0x3A   0x.... 0x....      BL       UART_DisableInterrupts
    702                  }
    703              }
    704          
    705              handle->rxRingBuffer = NULL;
   \                     ??UART_TransferStopRingBuffer_1: (+1)
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x61A0             STR      R0,[R4, #+24]
    706              handle->rxRingBufferSize = 0U;
   \       0x42   0x61E0             STR      R0,[R4, #+28]
    707              handle->rxRingBufferHead = 0U;
   \       0x44   0x8420             STRH     R0,[R4, #+32]
    708              handle->rxRingBufferTail = 0U;
   \       0x46   0x8460             STRH     R0,[R4, #+34]
    709          }
   \       0x48   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    710          

   \                                 In section .text, align 2, keep-with-next
    711          status_t UART_TransferSendNonBlocking(UART_Type *base, uart_handle_t *handle, uart_transfer_t *xfer)
    712          {
   \                     UART_TransferSendNonBlocking: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4615             MOV      R5,R2
    713              assert(handle);
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD109             BNE.N    ??UART_TransferSendNonBlocking_0
   \        0xC   0xF240 0x22C9      MOVW     R2,#+713
   \       0x10   0x.... 0x....      LDR.W    R1,??DataTable27
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable28_3
   \       0x18   0x.... 0x....      BL       __aeabi_assert
   \       0x1C   0x.... 0x....      BL       __iar_EmptyStepPoint
    714              assert(xfer);
   \                     ??UART_TransferSendNonBlocking_0: (+1)
   \       0x20   0x2D00             CMP      R5,#+0
   \       0x22   0xD109             BNE.N    ??UART_TransferSendNonBlocking_1
   \       0x24   0xF240 0x22CA      MOVW     R2,#+714
   \       0x28   0x.... 0x....      LDR.W    R1,??DataTable27
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable28_19
   \       0x30   0x.... 0x....      BL       __aeabi_assert
   \       0x34   0x.... 0x....      BL       __iar_EmptyStepPoint
    715              assert(xfer->dataSize);
   \                     ??UART_TransferSendNonBlocking_1: (+1)
   \       0x38   0x6868             LDR      R0,[R5, #+4]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD109             BNE.N    ??UART_TransferSendNonBlocking_2
   \       0x3E   0xF240 0x22CB      MOVW     R2,#+715
   \       0x42   0x.... 0x....      LDR.W    R1,??DataTable27
   \       0x46   0x.... 0x....      LDR.W    R0,??DataTable28_20
   \       0x4A   0x.... 0x....      BL       __aeabi_assert
   \       0x4E   0x.... 0x....      BL       __iar_EmptyStepPoint
    716              assert(xfer->data);
   \                     ??UART_TransferSendNonBlocking_2: (+1)
   \       0x52   0x6828             LDR      R0,[R5, #+0]
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD109             BNE.N    ??UART_TransferSendNonBlocking_3
   \       0x58   0xF44F 0x7233      MOV      R2,#+716
   \       0x5C   0x.... 0x....      LDR.W    R1,??DataTable27
   \       0x60   0x.... 0x....      LDR.W    R0,??DataTable28_21
   \       0x64   0x.... 0x....      BL       __aeabi_assert
   \       0x68   0x.... 0x....      BL       __iar_EmptyStepPoint
    717          
    718              status_t status;
    719          
    720              /* Return error if current TX busy. */
    721              if (kUART_TxBusy == handle->txState)
   \                     ??UART_TransferSendNonBlocking_3: (+1)
   \       0x6C   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \       0x70   0x2801             CMP      R0,#+1
   \       0x72   0xD102             BNE.N    ??UART_TransferSendNonBlocking_4
    722              {
    723                  status = kStatus_UART_TxBusy;
   \       0x74   0xF44F 0x707A      MOV      R0,#+1000
   \       0x78   0xBD70             POP      {R4-R6,PC}
    724              }
    725              else
    726              {
    727                  handle->txData = xfer->data;
   \                     ??UART_TransferSendNonBlocking_4: (+1)
   \       0x7A   0x6828             LDR      R0,[R5, #+0]
   \       0x7C   0x6020             STR      R0,[R4, #+0]
    728                  handle->txDataSize = xfer->dataSize;
   \       0x7E   0x6868             LDR      R0,[R5, #+4]
   \       0x80   0x6060             STR      R0,[R4, #+4]
    729                  handle->txDataSizeAll = xfer->dataSize;
   \       0x82   0x6868             LDR      R0,[R5, #+4]
   \       0x84   0x60A0             STR      R0,[R4, #+8]
    730                  handle->txState = kUART_TxBusy;
   \       0x86   0x2001             MOVS     R0,#+1
   \       0x88   0xF884 0x002C      STRB     R0,[R4, #+44]
    731          
    732                  /* Enable transmiter interrupt. */
    733                  UART_EnableInterrupts(base, kUART_TxDataRegEmptyInterruptEnable);
   \       0x8C   0xF44F 0x4100      MOV      R1,#+32768
   \       0x90   0x4630             MOV      R0,R6
   \       0x92   0x.... 0x....      BL       UART_EnableInterrupts
    734          
    735                  status = kStatus_Success;
   \       0x96   0x2000             MOVS     R0,#+0
    736              }
    737          
    738              return status;
   \       0x98   0xBD70             POP      {R4-R6,PC}       ;; return
    739          }
    740          

   \                                 In section .text, align 2, keep-with-next
    741          void UART_TransferAbortSend(UART_Type *base, uart_handle_t *handle)
    742          {
   \                     UART_TransferAbortSend: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    743              assert(handle);
   \        0x6   0xD109             BNE.N    ??UART_TransferAbortSend_0
   \        0x8   0xF240 0x22E7      MOVW     R2,#+743
   \        0xC   0x.... 0x....      LDR.W    R1,??DataTable27
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable28_3
   \       0x14   0x.... 0x....      BL       __aeabi_assert
   \       0x18   0x.... 0x....      BL       __iar_EmptyStepPoint
    744          
    745              UART_DisableInterrupts(base, kUART_TxDataRegEmptyInterruptEnable | kUART_TransmissionCompleteInterruptEnable);
   \                     ??UART_TransferAbortSend_0: (+1)
   \       0x1C   0xF44F 0x4140      MOV      R1,#+49152
   \       0x20   0x4628             MOV      R0,R5
   \       0x22   0x.... 0x....      BL       UART_DisableInterrupts
    746          
    747              handle->txDataSize = 0;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x6060             STR      R0,[R4, #+4]
    748              handle->txState = kUART_TxIdle;
   \       0x2A   0xF884 0x002C      STRB     R0,[R4, #+44]
    749          }
   \       0x2E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    750          

   \                                 In section .text, align 2, keep-with-next
    751          status_t UART_TransferGetSendCount(UART_Type *base, uart_handle_t *handle, uint32_t *count)
    752          {
   \                     UART_TransferGetSendCount: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x460D             MOV      R5,R1
   \        0x4   0x4614             MOV      R4,R2
    753              assert(handle);
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD109             BNE.N    ??UART_TransferGetSendCount_0
   \        0xA   0xF240 0x22F1      MOVW     R2,#+753
   \        0xE   0x.... 0x....      LDR.W    R1,??DataTable27
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable28_3
   \       0x16   0x.... 0x....      BL       __aeabi_assert
   \       0x1A   0x.... 0x....      BL       __iar_EmptyStepPoint
    754              assert(count);
   \                     ??UART_TransferGetSendCount_0: (+1)
   \       0x1E   0x2C00             CMP      R4,#+0
   \       0x20   0xD109             BNE.N    ??UART_TransferGetSendCount_1
   \       0x22   0xF240 0x22F2      MOVW     R2,#+754
   \       0x26   0x.... 0x....      LDR.W    R1,??DataTable27
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable28_22
   \       0x2E   0x.... 0x....      BL       __aeabi_assert
   \       0x32   0x.... 0x....      BL       __iar_EmptyStepPoint
    755          
    756              if (kUART_TxIdle == handle->txState)
   \                     ??UART_TransferGetSendCount_1: (+1)
   \       0x36   0xF895 0x002C      LDRB     R0,[R5, #+44]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD101             BNE.N    ??UART_TransferGetSendCount_2
    757              {
    758                  return kStatus_NoTransferInProgress;
   \       0x3E   0x2006             MOVS     R0,#+6
   \       0x40   0xBD32             POP      {R1,R4,R5,PC}
    759              }
    760          
    761              *count = handle->txDataSizeAll - handle->txDataSize;
   \                     ??UART_TransferGetSendCount_2: (+1)
   \       0x42   0x68A9             LDR      R1,[R5, #+8]
   \       0x44   0x6868             LDR      R0,[R5, #+4]
   \       0x46   0x1A09             SUBS     R1,R1,R0
   \       0x48   0x6021             STR      R1,[R4, #+0]
    762          
    763              return kStatus_Success;
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    764          }
    765          

   \                                 In section .text, align 2, keep-with-next
    766          status_t UART_TransferReceiveNonBlocking(UART_Type *base,
    767                                                   uart_handle_t *handle,
    768                                                   uart_transfer_t *xfer,
    769                                                   size_t *receivedBytes)
    770          {
   \                     UART_TransferReceiveNonBlocking: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x461F             MOV      R7,R3
    771              assert(handle);
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xD109             BNE.N    ??UART_TransferReceiveNonBlocking_0
   \       0x10   0xF240 0x3203      MOVW     R2,#+771
   \       0x14   0x.... 0x....      LDR.W    R1,??DataTable27
   \       0x18   0x.... 0x....      LDR.W    R0,??DataTable28_3
   \       0x1C   0x.... 0x....      BL       __aeabi_assert
   \       0x20   0x.... 0x....      BL       __iar_EmptyStepPoint
    772              assert(xfer);
   \                     ??UART_TransferReceiveNonBlocking_0: (+1)
   \       0x24   0x2E00             CMP      R6,#+0
   \       0x26   0xD109             BNE.N    ??UART_TransferReceiveNonBlocking_1
   \       0x28   0xF44F 0x7241      MOV      R2,#+772
   \       0x2C   0x.... 0x....      LDR.W    R1,??DataTable27
   \       0x30   0x.... 0x....      LDR.W    R0,??DataTable28_19
   \       0x34   0x.... 0x....      BL       __aeabi_assert
   \       0x38   0x.... 0x....      BL       __iar_EmptyStepPoint
    773              assert(xfer->data);
   \                     ??UART_TransferReceiveNonBlocking_1: (+1)
   \       0x3C   0x6830             LDR      R0,[R6, #+0]
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD109             BNE.N    ??UART_TransferReceiveNonBlocking_2
   \       0x42   0xF240 0x3205      MOVW     R2,#+773
   \       0x46   0x.... 0x....      LDR.W    R1,??DataTable27
   \       0x4A   0x.... 0x....      LDR.W    R0,??DataTable28_21
   \       0x4E   0x.... 0x....      BL       __aeabi_assert
   \       0x52   0x.... 0x....      BL       __iar_EmptyStepPoint
    774              assert(xfer->dataSize);
   \                     ??UART_TransferReceiveNonBlocking_2: (+1)
   \       0x56   0x6870             LDR      R0,[R6, #+4]
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD109             BNE.N    ??UART_TransferReceiveNonBlocking_3
   \       0x5C   0xF240 0x3206      MOVW     R2,#+774
   \       0x60   0x.... 0x....      LDR.W    R1,??DataTable27
   \       0x64   0x.... 0x....      LDR.W    R0,??DataTable28_20
   \       0x68   0x.... 0x....      BL       __aeabi_assert
   \       0x6C   0x.... 0x....      BL       __iar_EmptyStepPoint
    775          
    776              uint32_t i;
    777              status_t status;
    778              /* How many bytes to copy from ring buffer to user memory. */
    779              size_t bytesToCopy = 0U;
    780              /* How many bytes to receive. */
    781              size_t bytesToReceive;
    782              /* How many bytes currently have received. */
    783              size_t bytesCurrentReceived;
    784          
    785              /* How to get data:
    786                 1. If RX ring buffer is not enabled, then save xfer->data and xfer->dataSize
    787                    to uart handle, enable interrupt to store received data to xfer->data. When
    788                    all data received, trigger callback.
    789                 2. If RX ring buffer is enabled and not empty, get data from ring buffer first.
    790                    If there are enough data in ring buffer, copy them to xfer->data and return.
    791                    If there are not enough data in ring buffer, copy all of them to xfer->data,
    792                    save the xfer->data remained empty space to uart handle, receive data
    793                    to this empty space and trigger callback when finished. */
    794          
    795              if (kUART_RxBusy == handle->rxState)
   \                     ??UART_TransferReceiveNonBlocking_3: (+1)
   \       0x70   0xF895 0x002D      LDRB     R0,[R5, #+45]
   \       0x74   0x2803             CMP      R0,#+3
   \       0x76   0xD102             BNE.N    ??UART_TransferReceiveNonBlocking_4
    796              {
    797                  status = kStatus_UART_RxBusy;
   \       0x78   0xF240 0x30E9      MOVW     R0,#+1001
   \       0x7C   0xE045             B.N      ??UART_TransferReceiveNonBlocking_5
    798              }
    799              else
    800              {
    801                  bytesToReceive = xfer->dataSize;
   \                     ??UART_TransferReceiveNonBlocking_4: (+1)
   \       0x7E   0x6874             LDR      R4,[R6, #+4]
    802                  bytesCurrentReceived = 0U;
   \       0x80   0xF04F 0x0900      MOV      R9,#+0
    803          
    804                  /* If RX ring buffer is used. */
    805                  if (handle->rxRingBuffer)
   \       0x84   0x69A8             LDR      R0,[R5, #+24]
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xD025             BEQ.N    ??UART_TransferReceiveNonBlocking_6
    806                  {
    807                      /* Disable UART RX IRQ, protect ring buffer. */
    808                      UART_DisableInterrupts(base, kUART_RxDataRegFullInterruptEnable);
   \       0x8A   0xF44F 0x5100      MOV      R1,#+8192
   \       0x8E   0x4640             MOV      R0,R8
   \       0x90   0x.... 0x....      BL       UART_DisableInterrupts
    809          
    810                      /* How many bytes in RX ring buffer currently. */
    811                      bytesToCopy = UART_TransferGetRxRingBufferLength(handle);
   \       0x94   0x4628             MOV      R0,R5
   \       0x96   0x.... 0x....      BL       UART_TransferGetRxRingBufferLength
    812          
    813                      if (bytesToCopy)
   \       0x9A   0x2800             CMP      R0,#+0
   \       0x9C   0xD037             BEQ.N    ??UART_TransferReceiveNonBlocking_7
    814                      {
    815                          bytesToCopy = MIN(bytesToReceive, bytesToCopy);
   \       0x9E   0x4284             CMP      R4,R0
   \       0xA0   0xD800             BHI.N    ??UART_TransferReceiveNonBlocking_8
   \       0xA2   0x4620             MOV      R0,R4
    816          
    817                          bytesToReceive -= bytesToCopy;
   \                     ??UART_TransferReceiveNonBlocking_8: (+1)
   \       0xA4   0x1A24             SUBS     R4,R4,R0
    818          
    819                          /* Copy data from ring buffer to user memory. */
    820                          for (i = 0U; i < bytesToCopy; i++)
   \       0xA6   0x4649             MOV      R1,R9
   \                     ??UART_TransferReceiveNonBlocking_9: (+1)
   \       0xA8   0x4281             CMP      R1,R0
   \       0xAA   0xD230             BCS.N    ??UART_TransferReceiveNonBlocking_7
    821                          {
    822                              xfer->data[bytesCurrentReceived++] = handle->rxRingBuffer[handle->rxRingBufferTail];
   \       0xAC   0x69AA             LDR      R2,[R5, #+24]
   \       0xAE   0x8C6B             LDRH     R3,[R5, #+34]
   \       0xB0   0x5CD2             LDRB     R2,[R2, R3]
   \       0xB2   0x6833             LDR      R3,[R6, #+0]
   \       0xB4   0xF803 0x2009      STRB     R2,[R3, R9]
   \       0xB8   0xF109 0x0901      ADD      R9,R9,#+1
    823          
    824                              /* Wrap to 0. Not use modulo (%) because it might be large and slow. */
    825                              if (handle->rxRingBufferTail + 1U == handle->rxRingBufferSize)
   \       0xBC   0x8C6A             LDRH     R2,[R5, #+34]
   \       0xBE   0x1C52             ADDS     R2,R2,#+1
   \       0xC0   0x69EB             LDR      R3,[R5, #+28]
   \       0xC2   0x429A             CMP      R2,R3
   \       0xC4   0xD003             BEQ.N    ??UART_TransferReceiveNonBlocking_10
    826                              {
    827                                  handle->rxRingBufferTail = 0U;
    828                              }
    829                              else
    830                              {
    831                                  handle->rxRingBufferTail++;
   \       0xC6   0x8C6A             LDRH     R2,[R5, #+34]
   \       0xC8   0x1C52             ADDS     R2,R2,#+1
   \       0xCA   0x846A             STRH     R2,[R5, #+34]
   \       0xCC   0xE001             B.N      ??UART_TransferReceiveNonBlocking_11
    832                              }
   \                     ??UART_TransferReceiveNonBlocking_10: (+1)
   \       0xCE   0x2200             MOVS     R2,#+0
   \       0xD0   0x846A             STRH     R2,[R5, #+34]
    833                          }
   \                     ??UART_TransferReceiveNonBlocking_11: (+1)
   \       0xD2   0x1C49             ADDS     R1,R1,#+1
   \       0xD4   0xE7E8             B.N      ??UART_TransferReceiveNonBlocking_9
    834                      }
    835          
    836                      /* If ring buffer does not have enough data, still need to read more data. */
    837                      if (bytesToReceive)
    838                      {
    839                          /* No data in ring buffer, save the request to UART handle. */
    840                          handle->rxData = xfer->data + bytesCurrentReceived;
    841                          handle->rxDataSize = bytesToReceive;
    842                          handle->rxDataSizeAll = bytesToReceive;
    843                          handle->rxState = kUART_RxBusy;
    844                      }
    845          
    846                      /* Enable UART RX IRQ if previously enabled. */
    847                      UART_EnableInterrupts(base, kUART_RxDataRegFullInterruptEnable);
    848          
    849                      /* Call user callback since all data are received. */
    850                      if (0 == bytesToReceive)
    851                      {
    852                          if (handle->callback)
    853                          {
    854                              handle->callback(base, handle, kStatus_UART_RxIdle, handle->userData);
    855                          }
    856                      }
    857                  }
    858                  /* Ring buffer not used. */
    859                  else
    860                  {
    861                      handle->rxData = xfer->data + bytesCurrentReceived;
   \                     ??UART_TransferReceiveNonBlocking_6: (+1)
   \       0xD6   0x6830             LDR      R0,[R6, #+0]
   \       0xD8   0x60E8             STR      R0,[R5, #+12]
    862                      handle->rxDataSize = bytesToReceive;
   \       0xDA   0x612C             STR      R4,[R5, #+16]
    863                      handle->rxDataSizeAll = bytesToReceive;
   \       0xDC   0x616C             STR      R4,[R5, #+20]
    864                      handle->rxState = kUART_RxBusy;
   \       0xDE   0x2003             MOVS     R0,#+3
   \       0xE0   0xF885 0x002D      STRB     R0,[R5, #+45]
    865          
    866                      /* Enable RX/Rx overrun/framing error interrupt. */
    867                      UART_EnableInterrupts(base, kUART_RxDataRegFullInterruptEnable | kUART_RxOverrunInterruptEnable |
    868                                                      kUART_FramingErrorInterruptEnable);
   \       0xE4   0xF44F 0x2122      MOV      R1,#+663552
   \       0xE8   0x4640             MOV      R0,R8
   \       0xEA   0x.... 0x....      BL       UART_EnableInterrupts
    869                      /* Enable parity error interrupt when parity mode is enable*/
    870                      if (UART_C1_PE_MASK & base->C1)
   \       0xEE   0xF898 0x0002      LDRB     R0,[R8, #+2]
   \       0xF2   0x0780             LSLS     R0,R0,#+30
   \       0xF4   0xD504             BPL.N    ??UART_TransferReceiveNonBlocking_12
    871                      {
    872                          UART_EnableInterrupts(base, kUART_ParityErrorInterruptEnable);
   \       0xF6   0xF44F 0x3180      MOV      R1,#+65536
   \       0xFA   0x4640             MOV      R0,R8
   \       0xFC   0x.... 0x....      BL       UART_EnableInterrupts
    873                      }
    874                  }
    875          
    876                  /* Return the how many bytes have read. */
    877                  if (receivedBytes)
   \                     ??UART_TransferReceiveNonBlocking_12: (+1)
   \      0x100   0x2F00             CMP      R7,#+0
   \      0x102   0xD001             BEQ.N    ??UART_TransferReceiveNonBlocking_13
    878                  {
    879                      *receivedBytes = bytesCurrentReceived;
   \      0x104   0xF8C7 0x9000      STR      R9,[R7, #+0]
    880                  }
    881          
    882                  status = kStatus_Success;
   \                     ??UART_TransferReceiveNonBlocking_13: (+1)
   \      0x108   0x2000             MOVS     R0,#+0
    883              }
    884          
    885              return status;
   \                     ??UART_TransferReceiveNonBlocking_5: (+1)
   \      0x10A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   \                     ??UART_TransferReceiveNonBlocking_7: (+1)
   \      0x10E   0x2C00             CMP      R4,#+0
   \      0x110   0xD007             BEQ.N    ??UART_TransferReceiveNonBlocking_14
   \      0x112   0x6830             LDR      R0,[R6, #+0]
   \      0x114   0x4448             ADD      R0,R0,R9
   \      0x116   0x60E8             STR      R0,[R5, #+12]
   \      0x118   0x612C             STR      R4,[R5, #+16]
   \      0x11A   0x616C             STR      R4,[R5, #+20]
   \      0x11C   0x2003             MOVS     R0,#+3
   \      0x11E   0xF885 0x002D      STRB     R0,[R5, #+45]
   \                     ??UART_TransferReceiveNonBlocking_14: (+1)
   \      0x122   0xF44F 0x5100      MOV      R1,#+8192
   \      0x126   0x4640             MOV      R0,R8
   \      0x128   0x.... 0x....      BL       UART_EnableInterrupts
   \      0x12C   0x2C00             CMP      R4,#+0
   \      0x12E   0xD1E7             BNE.N    ??UART_TransferReceiveNonBlocking_12
   \      0x130   0x6A68             LDR      R0,[R5, #+36]
   \      0x132   0x2800             CMP      R0,#+0
   \      0x134   0xD0E4             BEQ.N    ??UART_TransferReceiveNonBlocking_12
   \      0x136   0x6AAB             LDR      R3,[R5, #+40]
   \      0x138   0xF240 0x32EB      MOVW     R2,#+1003
   \      0x13C   0x4629             MOV      R1,R5
   \      0x13E   0x4640             MOV      R0,R8
   \      0x140   0x6A6C             LDR      R4,[R5, #+36]
   \      0x142   0x47A0             BLX      R4
   \      0x144   0xE7DC             B.N      ??UART_TransferReceiveNonBlocking_12
    886          }
    887          

   \                                 In section .text, align 2, keep-with-next
    888          void UART_TransferAbortReceive(UART_Type *base, uart_handle_t *handle)
    889          {
   \                     UART_TransferAbortReceive: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    890              assert(handle);
   \        0x6   0xD109             BNE.N    ??UART_TransferAbortReceive_0
   \        0x8   0xF240 0x327A      MOVW     R2,#+890
   \        0xC   0x.... 0x....      LDR.W    R1,??DataTable27
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable28_3
   \       0x14   0x.... 0x....      BL       __aeabi_assert
   \       0x18   0x.... 0x....      BL       __iar_EmptyStepPoint
    891          
    892              /* Only abort the receive to handle->rxData, the RX ring buffer is still working. */
    893              if (!handle->rxRingBuffer)
   \                     ??UART_TransferAbortReceive_0: (+1)
   \       0x1C   0x69A0             LDR      R0,[R4, #+24]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD10C             BNE.N    ??UART_TransferAbortReceive_1
    894              {
    895                  /* Disable RX interrupt. */
    896                  UART_DisableInterrupts(base, kUART_RxDataRegFullInterruptEnable | kUART_RxOverrunInterruptEnable |
    897                                                   kUART_FramingErrorInterruptEnable);
   \       0x22   0xF44F 0x2122      MOV      R1,#+663552
   \       0x26   0x4628             MOV      R0,R5
   \       0x28   0x.... 0x....      BL       UART_DisableInterrupts
    898                  /* Disable parity error interrupt when parity mode is enable*/
    899                  if (UART_C1_PE_MASK & base->C1)
   \       0x2C   0x78A8             LDRB     R0,[R5, #+2]
   \       0x2E   0x0780             LSLS     R0,R0,#+30
   \       0x30   0xD504             BPL.N    ??UART_TransferAbortReceive_1
    900                  {
    901                      UART_DisableInterrupts(base, kUART_ParityErrorInterruptEnable);
   \       0x32   0xF44F 0x3180      MOV      R1,#+65536
   \       0x36   0x4628             MOV      R0,R5
   \       0x38   0x.... 0x....      BL       UART_DisableInterrupts
    902                  }
    903              }
    904          
    905              handle->rxDataSize = 0U;
   \                     ??UART_TransferAbortReceive_1: (+1)
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0x6120             STR      R0,[R4, #+16]
    906              handle->rxState = kUART_RxIdle;
   \       0x40   0x2002             MOVS     R0,#+2
   \       0x42   0xF884 0x002D      STRB     R0,[R4, #+45]
    907          }
   \       0x46   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    908          

   \                                 In section .text, align 2, keep-with-next
    909          status_t UART_TransferGetReceiveCount(UART_Type *base, uart_handle_t *handle, uint32_t *count)
    910          {
   \                     UART_TransferGetReceiveCount: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x460D             MOV      R5,R1
   \        0x4   0x4614             MOV      R4,R2
    911              assert(handle);
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD107             BNE.N    ??UART_TransferGetReceiveCount_0
   \        0xA   0xF240 0x328F      MOVW     R2,#+911
   \        0xE   0x....             LDR.N    R1,??DataTable27
   \       0x10   0x....             LDR.N    R0,??DataTable28_3
   \       0x12   0x.... 0x....      BL       __aeabi_assert
   \       0x16   0x.... 0x....      BL       __iar_EmptyStepPoint
    912              assert(count);
   \                     ??UART_TransferGetReceiveCount_0: (+1)
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD108             BNE.N    ??UART_TransferGetReceiveCount_1
   \       0x1E   0xF44F 0x7264      MOV      R2,#+912
   \       0x22   0x....             LDR.N    R1,??DataTable27
   \       0x24   0x.... 0x....      LDR.W    R0,??DataTable28_22
   \       0x28   0x.... 0x....      BL       __aeabi_assert
   \       0x2C   0x.... 0x....      BL       __iar_EmptyStepPoint
    913          
    914              if (kUART_RxIdle == handle->rxState)
   \                     ??UART_TransferGetReceiveCount_1: (+1)
   \       0x30   0xF895 0x002D      LDRB     R0,[R5, #+45]
   \       0x34   0x2802             CMP      R0,#+2
   \       0x36   0xD101             BNE.N    ??UART_TransferGetReceiveCount_2
    915              {
    916                  return kStatus_NoTransferInProgress;
   \       0x38   0x2006             MOVS     R0,#+6
   \       0x3A   0xBD32             POP      {R1,R4,R5,PC}
    917              }
    918          
    919              if (!count)
   \                     ??UART_TransferGetReceiveCount_2: (+1)
   \       0x3C   0x2C00             CMP      R4,#+0
   \       0x3E   0xD101             BNE.N    ??UART_TransferGetReceiveCount_3
    920              {
    921                  return kStatus_InvalidArgument;
   \       0x40   0x2004             MOVS     R0,#+4
   \       0x42   0xBD32             POP      {R1,R4,R5,PC}
    922              }
    923          
    924              *count = handle->rxDataSizeAll - handle->rxDataSize;
   \                     ??UART_TransferGetReceiveCount_3: (+1)
   \       0x44   0x6969             LDR      R1,[R5, #+20]
   \       0x46   0x6928             LDR      R0,[R5, #+16]
   \       0x48   0x1A09             SUBS     R1,R1,R0
   \       0x4A   0x6021             STR      R1,[R4, #+0]
    925          
    926              return kStatus_Success;
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    927          }
    928          

   \                                 In section .text, align 4, keep-with-next
    929          void UART_TransferHandleIRQ(UART_Type *base, uart_handle_t *handle)
    930          {
   \                     UART_TransferHandleIRQ: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    931              assert(handle);
   \        0x6   0xD107             BNE.N    ??UART_TransferHandleIRQ_0
   \        0x8   0xF240 0x32A3      MOVW     R2,#+931
   \        0xC   0x....             LDR.N    R1,??DataTable27
   \        0xE   0x....             LDR.N    R0,??DataTable28_3
   \       0x10   0x.... 0x....      BL       __aeabi_assert
   \       0x14   0x.... 0x....      BL       __iar_EmptyStepPoint
    932          
    933              uint8_t count;
    934              uint8_t tempCount;
    935          
    936              /* If RX framing error */
    937              if (UART_S1_FE_MASK & base->S1)
   \                     ??UART_TransferHandleIRQ_0: (+1)
   \       0x18   0x7928             LDRB     R0,[R5, #+4]
   \       0x1A   0x0780             LSLS     R0,R0,#+30
   \       0x1C   0xD401             BMI.N    ??UART_TransferHandleIRQ_1
   \       0x1E   0xE016             B.N      ??UART_TransferHandleIRQ_2
    938              {
    939                  /* Read base->D to clear framing error flag, otherwise the RX does not work. */
    940                  while (base->S1 & UART_S1_RDRF_MASK)
    941                  {
    942                      (void)base->D;
   \                     ??UART_TransferHandleIRQ_3: (+1)
   \       0x20   0x79E8             LDRB     R0,[R5, #+7]
    943                  }
   \                     ??UART_TransferHandleIRQ_1: (+1)
   \       0x22   0x7928             LDRB     R0,[R5, #+4]
   \       0x24   0x0680             LSLS     R0,R0,#+26
   \       0x26   0xD4FB             BMI.N    ??UART_TransferHandleIRQ_3
    944          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    945                  /* Flush FIFO date, otherwise FIFO pointer will be in unknown state. */
    946                  base->CFIFO |= UART_CFIFO_RXFLUSH_MASK;
   \       0x28   0x7C68             LDRB     R0,[R5, #+17]
   \       0x2A   0xF040 0x0040      ORR      R0,R0,#0x40
   \       0x2E   0x7468             STRB     R0,[R5, #+17]
    947          #endif
    948          
    949                  handle->rxState = kUART_RxFramingError;
   \       0x30   0x2004             MOVS     R0,#+4
   \       0x32   0xF884 0x002D      STRB     R0,[R4, #+45]
    950                  handle->rxDataSize = 0U;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x6120             STR      R0,[R4, #+16]
    951                  /* Trigger callback. */
    952                  if (handle->callback)
   \       0x3A   0x6A60             LDR      R0,[R4, #+36]
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD006             BEQ.N    ??UART_TransferHandleIRQ_2
    953                  {
    954                      handle->callback(base, handle, kStatus_UART_FramingError, handle->userData);
   \       0x40   0x6AA3             LDR      R3,[R4, #+40]
   \       0x42   0xF240 0x32F3      MOVW     R2,#+1011
   \       0x46   0x4621             MOV      R1,R4
   \       0x48   0x4628             MOV      R0,R5
   \       0x4A   0x6A66             LDR      R6,[R4, #+36]
   \       0x4C   0x47B0             BLX      R6
    955                  }
    956              }
    957          
    958              /* If RX parity error */
    959              if (UART_S1_PF_MASK & base->S1)
   \                     ??UART_TransferHandleIRQ_2: (+1)
   \       0x4E   0x7928             LDRB     R0,[R5, #+4]
   \       0x50   0x07C0             LSLS     R0,R0,#+31
   \       0x52   0xD401             BMI.N    ??UART_TransferHandleIRQ_4
   \       0x54   0xE016             B.N      ??UART_TransferHandleIRQ_5
    960              {
    961                  /* Read base->D to clear parity error flag, otherwise the RX does not work. */
    962                  while (base->S1 & UART_S1_RDRF_MASK)
    963                  {
    964                      (void)base->D;
   \                     ??UART_TransferHandleIRQ_6: (+1)
   \       0x56   0x79E8             LDRB     R0,[R5, #+7]
    965                  }
   \                     ??UART_TransferHandleIRQ_4: (+1)
   \       0x58   0x7928             LDRB     R0,[R5, #+4]
   \       0x5A   0x0680             LSLS     R0,R0,#+26
   \       0x5C   0xD4FB             BMI.N    ??UART_TransferHandleIRQ_6
    966          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    967                  /* Flush FIFO date, otherwise FIFO pointer will be in unknown state. */
    968                  base->CFIFO |= UART_CFIFO_RXFLUSH_MASK;
   \       0x5E   0x7C68             LDRB     R0,[R5, #+17]
   \       0x60   0xF040 0x0040      ORR      R0,R0,#0x40
   \       0x64   0x7468             STRB     R0,[R5, #+17]
    969          #endif
    970          
    971                  handle->rxState = kUART_RxParityError;
   \       0x66   0x2005             MOVS     R0,#+5
   \       0x68   0xF884 0x002D      STRB     R0,[R4, #+45]
    972                  handle->rxDataSize = 0U;
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0x6120             STR      R0,[R4, #+16]
    973                  /* Trigger callback. */
    974                  if (handle->callback)
   \       0x70   0x6A60             LDR      R0,[R4, #+36]
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD006             BEQ.N    ??UART_TransferHandleIRQ_5
    975                  {
    976                      handle->callback(base, handle, kStatus_UART_ParityError, handle->userData);
   \       0x76   0x6AA3             LDR      R3,[R4, #+40]
   \       0x78   0xF44F 0x727D      MOV      R2,#+1012
   \       0x7C   0x4621             MOV      R1,R4
   \       0x7E   0x4628             MOV      R0,R5
   \       0x80   0x6A66             LDR      R6,[R4, #+36]
   \       0x82   0x47B0             BLX      R6
    977                  }
    978              }
    979          
    980              /* If RX overrun. */
    981              if (UART_S1_OR_MASK & base->S1)
   \                     ??UART_TransferHandleIRQ_5: (+1)
   \       0x84   0x7928             LDRB     R0,[R5, #+4]
   \       0x86   0x0700             LSLS     R0,R0,#+28
   \       0x88   0xD401             BMI.N    ??UART_TransferHandleIRQ_7
   \       0x8A   0xE011             B.N      ??UART_TransferHandleIRQ_8
    982              {
    983                  /* Read base->D to clear overrun flag, otherwise the RX does not work. */
    984                  while (base->S1 & UART_S1_RDRF_MASK)
    985                  {
    986                      (void)base->D;
   \                     ??UART_TransferHandleIRQ_9: (+1)
   \       0x8C   0x79E8             LDRB     R0,[R5, #+7]
    987                  }
   \                     ??UART_TransferHandleIRQ_7: (+1)
   \       0x8E   0x7928             LDRB     R0,[R5, #+4]
   \       0x90   0x0680             LSLS     R0,R0,#+26
   \       0x92   0xD4FB             BMI.N    ??UART_TransferHandleIRQ_9
    988          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    989                  /* Flush FIFO date, otherwise FIFO pointer will be in unknown state. */
    990                  base->CFIFO |= UART_CFIFO_RXFLUSH_MASK;
   \       0x94   0x7C68             LDRB     R0,[R5, #+17]
   \       0x96   0xF040 0x0040      ORR      R0,R0,#0x40
   \       0x9A   0x7468             STRB     R0,[R5, #+17]
    991          #endif
    992                  /* Trigger callback. */
    993                  if (handle->callback)
   \       0x9C   0x6A60             LDR      R0,[R4, #+36]
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD006             BEQ.N    ??UART_TransferHandleIRQ_8
    994                  {
    995                      handle->callback(base, handle, kStatus_UART_RxHardwareOverrun, handle->userData);
   \       0xA2   0x6AA3             LDR      R3,[R4, #+40]
   \       0xA4   0xF240 0x32F1      MOVW     R2,#+1009
   \       0xA8   0x4621             MOV      R1,R4
   \       0xAA   0x4628             MOV      R0,R5
   \       0xAC   0x6A66             LDR      R6,[R4, #+36]
   \       0xAE   0x47B0             BLX      R6
    996                  }
    997              }
    998          
    999              /* Receive data register full */
   1000              if ((UART_S1_RDRF_MASK & base->S1) && (UART_C2_RIE_MASK & base->C2))
   \                     ??UART_TransferHandleIRQ_8: (+1)
   \       0xB0   0x7928             LDRB     R0,[R5, #+4]
   \       0xB2   0x0680             LSLS     R0,R0,#+26
   \       0xB4   0xD544             BPL.N    ??UART_TransferHandleIRQ_10
   \       0xB6   0x78E8             LDRB     R0,[R5, #+3]
   \       0xB8   0x0680             LSLS     R0,R0,#+26
   \       0xBA   0xD541             BPL.N    ??UART_TransferHandleIRQ_10
   1001              {
   1002          /* Get the size that can be stored into buffer for this interrupt. */
   1003          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
   1004                  count = base->RCFIFO;
   \       0xBC   0x7DAE             LDRB     R6,[R5, #+22]
   \       0xBE   0xE00F             B.N      ??UART_TransferHandleIRQ_11
   1005          #else
   1006                  count = 1;
   1007          #endif
   1008          
   1009                  /* If handle->rxDataSize is not 0, first save data to handle->rxData. */
   1010                  while ((count) && (handle->rxDataSize))
   1011                  {
   1012          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
   1013                      tempCount = MIN(handle->rxDataSize, count);
   \                     ??UART_TransferHandleIRQ_12: (+1)
   \       0xC0   0x4637             MOV      R7,R6
   \       0xC2   0xB2FF             UXTB     R7,R7
   \       0xC4   0xE01C             B.N      ??UART_TransferHandleIRQ_13
   1014          #else
   1015                      tempCount = 1;
   1016          #endif
   1017          
   1018                      /* Using non block API to read the data from the registers. */
   1019                      UART_ReadNonBlocking(base, handle->rxData, tempCount);
   1020                      handle->rxData += tempCount;
   1021                      handle->rxDataSize -= tempCount;
   1022                      count -= tempCount;
   1023          
   1024                      /* If all the data required for upper layer is ready, trigger callback. */
   1025                      if (!handle->rxDataSize)
   1026                      {
   1027                          handle->rxState = kUART_RxIdle;
   \                     ??UART_TransferHandleIRQ_14: (+1)
   \       0xC6   0x2002             MOVS     R0,#+2
   \       0xC8   0xF884 0x002D      STRB     R0,[R4, #+45]
   1028          
   1029                          if (handle->callback)
   \       0xCC   0x6A60             LDR      R0,[R4, #+36]
   \       0xCE   0x2800             CMP      R0,#+0
   \       0xD0   0xD006             BEQ.N    ??UART_TransferHandleIRQ_11
   1030                          {
   1031                              handle->callback(base, handle, kStatus_UART_RxIdle, handle->userData);
   \       0xD2   0x6AA3             LDR      R3,[R4, #+40]
   \       0xD4   0xF240 0x32EB      MOVW     R2,#+1003
   \       0xD8   0x4621             MOV      R1,R4
   \       0xDA   0x4628             MOV      R0,R5
   \       0xDC   0x6A67             LDR      R7,[R4, #+36]
   \       0xDE   0x47B8             BLX      R7
   1032                          }
   1033                      }
   \                     ??UART_TransferHandleIRQ_11: (+1)
   \       0xE0   0x4630             MOV      R0,R6
   \       0xE2   0xB2C0             UXTB     R0,R0
   \       0xE4   0x2800             CMP      R0,#+0
   \       0xE6   0xF000 0x80C3      BEQ.W    ??UART_TransferHandleIRQ_15
   \       0xEA   0x6920             LDR      R0,[R4, #+16]
   \       0xEC   0x2800             CMP      R0,#+0
   \       0xEE   0xF000 0x80BF      BEQ.W    ??UART_TransferHandleIRQ_15
   \       0xF2   0x6920             LDR      R0,[R4, #+16]
   \       0xF4   0x4631             MOV      R1,R6
   \       0xF6   0xB2C9             UXTB     R1,R1
   \       0xF8   0x4288             CMP      R0,R1
   \       0xFA   0xD2E1             BCS.N    ??UART_TransferHandleIRQ_12
   \       0xFC   0x6927             LDR      R7,[R4, #+16]
   \       0xFE   0xB2FF             UXTB     R7,R7
   \                     ??UART_TransferHandleIRQ_13: (+1)
   \      0x100   0x463A             MOV      R2,R7
   \      0x102   0x68E1             LDR      R1,[R4, #+12]
   \      0x104   0x4628             MOV      R0,R5
   \      0x106   0x.... 0x....      BL       UART_ReadNonBlocking
   \      0x10A   0x68E0             LDR      R0,[R4, #+12]
   \      0x10C   0x4438             ADD      R0,R0,R7
   \      0x10E   0x60E0             STR      R0,[R4, #+12]
   \      0x110   0x6920             LDR      R0,[R4, #+16]
   \      0x112   0x1BC0             SUBS     R0,R0,R7
   \      0x114   0x6120             STR      R0,[R4, #+16]
   \      0x116   0x1BF6             SUBS     R6,R6,R7
   \      0x118   0x6920             LDR      R0,[R4, #+16]
   \      0x11A   0x2800             CMP      R0,#+0
   \      0x11C   0xD1E0             BNE.N    ??UART_TransferHandleIRQ_11
   \      0x11E   0xE7D2             B.N      ??UART_TransferHandleIRQ_14
   1034                  }
   1035          
   1036                  /* If use RX ring buffer, receive data to ring buffer. */
   1037                  if (handle->rxRingBuffer)
   1038                  {
   1039                      while (count--)
   1040                      {
   1041                          /* If RX ring buffer is full, trigger callback to notify over run. */
   1042                          if (UART_TransferIsRxRingBufferFull(handle))
   1043                          {
   1044                              if (handle->callback)
   1045                              {
   1046                                  handle->callback(base, handle, kStatus_UART_RxRingBufferOverrun, handle->userData);
   1047                              }
   1048                          }
   1049          
   1050                          /* If ring buffer is still full after callback function, the oldest data is overrided. */
   1051                          if (UART_TransferIsRxRingBufferFull(handle))
   1052                          {
   1053                              /* Increase handle->rxRingBufferTail to make room for new data. */
   1054                              if (handle->rxRingBufferTail + 1U == handle->rxRingBufferSize)
   1055                              {
   1056                                  handle->rxRingBufferTail = 0U;
   1057                              }
   1058                              else
   1059                              {
   1060                                  handle->rxRingBufferTail++;
   1061                              }
   1062                          }
   1063          
   1064                          /* Read data. */
   1065                          handle->rxRingBuffer[handle->rxRingBufferHead] = base->D;
   1066          
   1067                          /* Increase handle->rxRingBufferHead. */
   1068                          if (handle->rxRingBufferHead + 1U == handle->rxRingBufferSize)
   1069                          {
   1070                              handle->rxRingBufferHead = 0U;
   1071                          }
   1072                          else
   1073                          {
   1074                              handle->rxRingBufferHead++;
   1075                          }
   1076                      }
   1077                  }
   1078          
   1079                  else if (!handle->rxDataSize)
   \                     ??UART_TransferHandleIRQ_16: (+1)
   \      0x120   0x6920             LDR      R0,[R4, #+16]
   \      0x122   0x2800             CMP      R0,#+0
   \      0x124   0xD10C             BNE.N    ??UART_TransferHandleIRQ_10
   1080                  {
   1081                      /* Disable RX interrupt/overrun interrupt/fram error interrupt */
   1082                      UART_DisableInterrupts(base, kUART_RxDataRegFullInterruptEnable | kUART_RxOverrunInterruptEnable |
   1083                                                       kUART_FramingErrorInterruptEnable);
   \      0x126   0xF44F 0x2122      MOV      R1,#+663552
   \      0x12A   0x4628             MOV      R0,R5
   \      0x12C   0x.... 0x....      BL       UART_DisableInterrupts
   1084          
   1085                      /* Disable parity error interrupt when parity mode is enable*/
   1086                      if (UART_C1_PE_MASK & base->C1)
   \      0x130   0x78A8             LDRB     R0,[R5, #+2]
   \      0x132   0x0780             LSLS     R0,R0,#+30
   \      0x134   0xD504             BPL.N    ??UART_TransferHandleIRQ_10
   1087                      {
   1088                          UART_DisableInterrupts(base, kUART_ParityErrorInterruptEnable);
   \      0x136   0xF44F 0x3180      MOV      R1,#+65536
   \      0x13A   0x4628             MOV      R0,R5
   \      0x13C   0x.... 0x....      BL       UART_DisableInterrupts
   1089                      }
   1090                  }
   1091                  else
   1092                  {
   1093                  }
   1094              }
   1095          
   1096              /* If framing error or parity error happened, stop the RX interrupt when ues no ring buffer */
   1097              if (((handle->rxState == kUART_RxFramingError) || (handle->rxState == kUART_RxParityError)) &&
   1098                  (!handle->rxRingBuffer))
   \                     ??UART_TransferHandleIRQ_10: (+1)
   \      0x140   0xF894 0x002D      LDRB     R0,[R4, #+45]
   \      0x144   0x2804             CMP      R0,#+4
   \      0x146   0xD003             BEQ.N    ??UART_TransferHandleIRQ_17
   \      0x148   0xF894 0x002D      LDRB     R0,[R4, #+45]
   \      0x14C   0x2805             CMP      R0,#+5
   \      0x14E   0xD10F             BNE.N    ??UART_TransferHandleIRQ_18
   \                     ??UART_TransferHandleIRQ_17: (+1)
   \      0x150   0x69A0             LDR      R0,[R4, #+24]
   \      0x152   0x2800             CMP      R0,#+0
   \      0x154   0xD10C             BNE.N    ??UART_TransferHandleIRQ_18
   1099              {
   1100                  UART_DisableInterrupts(base, kUART_RxDataRegFullInterruptEnable | kUART_RxOverrunInterruptEnable |
   1101                                                   kUART_FramingErrorInterruptEnable);
   \      0x156   0xF44F 0x2122      MOV      R1,#+663552
   \      0x15A   0x4628             MOV      R0,R5
   \      0x15C   0x.... 0x....      BL       UART_DisableInterrupts
   1102          
   1103                  /* Disable parity error interrupt when parity mode is enable*/
   1104                  if (UART_C1_PE_MASK & base->C1)
   \      0x160   0x78A8             LDRB     R0,[R5, #+2]
   \      0x162   0x0780             LSLS     R0,R0,#+30
   \      0x164   0xD504             BPL.N    ??UART_TransferHandleIRQ_18
   1105                  {
   1106                      UART_DisableInterrupts(base, kUART_ParityErrorInterruptEnable);
   \      0x166   0xF44F 0x3180      MOV      R1,#+65536
   \      0x16A   0x4628             MOV      R0,R5
   \      0x16C   0x.... 0x....      BL       UART_DisableInterrupts
   1107                  }
   1108              }
   1109          
   1110              /* Send data register empty and the interrupt is enabled. */
   1111              if ((base->S1 & UART_S1_TDRE_MASK) && (base->C2 & UART_C2_TIE_MASK))
   \                     ??UART_TransferHandleIRQ_18: (+1)
   \      0x170   0x7928             LDRB     R0,[R5, #+4]
   \      0x172   0x0600             LSLS     R0,R0,#+24
   \      0x174   0xF140 0x8080      BPL.W    ??UART_TransferHandleIRQ_19
   \      0x178   0x78E8             LDRB     R0,[R5, #+3]
   \      0x17A   0x0600             LSLS     R0,R0,#+24
   \      0x17C   0xD57C             BPL.N    ??UART_TransferHandleIRQ_19
   1112              {
   1113          /* Get the bytes that available at this moment. */
   1114          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
   1115                  count = FSL_FEATURE_UART_FIFO_SIZEn(base) - base->TCFIFO;
   \      0x17E   0x....             LDR.N    R0,??DataTable28_6  ;; 0x4006a000
   \      0x180   0x4285             CMP      R5,R0
   \      0x182   0xD134             BNE.N    ??UART_TransferHandleIRQ_20
   \      0x184   0x2008             MOVS     R0,#+8
   \      0x186   0xE03E             B.N      ??UART_TransferHandleIRQ_21
   \                     ??UART_TransferHandleIRQ_22: (+1)
   \      0x188   0x2000             MOVS     R0,#+0
   \      0x18A   0x8420             STRH     R0,[R4, #+32]
   \                     ??UART_TransferHandleIRQ_23: (+1)
   \      0x18C   0x4630             MOV      R0,R6
   \      0x18E   0x1E46             SUBS     R6,R0,#+1
   \      0x190   0xB2C0             UXTB     R0,R0
   \      0x192   0x2800             CMP      R0,#+0
   \      0x194   0xD0D4             BEQ.N    ??UART_TransferHandleIRQ_10
   \      0x196   0x4620             MOV      R0,R4
   \      0x198   0x.... 0x....      BL       UART_TransferIsRxRingBufferFull
   \      0x19C   0x2800             CMP      R0,#+0
   \      0x19E   0xD009             BEQ.N    ??UART_TransferHandleIRQ_24
   \      0x1A0   0x6A60             LDR      R0,[R4, #+36]
   \      0x1A2   0x2800             CMP      R0,#+0
   \      0x1A4   0xD006             BEQ.N    ??UART_TransferHandleIRQ_24
   \      0x1A6   0x6AA3             LDR      R3,[R4, #+40]
   \      0x1A8   0xF44F 0x727C      MOV      R2,#+1008
   \      0x1AC   0x4621             MOV      R1,R4
   \      0x1AE   0x4628             MOV      R0,R5
   \      0x1B0   0x6A67             LDR      R7,[R4, #+36]
   \      0x1B2   0x47B8             BLX      R7
   \                     ??UART_TransferHandleIRQ_24: (+1)
   \      0x1B4   0x4620             MOV      R0,R4
   \      0x1B6   0x.... 0x....      BL       UART_TransferIsRxRingBufferFull
   \      0x1BA   0x2800             CMP      R0,#+0
   \      0x1BC   0xD00A             BEQ.N    ??UART_TransferHandleIRQ_25
   \      0x1BE   0x8C60             LDRH     R0,[R4, #+34]
   \      0x1C0   0x1C40             ADDS     R0,R0,#+1
   \      0x1C2   0x69E1             LDR      R1,[R4, #+28]
   \      0x1C4   0x4288             CMP      R0,R1
   \      0x1C6   0xD102             BNE.N    ??UART_TransferHandleIRQ_26
   \      0x1C8   0x2000             MOVS     R0,#+0
   \      0x1CA   0x8460             STRH     R0,[R4, #+34]
   \      0x1CC   0xE002             B.N      ??UART_TransferHandleIRQ_25
   \                     ??UART_TransferHandleIRQ_26: (+1)
   \      0x1CE   0x8C60             LDRH     R0,[R4, #+34]
   \      0x1D0   0x1C40             ADDS     R0,R0,#+1
   \      0x1D2   0x8460             STRH     R0,[R4, #+34]
   \                     ??UART_TransferHandleIRQ_25: (+1)
   \      0x1D4   0x8C20             LDRH     R0,[R4, #+32]
   \      0x1D6   0x79E9             LDRB     R1,[R5, #+7]
   \      0x1D8   0x69A2             LDR      R2,[R4, #+24]
   \      0x1DA   0x5411             STRB     R1,[R2, R0]
   \      0x1DC   0x8C20             LDRH     R0,[R4, #+32]
   \      0x1DE   0x1C40             ADDS     R0,R0,#+1
   \      0x1E0   0x69E1             LDR      R1,[R4, #+28]
   \      0x1E2   0x4288             CMP      R0,R1
   \      0x1E4   0xD0D0             BEQ.N    ??UART_TransferHandleIRQ_22
   \      0x1E6   0x8C20             LDRH     R0,[R4, #+32]
   \      0x1E8   0x1C40             ADDS     R0,R0,#+1
   \      0x1EA   0x8420             STRH     R0,[R4, #+32]
   \      0x1EC   0xE7CE             B.N      ??UART_TransferHandleIRQ_23
   \                     ??UART_TransferHandleIRQ_20: (+1)
   \      0x1EE   0x....             LDR.N    R0,??DataTable28_7  ;; 0x4006b000
   \      0x1F0   0x4285             CMP      R5,R0
   \      0x1F2   0xD101             BNE.N    ??UART_TransferHandleIRQ_27
   \      0x1F4   0x2001             MOVS     R0,#+1
   \      0x1F6   0xE006             B.N      ??UART_TransferHandleIRQ_21
   \                     ??UART_TransferHandleIRQ_27: (+1)
   \      0x1F8   0x....             LDR.N    R0,??DataTable28_8  ;; 0x4006c000
   \      0x1FA   0x4285             CMP      R5,R0
   \      0x1FC   0xD101             BNE.N    ??UART_TransferHandleIRQ_28
   \      0x1FE   0x2001             MOVS     R0,#+1
   \      0x200   0xE001             B.N      ??UART_TransferHandleIRQ_21
   \                     ??UART_TransferHandleIRQ_28: (+1)
   \      0x202   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??UART_TransferHandleIRQ_21: (+1)
   \      0x206   0x7D2E             LDRB     R6,[R5, #+20]
   \      0x208   0x1B86             SUBS     R6,R0,R6
   \      0x20A   0xE013             B.N      ??UART_TransferHandleIRQ_29
   1116          #else
   1117                  count = 1;
   1118          #endif
   1119          
   1120                  while ((count) && (handle->txDataSize))
   1121                  {
   1122          #if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
   1123                      tempCount = MIN(handle->txDataSize, count);
   \                     ??UART_TransferHandleIRQ_30: (+1)
   \      0x20C   0x4637             MOV      R7,R6
   \      0x20E   0xB2FF             UXTB     R7,R7
   \      0x210   0xE01E             B.N      ??UART_TransferHandleIRQ_31
   1124          #else
   1125                      tempCount = 1;
   1126          #endif
   1127          
   1128                      /* Using non block API to write the data to the registers. */
   1129                      UART_WriteNonBlocking(base, handle->txData, tempCount);
   1130                      handle->txData += tempCount;
   1131                      handle->txDataSize -= tempCount;
   1132                      count -= tempCount;
   1133          
   1134                      /* If all the data are written to data register, TX finished. */
   1135                      if (!handle->txDataSize)
   1136                      {
   1137                          handle->txState = kUART_TxIdle;
   \                     ??UART_TransferHandleIRQ_32: (+1)
   \      0x212   0x2000             MOVS     R0,#+0
   \      0x214   0xF884 0x002C      STRB     R0,[R4, #+44]
   1138          
   1139                          /* Disable TX register empty interrupt. */
   1140                          base->C2 = (base->C2 & ~UART_C2_TIE_MASK);
   \      0x218   0x78E8             LDRB     R0,[R5, #+3]
   \      0x21A   0xF000 0x007F      AND      R0,R0,#0x7F
   \      0x21E   0x70E8             STRB     R0,[R5, #+3]
   1141          
   1142                          /* Trigger callback. */
   1143                          if (handle->callback)
   \      0x220   0x6A60             LDR      R0,[R4, #+36]
   \      0x222   0x2800             CMP      R0,#+0
   \      0x224   0xD006             BEQ.N    ??UART_TransferHandleIRQ_29
   1144                          {
   1145                              handle->callback(base, handle, kStatus_UART_TxIdle, handle->userData);
   \      0x226   0x6AA3             LDR      R3,[R4, #+40]
   \      0x228   0xF240 0x32EA      MOVW     R2,#+1002
   \      0x22C   0x4621             MOV      R1,R4
   \      0x22E   0x4628             MOV      R0,R5
   \      0x230   0x6A67             LDR      R7,[R4, #+36]
   \      0x232   0x47B8             BLX      R7
   1146                          }
   1147                      }
   \                     ??UART_TransferHandleIRQ_29: (+1)
   \      0x234   0x4630             MOV      R0,R6
   \      0x236   0xB2C0             UXTB     R0,R0
   \      0x238   0x2800             CMP      R0,#+0
   \      0x23A   0xD01D             BEQ.N    ??UART_TransferHandleIRQ_19
   \      0x23C   0x6860             LDR      R0,[R4, #+4]
   \      0x23E   0x2800             CMP      R0,#+0
   \      0x240   0xD01A             BEQ.N    ??UART_TransferHandleIRQ_19
   \      0x242   0x6860             LDR      R0,[R4, #+4]
   \      0x244   0x4631             MOV      R1,R6
   \      0x246   0xB2C9             UXTB     R1,R1
   \      0x248   0x4288             CMP      R0,R1
   \      0x24A   0xD2DF             BCS.N    ??UART_TransferHandleIRQ_30
   \      0x24C   0x6867             LDR      R7,[R4, #+4]
   \      0x24E   0xB2FF             UXTB     R7,R7
   \                     ??UART_TransferHandleIRQ_31: (+1)
   \      0x250   0x463A             MOV      R2,R7
   \      0x252   0x6821             LDR      R1,[R4, #+0]
   \      0x254   0x4628             MOV      R0,R5
   \      0x256   0x.... 0x....      BL       UART_WriteNonBlocking
   \      0x25A   0x6820             LDR      R0,[R4, #+0]
   \      0x25C   0x4438             ADD      R0,R0,R7
   \      0x25E   0x6020             STR      R0,[R4, #+0]
   \      0x260   0x6860             LDR      R0,[R4, #+4]
   \      0x262   0x1BC0             SUBS     R0,R0,R7
   \      0x264   0x6060             STR      R0,[R4, #+4]
   \      0x266   0x1BF6             SUBS     R6,R6,R7
   \      0x268   0x6860             LDR      R0,[R4, #+4]
   \      0x26A   0x2800             CMP      R0,#+0
   \      0x26C   0xD1E2             BNE.N    ??UART_TransferHandleIRQ_29
   \      0x26E   0xE7D0             B.N      ??UART_TransferHandleIRQ_32
   1148                  }
   1149              }
   \                     ??UART_TransferHandleIRQ_15: (+1)
   \      0x270   0x69A0             LDR      R0,[R4, #+24]
   \      0x272   0x2800             CMP      R0,#+0
   \      0x274   0xD18A             BNE.N    ??UART_TransferHandleIRQ_23
   \      0x276   0xE753             B.N      ??UART_TransferHandleIRQ_16
   1150          }
   \                     ??UART_TransferHandleIRQ_19: (+1)
   \      0x278   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1151          

   \                                 In section .text, align 2, keep-with-next
   1152          void UART_TransferHandleErrorIRQ(UART_Type *base, uart_handle_t *handle)
   1153          {
   1154              /* To be implemented by User. */
   1155          }
   \                     UART_TransferHandleErrorIRQ: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   1156          
   1157          #if defined(UART0)
   1158          #if ((!(defined(FSL_FEATURE_SOC_LPSCI_COUNT))) || \
   1159               ((defined(FSL_FEATURE_SOC_LPSCI_COUNT)) && (FSL_FEATURE_SOC_LPSCI_COUNT == 0)))

   \                                 In section .text, align 2, keep-with-next
   1160          void UART0_DriverIRQHandler(void)
   1161          {
   1162              s_uartIsr(UART0, s_uartHandle[0]);
   \                     UART0_DriverIRQHandler: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable28_15
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x....             LDR.N    R0,??DataTable28_6  ;; 0x4006a000
   \        0x6   0x....             LDR.N    R2,??DataTable28_16
   \        0x8   0x6812             LDR      R2,[R2, #+0]
   \        0xA   0x4710             BX       R2
   1163          }
   1164          

   \                                 In section .text, align 2, keep-with-next
   1165          void UART0_RX_TX_DriverIRQHandler(void)
   1166          {
   1167              UART0_DriverIRQHandler();
   \                     UART0_RX_TX_DriverIRQHandler: (+1)
   \        0x0   0x....             B.N      UART0_DriverIRQHandler
   1168          }
   1169          #endif
   1170          #endif
   1171          
   1172          #if defined(UART1)

   \                                 In section .text, align 2, keep-with-next
   1173          void UART1_DriverIRQHandler(void)
   1174          {
   1175              s_uartIsr(UART1, s_uartHandle[1]);
   \                     UART1_DriverIRQHandler: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable28_15
   \        0x2   0x6841             LDR      R1,[R0, #+4]
   \        0x4   0x....             LDR.N    R0,??DataTable28_7  ;; 0x4006b000
   \        0x6   0x....             LDR.N    R2,??DataTable28_16
   \        0x8   0x6812             LDR      R2,[R2, #+0]
   \        0xA   0x4710             BX       R2
   1176          }
   1177          

   \                                 In section .text, align 2, keep-with-next
   1178          void UART1_RX_TX_DriverIRQHandler(void)
   1179          {
   1180              UART1_DriverIRQHandler();
   \                     UART1_RX_TX_DriverIRQHandler: (+1)
   \        0x0   0x....             B.N      UART1_DriverIRQHandler
   1181          }
   1182          #endif
   1183          
   1184          #if defined(UART2)

   \                                 In section .text, align 2, keep-with-next
   1185          void UART2_DriverIRQHandler(void)
   1186          {
   1187              s_uartIsr(UART2, s_uartHandle[2]);
   \                     UART2_DriverIRQHandler: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable28_15
   \        0x2   0x6881             LDR      R1,[R0, #+8]
   \        0x4   0x....             LDR.N    R0,??DataTable28_8  ;; 0x4006c000
   \        0x6   0x....             LDR.N    R2,??DataTable28_16
   \        0x8   0x6812             LDR      R2,[R2, #+0]
   \        0xA   0x4710             BX       R2
   1188          }
   1189          

   \                                 In section .text, align 2, keep-with-next
   1190          void UART2_RX_TX_DriverIRQHandler(void)
   1191          {
   1192              UART2_DriverIRQHandler();
   \                     UART2_RX_TX_DriverIRQHandler: (+1)
   \        0x0   0x....             B.N      UART2_DriverIRQHandler
   1193          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \        0x0   0x....'....        DC32     s_uartBases

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \        0x0   0xE000'E100        DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_1:
   \        0x0   0x4004'7000        DC32     0x40047000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_2:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_3:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_4:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_5:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_6:
   \        0x0   0x4006'A000        DC32     0x4006a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_7:
   \        0x0   0x4006'B000        DC32     0x4006b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_8:
   \        0x0   0x4006'C000        DC32     0x4006c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_9:
   \        0x0   0x....'....        DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_10:
   \        0x0   0x....'....        DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_11:
   \        0x0   0x....'....        DC32     s_uartClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_12:
   \        0x0   0x....'....        DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_13:
   \        0x0   0x070F'F0C0        DC32     0x70ff0c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_14:
   \        0x0   0x....'....        DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_15:
   \        0x0   0x....'....        DC32     s_uartHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_16:
   \        0x0   0x....'....        DC32     s_uartIsr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_17:
   \        0x0   0x....'....        DC32     s_uartIRQ

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_18:
   \        0x0   0x....'....        DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_19:
   \        0x0   0x....'....        DC32     ?_10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_20:
   \        0x0   0x....'....        DC32     ?_11

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_21:
   \        0x0   0x....'....        DC32     ?_12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_22:
   \        0x0   0x....'....        DC32     ?_13

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x69 0x6E          DC8 "instance < uartArrayCount"
   \              0x73 0x74    
   \              0x61 0x6E    
   \              0x63 0x65    
   \              0x20 0x3C    
   \              0x20 0x75    
   \              0x61 0x72    
   \              0x74 0x41    
   \              0x72 0x72    
   \              0x61 0x79    
   \              0x43 0x6F    
   \              0x75 0x6E    
   \              0x74 0x00    
   \       0x1A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x66 0x73          DC8 "fsl_uart.c"
   \              0x6C 0x5F    
   \              0x75 0x61    
   \              0x72 0x74    
   \              0x2E 0x63    
   \              0x00         
   \        0xB   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x68 0x61          DC8 "handle"
   \              0x6E 0x64    
   \              0x6C 0x65    
   \              0x00         
   \        0x7   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x63 0x6F          DC8 "config"
   \              0x6E 0x66    
   \              0x69 0x67    
   \              0x00         
   \        0x7   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x63 0x6F          DC8 "config->baudRate_Bps"
   \              0x6E 0x66    
   \              0x69 0x67    
   \              0x2D 0x3E    
   \              0x62 0x61    
   \              0x75 0x64    
   \              0x52 0x61    
   \              0x74 0x65    
   \              0x5F 0x42    
   \              0x70 0x73    
   \              0x00         
   \       0x15   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0x28 0x28          DC8 28H, 28H, 62H, 61H, 73H, 65H, 29H, 20H
   \              0x62 0x61    
   \              0x73 0x65    
   \              0x29 0x20    
   \        0x8   0x3D 0x3D          DC8 3DH, 3DH, 20H, 28H, 28H, 55H, 41H, 52H
   \              0x20 0x28    
   \              0x28 0x55    
   \              0x41 0x52    
   \       0x10   0x54 0x5F          DC8 54H, 5FH, 54H, 79H, 70H, 65H, 20H, 2AH
   \              0x54 0x79    
   \              0x70 0x65    
   \              0x20 0x2A    
   \       0x18   0x29 0x28          DC8 29H, 28H, 30H, 78H, 34H, 30H, 30H, 36H
   \              0x30 0x78    
   \              0x34 0x30    
   \              0x30 0x36    
   \       0x20   0x41 0x30          DC8 41H, 30H, 30H, 30H, 75H, 29H, 29H, 20H
   \              0x30 0x30    
   \              0x75 0x29    
   \              0x29 0x20    
   \       0x28   0x3F 0x20          DC8 3FH, 20H, 28H, 38H, 29H, 20H, 3AH, 20H
   \              0x28 0x38    
   \              0x29 0x20    
   \              0x3A 0x20    
   \       0x30   0x28 0x28          DC8 28H, 28H, 62H, 61H, 73H, 65H, 29H, 20H
   \              0x62 0x61    
   \              0x73 0x65    
   \              0x29 0x20    
   \       0x38   0x3D 0x3D          DC8 3DH, 3DH, 20H, 28H, 28H, 55H, 41H, 52H
   \              0x20 0x28    
   \              0x28 0x55    
   \              0x41 0x52    
   \       0x40   0x54 0x5F          DC8 54H, 5FH, 54H, 79H, 70H, 65H, 20H, 2AH
   \              0x54 0x79    
   \              0x70 0x65    
   \              0x20 0x2A    
   \       0x48   0x29 0x28          DC8 29H, 28H, 30H, 78H, 34H, 30H, 30H, 36H
   \              0x30 0x78    
   \              0x34 0x30    
   \              0x30 0x36    
   \       0x50   0x42 0x30          DC8 42H, 30H, 30H, 30H, 75H, 29H, 29H, 20H
   \              0x30 0x30    
   \              0x75 0x29    
   \              0x29 0x20    
   \       0x58   0x3F 0x20          DC8 3FH, 20H, 28H, 31H, 29H, 20H, 3AH, 20H
   \              0x28 0x31    
   \              0x29 0x20    
   \              0x3A 0x20    
   \       0x60   0x28 0x28          DC8 28H, 28H, 62H, 61H, 73H, 65H, 29H, 20H
   \              0x62 0x61    
   \              0x73 0x65    
   \              0x29 0x20    
   \       0x68   0x3D 0x3D          DC8 3DH, 3DH, 20H, 28H, 28H, 55H, 41H, 52H
   \              0x20 0x28    
   \              0x28 0x55    
   \              0x41 0x52    
   \       0x70   0x54 0x5F          DC8 54H, 5FH, 54H, 79H, 70H, 65H, 20H, 2AH
   \              0x54 0x79    
   \              0x70 0x65    
   \              0x20 0x2A    
   \       0x78   0x29 0x28          DC8 29H, 28H, 30H, 78H, 34H, 30H, 30H, 36H
   \              0x30 0x78    
   \              0x34 0x30    
   \              0x30 0x36    
   \       0x80   0x43 0x30          DC8 43H, 30H, 30H, 30H, 75H, 29H, 29H, 20H
   \              0x30 0x30    
   \              0x75 0x29    
   \              0x29 0x20    
   \       0x88   0x3F 0x20          DC8 3FH, 20H, 28H, 31H, 29H, 20H, 3AH, 20H
   \              0x28 0x31    
   \              0x29 0x20    
   \              0x3A 0x20    
   \       0x90   0x28 0x2D          DC8 28H, 2DH, 31H, 29H, 29H, 29H, 29H, 20H
   \              0x31 0x29    
   \              0x29 0x29    
   \              0x29 0x20    
   \       0x98   0x3E 0x3D          DC8 3EH, 3DH, 20H, 63H, 6FH, 6EH, 66H, 69H
   \              0x20 0x63    
   \              0x6F 0x6E    
   \              0x66 0x69    
   \       0xA0   0x67 0x2D          DC8 67H, 2DH, 3EH, 74H, 78H, 46H, 69H, 66H
   \              0x3E 0x74    
   \              0x78 0x46    
   \              0x69 0x66    
   \       0xA8   0x6F 0x57          DC8 6FH, 57H, 61H, 74H, 65H, 72H, 6DH, 61H
   \              0x61 0x74    
   \              0x65 0x72    
   \              0x6D 0x61    
   \       0xB0   0x72 0x6B          DC8 72H, 6BH, 0
   \              0x00         
   \       0xB3   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_6:
   \        0x0   0x28 0x28          DC8 28H, 28H, 62H, 61H, 73H, 65H, 29H, 20H
   \              0x62 0x61    
   \              0x73 0x65    
   \              0x29 0x20    
   \        0x8   0x3D 0x3D          DC8 3DH, 3DH, 20H, 28H, 28H, 55H, 41H, 52H
   \              0x20 0x28    
   \              0x28 0x55    
   \              0x41 0x52    
   \       0x10   0x54 0x5F          DC8 54H, 5FH, 54H, 79H, 70H, 65H, 20H, 2AH
   \              0x54 0x79    
   \              0x70 0x65    
   \              0x20 0x2A    
   \       0x18   0x29 0x28          DC8 29H, 28H, 30H, 78H, 34H, 30H, 30H, 36H
   \              0x30 0x78    
   \              0x34 0x30    
   \              0x30 0x36    
   \       0x20   0x41 0x30          DC8 41H, 30H, 30H, 30H, 75H, 29H, 29H, 20H
   \              0x30 0x30    
   \              0x75 0x29    
   \              0x29 0x20    
   \       0x28   0x3F 0x20          DC8 3FH, 20H, 28H, 38H, 29H, 20H, 3AH, 20H
   \              0x28 0x38    
   \              0x29 0x20    
   \              0x3A 0x20    
   \       0x30   0x28 0x28          DC8 28H, 28H, 62H, 61H, 73H, 65H, 29H, 20H
   \              0x62 0x61    
   \              0x73 0x65    
   \              0x29 0x20    
   \       0x38   0x3D 0x3D          DC8 3DH, 3DH, 20H, 28H, 28H, 55H, 41H, 52H
   \              0x20 0x28    
   \              0x28 0x55    
   \              0x41 0x52    
   \       0x40   0x54 0x5F          DC8 54H, 5FH, 54H, 79H, 70H, 65H, 20H, 2AH
   \              0x54 0x79    
   \              0x70 0x65    
   \              0x20 0x2A    
   \       0x48   0x29 0x28          DC8 29H, 28H, 30H, 78H, 34H, 30H, 30H, 36H
   \              0x30 0x78    
   \              0x34 0x30    
   \              0x30 0x36    
   \       0x50   0x42 0x30          DC8 42H, 30H, 30H, 30H, 75H, 29H, 29H, 20H
   \              0x30 0x30    
   \              0x75 0x29    
   \              0x29 0x20    
   \       0x58   0x3F 0x20          DC8 3FH, 20H, 28H, 31H, 29H, 20H, 3AH, 20H
   \              0x28 0x31    
   \              0x29 0x20    
   \              0x3A 0x20    
   \       0x60   0x28 0x28          DC8 28H, 28H, 62H, 61H, 73H, 65H, 29H, 20H
   \              0x62 0x61    
   \              0x73 0x65    
   \              0x29 0x20    
   \       0x68   0x3D 0x3D          DC8 3DH, 3DH, 20H, 28H, 28H, 55H, 41H, 52H
   \              0x20 0x28    
   \              0x28 0x55    
   \              0x41 0x52    
   \       0x70   0x54 0x5F          DC8 54H, 5FH, 54H, 79H, 70H, 65H, 20H, 2AH
   \              0x54 0x79    
   \              0x70 0x65    
   \              0x20 0x2A    
   \       0x78   0x29 0x28          DC8 29H, 28H, 30H, 78H, 34H, 30H, 30H, 36H
   \              0x30 0x78    
   \              0x34 0x30    
   \              0x30 0x36    
   \       0x80   0x43 0x30          DC8 43H, 30H, 30H, 30H, 75H, 29H, 29H, 20H
   \              0x30 0x30    
   \              0x75 0x29    
   \              0x29 0x20    
   \       0x88   0x3F 0x20          DC8 3FH, 20H, 28H, 31H, 29H, 20H, 3AH, 20H
   \              0x28 0x31    
   \              0x29 0x20    
   \              0x3A 0x20    
   \       0x90   0x28 0x2D          DC8 28H, 2DH, 31H, 29H, 29H, 29H, 29H, 20H
   \              0x31 0x29    
   \              0x29 0x29    
   \              0x29 0x20    
   \       0x98   0x3E 0x3D          DC8 3EH, 3DH, 20H, 63H, 6FH, 6EH, 66H, 69H
   \              0x20 0x63    
   \              0x6F 0x6E    
   \              0x66 0x69    
   \       0xA0   0x67 0x2D          DC8 67H, 2DH, 3EH, 72H, 78H, 46H, 69H, 66H
   \              0x3E 0x72    
   \              0x78 0x46    
   \              0x69 0x66    
   \       0xA8   0x6F 0x57          DC8 6FH, 57H, 61H, 74H, 65H, 72H, 6DH, 61H
   \              0x61 0x74    
   \              0x65 0x72    
   \              0x6D 0x61    
   \       0xB0   0x72 0x6B          DC8 72H, 6BH, 0
   \              0x00         
   \       0xB3   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_7:
   \        0x0   0x62 0x61          DC8 "baudRate_Bps"
   \              0x75 0x64    
   \              0x52 0x61    
   \              0x74 0x65    
   \              0x5F 0x42    
   \              0x70 0x73    
   \              0x00         
   \        0xD   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_8:
   \        0x0   0x64 0x61          DC8 "data"
   \              0x74 0x61    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_9:
   \        0x0   0x72 0x69          DC8 "ringBuffer"
   \              0x6E 0x67    
   \              0x42 0x75    
   \              0x66 0x66    
   \              0x65 0x72    
   \              0x00         
   \        0xB   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_10:
   \        0x0   0x78 0x66          DC8 "xfer"
   \              0x65 0x72    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_11:
   \        0x0   0x78 0x66          DC8 "xfer->dataSize"
   \              0x65 0x72    
   \              0x2D 0x3E    
   \              0x64 0x61    
   \              0x74 0x61    
   \              0x53 0x69    
   \              0x7A 0x65    
   \              0x00         
   \        0xF   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_12:
   \        0x0   0x78 0x66          DC8 "xfer->data"
   \              0x65 0x72    
   \              0x2D 0x3E    
   \              0x64 0x61    
   \              0x74 0x61    
   \              0x00         
   \        0xB   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_13:
   \        0x0   0x63 0x6F          DC8 "count"
   \              0x75 0x6E    
   \              0x74 0x00    
   \        0x6   0x00 0x00          DC8 0, 0
   1194          #endif
   1195          
   1196          #if defined(UART3)
   1197          void UART3_DriverIRQHandler(void)
   1198          {
   1199              s_uartIsr(UART3, s_uartHandle[3]);
   1200          }
   1201          
   1202          void UART3_RX_TX_DriverIRQHandler(void)
   1203          {
   1204              UART3_DriverIRQHandler();
   1205          }
   1206          #endif
   1207          
   1208          #if defined(UART4)
   1209          void UART4_DriverIRQHandler(void)
   1210          {
   1211              s_uartIsr(UART4, s_uartHandle[4]);
   1212          }
   1213          
   1214          void UART4_RX_TX_DriverIRQHandler(void)
   1215          {
   1216              UART4_DriverIRQHandler();
   1217          }
   1218          #endif
   1219          
   1220          #if defined(UART5)
   1221          void UART5_DriverIRQHandler(void)
   1222          {
   1223              s_uartIsr(UART5, s_uartHandle[5]);
   1224          }
   1225          
   1226          void UART5_RX_TX_DriverIRQHandler(void)
   1227          {
   1228              UART5_DriverIRQHandler();
   1229          }
   1230          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CLOCK_DisableClock
       0   CLOCK_EnableClock
       0   EnableIRQ
         0   -> NVIC_EnableIRQ
       0   NVIC_EnableIRQ
       0   UART0_DriverIRQHandler
         0   -- Indirect call
       0   UART0_RX_TX_DriverIRQHandler
         0   -> UART0_DriverIRQHandler
       0   UART1_DriverIRQHandler
         0   -- Indirect call
       0   UART1_RX_TX_DriverIRQHandler
         0   -> UART1_DriverIRQHandler
       0   UART2_DriverIRQHandler
         0   -- Indirect call
       0   UART2_RX_TX_DriverIRQHandler
         0   -> UART2_DriverIRQHandler
       8   UART_ClearStatusFlags
         8   -> UART_GetStatusFlags
       8   UART_Deinit
         0   -> CLOCK_DisableClock
         8   -> UART_GetInstance
       0   UART_DisableInterrupts
       0   UART_EnableInterrupts
       8   UART_GetDefaultConfig
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       0   UART_GetEnabledInterrupts
       8   UART_GetInstance
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
       0   UART_GetStatusFlags
      24   UART_Init
        24   -> CLOCK_EnableClock
        24   -> UART_GetInstance
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
      16   UART_ReadBlocking
        16   -> UART_GetStatusFlags
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   UART_ReadNonBlocking
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   UART_SetBaudRate
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   UART_TransferAbortReceive
        16   -> UART_DisableInterrupts
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      16   UART_TransferAbortSend
        16   -> UART_DisableInterrupts
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      24   UART_TransferCreateHandle
         0   -> EnableIRQ
        24   -> UART_GetInstance
        24   -> __aeabi_assert
        24   -> __aeabi_memset4
        24   -> __iar_EmptyStepPoint
      16   UART_TransferGetReceiveCount
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       8   UART_TransferGetRxRingBufferLength
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
      16   UART_TransferGetSendCount
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       0   UART_TransferHandleErrorIRQ
      24   UART_TransferHandleIRQ
        24   -- Indirect call
        24   -> UART_DisableInterrupts
        24   -> UART_ReadNonBlocking
        24   -> UART_TransferIsRxRingBufferFull
        24   -> UART_WriteNonBlocking
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
       8   UART_TransferIsRxRingBufferFull
         8   -> UART_TransferGetRxRingBufferLength
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
      32   UART_TransferReceiveNonBlocking
        32   -- Indirect call
        32   -> UART_DisableInterrupts
        32   -> UART_EnableInterrupts
        32   -> UART_TransferGetRxRingBufferLength
        32   -> __aeabi_assert
        32   -> __iar_EmptyStepPoint
      16   UART_TransferSendNonBlocking
        16   -> UART_EnableInterrupts
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
      24   UART_TransferStartRingBuffer
         0   -> UART_EnableInterrupts
        24   -> UART_EnableInterrupts
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
      16   UART_TransferStopRingBuffer
        16   -> UART_DisableInterrupts
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       0   UART_WriteBlocking
      16   UART_WriteNonBlocking
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable26
       4  ??DataTable27
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable28_10
       4  ??DataTable28_11
       4  ??DataTable28_12
       4  ??DataTable28_13
       4  ??DataTable28_14
       4  ??DataTable28_15
       4  ??DataTable28_16
       4  ??DataTable28_17
       4  ??DataTable28_18
       4  ??DataTable28_19
       4  ??DataTable28_2
       4  ??DataTable28_20
       4  ??DataTable28_21
       4  ??DataTable28_22
       4  ??DataTable28_3
       4  ??DataTable28_4
       4  ??DataTable28_5
       4  ??DataTable28_6
       4  ??DataTable28_7
       4  ??DataTable28_8
       4  ??DataTable28_9
      28  ?_0
      12  ?_1
       8  ?_10
      16  ?_11
      12  ?_12
       8  ?_13
       8  ?_2
       8  ?_3
      24  ?_4
     180  ?_5
     180  ?_6
      16  ?_7
       8  ?_8
      12  ?_9
      24  CLOCK_DisableClock
      22  CLOCK_EnableClock
      14  EnableIRQ
      20  NVIC_EnableIRQ
      12  UART0_DriverIRQHandler
       2  UART0_RX_TX_DriverIRQHandler
      12  UART1_DriverIRQHandler
       2  UART1_RX_TX_DriverIRQHandler
      12  UART2_DriverIRQHandler
       2  UART2_RX_TX_DriverIRQHandler
      66  UART_ClearStatusFlags
      36  UART_Deinit
      42  UART_DisableInterrupts
      42  UART_EnableInterrupts
      50  UART_GetDefaultConfig
      30  UART_GetEnabledInterrupts
      50  UART_GetInstance
      24  UART_GetStatusFlags
     386  UART_Init
     104  UART_ReadBlocking
      48  UART_ReadNonBlocking
     144  UART_SetBaudRate
      72  UART_TransferAbortReceive
      48  UART_TransferAbortSend
     100  UART_TransferCreateHandle
      80  UART_TransferGetReceiveCount
      52  UART_TransferGetRxRingBufferLength
      78  UART_TransferGetSendCount
       2  UART_TransferHandleErrorIRQ
     634  UART_TransferHandleIRQ
      46  UART_TransferIsRxRingBufferFull
     326  UART_TransferReceiveNonBlocking
     154  UART_TransferSendNonBlocking
      98  UART_TransferStartRingBuffer
      74  UART_TransferStopRingBuffer
      24  UART_WriteBlocking
      48  UART_WriteNonBlocking
      12  s_uartBases
      12  s_uartClock
      12  s_uartHandle
       4  s_uartIRQ
       4  s_uartIsr

 
    16 bytes in section .bss
   548 bytes in section .rodata
 3 080 bytes in section .text
 
 3 080 bytes of CODE  memory
   548 bytes of CONST memory
    16 bytes of DATA  memory

Errors: none
Warnings: none
